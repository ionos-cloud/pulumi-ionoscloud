# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'DatacenterCpuArchitecture',
    'GroupUser',
    'IPBlockIpConsumer',
    'LanIpFailover',
    'NicFlowlog',
    'ServerLabel',
    'ServerNic',
    'ServerNicFirewall',
    'ServerVolume',
]

@pulumi.output_type
class DatacenterCpuArchitecture(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuFamily":
            suggest = "cpu_family"
        elif key == "maxCores":
            suggest = "max_cores"
        elif key == "maxRam":
            suggest = "max_ram"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatacenterCpuArchitecture. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatacenterCpuArchitecture.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatacenterCpuArchitecture.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_family: Optional[str] = None,
                 max_cores: Optional[int] = None,
                 max_ram: Optional[int] = None,
                 vendor: Optional[str] = None):
        """
        :param str cpu_family: A valid CPU family name
        :param int max_cores: The maximum number of cores available
        :param int max_ram: The maximum number of RAM in MB
        :param str vendor: A valid CPU vendor name
        """
        if cpu_family is not None:
            pulumi.set(__self__, "cpu_family", cpu_family)
        if max_cores is not None:
            pulumi.set(__self__, "max_cores", max_cores)
        if max_ram is not None:
            pulumi.set(__self__, "max_ram", max_ram)
        if vendor is not None:
            pulumi.set(__self__, "vendor", vendor)

    @property
    @pulumi.getter(name="cpuFamily")
    def cpu_family(self) -> Optional[str]:
        """
        A valid CPU family name
        """
        return pulumi.get(self, "cpu_family")

    @property
    @pulumi.getter(name="maxCores")
    def max_cores(self) -> Optional[int]:
        """
        The maximum number of cores available
        """
        return pulumi.get(self, "max_cores")

    @property
    @pulumi.getter(name="maxRam")
    def max_ram(self) -> Optional[int]:
        """
        The maximum number of RAM in MB
        """
        return pulumi.get(self, "max_ram")

    @property
    @pulumi.getter
    def vendor(self) -> Optional[str]:
        """
        A valid CPU vendor name
        """
        return pulumi.get(self, "vendor")


@pulumi.output_type
class GroupUser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "firstName":
            suggest = "first_name"
        elif key == "forceSecAuth":
            suggest = "force_sec_auth"
        elif key == "lastName":
            suggest = "last_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupUser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupUser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupUser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 administrator: Optional[bool] = None,
                 email: Optional[str] = None,
                 first_name: Optional[str] = None,
                 force_sec_auth: Optional[bool] = None,
                 id: Optional[str] = None,
                 last_name: Optional[str] = None,
                 password: Optional[str] = None):
        if administrator is not None:
            pulumi.set(__self__, "administrator", administrator)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if first_name is not None:
            pulumi.set(__self__, "first_name", first_name)
        if force_sec_auth is not None:
            pulumi.set(__self__, "force_sec_auth", force_sec_auth)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if last_name is not None:
            pulumi.set(__self__, "last_name", last_name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def administrator(self) -> Optional[bool]:
        return pulumi.get(self, "administrator")

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> Optional[str]:
        return pulumi.get(self, "first_name")

    @property
    @pulumi.getter(name="forceSecAuth")
    def force_sec_auth(self) -> Optional[bool]:
        return pulumi.get(self, "force_sec_auth")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> Optional[str]:
        return pulumi.get(self, "last_name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        return pulumi.get(self, "password")


@pulumi.output_type
class IPBlockIpConsumer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datacenterId":
            suggest = "datacenter_id"
        elif key == "datacenterName":
            suggest = "datacenter_name"
        elif key == "k8sClusterUuid":
            suggest = "k8s_cluster_uuid"
        elif key == "k8sNodepoolUuid":
            suggest = "k8s_nodepool_uuid"
        elif key == "nicId":
            suggest = "nic_id"
        elif key == "serverId":
            suggest = "server_id"
        elif key == "serverName":
            suggest = "server_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IPBlockIpConsumer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IPBlockIpConsumer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IPBlockIpConsumer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datacenter_id: Optional[str] = None,
                 datacenter_name: Optional[str] = None,
                 ip: Optional[str] = None,
                 k8s_cluster_uuid: Optional[str] = None,
                 k8s_nodepool_uuid: Optional[str] = None,
                 mac: Optional[str] = None,
                 nic_id: Optional[str] = None,
                 server_id: Optional[str] = None,
                 server_name: Optional[str] = None):
        if datacenter_id is not None:
            pulumi.set(__self__, "datacenter_id", datacenter_id)
        if datacenter_name is not None:
            pulumi.set(__self__, "datacenter_name", datacenter_name)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if k8s_cluster_uuid is not None:
            pulumi.set(__self__, "k8s_cluster_uuid", k8s_cluster_uuid)
        if k8s_nodepool_uuid is not None:
            pulumi.set(__self__, "k8s_nodepool_uuid", k8s_nodepool_uuid)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if nic_id is not None:
            pulumi.set(__self__, "nic_id", nic_id)
        if server_id is not None:
            pulumi.set(__self__, "server_id", server_id)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)

    @property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> Optional[str]:
        return pulumi.get(self, "datacenter_id")

    @property
    @pulumi.getter(name="datacenterName")
    def datacenter_name(self) -> Optional[str]:
        return pulumi.get(self, "datacenter_name")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="k8sClusterUuid")
    def k8s_cluster_uuid(self) -> Optional[str]:
        return pulumi.get(self, "k8s_cluster_uuid")

    @property
    @pulumi.getter(name="k8sNodepoolUuid")
    def k8s_nodepool_uuid(self) -> Optional[str]:
        return pulumi.get(self, "k8s_nodepool_uuid")

    @property
    @pulumi.getter
    def mac(self) -> Optional[str]:
        return pulumi.get(self, "mac")

    @property
    @pulumi.getter(name="nicId")
    def nic_id(self) -> Optional[str]:
        return pulumi.get(self, "nic_id")

    @property
    @pulumi.getter(name="serverId")
    def server_id(self) -> Optional[str]:
        return pulumi.get(self, "server_id")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[str]:
        return pulumi.get(self, "server_name")


@pulumi.output_type
class LanIpFailover(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nicUuid":
            suggest = "nic_uuid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LanIpFailover. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LanIpFailover.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LanIpFailover.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip: Optional[str] = None,
                 nic_uuid: Optional[str] = None):
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if nic_uuid is not None:
            pulumi.set(__self__, "nic_uuid", nic_uuid)

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="nicUuid")
    def nic_uuid(self) -> Optional[str]:
        return pulumi.get(self, "nic_uuid")


@pulumi.output_type
class NicFlowlog(dict):
    def __init__(__self__, *,
                 action: str,
                 bucket: str,
                 direction: str,
                 name: str,
                 id: Optional[str] = None):
        """
        :param str action: Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL. Immutable, update forces re-creation.
        :param str bucket: Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist. Immutable, update forces re-creation.
        :param str direction: Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, update forces re-creation.
        :param str name: Specifies the name of the flow log.
               
               ⚠️ **Note:**: Removing the `flowlog` forces re-creation of the NIC resource.
        :param str id: The ID of the NIC.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "name", name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL. Immutable, update forces re-creation.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist. Immutable, update forces re-creation.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def direction(self) -> str:
        """
        Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, update forces re-creation.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the flow log.

        ⚠️ **Note:**: Removing the `flowlog` forces re-creation of the NIC resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the NIC.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ServerLabel(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: [string] The key of the label.
        :param str value: [string] The value of the label.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        [string] The key of the label.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        [string] The value of the label.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServerNic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceNumber":
            suggest = "device_number"
        elif key == "firewallActive":
            suggest = "firewall_active"
        elif key == "firewallType":
            suggest = "firewall_type"
        elif key == "ipv6CidrBlock":
            suggest = "ipv6_cidr_block"
        elif key == "ipv6Ips":
            suggest = "ipv6_ips"
        elif key == "pciSlot":
            suggest = "pci_slot"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerNic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerNic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerNic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lan: int,
                 device_number: Optional[int] = None,
                 dhcp: Optional[bool] = None,
                 dhcpv6: Optional[bool] = None,
                 firewall_active: Optional[bool] = None,
                 firewall_type: Optional[str] = None,
                 firewalls: Optional[Sequence['outputs.ServerNicFirewall']] = None,
                 id: Optional[str] = None,
                 ips: Optional[Sequence[str]] = None,
                 ipv6_cidr_block: Optional[str] = None,
                 ipv6_ips: Optional[Sequence[str]] = None,
                 mac: Optional[str] = None,
                 name: Optional[str] = None,
                 pci_slot: Optional[int] = None):
        """
        :param bool dhcpv6: Indicates whether this NIC receives an IPv6 address through DHCP.
        :param Sequence['ServerNicFirewallArgs'] firewalls: Allows to define firewall rules inline in the server. See the Firewall section.
        :param Sequence[str] ips: Collection of IP addresses assigned to a nic. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.
        :param str ipv6_cidr_block: IPv6 CIDR block assigned to the NIC.
        :param Sequence[str] ipv6_ips: Collection for IPv6 addresses assigned to a nic. Explicitly assigned IPv6 addresses need to come from inside the IPv6 CIDR block assigned to the nic.
        :param str name: [string] The name of the server.
        """
        pulumi.set(__self__, "lan", lan)
        if device_number is not None:
            pulumi.set(__self__, "device_number", device_number)
        if dhcp is not None:
            pulumi.set(__self__, "dhcp", dhcp)
        if dhcpv6 is not None:
            pulumi.set(__self__, "dhcpv6", dhcpv6)
        if firewall_active is not None:
            pulumi.set(__self__, "firewall_active", firewall_active)
        if firewall_type is not None:
            pulumi.set(__self__, "firewall_type", firewall_type)
        if firewalls is not None:
            pulumi.set(__self__, "firewalls", firewalls)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if ipv6_cidr_block is not None:
            pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)
        if ipv6_ips is not None:
            pulumi.set(__self__, "ipv6_ips", ipv6_ips)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if pci_slot is not None:
            pulumi.set(__self__, "pci_slot", pci_slot)

    @property
    @pulumi.getter
    def lan(self) -> int:
        return pulumi.get(self, "lan")

    @property
    @pulumi.getter(name="deviceNumber")
    def device_number(self) -> Optional[int]:
        return pulumi.get(self, "device_number")

    @property
    @pulumi.getter
    def dhcp(self) -> Optional[bool]:
        return pulumi.get(self, "dhcp")

    @property
    @pulumi.getter
    def dhcpv6(self) -> Optional[bool]:
        """
        Indicates whether this NIC receives an IPv6 address through DHCP.
        """
        return pulumi.get(self, "dhcpv6")

    @property
    @pulumi.getter(name="firewallActive")
    def firewall_active(self) -> Optional[bool]:
        return pulumi.get(self, "firewall_active")

    @property
    @pulumi.getter(name="firewallType")
    def firewall_type(self) -> Optional[str]:
        return pulumi.get(self, "firewall_type")

    @property
    @pulumi.getter
    def firewalls(self) -> Optional[Sequence['outputs.ServerNicFirewall']]:
        """
        Allows to define firewall rules inline in the server. See the Firewall section.
        """
        return pulumi.get(self, "firewalls")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[str]]:
        """
        Collection of IP addresses assigned to a nic. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[str]:
        """
        IPv6 CIDR block assigned to the NIC.
        """
        return pulumi.get(self, "ipv6_cidr_block")

    @property
    @pulumi.getter(name="ipv6Ips")
    def ipv6_ips(self) -> Optional[Sequence[str]]:
        """
        Collection for IPv6 addresses assigned to a nic. Explicitly assigned IPv6 addresses need to come from inside the IPv6 CIDR block assigned to the nic.
        """
        return pulumi.get(self, "ipv6_ips")

    @property
    @pulumi.getter
    def mac(self) -> Optional[str]:
        return pulumi.get(self, "mac")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        [string] The name of the server.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="pciSlot")
    def pci_slot(self) -> Optional[int]:
        return pulumi.get(self, "pci_slot")


@pulumi.output_type
class ServerNicFirewall(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "icmpCode":
            suggest = "icmp_code"
        elif key == "icmpType":
            suggest = "icmp_type"
        elif key == "portRangeEnd":
            suggest = "port_range_end"
        elif key == "portRangeStart":
            suggest = "port_range_start"
        elif key == "sourceIp":
            suggest = "source_ip"
        elif key == "sourceMac":
            suggest = "source_mac"
        elif key == "targetIp":
            suggest = "target_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerNicFirewall. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerNicFirewall.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerNicFirewall.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 protocol: str,
                 icmp_code: Optional[str] = None,
                 icmp_type: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 port_range_end: Optional[int] = None,
                 port_range_start: Optional[int] = None,
                 source_ip: Optional[str] = None,
                 source_mac: Optional[str] = None,
                 target_ip: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str name: [string] The name of the server.
        :param str type: (Computed)[string] Server usages: [ENTERPRISE](https://docs.ionos.com/cloud/compute-engine/virtual-servers/virtual-servers) or [CUBE](https://docs.ionos.com/cloud/compute-engine/virtual-servers/cloud-cubes). This property is immutable.
        """
        pulumi.set(__self__, "protocol", protocol)
        if icmp_code is not None:
            pulumi.set(__self__, "icmp_code", icmp_code)
        if icmp_type is not None:
            pulumi.set(__self__, "icmp_type", icmp_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_range_end is not None:
            pulumi.set(__self__, "port_range_end", port_range_end)
        if port_range_start is not None:
            pulumi.set(__self__, "port_range_start", port_range_start)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)
        if source_mac is not None:
            pulumi.set(__self__, "source_mac", source_mac)
        if target_ip is not None:
            pulumi.set(__self__, "target_ip", target_ip)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> Optional[str]:
        return pulumi.get(self, "icmp_code")

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[str]:
        return pulumi.get(self, "icmp_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        [string] The name of the server.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="portRangeEnd")
    def port_range_end(self) -> Optional[int]:
        return pulumi.get(self, "port_range_end")

    @property
    @pulumi.getter(name="portRangeStart")
    def port_range_start(self) -> Optional[int]:
        return pulumi.get(self, "port_range_start")

    @property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional[str]:
        return pulumi.get(self, "source_ip")

    @property
    @pulumi.getter(name="sourceMac")
    def source_mac(self) -> Optional[str]:
        return pulumi.get(self, "source_mac")

    @property
    @pulumi.getter(name="targetIp")
    def target_ip(self) -> Optional[str]:
        return pulumi.get(self, "target_ip")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        (Computed)[string] Server usages: [ENTERPRISE](https://docs.ionos.com/cloud/compute-engine/virtual-servers/virtual-servers) or [CUBE](https://docs.ionos.com/cloud/compute-engine/virtual-servers/cloud-cubes). This property is immutable.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ServerVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskType":
            suggest = "disk_type"
        elif key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "backupUnitId":
            suggest = "backup_unit_id"
        elif key == "bootServer":
            suggest = "boot_server"
        elif key == "cpuHotPlug":
            suggest = "cpu_hot_plug"
        elif key == "deviceNumber":
            suggest = "device_number"
        elif key == "discVirtioHotPlug":
            suggest = "disc_virtio_hot_plug"
        elif key == "discVirtioHotUnplug":
            suggest = "disc_virtio_hot_unplug"
        elif key == "imagePassword":
            suggest = "image_password"
        elif key == "licenceType":
            suggest = "licence_type"
        elif key == "nicHotPlug":
            suggest = "nic_hot_plug"
        elif key == "nicHotUnplug":
            suggest = "nic_hot_unplug"
        elif key == "pciSlot":
            suggest = "pci_slot"
        elif key == "ramHotPlug":
            suggest = "ram_hot_plug"
        elif key == "sshKeyPaths":
            suggest = "ssh_key_paths"
        elif key == "sshKeys":
            suggest = "ssh_keys"
        elif key == "userData":
            suggest = "user_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_type: str,
                 availability_zone: Optional[str] = None,
                 backup_unit_id: Optional[str] = None,
                 boot_server: Optional[str] = None,
                 bus: Optional[str] = None,
                 cpu_hot_plug: Optional[bool] = None,
                 device_number: Optional[int] = None,
                 disc_virtio_hot_plug: Optional[bool] = None,
                 disc_virtio_hot_unplug: Optional[bool] = None,
                 image_password: Optional[str] = None,
                 licence_type: Optional[str] = None,
                 name: Optional[str] = None,
                 nic_hot_plug: Optional[bool] = None,
                 nic_hot_unplug: Optional[bool] = None,
                 pci_slot: Optional[int] = None,
                 ram_hot_plug: Optional[bool] = None,
                 size: Optional[int] = None,
                 ssh_key_paths: Optional[Sequence[str]] = None,
                 ssh_keys: Optional[Sequence[str]] = None,
                 user_data: Optional[str] = None):
        """
        :param str availability_zone: [string] The availability zone in which the server should exist. E.g: `AUTO`, `ZONE_1`, `ZONE_2`. This property is immutable.
        :param str backup_unit_id: The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
        :param str boot_server: The UUID of the attached server.
        :param str image_password: [string] Required if `ssh_key_path` is not provided.
        :param str licence_type: [string] Sets the OS type of the server.
        :param str name: [string] The name of the server.
        :param int size: The size of the volume in GB.
        :param Sequence[str] ssh_key_paths: [list] List of absolute paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images.  Also accepts ssh keys directly. Required for IonosCloud Linux images. Required if `image_password` is not provided. Does not support `~` expansion to homedir in the given path. This property is immutable.
        :param Sequence[str] ssh_keys: [list] Immutable List of absolute or relative paths to files containing public SSH key that will be injected into IonosCloud provided Linux images. Also accepts ssh keys directly. Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key. This field may only be set in creation requests. When reading, it always returns null. SSH keys are only supported if a public Linux image is used for the volume creation. Does not support `~` expansion to homedir in the given path.
        :param str user_data: The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
        """
        pulumi.set(__self__, "disk_type", disk_type)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if backup_unit_id is not None:
            pulumi.set(__self__, "backup_unit_id", backup_unit_id)
        if boot_server is not None:
            pulumi.set(__self__, "boot_server", boot_server)
        if bus is not None:
            pulumi.set(__self__, "bus", bus)
        if cpu_hot_plug is not None:
            pulumi.set(__self__, "cpu_hot_plug", cpu_hot_plug)
        if device_number is not None:
            pulumi.set(__self__, "device_number", device_number)
        if disc_virtio_hot_plug is not None:
            pulumi.set(__self__, "disc_virtio_hot_plug", disc_virtio_hot_plug)
        if disc_virtio_hot_unplug is not None:
            pulumi.set(__self__, "disc_virtio_hot_unplug", disc_virtio_hot_unplug)
        if image_password is not None:
            pulumi.set(__self__, "image_password", image_password)
        if licence_type is not None:
            pulumi.set(__self__, "licence_type", licence_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if nic_hot_plug is not None:
            pulumi.set(__self__, "nic_hot_plug", nic_hot_plug)
        if nic_hot_unplug is not None:
            pulumi.set(__self__, "nic_hot_unplug", nic_hot_unplug)
        if pci_slot is not None:
            pulumi.set(__self__, "pci_slot", pci_slot)
        if ram_hot_plug is not None:
            pulumi.set(__self__, "ram_hot_plug", ram_hot_plug)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if ssh_key_paths is not None:
            pulumi.set(__self__, "ssh_key_paths", ssh_key_paths)
        if ssh_keys is not None:
            pulumi.set(__self__, "ssh_keys", ssh_keys)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)

    @property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> str:
        return pulumi.get(self, "disk_type")

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[str]:
        """
        [string] The availability zone in which the server should exist. E.g: `AUTO`, `ZONE_1`, `ZONE_2`. This property is immutable.
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="backupUnitId")
    def backup_unit_id(self) -> Optional[str]:
        """
        The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
        """
        return pulumi.get(self, "backup_unit_id")

    @property
    @pulumi.getter(name="bootServer")
    def boot_server(self) -> Optional[str]:
        """
        The UUID of the attached server.
        """
        return pulumi.get(self, "boot_server")

    @property
    @pulumi.getter
    def bus(self) -> Optional[str]:
        return pulumi.get(self, "bus")

    @property
    @pulumi.getter(name="cpuHotPlug")
    def cpu_hot_plug(self) -> Optional[bool]:
        return pulumi.get(self, "cpu_hot_plug")

    @property
    @pulumi.getter(name="deviceNumber")
    def device_number(self) -> Optional[int]:
        return pulumi.get(self, "device_number")

    @property
    @pulumi.getter(name="discVirtioHotPlug")
    def disc_virtio_hot_plug(self) -> Optional[bool]:
        return pulumi.get(self, "disc_virtio_hot_plug")

    @property
    @pulumi.getter(name="discVirtioHotUnplug")
    def disc_virtio_hot_unplug(self) -> Optional[bool]:
        return pulumi.get(self, "disc_virtio_hot_unplug")

    @property
    @pulumi.getter(name="imagePassword")
    @_utilities.deprecated("""Please use image_password under server level""")
    def image_password(self) -> Optional[str]:
        """
        [string] Required if `ssh_key_path` is not provided.
        """
        return pulumi.get(self, "image_password")

    @property
    @pulumi.getter(name="licenceType")
    def licence_type(self) -> Optional[str]:
        """
        [string] Sets the OS type of the server.
        """
        return pulumi.get(self, "licence_type")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        [string] The name of the server.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nicHotPlug")
    def nic_hot_plug(self) -> Optional[bool]:
        return pulumi.get(self, "nic_hot_plug")

    @property
    @pulumi.getter(name="nicHotUnplug")
    def nic_hot_unplug(self) -> Optional[bool]:
        return pulumi.get(self, "nic_hot_unplug")

    @property
    @pulumi.getter(name="pciSlot")
    def pci_slot(self) -> Optional[int]:
        return pulumi.get(self, "pci_slot")

    @property
    @pulumi.getter(name="ramHotPlug")
    def ram_hot_plug(self) -> Optional[bool]:
        return pulumi.get(self, "ram_hot_plug")

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        """
        The size of the volume in GB.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="sshKeyPaths")
    @_utilities.deprecated("""Please use ssh_key_path under server level""")
    def ssh_key_paths(self) -> Optional[Sequence[str]]:
        """
        [list] List of absolute paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images.  Also accepts ssh keys directly. Required for IonosCloud Linux images. Required if `image_password` is not provided. Does not support `~` expansion to homedir in the given path. This property is immutable.
        """
        return pulumi.get(self, "ssh_key_paths")

    @property
    @pulumi.getter(name="sshKeys")
    @_utilities.deprecated("""Please use ssh_keys under server level""")
    def ssh_keys(self) -> Optional[Sequence[str]]:
        """
        [list] Immutable List of absolute or relative paths to files containing public SSH key that will be injected into IonosCloud provided Linux images. Also accepts ssh keys directly. Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key. This field may only be set in creation requests. When reading, it always returns null. SSH keys are only supported if a public Linux image is used for the volume creation. Does not support `~` expansion to homedir in the given path.
        """
        return pulumi.get(self, "ssh_keys")

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[str]:
        """
        The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
        """
        return pulumi.get(self, "user_data")


