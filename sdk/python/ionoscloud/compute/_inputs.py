# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'DatacenterCpuArchitectureArgs',
    'DatacenterCpuArchitectureArgsDict',
    'GroupUserArgs',
    'GroupUserArgsDict',
    'IPBlockIpConsumerArgs',
    'IPBlockIpConsumerArgsDict',
    'LanIpFailoverArgs',
    'LanIpFailoverArgsDict',
    'NicFlowlogArgs',
    'NicFlowlogArgsDict',
    'ServerLabelArgs',
    'ServerLabelArgsDict',
    'ServerNicArgs',
    'ServerNicArgsDict',
    'ServerNicFirewallArgs',
    'ServerNicFirewallArgsDict',
    'ServerVolumeArgs',
    'ServerVolumeArgsDict',
]

MYPY = False

if not MYPY:
    class DatacenterCpuArchitectureArgsDict(TypedDict):
        cpu_family: NotRequired[pulumi.Input[str]]
        """
        A valid CPU family name
        """
        max_cores: NotRequired[pulumi.Input[int]]
        """
        The maximum number of cores available
        """
        max_ram: NotRequired[pulumi.Input[int]]
        """
        The maximum number of RAM in MB
        """
        vendor: NotRequired[pulumi.Input[str]]
        """
        A valid CPU vendor name
        """
elif False:
    DatacenterCpuArchitectureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatacenterCpuArchitectureArgs:
    def __init__(__self__, *,
                 cpu_family: Optional[pulumi.Input[str]] = None,
                 max_cores: Optional[pulumi.Input[int]] = None,
                 max_ram: Optional[pulumi.Input[int]] = None,
                 vendor: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cpu_family: A valid CPU family name
        :param pulumi.Input[int] max_cores: The maximum number of cores available
        :param pulumi.Input[int] max_ram: The maximum number of RAM in MB
        :param pulumi.Input[str] vendor: A valid CPU vendor name
        """
        if cpu_family is not None:
            pulumi.set(__self__, "cpu_family", cpu_family)
        if max_cores is not None:
            pulumi.set(__self__, "max_cores", max_cores)
        if max_ram is not None:
            pulumi.set(__self__, "max_ram", max_ram)
        if vendor is not None:
            pulumi.set(__self__, "vendor", vendor)

    @property
    @pulumi.getter(name="cpuFamily")
    def cpu_family(self) -> Optional[pulumi.Input[str]]:
        """
        A valid CPU family name
        """
        return pulumi.get(self, "cpu_family")

    @cpu_family.setter
    def cpu_family(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cpu_family", value)

    @property
    @pulumi.getter(name="maxCores")
    def max_cores(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of cores available
        """
        return pulumi.get(self, "max_cores")

    @max_cores.setter
    def max_cores(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_cores", value)

    @property
    @pulumi.getter(name="maxRam")
    def max_ram(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of RAM in MB
        """
        return pulumi.get(self, "max_ram")

    @max_ram.setter
    def max_ram(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_ram", value)

    @property
    @pulumi.getter
    def vendor(self) -> Optional[pulumi.Input[str]]:
        """
        A valid CPU vendor name
        """
        return pulumi.get(self, "vendor")

    @vendor.setter
    def vendor(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vendor", value)


if not MYPY:
    class GroupUserArgsDict(TypedDict):
        administrator: NotRequired[pulumi.Input[bool]]
        email: NotRequired[pulumi.Input[str]]
        first_name: NotRequired[pulumi.Input[str]]
        force_sec_auth: NotRequired[pulumi.Input[bool]]
        id: NotRequired[pulumi.Input[str]]
        last_name: NotRequired[pulumi.Input[str]]
        password: NotRequired[pulumi.Input[str]]
elif False:
    GroupUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupUserArgs:
    def __init__(__self__, *,
                 administrator: Optional[pulumi.Input[bool]] = None,
                 email: Optional[pulumi.Input[str]] = None,
                 first_name: Optional[pulumi.Input[str]] = None,
                 force_sec_auth: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 last_name: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None):
        if administrator is not None:
            pulumi.set(__self__, "administrator", administrator)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if first_name is not None:
            pulumi.set(__self__, "first_name", first_name)
        if force_sec_auth is not None:
            pulumi.set(__self__, "force_sec_auth", force_sec_auth)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if last_name is not None:
            pulumi.set(__self__, "last_name", last_name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def administrator(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "administrator")

    @administrator.setter
    def administrator(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "administrator", value)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "first_name")

    @first_name.setter
    def first_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "first_name", value)

    @property
    @pulumi.getter(name="forceSecAuth")
    def force_sec_auth(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "force_sec_auth")

    @force_sec_auth.setter
    def force_sec_auth(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "force_sec_auth", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "last_name")

    @last_name.setter
    def last_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_name", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)


if not MYPY:
    class IPBlockIpConsumerArgsDict(TypedDict):
        datacenter_id: NotRequired[pulumi.Input[str]]
        datacenter_name: NotRequired[pulumi.Input[str]]
        ip: NotRequired[pulumi.Input[str]]
        k8s_cluster_uuid: NotRequired[pulumi.Input[str]]
        k8s_nodepool_uuid: NotRequired[pulumi.Input[str]]
        mac: NotRequired[pulumi.Input[str]]
        nic_id: NotRequired[pulumi.Input[str]]
        server_id: NotRequired[pulumi.Input[str]]
        server_name: NotRequired[pulumi.Input[str]]
elif False:
    IPBlockIpConsumerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IPBlockIpConsumerArgs:
    def __init__(__self__, *,
                 datacenter_id: Optional[pulumi.Input[str]] = None,
                 datacenter_name: Optional[pulumi.Input[str]] = None,
                 ip: Optional[pulumi.Input[str]] = None,
                 k8s_cluster_uuid: Optional[pulumi.Input[str]] = None,
                 k8s_nodepool_uuid: Optional[pulumi.Input[str]] = None,
                 mac: Optional[pulumi.Input[str]] = None,
                 nic_id: Optional[pulumi.Input[str]] = None,
                 server_id: Optional[pulumi.Input[str]] = None,
                 server_name: Optional[pulumi.Input[str]] = None):
        if datacenter_id is not None:
            pulumi.set(__self__, "datacenter_id", datacenter_id)
        if datacenter_name is not None:
            pulumi.set(__self__, "datacenter_name", datacenter_name)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if k8s_cluster_uuid is not None:
            pulumi.set(__self__, "k8s_cluster_uuid", k8s_cluster_uuid)
        if k8s_nodepool_uuid is not None:
            pulumi.set(__self__, "k8s_nodepool_uuid", k8s_nodepool_uuid)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if nic_id is not None:
            pulumi.set(__self__, "nic_id", nic_id)
        if server_id is not None:
            pulumi.set(__self__, "server_id", server_id)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)

    @property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datacenter_id", value)

    @property
    @pulumi.getter(name="datacenterName")
    def datacenter_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "datacenter_name")

    @datacenter_name.setter
    def datacenter_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datacenter_name", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="k8sClusterUuid")
    def k8s_cluster_uuid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "k8s_cluster_uuid")

    @k8s_cluster_uuid.setter
    def k8s_cluster_uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "k8s_cluster_uuid", value)

    @property
    @pulumi.getter(name="k8sNodepoolUuid")
    def k8s_nodepool_uuid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "k8s_nodepool_uuid")

    @k8s_nodepool_uuid.setter
    def k8s_nodepool_uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "k8s_nodepool_uuid", value)

    @property
    @pulumi.getter
    def mac(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mac")

    @mac.setter
    def mac(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mac", value)

    @property
    @pulumi.getter(name="nicId")
    def nic_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "nic_id")

    @nic_id.setter
    def nic_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nic_id", value)

    @property
    @pulumi.getter(name="serverId")
    def server_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "server_id")

    @server_id.setter
    def server_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_id", value)

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "server_name")

    @server_name.setter
    def server_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_name", value)


if not MYPY:
    class LanIpFailoverArgsDict(TypedDict):
        ip: NotRequired[pulumi.Input[str]]
        nic_uuid: NotRequired[pulumi.Input[str]]
elif False:
    LanIpFailoverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LanIpFailoverArgs:
    def __init__(__self__, *,
                 ip: Optional[pulumi.Input[str]] = None,
                 nic_uuid: Optional[pulumi.Input[str]] = None):
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if nic_uuid is not None:
            pulumi.set(__self__, "nic_uuid", nic_uuid)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="nicUuid")
    def nic_uuid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "nic_uuid")

    @nic_uuid.setter
    def nic_uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nic_uuid", value)


if not MYPY:
    class NicFlowlogArgsDict(TypedDict):
        action: pulumi.Input[str]
        """
        Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL. Immutable, update forces re-creation.
        """
        bucket: pulumi.Input[str]
        """
        Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist. Immutable, update forces re-creation.
        """
        direction: pulumi.Input[str]
        """
        Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, update forces re-creation.
        """
        name: pulumi.Input[str]
        """
        Specifies the name of the flow log.

        ⚠️ **Note:**: Removing the `flowlog` forces re-creation of the NIC resource.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The ID of the NIC.
        """
elif False:
    NicFlowlogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NicFlowlogArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 bucket: pulumi.Input[str],
                 direction: pulumi.Input[str],
                 name: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL. Immutable, update forces re-creation.
        :param pulumi.Input[str] bucket: Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist. Immutable, update forces re-creation.
        :param pulumi.Input[str] direction: Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, update forces re-creation.
        :param pulumi.Input[str] name: Specifies the name of the flow log.
               
               ⚠️ **Note:**: Removing the `flowlog` forces re-creation of the NIC resource.
        :param pulumi.Input[str] id: The ID of the NIC.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "name", name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL. Immutable, update forces re-creation.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist. Immutable, update forces re-creation.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def direction(self) -> pulumi.Input[str]:
        """
        Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, update forces re-creation.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: pulumi.Input[str]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Specifies the name of the flow log.

        ⚠️ **Note:**: Removing the `flowlog` forces re-creation of the NIC resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the NIC.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ServerLabelArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        [string] The key of the label.
        """
        value: pulumi.Input[str]
        """
        [string] The value of the label.
        """
elif False:
    ServerLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerLabelArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: [string] The key of the label.
        :param pulumi.Input[str] value: [string] The value of the label.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        [string] The key of the label.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        [string] The value of the label.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ServerNicArgsDict(TypedDict):
        lan: pulumi.Input[int]
        device_number: NotRequired[pulumi.Input[int]]
        dhcp: NotRequired[pulumi.Input[bool]]
        dhcpv6: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether this NIC receives an IPv6 address through DHCP.
        """
        firewall_active: NotRequired[pulumi.Input[bool]]
        firewall_type: NotRequired[pulumi.Input[str]]
        firewalls: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServerNicFirewallArgsDict']]]]
        """
        Allows to define firewall rules inline in the server. See the Firewall section.
        """
        id: NotRequired[pulumi.Input[str]]
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Collection of IP addresses assigned to a nic. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.
        """
        ipv6_cidr_block: NotRequired[pulumi.Input[str]]
        """
        IPv6 CIDR block assigned to the NIC.
        """
        ipv6_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Collection for IPv6 addresses assigned to a nic. Explicitly assigned IPv6 addresses need to come from inside the IPv6 CIDR block assigned to the nic.
        """
        mac: NotRequired[pulumi.Input[str]]
        name: NotRequired[pulumi.Input[str]]
        """
        [string] The name of the server.
        """
        pci_slot: NotRequired[pulumi.Input[int]]
elif False:
    ServerNicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerNicArgs:
    def __init__(__self__, *,
                 lan: pulumi.Input[int],
                 device_number: Optional[pulumi.Input[int]] = None,
                 dhcp: Optional[pulumi.Input[bool]] = None,
                 dhcpv6: Optional[pulumi.Input[bool]] = None,
                 firewall_active: Optional[pulumi.Input[bool]] = None,
                 firewall_type: Optional[pulumi.Input[str]] = None,
                 firewalls: Optional[pulumi.Input[Sequence[pulumi.Input['ServerNicFirewallArgs']]]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ipv6_cidr_block: Optional[pulumi.Input[str]] = None,
                 ipv6_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 mac: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 pci_slot: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] dhcpv6: Indicates whether this NIC receives an IPv6 address through DHCP.
        :param pulumi.Input[Sequence[pulumi.Input['ServerNicFirewallArgs']]] firewalls: Allows to define firewall rules inline in the server. See the Firewall section.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ips: Collection of IP addresses assigned to a nic. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.
        :param pulumi.Input[str] ipv6_cidr_block: IPv6 CIDR block assigned to the NIC.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ipv6_ips: Collection for IPv6 addresses assigned to a nic. Explicitly assigned IPv6 addresses need to come from inside the IPv6 CIDR block assigned to the nic.
        :param pulumi.Input[str] name: [string] The name of the server.
        """
        pulumi.set(__self__, "lan", lan)
        if device_number is not None:
            pulumi.set(__self__, "device_number", device_number)
        if dhcp is not None:
            pulumi.set(__self__, "dhcp", dhcp)
        if dhcpv6 is not None:
            pulumi.set(__self__, "dhcpv6", dhcpv6)
        if firewall_active is not None:
            pulumi.set(__self__, "firewall_active", firewall_active)
        if firewall_type is not None:
            pulumi.set(__self__, "firewall_type", firewall_type)
        if firewalls is not None:
            pulumi.set(__self__, "firewalls", firewalls)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if ipv6_cidr_block is not None:
            pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)
        if ipv6_ips is not None:
            pulumi.set(__self__, "ipv6_ips", ipv6_ips)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if pci_slot is not None:
            pulumi.set(__self__, "pci_slot", pci_slot)

    @property
    @pulumi.getter
    def lan(self) -> pulumi.Input[int]:
        return pulumi.get(self, "lan")

    @lan.setter
    def lan(self, value: pulumi.Input[int]):
        pulumi.set(self, "lan", value)

    @property
    @pulumi.getter(name="deviceNumber")
    def device_number(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "device_number")

    @device_number.setter
    def device_number(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "device_number", value)

    @property
    @pulumi.getter
    def dhcp(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "dhcp")

    @dhcp.setter
    def dhcp(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dhcp", value)

    @property
    @pulumi.getter
    def dhcpv6(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether this NIC receives an IPv6 address through DHCP.
        """
        return pulumi.get(self, "dhcpv6")

    @dhcpv6.setter
    def dhcpv6(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dhcpv6", value)

    @property
    @pulumi.getter(name="firewallActive")
    def firewall_active(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "firewall_active")

    @firewall_active.setter
    def firewall_active(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "firewall_active", value)

    @property
    @pulumi.getter(name="firewallType")
    def firewall_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "firewall_type")

    @firewall_type.setter
    def firewall_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "firewall_type", value)

    @property
    @pulumi.getter
    def firewalls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServerNicFirewallArgs']]]]:
        """
        Allows to define firewall rules inline in the server. See the Firewall section.
        """
        return pulumi.get(self, "firewalls")

    @firewalls.setter
    def firewalls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServerNicFirewallArgs']]]]):
        pulumi.set(self, "firewalls", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Collection of IP addresses assigned to a nic. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[pulumi.Input[str]]:
        """
        IPv6 CIDR block assigned to the NIC.
        """
        return pulumi.get(self, "ipv6_cidr_block")

    @ipv6_cidr_block.setter
    def ipv6_cidr_block(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6_cidr_block", value)

    @property
    @pulumi.getter(name="ipv6Ips")
    def ipv6_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Collection for IPv6 addresses assigned to a nic. Explicitly assigned IPv6 addresses need to come from inside the IPv6 CIDR block assigned to the nic.
        """
        return pulumi.get(self, "ipv6_ips")

    @ipv6_ips.setter
    def ipv6_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ipv6_ips", value)

    @property
    @pulumi.getter
    def mac(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mac")

    @mac.setter
    def mac(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mac", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The name of the server.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="pciSlot")
    def pci_slot(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "pci_slot")

    @pci_slot.setter
    def pci_slot(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pci_slot", value)


if not MYPY:
    class ServerNicFirewallArgsDict(TypedDict):
        protocol: pulumi.Input[str]
        icmp_code: NotRequired[pulumi.Input[str]]
        icmp_type: NotRequired[pulumi.Input[str]]
        id: NotRequired[pulumi.Input[str]]
        name: NotRequired[pulumi.Input[str]]
        """
        [string] The name of the server.
        """
        port_range_end: NotRequired[pulumi.Input[int]]
        port_range_start: NotRequired[pulumi.Input[int]]
        source_ip: NotRequired[pulumi.Input[str]]
        source_mac: NotRequired[pulumi.Input[str]]
        target_ip: NotRequired[pulumi.Input[str]]
        type: NotRequired[pulumi.Input[str]]
        """
        (Computed)[string] Server usages: [ENTERPRISE](https://docs.ionos.com/cloud/compute-engine/virtual-servers/virtual-servers) or [CUBE](https://docs.ionos.com/cloud/compute-engine/virtual-servers/cloud-cubes). This property is immutable.
        """
elif False:
    ServerNicFirewallArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerNicFirewallArgs:
    def __init__(__self__, *,
                 protocol: pulumi.Input[str],
                 icmp_code: Optional[pulumi.Input[str]] = None,
                 icmp_type: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 port_range_end: Optional[pulumi.Input[int]] = None,
                 port_range_start: Optional[pulumi.Input[int]] = None,
                 source_ip: Optional[pulumi.Input[str]] = None,
                 source_mac: Optional[pulumi.Input[str]] = None,
                 target_ip: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: [string] The name of the server.
        :param pulumi.Input[str] type: (Computed)[string] Server usages: [ENTERPRISE](https://docs.ionos.com/cloud/compute-engine/virtual-servers/virtual-servers) or [CUBE](https://docs.ionos.com/cloud/compute-engine/virtual-servers/cloud-cubes). This property is immutable.
        """
        pulumi.set(__self__, "protocol", protocol)
        if icmp_code is not None:
            pulumi.set(__self__, "icmp_code", icmp_code)
        if icmp_type is not None:
            pulumi.set(__self__, "icmp_type", icmp_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_range_end is not None:
            pulumi.set(__self__, "port_range_end", port_range_end)
        if port_range_start is not None:
            pulumi.set(__self__, "port_range_start", port_range_start)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)
        if source_mac is not None:
            pulumi.set(__self__, "source_mac", source_mac)
        if target_ip is not None:
            pulumi.set(__self__, "target_ip", target_ip)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "icmp_code")

    @icmp_code.setter
    def icmp_code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "icmp_code", value)

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "icmp_type")

    @icmp_type.setter
    def icmp_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "icmp_type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The name of the server.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="portRangeEnd")
    def port_range_end(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "port_range_end")

    @port_range_end.setter
    def port_range_end(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port_range_end", value)

    @property
    @pulumi.getter(name="portRangeStart")
    def port_range_start(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "port_range_start")

    @port_range_start.setter
    def port_range_start(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port_range_start", value)

    @property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "source_ip")

    @source_ip.setter
    def source_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_ip", value)

    @property
    @pulumi.getter(name="sourceMac")
    def source_mac(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "source_mac")

    @source_mac.setter
    def source_mac(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_mac", value)

    @property
    @pulumi.getter(name="targetIp")
    def target_ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "target_ip")

    @target_ip.setter
    def target_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_ip", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        (Computed)[string] Server usages: [ENTERPRISE](https://docs.ionos.com/cloud/compute-engine/virtual-servers/virtual-servers) or [CUBE](https://docs.ionos.com/cloud/compute-engine/virtual-servers/cloud-cubes). This property is immutable.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServerVolumeArgsDict(TypedDict):
        disk_type: pulumi.Input[str]
        availability_zone: NotRequired[pulumi.Input[str]]
        """
        [string] The availability zone in which the server should exist. E.g: `AUTO`, `ZONE_1`, `ZONE_2`. This property is immutable.
        """
        backup_unit_id: NotRequired[pulumi.Input[str]]
        """
        The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
        """
        boot_server: NotRequired[pulumi.Input[str]]
        """
        The UUID of the attached server.
        """
        bus: NotRequired[pulumi.Input[str]]
        cpu_hot_plug: NotRequired[pulumi.Input[bool]]
        device_number: NotRequired[pulumi.Input[int]]
        disc_virtio_hot_plug: NotRequired[pulumi.Input[bool]]
        disc_virtio_hot_unplug: NotRequired[pulumi.Input[bool]]
        image_password: NotRequired[pulumi.Input[str]]
        """
        [string] Required if `ssh_key_path` is not provided.
        """
        licence_type: NotRequired[pulumi.Input[str]]
        """
        [string] Sets the OS type of the server.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        [string] The name of the server.
        """
        nic_hot_plug: NotRequired[pulumi.Input[bool]]
        nic_hot_unplug: NotRequired[pulumi.Input[bool]]
        pci_slot: NotRequired[pulumi.Input[int]]
        ram_hot_plug: NotRequired[pulumi.Input[bool]]
        size: NotRequired[pulumi.Input[int]]
        """
        The size of the volume in GB.
        """
        ssh_key_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        [list] List of absolute paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images.  Also accepts ssh keys directly. Required for IonosCloud Linux images. Required if `image_password` is not provided. Does not support `~` expansion to homedir in the given path. This property is immutable.
        """
        ssh_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        [list] Immutable List of absolute or relative paths to files containing public SSH key that will be injected into IonosCloud provided Linux images. Also accepts ssh keys directly. Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key. This field may only be set in creation requests. When reading, it always returns null. SSH keys are only supported if a public Linux image is used for the volume creation. Does not support `~` expansion to homedir in the given path.
        """
        user_data: NotRequired[pulumi.Input[str]]
        """
        The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
        """
elif False:
    ServerVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerVolumeArgs:
    def __init__(__self__, *,
                 disk_type: pulumi.Input[str],
                 availability_zone: Optional[pulumi.Input[str]] = None,
                 backup_unit_id: Optional[pulumi.Input[str]] = None,
                 boot_server: Optional[pulumi.Input[str]] = None,
                 bus: Optional[pulumi.Input[str]] = None,
                 cpu_hot_plug: Optional[pulumi.Input[bool]] = None,
                 device_number: Optional[pulumi.Input[int]] = None,
                 disc_virtio_hot_plug: Optional[pulumi.Input[bool]] = None,
                 disc_virtio_hot_unplug: Optional[pulumi.Input[bool]] = None,
                 image_password: Optional[pulumi.Input[str]] = None,
                 licence_type: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 nic_hot_plug: Optional[pulumi.Input[bool]] = None,
                 nic_hot_unplug: Optional[pulumi.Input[bool]] = None,
                 pci_slot: Optional[pulumi.Input[int]] = None,
                 ram_hot_plug: Optional[pulumi.Input[bool]] = None,
                 size: Optional[pulumi.Input[int]] = None,
                 ssh_key_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ssh_keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 user_data: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] availability_zone: [string] The availability zone in which the server should exist. E.g: `AUTO`, `ZONE_1`, `ZONE_2`. This property is immutable.
        :param pulumi.Input[str] backup_unit_id: The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
        :param pulumi.Input[str] boot_server: The UUID of the attached server.
        :param pulumi.Input[str] image_password: [string] Required if `ssh_key_path` is not provided.
        :param pulumi.Input[str] licence_type: [string] Sets the OS type of the server.
        :param pulumi.Input[str] name: [string] The name of the server.
        :param pulumi.Input[int] size: The size of the volume in GB.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ssh_key_paths: [list] List of absolute paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images.  Also accepts ssh keys directly. Required for IonosCloud Linux images. Required if `image_password` is not provided. Does not support `~` expansion to homedir in the given path. This property is immutable.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ssh_keys: [list] Immutable List of absolute or relative paths to files containing public SSH key that will be injected into IonosCloud provided Linux images. Also accepts ssh keys directly. Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key. This field may only be set in creation requests. When reading, it always returns null. SSH keys are only supported if a public Linux image is used for the volume creation. Does not support `~` expansion to homedir in the given path.
        :param pulumi.Input[str] user_data: The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
        """
        pulumi.set(__self__, "disk_type", disk_type)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if backup_unit_id is not None:
            pulumi.set(__self__, "backup_unit_id", backup_unit_id)
        if boot_server is not None:
            pulumi.set(__self__, "boot_server", boot_server)
        if bus is not None:
            pulumi.set(__self__, "bus", bus)
        if cpu_hot_plug is not None:
            pulumi.set(__self__, "cpu_hot_plug", cpu_hot_plug)
        if device_number is not None:
            pulumi.set(__self__, "device_number", device_number)
        if disc_virtio_hot_plug is not None:
            pulumi.set(__self__, "disc_virtio_hot_plug", disc_virtio_hot_plug)
        if disc_virtio_hot_unplug is not None:
            pulumi.set(__self__, "disc_virtio_hot_unplug", disc_virtio_hot_unplug)
        if image_password is not None:
            warnings.warn("""Please use image_password under server level""", DeprecationWarning)
            pulumi.log.warn("""image_password is deprecated: Please use image_password under server level""")
        if image_password is not None:
            pulumi.set(__self__, "image_password", image_password)
        if licence_type is not None:
            pulumi.set(__self__, "licence_type", licence_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if nic_hot_plug is not None:
            pulumi.set(__self__, "nic_hot_plug", nic_hot_plug)
        if nic_hot_unplug is not None:
            pulumi.set(__self__, "nic_hot_unplug", nic_hot_unplug)
        if pci_slot is not None:
            pulumi.set(__self__, "pci_slot", pci_slot)
        if ram_hot_plug is not None:
            pulumi.set(__self__, "ram_hot_plug", ram_hot_plug)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if ssh_key_paths is not None:
            warnings.warn("""Please use ssh_key_path under server level""", DeprecationWarning)
            pulumi.log.warn("""ssh_key_paths is deprecated: Please use ssh_key_path under server level""")
        if ssh_key_paths is not None:
            pulumi.set(__self__, "ssh_key_paths", ssh_key_paths)
        if ssh_keys is not None:
            warnings.warn("""Please use ssh_keys under server level""", DeprecationWarning)
            pulumi.log.warn("""ssh_keys is deprecated: Please use ssh_keys under server level""")
        if ssh_keys is not None:
            pulumi.set(__self__, "ssh_keys", ssh_keys)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)

    @property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "disk_type", value)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The availability zone in which the server should exist. E.g: `AUTO`, `ZONE_1`, `ZONE_2`. This property is immutable.
        """
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability_zone", value)

    @property
    @pulumi.getter(name="backupUnitId")
    def backup_unit_id(self) -> Optional[pulumi.Input[str]]:
        """
        The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
        """
        return pulumi.get(self, "backup_unit_id")

    @backup_unit_id.setter
    def backup_unit_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_unit_id", value)

    @property
    @pulumi.getter(name="bootServer")
    def boot_server(self) -> Optional[pulumi.Input[str]]:
        """
        The UUID of the attached server.
        """
        return pulumi.get(self, "boot_server")

    @boot_server.setter
    def boot_server(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "boot_server", value)

    @property
    @pulumi.getter
    def bus(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bus")

    @bus.setter
    def bus(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bus", value)

    @property
    @pulumi.getter(name="cpuHotPlug")
    def cpu_hot_plug(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "cpu_hot_plug")

    @cpu_hot_plug.setter
    def cpu_hot_plug(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cpu_hot_plug", value)

    @property
    @pulumi.getter(name="deviceNumber")
    def device_number(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "device_number")

    @device_number.setter
    def device_number(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "device_number", value)

    @property
    @pulumi.getter(name="discVirtioHotPlug")
    def disc_virtio_hot_plug(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "disc_virtio_hot_plug")

    @disc_virtio_hot_plug.setter
    def disc_virtio_hot_plug(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disc_virtio_hot_plug", value)

    @property
    @pulumi.getter(name="discVirtioHotUnplug")
    def disc_virtio_hot_unplug(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "disc_virtio_hot_unplug")

    @disc_virtio_hot_unplug.setter
    def disc_virtio_hot_unplug(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disc_virtio_hot_unplug", value)

    @property
    @pulumi.getter(name="imagePassword")
    @_utilities.deprecated("""Please use image_password under server level""")
    def image_password(self) -> Optional[pulumi.Input[str]]:
        """
        [string] Required if `ssh_key_path` is not provided.
        """
        return pulumi.get(self, "image_password")

    @image_password.setter
    def image_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_password", value)

    @property
    @pulumi.getter(name="licenceType")
    def licence_type(self) -> Optional[pulumi.Input[str]]:
        """
        [string] Sets the OS type of the server.
        """
        return pulumi.get(self, "licence_type")

    @licence_type.setter
    def licence_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "licence_type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The name of the server.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nicHotPlug")
    def nic_hot_plug(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "nic_hot_plug")

    @nic_hot_plug.setter
    def nic_hot_plug(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "nic_hot_plug", value)

    @property
    @pulumi.getter(name="nicHotUnplug")
    def nic_hot_unplug(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "nic_hot_unplug")

    @nic_hot_unplug.setter
    def nic_hot_unplug(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "nic_hot_unplug", value)

    @property
    @pulumi.getter(name="pciSlot")
    def pci_slot(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "pci_slot")

    @pci_slot.setter
    def pci_slot(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pci_slot", value)

    @property
    @pulumi.getter(name="ramHotPlug")
    def ram_hot_plug(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "ram_hot_plug")

    @ram_hot_plug.setter
    def ram_hot_plug(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ram_hot_plug", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[int]]:
        """
        The size of the volume in GB.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="sshKeyPaths")
    @_utilities.deprecated("""Please use ssh_key_path under server level""")
    def ssh_key_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        [list] List of absolute paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images.  Also accepts ssh keys directly. Required for IonosCloud Linux images. Required if `image_password` is not provided. Does not support `~` expansion to homedir in the given path. This property is immutable.
        """
        return pulumi.get(self, "ssh_key_paths")

    @ssh_key_paths.setter
    def ssh_key_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ssh_key_paths", value)

    @property
    @pulumi.getter(name="sshKeys")
    @_utilities.deprecated("""Please use ssh_keys under server level""")
    def ssh_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        [list] Immutable List of absolute or relative paths to files containing public SSH key that will be injected into IonosCloud provided Linux images. Also accepts ssh keys directly. Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key. This field may only be set in creation requests. When reading, it always returns null. SSH keys are only supported if a public Linux image is used for the volume creation. Does not support `~` expansion to homedir in the given path.
        """
        return pulumi.get(self, "ssh_keys")

    @ssh_keys.setter
    def ssh_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ssh_keys", value)

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[pulumi.Input[str]]:
        """
        The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
        """
        return pulumi.get(self, "user_data")

    @user_data.setter
    def user_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_data", value)


