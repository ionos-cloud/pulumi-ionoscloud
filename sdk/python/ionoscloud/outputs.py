# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'ApigatewayCustomDomain',
    'ApigatewayRouteUpstream',
    'AutoscalingGroupPolicy',
    'AutoscalingGroupPolicyScaleInAction',
    'AutoscalingGroupPolicyScaleOutAction',
    'AutoscalingGroupReplicaConfiguration',
    'AutoscalingGroupReplicaConfigurationNic',
    'AutoscalingGroupReplicaConfigurationNicFirewallRule',
    'AutoscalingGroupReplicaConfigurationNicFlowLog',
    'AutoscalingGroupReplicaConfigurationNicTargetGroup',
    'AutoscalingGroupReplicaConfigurationVolume',
    'KafkaClusterConnections',
    'TargetGroupHealthCheck',
    'TargetGroupHttpHealthCheck',
    'TargetGroupTarget',
    'GetApigatewayCustomDomainResult',
    'GetApigatewayRouteUpstreamResult',
    'GetAutoscalingGroupPolicyResult',
    'GetAutoscalingGroupPolicyScaleInActionResult',
    'GetAutoscalingGroupPolicyScaleOutActionResult',
    'GetAutoscalingGroupReplicaConfigurationResult',
    'GetAutoscalingGroupReplicaConfigurationNicResult',
    'GetAutoscalingGroupReplicaConfigurationNicFirewallRuleResult',
    'GetAutoscalingGroupReplicaConfigurationNicFlowLogResult',
    'GetAutoscalingGroupReplicaConfigurationNicTargetGroupResult',
    'GetAutoscalingGroupReplicaConfigurationVolumeResult',
    'GetAutoscalingGroupServersServerResult',
    'GetDataplatformNodePoolsNodePoolResult',
    'GetDataplatformNodePoolsNodePoolMaintenanceWindowResult',
    'GetInmemorydbSnapshotMetadataResult',
    'GetK8sClustersClusterResult',
    'GetK8sClustersClusterConfigResult',
    'GetK8sClustersClusterConfigClusterResult',
    'GetK8sClustersClusterConfigContextResult',
    'GetK8sClustersClusterConfigUserResult',
    'GetK8sClustersClusterMaintenanceWindowResult',
    'GetK8sClustersClusterS3BucketResult',
    'GetK8sClustersFilterResult',
    'GetK8sNodePoolNodesNodeResult',
    'GetKafkaClusterConnectionResult',
    'GetLocationCpuArchitectureResult',
    'GetMariadbBackupsBackupResult',
    'GetMariadbBackupsBackupBaseBackupResult',
    'GetPgBackupsClusterBackupResult',
    'GetPgBackupsClusterBackupMetadataResult',
    'GetPgDatabasesDatabaseResult',
    'GetServersFilterResult',
    'GetServersServerResult',
    'GetServersServerCdromResult',
    'GetServersServerLabelResult',
    'GetServersServerNicResult',
    'GetServersServerNicFirewallRuleResult',
    'GetServersServerVolumeResult',
    'GetTargetGroupHealthCheckResult',
    'GetTargetGroupHttpHealthCheckResult',
    'GetTargetGroupTargetResult',
]

@pulumi.output_type
class ApigatewayCustomDomain(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateId":
            suggest = "certificate_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApigatewayCustomDomain. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApigatewayCustomDomain.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApigatewayCustomDomain.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 certificate_id: Optional[str] = None):
        """
        :param str name: The domain name.
        :param str certificate_id: The certificate ID for the domain.
        """
        pulumi.set(__self__, "name", name)
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The domain name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[str]:
        """
        The certificate ID for the domain.
        """
        return pulumi.get(self, "certificate_id")


@pulumi.output_type
class ApigatewayRouteUpstream(dict):
    def __init__(__self__, *,
                 host: str,
                 loadbalancer: Optional[str] = None,
                 port: Optional[int] = None,
                 scheme: Optional[str] = None,
                 weight: Optional[int] = None):
        """
        :param str host: The host of the upstream.
        :param str loadbalancer: The load balancer algorithm.
        :param int port: The port of the upstream.
        :param str scheme: The target URL of the upstream.
        :param int weight: Weight with which to split traffic to the upstream.
        """
        pulumi.set(__self__, "host", host)
        if loadbalancer is not None:
            pulumi.set(__self__, "loadbalancer", loadbalancer)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The host of the upstream.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def loadbalancer(self) -> Optional[str]:
        """
        The load balancer algorithm.
        """
        return pulumi.get(self, "loadbalancer")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port of the upstream.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        The target URL of the upstream.
        """
        return pulumi.get(self, "scheme")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        Weight with which to split traffic to the upstream.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class AutoscalingGroupPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scaleInAction":
            suggest = "scale_in_action"
        elif key == "scaleInThreshold":
            suggest = "scale_in_threshold"
        elif key == "scaleOutAction":
            suggest = "scale_out_action"
        elif key == "scaleOutThreshold":
            suggest = "scale_out_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoscalingGroupPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoscalingGroupPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoscalingGroupPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 scale_in_action: 'outputs.AutoscalingGroupPolicyScaleInAction',
                 scale_in_threshold: int,
                 scale_out_action: 'outputs.AutoscalingGroupPolicyScaleOutAction',
                 scale_out_threshold: int,
                 unit: str,
                 range: Optional[str] = None):
        """
        :param str metric: The Metric that should trigger the scaling actions. Metric values are checked at fixed intervals.
        :param 'AutoscalingGroupPolicyScaleInActionArgs' scale_in_action: Defines the action to be taken when the 'scaleInThreshold' is exceeded. Here, scaling is always about removing VMs associated with this VM Auto Scaling Group. By default, the termination policy is 'OLDEST_SERVER_FIRST' is effective.
        :param int scale_in_threshold: The upper threshold for the value of the 'metric'. Used with the 'greater than' (>) operator. A scale-out action is triggered when this value is exceeded, specified by the 'scale_out_action' property. The value must have a lower minimum delta to the 'scale_in_threshold', depending on the metric, to avoid competing for actions simultaneously. If 'properties.policy.unit=TOTAL', a value >= 40 must be chosen.
        :param 'AutoscalingGroupPolicyScaleOutActionArgs' scale_out_action: Defines the action to be performed when the 'scaleOutThreshold' is exceeded. Here, scaling is always about adding new VMs to this VM Auto Scaling Group.
        :param int scale_out_threshold: The upper threshold for the value of the 'metric'. Used with the 'greater than' (>) operator. A scale-out action is triggered when this value is exceeded, specified by the 'scaleOutAction' property. The value must have a lower minimum delta to the 'scaleInThreshold', depending on the metric, to avoid competing for actions simultaneously. If 'properties.policy.unit=TOTAL', a value >= 40 must be chosen.
        :param str unit: Units of the applied Metric. Possible values are: PER_HOUR, PER_MINUTE, PER_SECOND, TOTAL.
        :param str range: Specifies the time range for which the samples are to be aggregated. Must be >= 2 minutes.
        """
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "scale_in_action", scale_in_action)
        pulumi.set(__self__, "scale_in_threshold", scale_in_threshold)
        pulumi.set(__self__, "scale_out_action", scale_out_action)
        pulumi.set(__self__, "scale_out_threshold", scale_out_threshold)
        pulumi.set(__self__, "unit", unit)
        if range is not None:
            pulumi.set(__self__, "range", range)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The Metric that should trigger the scaling actions. Metric values are checked at fixed intervals.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="scaleInAction")
    def scale_in_action(self) -> 'outputs.AutoscalingGroupPolicyScaleInAction':
        """
        Defines the action to be taken when the 'scaleInThreshold' is exceeded. Here, scaling is always about removing VMs associated with this VM Auto Scaling Group. By default, the termination policy is 'OLDEST_SERVER_FIRST' is effective.
        """
        return pulumi.get(self, "scale_in_action")

    @property
    @pulumi.getter(name="scaleInThreshold")
    def scale_in_threshold(self) -> int:
        """
        The upper threshold for the value of the 'metric'. Used with the 'greater than' (>) operator. A scale-out action is triggered when this value is exceeded, specified by the 'scale_out_action' property. The value must have a lower minimum delta to the 'scale_in_threshold', depending on the metric, to avoid competing for actions simultaneously. If 'properties.policy.unit=TOTAL', a value >= 40 must be chosen.
        """
        return pulumi.get(self, "scale_in_threshold")

    @property
    @pulumi.getter(name="scaleOutAction")
    def scale_out_action(self) -> 'outputs.AutoscalingGroupPolicyScaleOutAction':
        """
        Defines the action to be performed when the 'scaleOutThreshold' is exceeded. Here, scaling is always about adding new VMs to this VM Auto Scaling Group.
        """
        return pulumi.get(self, "scale_out_action")

    @property
    @pulumi.getter(name="scaleOutThreshold")
    def scale_out_threshold(self) -> int:
        """
        The upper threshold for the value of the 'metric'. Used with the 'greater than' (>) operator. A scale-out action is triggered when this value is exceeded, specified by the 'scaleOutAction' property. The value must have a lower minimum delta to the 'scaleInThreshold', depending on the metric, to avoid competing for actions simultaneously. If 'properties.policy.unit=TOTAL', a value >= 40 must be chosen.
        """
        return pulumi.get(self, "scale_out_threshold")

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Units of the applied Metric. Possible values are: PER_HOUR, PER_MINUTE, PER_SECOND, TOTAL.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def range(self) -> Optional[str]:
        """
        Specifies the time range for which the samples are to be aggregated. Must be >= 2 minutes.
        """
        return pulumi.get(self, "range")


@pulumi.output_type
class AutoscalingGroupPolicyScaleInAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "amountType":
            suggest = "amount_type"
        elif key == "deleteVolumes":
            suggest = "delete_volumes"
        elif key == "cooldownPeriod":
            suggest = "cooldown_period"
        elif key == "terminationPolicyType":
            suggest = "termination_policy_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoscalingGroupPolicyScaleInAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoscalingGroupPolicyScaleInAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoscalingGroupPolicyScaleInAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amount: int,
                 amount_type: str,
                 delete_volumes: bool,
                 cooldown_period: Optional[str] = None,
                 termination_policy_type: Optional[str] = None):
        """
        :param int amount: When 'amountType=ABSOLUTE' specifies the absolute number of VMs that are removed. The value must be between 1 to 10. 'amountType=PERCENTAGE' specifies the percentage value that is applied to the current number of replicas of the VM Auto Scaling Group. The value must be between 1 to 200. At least one VM is always removed. Note that for 'SCALE_IN' operations, volumes are not deleted after the server is deleted.
        :param str amount_type: The type for the given amount. Possible values are: [ABSOLUTE, PERCENTAGE].
        :param bool delete_volumes: If set to 'true', when deleting an replica during scale in, any attached volume will also be deleted. When set to 'false', all volumes remain in the datacenter and must be deleted manually. Note that every scale-out creates new volumes. When they are not deleted, they will eventually use all of your contracts resource limits. At this point, scaling out would not be possible anymore.
        :param str cooldown_period: The minimum time that elapses after the start of this scaling action until the following scaling action is started. While a scaling action is in progress, no second action is initiated for the same VM Auto Scaling Group. Instead, the metric is re-evaluated after the current scaling action completes (either successfully or with errors). This is currently validated with a minimum value of 2 minutes and a maximum of 24 hours. The default value is 5 minutes if not specified.
        :param str termination_policy_type: The type of termination policy for the VM Auto Scaling Group to follow a specific pattern for scaling-in replicas. The default termination policy is 'OLDEST_SERVER_FIRST'.
        """
        pulumi.set(__self__, "amount", amount)
        pulumi.set(__self__, "amount_type", amount_type)
        pulumi.set(__self__, "delete_volumes", delete_volumes)
        if cooldown_period is not None:
            pulumi.set(__self__, "cooldown_period", cooldown_period)
        if termination_policy_type is not None:
            pulumi.set(__self__, "termination_policy_type", termination_policy_type)

    @property
    @pulumi.getter
    def amount(self) -> int:
        """
        When 'amountType=ABSOLUTE' specifies the absolute number of VMs that are removed. The value must be between 1 to 10. 'amountType=PERCENTAGE' specifies the percentage value that is applied to the current number of replicas of the VM Auto Scaling Group. The value must be between 1 to 200. At least one VM is always removed. Note that for 'SCALE_IN' operations, volumes are not deleted after the server is deleted.
        """
        return pulumi.get(self, "amount")

    @property
    @pulumi.getter(name="amountType")
    def amount_type(self) -> str:
        """
        The type for the given amount. Possible values are: [ABSOLUTE, PERCENTAGE].
        """
        return pulumi.get(self, "amount_type")

    @property
    @pulumi.getter(name="deleteVolumes")
    def delete_volumes(self) -> bool:
        """
        If set to 'true', when deleting an replica during scale in, any attached volume will also be deleted. When set to 'false', all volumes remain in the datacenter and must be deleted manually. Note that every scale-out creates new volumes. When they are not deleted, they will eventually use all of your contracts resource limits. At this point, scaling out would not be possible anymore.
        """
        return pulumi.get(self, "delete_volumes")

    @property
    @pulumi.getter(name="cooldownPeriod")
    def cooldown_period(self) -> Optional[str]:
        """
        The minimum time that elapses after the start of this scaling action until the following scaling action is started. While a scaling action is in progress, no second action is initiated for the same VM Auto Scaling Group. Instead, the metric is re-evaluated after the current scaling action completes (either successfully or with errors). This is currently validated with a minimum value of 2 minutes and a maximum of 24 hours. The default value is 5 minutes if not specified.
        """
        return pulumi.get(self, "cooldown_period")

    @property
    @pulumi.getter(name="terminationPolicyType")
    def termination_policy_type(self) -> Optional[str]:
        """
        The type of termination policy for the VM Auto Scaling Group to follow a specific pattern for scaling-in replicas. The default termination policy is 'OLDEST_SERVER_FIRST'.
        """
        return pulumi.get(self, "termination_policy_type")


@pulumi.output_type
class AutoscalingGroupPolicyScaleOutAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "amountType":
            suggest = "amount_type"
        elif key == "cooldownPeriod":
            suggest = "cooldown_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoscalingGroupPolicyScaleOutAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoscalingGroupPolicyScaleOutAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoscalingGroupPolicyScaleOutAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amount: int,
                 amount_type: str,
                 cooldown_period: Optional[str] = None):
        """
        :param int amount: When 'amountType=ABSOLUTE' specifies the absolute number of VMs that are added. The value must be between 1 to 10. 'amountType=PERCENTAGE' specifies the percentage value that is applied to the current number of replicas of the VM Auto Scaling Group. The value must be between 1 to 200. At least one VM is always added or removed.
        :param str amount_type: The type for the given amount. Possible values are: [ABSOLUTE, PERCENTAGE].
        :param str cooldown_period: The minimum time that elapses after the start of this scaling action until the following scaling action is started. While a scaling action is in progress, no second action is initiated for the same VM Auto Scaling Group. Instead, the metric is re-evaluated after the current scaling action completes (either successfully or with errors). This is currently validated with a minimum value of 2 minutes and a maximum of 24 hours. The default value is 5 minutes if not specified.
        """
        pulumi.set(__self__, "amount", amount)
        pulumi.set(__self__, "amount_type", amount_type)
        if cooldown_period is not None:
            pulumi.set(__self__, "cooldown_period", cooldown_period)

    @property
    @pulumi.getter
    def amount(self) -> int:
        """
        When 'amountType=ABSOLUTE' specifies the absolute number of VMs that are added. The value must be between 1 to 10. 'amountType=PERCENTAGE' specifies the percentage value that is applied to the current number of replicas of the VM Auto Scaling Group. The value must be between 1 to 200. At least one VM is always added or removed.
        """
        return pulumi.get(self, "amount")

    @property
    @pulumi.getter(name="amountType")
    def amount_type(self) -> str:
        """
        The type for the given amount. Possible values are: [ABSOLUTE, PERCENTAGE].
        """
        return pulumi.get(self, "amount_type")

    @property
    @pulumi.getter(name="cooldownPeriod")
    def cooldown_period(self) -> Optional[str]:
        """
        The minimum time that elapses after the start of this scaling action until the following scaling action is started. While a scaling action is in progress, no second action is initiated for the same VM Auto Scaling Group. Instead, the metric is re-evaluated after the current scaling action completes (either successfully or with errors). This is currently validated with a minimum value of 2 minutes and a maximum of 24 hours. The default value is 5 minutes if not specified.
        """
        return pulumi.get(self, "cooldown_period")


@pulumi.output_type
class AutoscalingGroupReplicaConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "cpuFamily":
            suggest = "cpu_family"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoscalingGroupReplicaConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoscalingGroupReplicaConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoscalingGroupReplicaConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone: str,
                 cores: int,
                 ram: int,
                 cpu_family: Optional[str] = None,
                 nics: Optional[Sequence['outputs.AutoscalingGroupReplicaConfigurationNic']] = None,
                 volumes: Optional[Sequence['outputs.AutoscalingGroupReplicaConfigurationVolume']] = None):
        """
        :param str availability_zone: The zone where the VMs are created using this configuration.
        :param int cores: The total number of cores for the VMs.
        :param int ram: The amount of memory for the VMs in MB, e.g. 2048. Size must be specified in multiples of 256 MB with a minimum of 256 MB; however, if you set ramHotPlug to TRUE then you must use a minimum of 1024 MB. If you set the RAM size more than 240GB, then ramHotPlug will be set to FALSE and can not be set to TRUE unless RAM size not set to less than 240GB.
        :param str cpu_family: The zone where the VMs are created using this configuration.
        :param Sequence['AutoscalingGroupReplicaConfigurationNicArgs'] nics: Set of NICs associated with this Replica.
        :param Sequence['AutoscalingGroupReplicaConfigurationVolumeArgs'] volumes: List of volumes associated with this Replica.
        """
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "cores", cores)
        pulumi.set(__self__, "ram", ram)
        if cpu_family is not None:
            pulumi.set(__self__, "cpu_family", cpu_family)
        if nics is not None:
            pulumi.set(__self__, "nics", nics)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> str:
        """
        The zone where the VMs are created using this configuration.
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter
    def cores(self) -> int:
        """
        The total number of cores for the VMs.
        """
        return pulumi.get(self, "cores")

    @property
    @pulumi.getter
    def ram(self) -> int:
        """
        The amount of memory for the VMs in MB, e.g. 2048. Size must be specified in multiples of 256 MB with a minimum of 256 MB; however, if you set ramHotPlug to TRUE then you must use a minimum of 1024 MB. If you set the RAM size more than 240GB, then ramHotPlug will be set to FALSE and can not be set to TRUE unless RAM size not set to less than 240GB.
        """
        return pulumi.get(self, "ram")

    @property
    @pulumi.getter(name="cpuFamily")
    def cpu_family(self) -> Optional[str]:
        """
        The zone where the VMs are created using this configuration.
        """
        return pulumi.get(self, "cpu_family")

    @property
    @pulumi.getter
    def nics(self) -> Optional[Sequence['outputs.AutoscalingGroupReplicaConfigurationNic']]:
        """
        Set of NICs associated with this Replica.
        """
        return pulumi.get(self, "nics")

    @property
    @pulumi.getter
    def volumes(self) -> Optional[Sequence['outputs.AutoscalingGroupReplicaConfigurationVolume']]:
        """
        List of volumes associated with this Replica.
        """
        return pulumi.get(self, "volumes")


@pulumi.output_type
class AutoscalingGroupReplicaConfigurationNic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "firewallActive":
            suggest = "firewall_active"
        elif key == "firewallRules":
            suggest = "firewall_rules"
        elif key == "firewallType":
            suggest = "firewall_type"
        elif key == "flowLogs":
            suggest = "flow_logs"
        elif key == "targetGroup":
            suggest = "target_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoscalingGroupReplicaConfigurationNic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoscalingGroupReplicaConfigurationNic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoscalingGroupReplicaConfigurationNic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lan: int,
                 name: str,
                 dhcp: Optional[bool] = None,
                 firewall_active: Optional[bool] = None,
                 firewall_rules: Optional[Sequence['outputs.AutoscalingGroupReplicaConfigurationNicFirewallRule']] = None,
                 firewall_type: Optional[str] = None,
                 flow_logs: Optional[Sequence['outputs.AutoscalingGroupReplicaConfigurationNicFlowLog']] = None,
                 target_group: Optional['outputs.AutoscalingGroupReplicaConfigurationNicTargetGroup'] = None):
        """
        :param int lan: Lan ID for this replica Nic.
        :param str name: Name for this replica NIC.
        :param bool dhcp: Dhcp flag for this replica Nic. This is an optional attribute with default value of 'true' if not given in the request payload or given as null.
        :param bool firewall_active: Activate or deactivate the firewall. By default, an active firewall without any defined rules will block all incoming network traffic except for the firewall rules that explicitly allows certain protocols, IP addresses and ports.
        :param Sequence['AutoscalingGroupReplicaConfigurationNicFirewallRuleArgs'] firewall_rules: List of all firewall rules for the specified NIC.
        :param str firewall_type: The type of firewall rules that will be allowed on the NIC. If not specified, the default INGRESS value is used.
        :param Sequence['AutoscalingGroupReplicaConfigurationNicFlowLogArgs'] flow_logs: List of all flow logs for the specified NIC.
        :param 'AutoscalingGroupReplicaConfigurationNicTargetGroupArgs' target_group: In order to link VM to ALB, target group must be provided.
        """
        pulumi.set(__self__, "lan", lan)
        pulumi.set(__self__, "name", name)
        if dhcp is not None:
            pulumi.set(__self__, "dhcp", dhcp)
        if firewall_active is not None:
            pulumi.set(__self__, "firewall_active", firewall_active)
        if firewall_rules is not None:
            pulumi.set(__self__, "firewall_rules", firewall_rules)
        if firewall_type is not None:
            pulumi.set(__self__, "firewall_type", firewall_type)
        if flow_logs is not None:
            pulumi.set(__self__, "flow_logs", flow_logs)
        if target_group is not None:
            pulumi.set(__self__, "target_group", target_group)

    @property
    @pulumi.getter
    def lan(self) -> int:
        """
        Lan ID for this replica Nic.
        """
        return pulumi.get(self, "lan")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name for this replica NIC.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def dhcp(self) -> Optional[bool]:
        """
        Dhcp flag for this replica Nic. This is an optional attribute with default value of 'true' if not given in the request payload or given as null.
        """
        return pulumi.get(self, "dhcp")

    @property
    @pulumi.getter(name="firewallActive")
    def firewall_active(self) -> Optional[bool]:
        """
        Activate or deactivate the firewall. By default, an active firewall without any defined rules will block all incoming network traffic except for the firewall rules that explicitly allows certain protocols, IP addresses and ports.
        """
        return pulumi.get(self, "firewall_active")

    @property
    @pulumi.getter(name="firewallRules")
    def firewall_rules(self) -> Optional[Sequence['outputs.AutoscalingGroupReplicaConfigurationNicFirewallRule']]:
        """
        List of all firewall rules for the specified NIC.
        """
        return pulumi.get(self, "firewall_rules")

    @property
    @pulumi.getter(name="firewallType")
    def firewall_type(self) -> Optional[str]:
        """
        The type of firewall rules that will be allowed on the NIC. If not specified, the default INGRESS value is used.
        """
        return pulumi.get(self, "firewall_type")

    @property
    @pulumi.getter(name="flowLogs")
    def flow_logs(self) -> Optional[Sequence['outputs.AutoscalingGroupReplicaConfigurationNicFlowLog']]:
        """
        List of all flow logs for the specified NIC.
        """
        return pulumi.get(self, "flow_logs")

    @property
    @pulumi.getter(name="targetGroup")
    def target_group(self) -> Optional['outputs.AutoscalingGroupReplicaConfigurationNicTargetGroup']:
        """
        In order to link VM to ALB, target group must be provided.
        """
        return pulumi.get(self, "target_group")


@pulumi.output_type
class AutoscalingGroupReplicaConfigurationNicFirewallRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "icmpCode":
            suggest = "icmp_code"
        elif key == "icmpType":
            suggest = "icmp_type"
        elif key == "portRangeEnd":
            suggest = "port_range_end"
        elif key == "portRangeStart":
            suggest = "port_range_start"
        elif key == "sourceIp":
            suggest = "source_ip"
        elif key == "sourceMac":
            suggest = "source_mac"
        elif key == "targetIp":
            suggest = "target_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoscalingGroupReplicaConfigurationNicFirewallRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoscalingGroupReplicaConfigurationNicFirewallRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoscalingGroupReplicaConfigurationNicFirewallRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 protocol: str,
                 icmp_code: Optional[int] = None,
                 icmp_type: Optional[int] = None,
                 name: Optional[str] = None,
                 port_range_end: Optional[int] = None,
                 port_range_start: Optional[int] = None,
                 source_ip: Optional[str] = None,
                 source_mac: Optional[str] = None,
                 target_ip: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str protocol: The protocol for the rule. The property cannot be modified after its creation (not allowed in update requests).
        :param int icmp_code: Sets the allowed code (from 0 to 254) when ICMP protocol is selected. The value 'null' allows all codes.
        :param int icmp_type: Sets the allowed type (from 0 to 254) if the protocol ICMP is selected. The value 'null' allows all types.
        :param str name: The name of the firewall rule.
        :param int port_range_end: Sets the end range of the allowed port (from 1 to 65535) if the protocol TCP or UDP is selected. The value 'null' for 'port_range_start' and 'port_range_end' allows all ports.
        :param int port_range_start: Sets the initial range of the allowed port (from 1 to 65535) if the protocol TCP or UDP is selected. The value 'null' for 'port_range_start' and 'port_range_end' allows all ports.
        :param str source_ip: Only traffic originating from the respective IPv4 address is permitted. The value 'null' allows traffic from any IP address.
        :param str source_mac: Only traffic originating from the respective MAC address is permitted. Valid format: 'aa:bb:cc:dd:ee:ff'. The value 'null' allows traffic from any MAC address.
        :param str target_ip: If the target NIC has multiple IP addresses, only the traffic directed to the respective IP address of the NIC is allowed. The value 'null' allows traffic to any target IP address.
        :param str type: The firewall rule type. If not specified, the default value 'INGRESS' is used.
        """
        pulumi.set(__self__, "protocol", protocol)
        if icmp_code is not None:
            pulumi.set(__self__, "icmp_code", icmp_code)
        if icmp_type is not None:
            pulumi.set(__self__, "icmp_type", icmp_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_range_end is not None:
            pulumi.set(__self__, "port_range_end", port_range_end)
        if port_range_start is not None:
            pulumi.set(__self__, "port_range_start", port_range_start)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)
        if source_mac is not None:
            pulumi.set(__self__, "source_mac", source_mac)
        if target_ip is not None:
            pulumi.set(__self__, "target_ip", target_ip)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The protocol for the rule. The property cannot be modified after its creation (not allowed in update requests).
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> Optional[int]:
        """
        Sets the allowed code (from 0 to 254) when ICMP protocol is selected. The value 'null' allows all codes.
        """
        return pulumi.get(self, "icmp_code")

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[int]:
        """
        Sets the allowed type (from 0 to 254) if the protocol ICMP is selected. The value 'null' allows all types.
        """
        return pulumi.get(self, "icmp_type")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the firewall rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="portRangeEnd")
    def port_range_end(self) -> Optional[int]:
        """
        Sets the end range of the allowed port (from 1 to 65535) if the protocol TCP or UDP is selected. The value 'null' for 'port_range_start' and 'port_range_end' allows all ports.
        """
        return pulumi.get(self, "port_range_end")

    @property
    @pulumi.getter(name="portRangeStart")
    def port_range_start(self) -> Optional[int]:
        """
        Sets the initial range of the allowed port (from 1 to 65535) if the protocol TCP or UDP is selected. The value 'null' for 'port_range_start' and 'port_range_end' allows all ports.
        """
        return pulumi.get(self, "port_range_start")

    @property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional[str]:
        """
        Only traffic originating from the respective IPv4 address is permitted. The value 'null' allows traffic from any IP address.
        """
        return pulumi.get(self, "source_ip")

    @property
    @pulumi.getter(name="sourceMac")
    def source_mac(self) -> Optional[str]:
        """
        Only traffic originating from the respective MAC address is permitted. Valid format: 'aa:bb:cc:dd:ee:ff'. The value 'null' allows traffic from any MAC address.
        """
        return pulumi.get(self, "source_mac")

    @property
    @pulumi.getter(name="targetIp")
    def target_ip(self) -> Optional[str]:
        """
        If the target NIC has multiple IP addresses, only the traffic directed to the respective IP address of the NIC is allowed. The value 'null' allows traffic to any target IP address.
        """
        return pulumi.get(self, "target_ip")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The firewall rule type. If not specified, the default value 'INGRESS' is used.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class AutoscalingGroupReplicaConfigurationNicFlowLog(dict):
    def __init__(__self__, *,
                 action: str,
                 bucket: str,
                 direction: str,
                 name: str,
                 id: Optional[str] = None):
        """
        :param str action: Specifies the traffic direction pattern. Valid values: ACCEPTED, REJECTED, ALL. Immutable, forces re-recreation of the nic resource.
        :param str bucket: The bucket name of an existing IONOS Object Storage bucket. Immutable, forces re-recreation of the nic resource.
        :param str direction: Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, forces re-recreation of the nic resource.
        :param str name: The resource name.
        :param str id: The resource's unique identifier.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "name", name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Specifies the traffic direction pattern. Valid values: ACCEPTED, REJECTED, ALL. Immutable, forces re-recreation of the nic resource.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        The bucket name of an existing IONOS Object Storage bucket. Immutable, forces re-recreation of the nic resource.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def direction(self) -> str:
        """
        Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, forces re-recreation of the nic resource.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The resource name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The resource's unique identifier.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class AutoscalingGroupReplicaConfigurationNicTargetGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetGroupId":
            suggest = "target_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoscalingGroupReplicaConfigurationNicTargetGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoscalingGroupReplicaConfigurationNicTargetGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoscalingGroupReplicaConfigurationNicTargetGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port: int,
                 target_group_id: str,
                 weight: int):
        """
        :param int port: The port for the target group.
        :param str target_group_id: The ID of the target group.
        :param int weight: The weight for the target group.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "target_group_id", target_group_id)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port for the target group.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="targetGroupId")
    def target_group_id(self) -> str:
        """
        The ID of the target group.
        """
        return pulumi.get(self, "target_group_id")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        The weight for the target group.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class AutoscalingGroupReplicaConfigurationVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bootOrder":
            suggest = "boot_order"
        elif key == "backupUnitId":
            suggest = "backup_unit_id"
        elif key == "imageAlias":
            suggest = "image_alias"
        elif key == "imagePassword":
            suggest = "image_password"
        elif key == "sshKeys":
            suggest = "ssh_keys"
        elif key == "userData":
            suggest = "user_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoscalingGroupReplicaConfigurationVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoscalingGroupReplicaConfigurationVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoscalingGroupReplicaConfigurationVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 boot_order: str,
                 name: str,
                 size: int,
                 type: str,
                 backup_unit_id: Optional[str] = None,
                 bus: Optional[str] = None,
                 image: Optional[str] = None,
                 image_alias: Optional[str] = None,
                 image_password: Optional[str] = None,
                 ssh_keys: Optional[Sequence[str]] = None,
                 user_data: Optional[str] = None):
        """
        :param str boot_order: Determines whether the volume will be used as a boot volume. Set to NONE, the volume will not be used as boot volume. 
               Set to PRIMARY, the volume will be used as boot volume and set to AUTO will delegate the decision to the provisioning engine to decide whether to use the volume as boot volume.
               Notice that exactly one volume can be set to PRIMARY or all of them set to AUTO.
        :param str name: Name for this replica volume.
        :param int size: User-defined size for this replica volume in GB.
        :param str type: Storage Type for this replica volume. Possible values: SSD, HDD, SSD_STANDARD or SSD_PREMIUM
        :param str backup_unit_id: The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
        :param str bus: The bus type of the volume. Default setting is 'VIRTIO'. The bus type 'IDE' is also supported.
        :param str image: The image installed on the disk. Currently, only the UUID of the image is supported. Note that either 'image' or 'imageAlias' must be specified, but not both.
        :param str image_alias: The image installed on the volume. Must be an 'imageAlias' as specified via the images API. Note that one of 'image' or 'imageAlias' must be set, but not both.
        :param str image_password: Image password for this replica volume.
        :param str user_data: User-data (Cloud Init) for this replica volume.
        """
        pulumi.set(__self__, "boot_order", boot_order)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)
        if backup_unit_id is not None:
            pulumi.set(__self__, "backup_unit_id", backup_unit_id)
        if bus is not None:
            pulumi.set(__self__, "bus", bus)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if image_alias is not None:
            pulumi.set(__self__, "image_alias", image_alias)
        if image_password is not None:
            pulumi.set(__self__, "image_password", image_password)
        if ssh_keys is not None:
            pulumi.set(__self__, "ssh_keys", ssh_keys)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)

    @property
    @pulumi.getter(name="bootOrder")
    def boot_order(self) -> str:
        """
        Determines whether the volume will be used as a boot volume. Set to NONE, the volume will not be used as boot volume. 
        Set to PRIMARY, the volume will be used as boot volume and set to AUTO will delegate the decision to the provisioning engine to decide whether to use the volume as boot volume.
        Notice that exactly one volume can be set to PRIMARY or all of them set to AUTO.
        """
        return pulumi.get(self, "boot_order")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name for this replica volume.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        User-defined size for this replica volume in GB.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Storage Type for this replica volume. Possible values: SSD, HDD, SSD_STANDARD or SSD_PREMIUM
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="backupUnitId")
    def backup_unit_id(self) -> Optional[str]:
        """
        The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
        """
        return pulumi.get(self, "backup_unit_id")

    @property
    @pulumi.getter
    def bus(self) -> Optional[str]:
        """
        The bus type of the volume. Default setting is 'VIRTIO'. The bus type 'IDE' is also supported.
        """
        return pulumi.get(self, "bus")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        The image installed on the disk. Currently, only the UUID of the image is supported. Note that either 'image' or 'imageAlias' must be specified, but not both.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="imageAlias")
    def image_alias(self) -> Optional[str]:
        """
        The image installed on the volume. Must be an 'imageAlias' as specified via the images API. Note that one of 'image' or 'imageAlias' must be set, but not both.
        """
        return pulumi.get(self, "image_alias")

    @property
    @pulumi.getter(name="imagePassword")
    def image_password(self) -> Optional[str]:
        """
        Image password for this replica volume.
        """
        return pulumi.get(self, "image_password")

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ssh_keys")

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[str]:
        """
        User-data (Cloud Init) for this replica volume.
        """
        return pulumi.get(self, "user_data")


@pulumi.output_type
class KafkaClusterConnections(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "brokerAddresses":
            suggest = "broker_addresses"
        elif key == "datacenterId":
            suggest = "datacenter_id"
        elif key == "lanId":
            suggest = "lan_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaClusterConnections. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaClusterConnections.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaClusterConnections.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 broker_addresses: Sequence[str],
                 datacenter_id: str,
                 lan_id: str):
        """
        :param Sequence[str] broker_addresses: The broker addresses of the Kafka Cluster. Can be empty, but must be present.
        :param str datacenter_id: The datacenter to connect your Kafka Cluster to.
        :param str lan_id: The numeric LAN ID to connect your Kafka Cluster to.
        """
        pulumi.set(__self__, "broker_addresses", broker_addresses)
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "lan_id", lan_id)

    @property
    @pulumi.getter(name="brokerAddresses")
    def broker_addresses(self) -> Sequence[str]:
        """
        The broker addresses of the Kafka Cluster. Can be empty, but must be present.
        """
        return pulumi.get(self, "broker_addresses")

    @property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> str:
        """
        The datacenter to connect your Kafka Cluster to.
        """
        return pulumi.get(self, "datacenter_id")

    @property
    @pulumi.getter(name="lanId")
    def lan_id(self) -> str:
        """
        The numeric LAN ID to connect your Kafka Cluster to.
        """
        return pulumi.get(self, "lan_id")


@pulumi.output_type
class TargetGroupHealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkInterval":
            suggest = "check_interval"
        elif key == "checkTimeout":
            suggest = "check_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetGroupHealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetGroupHealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetGroupHealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check_interval: Optional[int] = None,
                 check_timeout: Optional[int] = None,
                 retries: Optional[int] = None):
        """
        :param int check_interval: The interval in milliseconds between consecutive health checks; default is 2000.
        :param int check_timeout: The maximum time in milliseconds to wait for a target to respond to a check. For target VMs with 'Check Interval' set, the lesser of the two  values is used once the TCP connection is established.
        :param int retries: The maximum number of attempts to reconnect to a target after a connection failure. Valid range is 0 to 65535, and default is three reconnection.
        """
        if check_interval is not None:
            pulumi.set(__self__, "check_interval", check_interval)
        if check_timeout is not None:
            pulumi.set(__self__, "check_timeout", check_timeout)
        if retries is not None:
            pulumi.set(__self__, "retries", retries)

    @property
    @pulumi.getter(name="checkInterval")
    def check_interval(self) -> Optional[int]:
        """
        The interval in milliseconds between consecutive health checks; default is 2000.
        """
        return pulumi.get(self, "check_interval")

    @property
    @pulumi.getter(name="checkTimeout")
    def check_timeout(self) -> Optional[int]:
        """
        The maximum time in milliseconds to wait for a target to respond to a check. For target VMs with 'Check Interval' set, the lesser of the two  values is used once the TCP connection is established.
        """
        return pulumi.get(self, "check_timeout")

    @property
    @pulumi.getter
    def retries(self) -> Optional[int]:
        """
        The maximum number of attempts to reconnect to a target after a connection failure. Valid range is 0 to 65535, and default is three reconnection.
        """
        return pulumi.get(self, "retries")


@pulumi.output_type
class TargetGroupHttpHealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchType":
            suggest = "match_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetGroupHttpHealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetGroupHttpHealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetGroupHttpHealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_type: str,
                 response: str,
                 method: Optional[str] = None,
                 negate: Optional[bool] = None,
                 path: Optional[str] = None,
                 regex: Optional[bool] = None):
        """
        :param str response: The response returned by the request, depending on the match type.
        :param str method: The method for the HTTP health check.
        :param str path: The path (destination URL) for the HTTP health check request; the default is /.
        """
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "response", response)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> str:
        return pulumi.get(self, "match_type")

    @property
    @pulumi.getter
    def response(self) -> str:
        """
        The response returned by the request, depending on the match type.
        """
        return pulumi.get(self, "response")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        The method for the HTTP health check.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path (destination URL) for the HTTP health check request; the default is /.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class TargetGroupTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "healthCheckEnabled":
            suggest = "health_check_enabled"
        elif key == "maintenanceEnabled":
            suggest = "maintenance_enabled"
        elif key == "proxyProtocol":
            suggest = "proxy_protocol"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetGroupTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetGroupTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetGroupTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip: str,
                 port: int,
                 weight: int,
                 health_check_enabled: Optional[bool] = None,
                 maintenance_enabled: Optional[bool] = None,
                 proxy_protocol: Optional[str] = None):
        """
        :param str ip: The IP of the balanced target VM.
        :param int port: The port of the balanced target service; valid range is 1 to 65535.
        :param int weight: Traffic is distributed in proportion to target weight, relative to the combined weight of all targets. A target with higher weight receives a greater share of traffic. Valid range is 0 to 256 and default is 1; targets with weight of 0 do not participate in load balancing but still accept persistent connections. It is best use values in the middle of the range to leave room for later adjustments.
        :param bool health_check_enabled: Makes the target available only if it accepts periodic health check TCP connection attempts; when turned off, the target is considered always available. The health check only consists of a connection attempt to the address and port of the target. Default is True.
        :param bool maintenance_enabled: Maintenance mode prevents the target from receiving balanced traffic.
        :param str proxy_protocol: Proxy protocol version
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "weight", weight)
        if health_check_enabled is not None:
            pulumi.set(__self__, "health_check_enabled", health_check_enabled)
        if maintenance_enabled is not None:
            pulumi.set(__self__, "maintenance_enabled", maintenance_enabled)
        if proxy_protocol is not None:
            pulumi.set(__self__, "proxy_protocol", proxy_protocol)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        The IP of the balanced target VM.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port of the balanced target service; valid range is 1 to 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        Traffic is distributed in proportion to target weight, relative to the combined weight of all targets. A target with higher weight receives a greater share of traffic. Valid range is 0 to 256 and default is 1; targets with weight of 0 do not participate in load balancing but still accept persistent connections. It is best use values in the middle of the range to leave room for later adjustments.
        """
        return pulumi.get(self, "weight")

    @property
    @pulumi.getter(name="healthCheckEnabled")
    def health_check_enabled(self) -> Optional[bool]:
        """
        Makes the target available only if it accepts periodic health check TCP connection attempts; when turned off, the target is considered always available. The health check only consists of a connection attempt to the address and port of the target. Default is True.
        """
        return pulumi.get(self, "health_check_enabled")

    @property
    @pulumi.getter(name="maintenanceEnabled")
    def maintenance_enabled(self) -> Optional[bool]:
        """
        Maintenance mode prevents the target from receiving balanced traffic.
        """
        return pulumi.get(self, "maintenance_enabled")

    @property
    @pulumi.getter(name="proxyProtocol")
    def proxy_protocol(self) -> Optional[str]:
        """
        Proxy protocol version
        """
        return pulumi.get(self, "proxy_protocol")


@pulumi.output_type
class GetApigatewayCustomDomainResult(dict):
    def __init__(__self__, *,
                 certificate_id: str,
                 name: str):
        """
        :param str certificate_id: The ID of the certificate to use for the distribution.
        :param str name: The domain name of the distribution.
        """
        pulumi.set(__self__, "certificate_id", certificate_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> str:
        """
        The ID of the certificate to use for the distribution.
        """
        return pulumi.get(self, "certificate_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The domain name of the distribution.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetApigatewayRouteUpstreamResult(dict):
    def __init__(__self__, *,
                 host: str,
                 loadbalancer: str,
                 port: int,
                 scheme: str,
                 weight: int):
        """
        :param str host: The host of the upstream.
        :param str loadbalancer: The load balancer algorithm.
        :param int port: The port of the upstream.
        :param str scheme: The target URL of the upstream.
        :param int weight: Weight with which to split traffic to the upstream.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "loadbalancer", loadbalancer)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "scheme", scheme)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The host of the upstream.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def loadbalancer(self) -> str:
        """
        The load balancer algorithm.
        """
        return pulumi.get(self, "loadbalancer")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port of the upstream.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> str:
        """
        The target URL of the upstream.
        """
        return pulumi.get(self, "scheme")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        Weight with which to split traffic to the upstream.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetAutoscalingGroupPolicyResult(dict):
    def __init__(__self__, *,
                 metric: str,
                 range: str,
                 scale_in_actions: Sequence['outputs.GetAutoscalingGroupPolicyScaleInActionResult'],
                 scale_in_threshold: int,
                 scale_out_actions: Sequence['outputs.GetAutoscalingGroupPolicyScaleOutActionResult'],
                 scale_out_threshold: int,
                 unit: str):
        """
        :param str metric: The Metric that should trigger the scaling actions. Metric values are checked at fixed intervals.
        :param str range: Defines the time range, for which the samples will be aggregated. Default is 120s.
        :param Sequence['GetAutoscalingGroupPolicyScaleInActionArgs'] scale_in_actions: Specifies the action to take when the `scaleInThreshold` is exceeded. Hereby, scaling in is always about removing VMs that are currently associated with this autoscaling group. Default termination policy is OLDEST_SERVER_FIRST.
        :param int scale_in_threshold: The lower threshold for the value of the `metric`. Will be used with `less than` (<) operator. Exceeding this will start a Scale-In action as specified by the `scaleInAction` property. The value must have a higher minimum delta to the `scaleOutThreshold` depending on the `metric` to avoid competitive actions at the same time.
        :param Sequence['GetAutoscalingGroupPolicyScaleOutActionArgs'] scale_out_actions: Specifies the action to take when the `scaleOutThreshold` is exceeded. Hereby, scaling out is always about adding new VMs to this autoscaling group.
        :param int scale_out_threshold: The upper threshold for the value of the `metric`. Will be used with `greater than` (>) operator. Exceeding this will start a Scale-Out action as specified by the `scaleOutAction` property. The value must have a lower minimum delta to the `scaleInThreshold` depending on the `metric` to avoid competitive actions at the same time.
        :param str unit: Units of the applied Metric. Possible values are: PER_HOUR, PER_MINUTE, PER_SECOND, TOTAL.
        """
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "range", range)
        pulumi.set(__self__, "scale_in_actions", scale_in_actions)
        pulumi.set(__self__, "scale_in_threshold", scale_in_threshold)
        pulumi.set(__self__, "scale_out_actions", scale_out_actions)
        pulumi.set(__self__, "scale_out_threshold", scale_out_threshold)
        pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The Metric that should trigger the scaling actions. Metric values are checked at fixed intervals.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def range(self) -> str:
        """
        Defines the time range, for which the samples will be aggregated. Default is 120s.
        """
        return pulumi.get(self, "range")

    @property
    @pulumi.getter(name="scaleInActions")
    def scale_in_actions(self) -> Sequence['outputs.GetAutoscalingGroupPolicyScaleInActionResult']:
        """
        Specifies the action to take when the `scaleInThreshold` is exceeded. Hereby, scaling in is always about removing VMs that are currently associated with this autoscaling group. Default termination policy is OLDEST_SERVER_FIRST.
        """
        return pulumi.get(self, "scale_in_actions")

    @property
    @pulumi.getter(name="scaleInThreshold")
    def scale_in_threshold(self) -> int:
        """
        The lower threshold for the value of the `metric`. Will be used with `less than` (<) operator. Exceeding this will start a Scale-In action as specified by the `scaleInAction` property. The value must have a higher minimum delta to the `scaleOutThreshold` depending on the `metric` to avoid competitive actions at the same time.
        """
        return pulumi.get(self, "scale_in_threshold")

    @property
    @pulumi.getter(name="scaleOutActions")
    def scale_out_actions(self) -> Sequence['outputs.GetAutoscalingGroupPolicyScaleOutActionResult']:
        """
        Specifies the action to take when the `scaleOutThreshold` is exceeded. Hereby, scaling out is always about adding new VMs to this autoscaling group.
        """
        return pulumi.get(self, "scale_out_actions")

    @property
    @pulumi.getter(name="scaleOutThreshold")
    def scale_out_threshold(self) -> int:
        """
        The upper threshold for the value of the `metric`. Will be used with `greater than` (>) operator. Exceeding this will start a Scale-Out action as specified by the `scaleOutAction` property. The value must have a lower minimum delta to the `scaleInThreshold` depending on the `metric` to avoid competitive actions at the same time.
        """
        return pulumi.get(self, "scale_out_threshold")

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        Units of the applied Metric. Possible values are: PER_HOUR, PER_MINUTE, PER_SECOND, TOTAL.
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class GetAutoscalingGroupPolicyScaleInActionResult(dict):
    def __init__(__self__, *,
                 amount: int,
                 amount_type: str,
                 cooldown_period: str,
                 delete_volumes: bool,
                 termination_policy_type: str):
        """
        :param int amount: When 'amountType=ABSOLUTE' specifies the absolute number of VMs that are removed. The value must be between 1 to 10. 'amountType=PERCENTAGE' specifies the percentage value that is applied to the current number of replicas of the VM Auto Scaling Group. The value must be between 1 to 200. At least one VM is always removed. Note that for 'SCALE_IN' operations, volumes are not deleted after the server is deleted.
        :param str amount_type: The type for the given amount. Possible values are: [ABSOLUTE, PERCENTAGE].
        :param str cooldown_period: Minimum time to pass after this Scaling action has started, until the next Scaling action will be started. Additionally, if a Scaling action is currently in progress, no second Scaling action will be started for the same autoscaling group. Instead, the Metric will be re-evaluated after the current Scaling action is completed (either successfully or with failures). This is validated with a minimum value of 2 minutes and a maximum of 24 hours currently. Default value is 5 minutes if not given.
        :param bool delete_volumes: If set to 'true', when deleting an replica during scale in, any attached volume will also be deleted. When set to 'false', all volumes remain in the datacenter and must be deleted manually. Note that every scale-out creates new volumes. When they are not deleted, they will eventually use all of your contracts resource limits. At this point, scaling out would not be possible anymore.
        :param str termination_policy_type: The type of the termination policy for the autoscaling group so that a specific pattern is followed for Scaling-In instances. Default termination policy is OLDEST_SERVER_FIRST.
        """
        pulumi.set(__self__, "amount", amount)
        pulumi.set(__self__, "amount_type", amount_type)
        pulumi.set(__self__, "cooldown_period", cooldown_period)
        pulumi.set(__self__, "delete_volumes", delete_volumes)
        pulumi.set(__self__, "termination_policy_type", termination_policy_type)

    @property
    @pulumi.getter
    def amount(self) -> int:
        """
        When 'amountType=ABSOLUTE' specifies the absolute number of VMs that are removed. The value must be between 1 to 10. 'amountType=PERCENTAGE' specifies the percentage value that is applied to the current number of replicas of the VM Auto Scaling Group. The value must be between 1 to 200. At least one VM is always removed. Note that for 'SCALE_IN' operations, volumes are not deleted after the server is deleted.
        """
        return pulumi.get(self, "amount")

    @property
    @pulumi.getter(name="amountType")
    def amount_type(self) -> str:
        """
        The type for the given amount. Possible values are: [ABSOLUTE, PERCENTAGE].
        """
        return pulumi.get(self, "amount_type")

    @property
    @pulumi.getter(name="cooldownPeriod")
    def cooldown_period(self) -> str:
        """
        Minimum time to pass after this Scaling action has started, until the next Scaling action will be started. Additionally, if a Scaling action is currently in progress, no second Scaling action will be started for the same autoscaling group. Instead, the Metric will be re-evaluated after the current Scaling action is completed (either successfully or with failures). This is validated with a minimum value of 2 minutes and a maximum of 24 hours currently. Default value is 5 minutes if not given.
        """
        return pulumi.get(self, "cooldown_period")

    @property
    @pulumi.getter(name="deleteVolumes")
    def delete_volumes(self) -> bool:
        """
        If set to 'true', when deleting an replica during scale in, any attached volume will also be deleted. When set to 'false', all volumes remain in the datacenter and must be deleted manually. Note that every scale-out creates new volumes. When they are not deleted, they will eventually use all of your contracts resource limits. At this point, scaling out would not be possible anymore.
        """
        return pulumi.get(self, "delete_volumes")

    @property
    @pulumi.getter(name="terminationPolicyType")
    def termination_policy_type(self) -> str:
        """
        The type of the termination policy for the autoscaling group so that a specific pattern is followed for Scaling-In instances. Default termination policy is OLDEST_SERVER_FIRST.
        """
        return pulumi.get(self, "termination_policy_type")


@pulumi.output_type
class GetAutoscalingGroupPolicyScaleOutActionResult(dict):
    def __init__(__self__, *,
                 amount: int,
                 amount_type: str,
                 cooldown_period: str):
        """
        :param int amount: When 'amountType=ABSOLUTE' specifies the absolute number of VMs that are added. The value must be between 1 to 10. 'amountType=PERCENTAGE' specifies the percentage value that is applied to the current number of replicas of the VM Auto Scaling Group. The value must be between 1 to 200. At least one VM is always added. Note that for 'SCALE_IN' operations, volumes are not deleted after the server is deleted.
        :param str amount_type: The type for the given amount. Possible values are: [ABSOLUTE, PERCENTAGE].
        :param str cooldown_period: Minimum time to pass after this Scaling action has started, until the next Scaling action will be started. Additionally, if a Scaling action is currently in progress, no second Scaling action will be started for the same autoscaling group. Instead, the Metric will be re-evaluated after the current Scaling action is completed (either successfully or with failures). This is validated with a minimum value of 2 minutes and a maximum of 24 hours currently. Default value is 5 minutes if not given.
        """
        pulumi.set(__self__, "amount", amount)
        pulumi.set(__self__, "amount_type", amount_type)
        pulumi.set(__self__, "cooldown_period", cooldown_period)

    @property
    @pulumi.getter
    def amount(self) -> int:
        """
        When 'amountType=ABSOLUTE' specifies the absolute number of VMs that are added. The value must be between 1 to 10. 'amountType=PERCENTAGE' specifies the percentage value that is applied to the current number of replicas of the VM Auto Scaling Group. The value must be between 1 to 200. At least one VM is always added. Note that for 'SCALE_IN' operations, volumes are not deleted after the server is deleted.
        """
        return pulumi.get(self, "amount")

    @property
    @pulumi.getter(name="amountType")
    def amount_type(self) -> str:
        """
        The type for the given amount. Possible values are: [ABSOLUTE, PERCENTAGE].
        """
        return pulumi.get(self, "amount_type")

    @property
    @pulumi.getter(name="cooldownPeriod")
    def cooldown_period(self) -> str:
        """
        Minimum time to pass after this Scaling action has started, until the next Scaling action will be started. Additionally, if a Scaling action is currently in progress, no second Scaling action will be started for the same autoscaling group. Instead, the Metric will be re-evaluated after the current Scaling action is completed (either successfully or with failures). This is validated with a minimum value of 2 minutes and a maximum of 24 hours currently. Default value is 5 minutes if not given.
        """
        return pulumi.get(self, "cooldown_period")


@pulumi.output_type
class GetAutoscalingGroupReplicaConfigurationResult(dict):
    def __init__(__self__, *,
                 availability_zone: str,
                 cores: int,
                 cpu_family: str,
                 nics: Sequence['outputs.GetAutoscalingGroupReplicaConfigurationNicResult'],
                 ram: int,
                 volumes: Sequence['outputs.GetAutoscalingGroupReplicaConfigurationVolumeResult']):
        """
        :param str availability_zone: The zone where the VMs are created using this configuration.
        :param int cores: The total number of cores for the VMs.
        :param str cpu_family: The zone where the VMs are created using this configuration.
        :param Sequence['GetAutoscalingGroupReplicaConfigurationNicArgs'] nics: List of NICs associated with this Replica.
        :param int ram: The amount of memory for the VMs in MB, e.g. 2048. Size must be specified in multiples of 256 MB with a minimum of 256 MB; however, if you set ramHotPlug to TRUE then you must use a minimum of 1024 MB. If you set the RAM size more than 240GB, then ramHotPlug will be set to FALSE and can not be set to TRUE unless RAM size not set to less than 240GB.
        :param Sequence['GetAutoscalingGroupReplicaConfigurationVolumeArgs'] volumes: List of volumes associated with this Replica. Only a single volume is currently supported.
        """
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "cores", cores)
        pulumi.set(__self__, "cpu_family", cpu_family)
        pulumi.set(__self__, "nics", nics)
        pulumi.set(__self__, "ram", ram)
        pulumi.set(__self__, "volumes", volumes)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> str:
        """
        The zone where the VMs are created using this configuration.
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter
    def cores(self) -> int:
        """
        The total number of cores for the VMs.
        """
        return pulumi.get(self, "cores")

    @property
    @pulumi.getter(name="cpuFamily")
    def cpu_family(self) -> str:
        """
        The zone where the VMs are created using this configuration.
        """
        return pulumi.get(self, "cpu_family")

    @property
    @pulumi.getter
    def nics(self) -> Sequence['outputs.GetAutoscalingGroupReplicaConfigurationNicResult']:
        """
        List of NICs associated with this Replica.
        """
        return pulumi.get(self, "nics")

    @property
    @pulumi.getter
    def ram(self) -> int:
        """
        The amount of memory for the VMs in MB, e.g. 2048. Size must be specified in multiples of 256 MB with a minimum of 256 MB; however, if you set ramHotPlug to TRUE then you must use a minimum of 1024 MB. If you set the RAM size more than 240GB, then ramHotPlug will be set to FALSE and can not be set to TRUE unless RAM size not set to less than 240GB.
        """
        return pulumi.get(self, "ram")

    @property
    @pulumi.getter
    def volumes(self) -> Sequence['outputs.GetAutoscalingGroupReplicaConfigurationVolumeResult']:
        """
        List of volumes associated with this Replica. Only a single volume is currently supported.
        """
        return pulumi.get(self, "volumes")


@pulumi.output_type
class GetAutoscalingGroupReplicaConfigurationNicResult(dict):
    def __init__(__self__, *,
                 dhcp: bool,
                 firewall_active: bool,
                 firewall_rules: Sequence['outputs.GetAutoscalingGroupReplicaConfigurationNicFirewallRuleResult'],
                 firewall_type: str,
                 flow_logs: Sequence['outputs.GetAutoscalingGroupReplicaConfigurationNicFlowLogResult'],
                 lan: int,
                 name: str,
                 target_groups: Sequence['outputs.GetAutoscalingGroupReplicaConfigurationNicTargetGroupResult']):
        """
        :param bool dhcp: Dhcp flag for this replica Nic. This is an optional attribute with default value of 'true' if not given in the request payload or given as null.
        :param bool firewall_active: Activate or deactivate the firewall. By default, an active firewall without any defined rules will block all incoming network traffic except for the firewall rules that explicitly allows certain protocols, IP addresses and ports.
        :param Sequence['GetAutoscalingGroupReplicaConfigurationNicFirewallRuleArgs'] firewall_rules: List of all firewall rules for the specified NIC.
        :param str firewall_type: The type of firewall rules that will be allowed on the NIC. If not specified, the default INGRESS value is used.
        :param Sequence['GetAutoscalingGroupReplicaConfigurationNicFlowLogArgs'] flow_logs: Flow log configuration for the NIC. By default, the flow log is inactive. If you want to activate the flow log, you must specify the target resource and the type of traffic to log.
        :param int lan: Lan ID for this replica Nic.
        :param str name: Name for this replica NIC.
        :param Sequence['GetAutoscalingGroupReplicaConfigurationNicTargetGroupArgs'] target_groups: In order to link VM to ALB, target group must be provided.
        """
        pulumi.set(__self__, "dhcp", dhcp)
        pulumi.set(__self__, "firewall_active", firewall_active)
        pulumi.set(__self__, "firewall_rules", firewall_rules)
        pulumi.set(__self__, "firewall_type", firewall_type)
        pulumi.set(__self__, "flow_logs", flow_logs)
        pulumi.set(__self__, "lan", lan)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "target_groups", target_groups)

    @property
    @pulumi.getter
    def dhcp(self) -> bool:
        """
        Dhcp flag for this replica Nic. This is an optional attribute with default value of 'true' if not given in the request payload or given as null.
        """
        return pulumi.get(self, "dhcp")

    @property
    @pulumi.getter(name="firewallActive")
    def firewall_active(self) -> bool:
        """
        Activate or deactivate the firewall. By default, an active firewall without any defined rules will block all incoming network traffic except for the firewall rules that explicitly allows certain protocols, IP addresses and ports.
        """
        return pulumi.get(self, "firewall_active")

    @property
    @pulumi.getter(name="firewallRules")
    def firewall_rules(self) -> Sequence['outputs.GetAutoscalingGroupReplicaConfigurationNicFirewallRuleResult']:
        """
        List of all firewall rules for the specified NIC.
        """
        return pulumi.get(self, "firewall_rules")

    @property
    @pulumi.getter(name="firewallType")
    def firewall_type(self) -> str:
        """
        The type of firewall rules that will be allowed on the NIC. If not specified, the default INGRESS value is used.
        """
        return pulumi.get(self, "firewall_type")

    @property
    @pulumi.getter(name="flowLogs")
    def flow_logs(self) -> Sequence['outputs.GetAutoscalingGroupReplicaConfigurationNicFlowLogResult']:
        """
        Flow log configuration for the NIC. By default, the flow log is inactive. If you want to activate the flow log, you must specify the target resource and the type of traffic to log.
        """
        return pulumi.get(self, "flow_logs")

    @property
    @pulumi.getter
    def lan(self) -> int:
        """
        Lan ID for this replica Nic.
        """
        return pulumi.get(self, "lan")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name for this replica NIC.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="targetGroups")
    def target_groups(self) -> Sequence['outputs.GetAutoscalingGroupReplicaConfigurationNicTargetGroupResult']:
        """
        In order to link VM to ALB, target group must be provided.
        """
        return pulumi.get(self, "target_groups")


@pulumi.output_type
class GetAutoscalingGroupReplicaConfigurationNicFirewallRuleResult(dict):
    def __init__(__self__, *,
                 icmp_code: int,
                 icmp_type: int,
                 name: str,
                 port_range_end: int,
                 port_range_start: int,
                 protocol: str,
                 source_ip: str,
                 source_mac: str,
                 target_ip: str,
                 type: str):
        """
        :param int icmp_code: Sets the allowed code (from 0 to 254) when ICMP protocol is selected. The value 'null' allows all codes.
        :param int icmp_type: Sets the allowed type (from 0 to 254) if the protocol ICMP is selected. The value 'null' allows all types.
        :param str name: The name of the firewall rule.
        :param int port_range_end: Sets the end range of the allowed port (from 1 to 65535) if the protocol TCP or UDP is selected. The value 'null' for 'port_range_start' and 'port_range_end' allows all ports.
        :param int port_range_start: Sets the initial range of the allowed port (from 1 to 65535) if the protocol TCP or UDP is selected. The value 'null' for 'port_range_start' and 'port_range_end' allows all ports.
        :param str protocol: The protocol for the rule. The property cannot be modified after its creation (not allowed in update requests).
        :param str source_ip: Only traffic originating from the respective IPv4 address is permitted. The value 'null' allows traffic from any IP address.
        :param str source_mac: Only traffic originating from the respective MAC address is permitted. Valid format: 'aa:bb:cc:dd:ee:ff'. The value 'null' allows traffic from any MAC address.
        :param str target_ip: If the target NIC has multiple IP addresses, only the traffic directed to the respective IP address of the NIC is allowed. The value 'null' allows traffic to any target IP address.
        :param str type: The firewall rule type. If not specified, the default value 'INGRESS' is used.
        """
        pulumi.set(__self__, "icmp_code", icmp_code)
        pulumi.set(__self__, "icmp_type", icmp_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port_range_end", port_range_end)
        pulumi.set(__self__, "port_range_start", port_range_start)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "source_ip", source_ip)
        pulumi.set(__self__, "source_mac", source_mac)
        pulumi.set(__self__, "target_ip", target_ip)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> int:
        """
        Sets the allowed code (from 0 to 254) when ICMP protocol is selected. The value 'null' allows all codes.
        """
        return pulumi.get(self, "icmp_code")

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> int:
        """
        Sets the allowed type (from 0 to 254) if the protocol ICMP is selected. The value 'null' allows all types.
        """
        return pulumi.get(self, "icmp_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the firewall rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="portRangeEnd")
    def port_range_end(self) -> int:
        """
        Sets the end range of the allowed port (from 1 to 65535) if the protocol TCP or UDP is selected. The value 'null' for 'port_range_start' and 'port_range_end' allows all ports.
        """
        return pulumi.get(self, "port_range_end")

    @property
    @pulumi.getter(name="portRangeStart")
    def port_range_start(self) -> int:
        """
        Sets the initial range of the allowed port (from 1 to 65535) if the protocol TCP or UDP is selected. The value 'null' for 'port_range_start' and 'port_range_end' allows all ports.
        """
        return pulumi.get(self, "port_range_start")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The protocol for the rule. The property cannot be modified after its creation (not allowed in update requests).
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> str:
        """
        Only traffic originating from the respective IPv4 address is permitted. The value 'null' allows traffic from any IP address.
        """
        return pulumi.get(self, "source_ip")

    @property
    @pulumi.getter(name="sourceMac")
    def source_mac(self) -> str:
        """
        Only traffic originating from the respective MAC address is permitted. Valid format: 'aa:bb:cc:dd:ee:ff'. The value 'null' allows traffic from any MAC address.
        """
        return pulumi.get(self, "source_mac")

    @property
    @pulumi.getter(name="targetIp")
    def target_ip(self) -> str:
        """
        If the target NIC has multiple IP addresses, only the traffic directed to the respective IP address of the NIC is allowed. The value 'null' allows traffic to any target IP address.
        """
        return pulumi.get(self, "target_ip")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The firewall rule type. If not specified, the default value 'INGRESS' is used.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetAutoscalingGroupReplicaConfigurationNicFlowLogResult(dict):
    def __init__(__self__, *,
                 action: str,
                 bucket: str,
                 direction: str,
                 id: str,
                 name: str):
        """
        :param str action: Specifies the traffic direction pattern. Valid values: ACCEPTED, REJECTED, ALL.
        :param str bucket: The bucket name of an existing IONOS Object Storage bucket.
        :param str direction: Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL.
        :param str id: The resource's unique identifier.
        :param str name: The resource name.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Specifies the traffic direction pattern. Valid values: ACCEPTED, REJECTED, ALL.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        The bucket name of an existing IONOS Object Storage bucket.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def direction(self) -> str:
        """
        Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The resource's unique identifier.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The resource name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutoscalingGroupReplicaConfigurationNicTargetGroupResult(dict):
    def __init__(__self__, *,
                 port: int,
                 target_group_id: str,
                 weight: int):
        """
        :param int port: The port for the target group.
        :param str target_group_id: The ID of the target group.
        :param int weight: The weight for the target group.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "target_group_id", target_group_id)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port for the target group.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="targetGroupId")
    def target_group_id(self) -> str:
        """
        The ID of the target group.
        """
        return pulumi.get(self, "target_group_id")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        The weight for the target group.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetAutoscalingGroupReplicaConfigurationVolumeResult(dict):
    def __init__(__self__, *,
                 backup_unit_id: str,
                 boot_order: str,
                 bus: str,
                 image: str,
                 image_alias: str,
                 name: str,
                 size: int,
                 ssh_keys: Sequence[str],
                 type: str):
        """
        :param str backup_unit_id: The uuid of the Backup Unit that user has access to.
        :param str boot_order: Determines whether the volume will be used as a boot volume: NONE - the volume will not be used as boot volume, PRIMARY - the volume will be used as boot volume, AUTO - will delegate the decision to the provisioning engine to decide whether to use the volume as boot volume.
        :param str bus: The bus type of the volume. Default setting is 'VIRTIO'. The bus type 'IDE' is also supported.
        :param str image: The image installed on the volume. Only the UUID of the image is presently supported.
        :param str image_alias: The image installed on the volume. Must be an 'imageAlias' as specified via the images API.
        :param str name: Name for this replica volume.
        :param int size: User-defined size for this replica volume in GB.
        :param str type: Storage Type for this replica volume. Possible values: SSD, HDD, SSD_STANDARD or SSD_PREMIUM
        """
        pulumi.set(__self__, "backup_unit_id", backup_unit_id)
        pulumi.set(__self__, "boot_order", boot_order)
        pulumi.set(__self__, "bus", bus)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "image_alias", image_alias)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "ssh_keys", ssh_keys)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="backupUnitId")
    def backup_unit_id(self) -> str:
        """
        The uuid of the Backup Unit that user has access to.
        """
        return pulumi.get(self, "backup_unit_id")

    @property
    @pulumi.getter(name="bootOrder")
    def boot_order(self) -> str:
        """
        Determines whether the volume will be used as a boot volume: NONE - the volume will not be used as boot volume, PRIMARY - the volume will be used as boot volume, AUTO - will delegate the decision to the provisioning engine to decide whether to use the volume as boot volume.
        """
        return pulumi.get(self, "boot_order")

    @property
    @pulumi.getter
    def bus(self) -> str:
        """
        The bus type of the volume. Default setting is 'VIRTIO'. The bus type 'IDE' is also supported.
        """
        return pulumi.get(self, "bus")

    @property
    @pulumi.getter
    def image(self) -> str:
        """
        The image installed on the volume. Only the UUID of the image is presently supported.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="imageAlias")
    def image_alias(self) -> str:
        """
        The image installed on the volume. Must be an 'imageAlias' as specified via the images API.
        """
        return pulumi.get(self, "image_alias")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name for this replica volume.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        User-defined size for this replica volume in GB.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Sequence[str]:
        return pulumi.get(self, "ssh_keys")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Storage Type for this replica volume. Possible values: SSD, HDD, SSD_STANDARD or SSD_PREMIUM
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetAutoscalingGroupServersServerResult(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: Unique identifier for the resource
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier for the resource
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetDataplatformNodePoolsNodePoolResult(dict):
    def __init__(__self__, *,
                 annotations: Mapping[str, str],
                 availability_zone: str,
                 cores_count: int,
                 cpu_family: str,
                 datacenter_id: str,
                 id: str,
                 labels: Mapping[str, str],
                 maintenance_windows: Sequence['outputs.GetDataplatformNodePoolsNodePoolMaintenanceWindowResult'],
                 name: str,
                 node_count: int,
                 ram_size: int,
                 storage_size: int,
                 storage_type: str,
                 version: str):
        """
        :param Mapping[str, str] annotations: Key-value pairs attached to node pool resource as kubernetes annotations
        :param str availability_zone: The availability zone of the virtual datacenter region where the node pool resources should be provisioned.
        :param int cores_count: The number of CPU cores per node.
        :param str cpu_family: A valid CPU family name or `AUTO` if the platform shall choose the best fitting option. Available CPU architectures can be retrieved from the datacenter resource.
        :param str datacenter_id: The UUID of the virtual data center (VDC) in which the node pool is provisioned
        :param Mapping[str, str] labels: Key-value pairs attached to the node pool resource as kubernetes labels
        :param Sequence['GetDataplatformNodePoolsNodePoolMaintenanceWindowArgs'] maintenance_windows: Starting time of a weekly 4 hour-long window, during which maintenance might occur in hh:mm:ss format
        :param str name: The name of your node pool.
        :param int node_count: The number of nodes that make up the node pool.
        :param int ram_size: The RAM size for one node in MB. Must be set in multiples of 1024 MB, with a minimum size is of 2048 MB.
        :param int storage_size: The size of the volume in GB. The size must be greater than 10GB.
        :param str storage_type: The type of hardware for the volume.
        :param str version: The version of the Data Platform.
        """
        pulumi.set(__self__, "annotations", annotations)
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "cores_count", cores_count)
        pulumi.set(__self__, "cpu_family", cpu_family)
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "maintenance_windows", maintenance_windows)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "node_count", node_count)
        pulumi.set(__self__, "ram_size", ram_size)
        pulumi.set(__self__, "storage_size", storage_size)
        pulumi.set(__self__, "storage_type", storage_type)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def annotations(self) -> Mapping[str, str]:
        """
        Key-value pairs attached to node pool resource as kubernetes annotations
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> str:
        """
        The availability zone of the virtual datacenter region where the node pool resources should be provisioned.
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="coresCount")
    def cores_count(self) -> int:
        """
        The number of CPU cores per node.
        """
        return pulumi.get(self, "cores_count")

    @property
    @pulumi.getter(name="cpuFamily")
    def cpu_family(self) -> str:
        """
        A valid CPU family name or `AUTO` if the platform shall choose the best fitting option. Available CPU architectures can be retrieved from the datacenter resource.
        """
        return pulumi.get(self, "cpu_family")

    @property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> str:
        """
        The UUID of the virtual data center (VDC) in which the node pool is provisioned
        """
        return pulumi.get(self, "datacenter_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, str]:
        """
        Key-value pairs attached to the node pool resource as kubernetes labels
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Sequence['outputs.GetDataplatformNodePoolsNodePoolMaintenanceWindowResult']:
        """
        Starting time of a weekly 4 hour-long window, during which maintenance might occur in hh:mm:ss format
        """
        return pulumi.get(self, "maintenance_windows")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of your node pool.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> int:
        """
        The number of nodes that make up the node pool.
        """
        return pulumi.get(self, "node_count")

    @property
    @pulumi.getter(name="ramSize")
    def ram_size(self) -> int:
        """
        The RAM size for one node in MB. Must be set in multiples of 1024 MB, with a minimum size is of 2048 MB.
        """
        return pulumi.get(self, "ram_size")

    @property
    @pulumi.getter(name="storageSize")
    def storage_size(self) -> int:
        """
        The size of the volume in GB. The size must be greater than 10GB.
        """
        return pulumi.get(self, "storage_size")

    @property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> str:
        """
        The type of hardware for the volume.
        """
        return pulumi.get(self, "storage_type")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        The version of the Data Platform.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetDataplatformNodePoolsNodePoolMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 day_of_the_week: str,
                 time: str):
        """
        :param str time: Time at which the maintenance should start. Must conform to the 'HH:MM:SS' 24-hour format.
        """
        pulumi.set(__self__, "day_of_the_week", day_of_the_week)
        pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter(name="dayOfTheWeek")
    def day_of_the_week(self) -> str:
        return pulumi.get(self, "day_of_the_week")

    @property
    @pulumi.getter
    def time(self) -> str:
        """
        Time at which the maintenance should start. Must conform to the 'HH:MM:SS' 24-hour format.
        """
        return pulumi.get(self, "time")


@pulumi.output_type
class GetInmemorydbSnapshotMetadataResult(dict):
    def __init__(__self__, *,
                 created_date: str,
                 datacenter_id: str,
                 last_modified_date: str,
                 replica_set_id: str,
                 snapshot_time: str):
        """
        :param str created_date: The ISO 8601 creation timestamp.
        :param str datacenter_id: The ID of the datacenter the snapshot was created in. Please mind, that the snapshot is not available in other datacenters.
        :param str last_modified_date: The ISO 8601 modified timestamp.
        :param str replica_set_id: The ID of the InMemoryDB replica set the snapshot is taken from.
        :param str snapshot_time: The time the snapshot was dumped from the replica set.
        """
        pulumi.set(__self__, "created_date", created_date)
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "last_modified_date", last_modified_date)
        pulumi.set(__self__, "replica_set_id", replica_set_id)
        pulumi.set(__self__, "snapshot_time", snapshot_time)

    @property
    @pulumi.getter(name="createdDate")
    def created_date(self) -> str:
        """
        The ISO 8601 creation timestamp.
        """
        return pulumi.get(self, "created_date")

    @property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> str:
        """
        The ID of the datacenter the snapshot was created in. Please mind, that the snapshot is not available in other datacenters.
        """
        return pulumi.get(self, "datacenter_id")

    @property
    @pulumi.getter(name="lastModifiedDate")
    def last_modified_date(self) -> str:
        """
        The ISO 8601 modified timestamp.
        """
        return pulumi.get(self, "last_modified_date")

    @property
    @pulumi.getter(name="replicaSetId")
    def replica_set_id(self) -> str:
        """
        The ID of the InMemoryDB replica set the snapshot is taken from.
        """
        return pulumi.get(self, "replica_set_id")

    @property
    @pulumi.getter(name="snapshotTime")
    def snapshot_time(self) -> str:
        """
        The time the snapshot was dumped from the replica set.
        """
        return pulumi.get(self, "snapshot_time")


@pulumi.output_type
class GetK8sClustersClusterResult(dict):
    def __init__(__self__, *,
                 api_subnet_allow_lists: Sequence[str],
                 available_upgrade_versions: Sequence[str],
                 ca_crt: str,
                 configs: Sequence['outputs.GetK8sClustersClusterConfigResult'],
                 k8s_version: str,
                 kube_config: str,
                 location: str,
                 maintenance_windows: Sequence['outputs.GetK8sClustersClusterMaintenanceWindowResult'],
                 nat_gateway_ip: str,
                 node_pools: Sequence[str],
                 node_subnet: str,
                 public: bool,
                 s3_buckets: Sequence['outputs.GetK8sClustersClusterS3BucketResult'],
                 server: str,
                 state: str,
                 user_tokens: Mapping[str, str],
                 viable_node_pool_versions: Sequence[str],
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param Sequence[str] api_subnet_allow_lists: Access to the K8s API server is restricted to these CIDRs. Cluster-internal traffic is not affected by this restriction. If no allowlist is specified, access is not restricted. If an IP without subnet mask is provided, the default value will be used: 32 for IPv4 and 128 for IPv6.
        :param Sequence[str] available_upgrade_versions: A list of available versions for upgrading the cluster
        :param Sequence['GetK8sClustersClusterMaintenanceWindowArgs'] maintenance_windows: A maintenance window comprise of a day of the week and a time for maintenance to be allowed
        :param str nat_gateway_ip: The NAT gateway IP of the cluster if the cluster is private.
        :param str node_subnet: The node subnet of the cluster, if the cluster is private.
        :param bool public: The indicator if the cluster is public or private.
        :param Sequence['GetK8sClustersClusterS3BucketArgs'] s3_buckets: List of Object Storage bucket configured for K8s usage. For now it contains only an Object Storage bucket used to store K8s API audit logs.
        :param Sequence[str] viable_node_pool_versions: A list of versions that may be used for node pools under this cluster
        """
        pulumi.set(__self__, "api_subnet_allow_lists", api_subnet_allow_lists)
        pulumi.set(__self__, "available_upgrade_versions", available_upgrade_versions)
        pulumi.set(__self__, "ca_crt", ca_crt)
        pulumi.set(__self__, "configs", configs)
        pulumi.set(__self__, "k8s_version", k8s_version)
        pulumi.set(__self__, "kube_config", kube_config)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "maintenance_windows", maintenance_windows)
        pulumi.set(__self__, "nat_gateway_ip", nat_gateway_ip)
        pulumi.set(__self__, "node_pools", node_pools)
        pulumi.set(__self__, "node_subnet", node_subnet)
        pulumi.set(__self__, "public", public)
        pulumi.set(__self__, "s3_buckets", s3_buckets)
        pulumi.set(__self__, "server", server)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "user_tokens", user_tokens)
        pulumi.set(__self__, "viable_node_pool_versions", viable_node_pool_versions)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="apiSubnetAllowLists")
    def api_subnet_allow_lists(self) -> Sequence[str]:
        """
        Access to the K8s API server is restricted to these CIDRs. Cluster-internal traffic is not affected by this restriction. If no allowlist is specified, access is not restricted. If an IP without subnet mask is provided, the default value will be used: 32 for IPv4 and 128 for IPv6.
        """
        return pulumi.get(self, "api_subnet_allow_lists")

    @property
    @pulumi.getter(name="availableUpgradeVersions")
    def available_upgrade_versions(self) -> Sequence[str]:
        """
        A list of available versions for upgrading the cluster
        """
        return pulumi.get(self, "available_upgrade_versions")

    @property
    @pulumi.getter(name="caCrt")
    def ca_crt(self) -> str:
        return pulumi.get(self, "ca_crt")

    @property
    @pulumi.getter
    def configs(self) -> Sequence['outputs.GetK8sClustersClusterConfigResult']:
        return pulumi.get(self, "configs")

    @property
    @pulumi.getter(name="k8sVersion")
    def k8s_version(self) -> str:
        return pulumi.get(self, "k8s_version")

    @property
    @pulumi.getter(name="kubeConfig")
    def kube_config(self) -> str:
        return pulumi.get(self, "kube_config")

    @property
    @pulumi.getter
    def location(self) -> str:
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Sequence['outputs.GetK8sClustersClusterMaintenanceWindowResult']:
        """
        A maintenance window comprise of a day of the week and a time for maintenance to be allowed
        """
        return pulumi.get(self, "maintenance_windows")

    @property
    @pulumi.getter(name="natGatewayIp")
    def nat_gateway_ip(self) -> str:
        """
        The NAT gateway IP of the cluster if the cluster is private.
        """
        return pulumi.get(self, "nat_gateway_ip")

    @property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Sequence[str]:
        return pulumi.get(self, "node_pools")

    @property
    @pulumi.getter(name="nodeSubnet")
    def node_subnet(self) -> str:
        """
        The node subnet of the cluster, if the cluster is private.
        """
        return pulumi.get(self, "node_subnet")

    @property
    @pulumi.getter
    def public(self) -> bool:
        """
        The indicator if the cluster is public or private.
        """
        return pulumi.get(self, "public")

    @property
    @pulumi.getter(name="s3Buckets")
    def s3_buckets(self) -> Sequence['outputs.GetK8sClustersClusterS3BucketResult']:
        """
        List of Object Storage bucket configured for K8s usage. For now it contains only an Object Storage bucket used to store K8s API audit logs.
        """
        return pulumi.get(self, "s3_buckets")

    @property
    @pulumi.getter
    def server(self) -> str:
        return pulumi.get(self, "server")

    @property
    @pulumi.getter
    def state(self) -> str:
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="userTokens")
    def user_tokens(self) -> Mapping[str, str]:
        return pulumi.get(self, "user_tokens")

    @property
    @pulumi.getter(name="viableNodePoolVersions")
    def viable_node_pool_versions(self) -> Sequence[str]:
        """
        A list of versions that may be used for node pools under this cluster
        """
        return pulumi.get(self, "viable_node_pool_versions")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetK8sClustersClusterConfigResult(dict):
    def __init__(__self__, *,
                 api_version: str,
                 clusters: Sequence['outputs.GetK8sClustersClusterConfigClusterResult'],
                 contexts: Sequence['outputs.GetK8sClustersClusterConfigContextResult'],
                 current_context: str,
                 kind: str,
                 users: Sequence['outputs.GetK8sClustersClusterConfigUserResult']):
        pulumi.set(__self__, "api_version", api_version)
        pulumi.set(__self__, "clusters", clusters)
        pulumi.set(__self__, "contexts", contexts)
        pulumi.set(__self__, "current_context", current_context)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> str:
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter
    def clusters(self) -> Sequence['outputs.GetK8sClustersClusterConfigClusterResult']:
        return pulumi.get(self, "clusters")

    @property
    @pulumi.getter
    def contexts(self) -> Sequence['outputs.GetK8sClustersClusterConfigContextResult']:
        return pulumi.get(self, "contexts")

    @property
    @pulumi.getter(name="currentContext")
    def current_context(self) -> str:
        return pulumi.get(self, "current_context")

    @property
    @pulumi.getter
    def kind(self) -> str:
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def users(self) -> Sequence['outputs.GetK8sClustersClusterConfigUserResult']:
        return pulumi.get(self, "users")


@pulumi.output_type
class GetK8sClustersClusterConfigClusterResult(dict):
    def __init__(__self__, *,
                 cluster: Mapping[str, str],
                 name: str):
        pulumi.set(__self__, "cluster", cluster)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def cluster(self) -> Mapping[str, str]:
        return pulumi.get(self, "cluster")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetK8sClustersClusterConfigContextResult(dict):
    def __init__(__self__, *,
                 context: Mapping[str, str],
                 name: str):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def context(self) -> Mapping[str, str]:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetK8sClustersClusterConfigUserResult(dict):
    def __init__(__self__, *,
                 name: str,
                 user: Mapping[str, str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def user(self) -> Mapping[str, str]:
        return pulumi.get(self, "user")


@pulumi.output_type
class GetK8sClustersClusterMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 day_of_the_week: str,
                 time: str):
        """
        :param str day_of_the_week: Day of the week when maintenance is allowed
        :param str time: A clock time in the day when maintenance is allowed
        """
        pulumi.set(__self__, "day_of_the_week", day_of_the_week)
        pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter(name="dayOfTheWeek")
    def day_of_the_week(self) -> str:
        """
        Day of the week when maintenance is allowed
        """
        return pulumi.get(self, "day_of_the_week")

    @property
    @pulumi.getter
    def time(self) -> str:
        """
        A clock time in the day when maintenance is allowed
        """
        return pulumi.get(self, "time")


@pulumi.output_type
class GetK8sClustersClusterS3BucketResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the Object Storage bucket
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Object Storage bucket
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetK8sClustersFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetK8sNodePoolNodesNodeResult(dict):
    def __init__(__self__, *,
                 k8s_version: str,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 private_ip: Optional[str] = None,
                 public_ip: Optional[str] = None):
        """
        :param str k8s_version: The kubernetes version
        :param str name: The kubernetes node name
        :param str private_ip: A valid private IP
        :param str public_ip: A valid public IP
        """
        pulumi.set(__self__, "k8s_version", k8s_version)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if private_ip is not None:
            pulumi.set(__self__, "private_ip", private_ip)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)

    @property
    @pulumi.getter(name="k8sVersion")
    def k8s_version(self) -> str:
        """
        The kubernetes version
        """
        return pulumi.get(self, "k8s_version")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The kubernetes node name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[str]:
        """
        A valid private IP
        """
        return pulumi.get(self, "private_ip")

    @property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[str]:
        """
        A valid public IP
        """
        return pulumi.get(self, "public_ip")


@pulumi.output_type
class GetKafkaClusterConnectionResult(dict):
    def __init__(__self__, *,
                 broker_addresses: Sequence[str],
                 datacenter_id: str,
                 lan_id: str):
        """
        :param Sequence[str] broker_addresses: The broker addresses of the Kafka Cluster
        :param str datacenter_id: The datacenter to connect your Kafka Cluster to.
        :param str lan_id: The numeric LAN ID to connect your Kafka Cluster to.
        """
        pulumi.set(__self__, "broker_addresses", broker_addresses)
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "lan_id", lan_id)

    @property
    @pulumi.getter(name="brokerAddresses")
    def broker_addresses(self) -> Sequence[str]:
        """
        The broker addresses of the Kafka Cluster
        """
        return pulumi.get(self, "broker_addresses")

    @property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> str:
        """
        The datacenter to connect your Kafka Cluster to.
        """
        return pulumi.get(self, "datacenter_id")

    @property
    @pulumi.getter(name="lanId")
    def lan_id(self) -> str:
        """
        The numeric LAN ID to connect your Kafka Cluster to.
        """
        return pulumi.get(self, "lan_id")


@pulumi.output_type
class GetLocationCpuArchitectureResult(dict):
    def __init__(__self__, *,
                 cpu_family: str,
                 max_cores: int,
                 max_ram: int,
                 vendor: str):
        pulumi.set(__self__, "cpu_family", cpu_family)
        pulumi.set(__self__, "max_cores", max_cores)
        pulumi.set(__self__, "max_ram", max_ram)
        pulumi.set(__self__, "vendor", vendor)

    @property
    @pulumi.getter(name="cpuFamily")
    def cpu_family(self) -> str:
        return pulumi.get(self, "cpu_family")

    @property
    @pulumi.getter(name="maxCores")
    def max_cores(self) -> int:
        return pulumi.get(self, "max_cores")

    @property
    @pulumi.getter(name="maxRam")
    def max_ram(self) -> int:
        return pulumi.get(self, "max_ram")

    @property
    @pulumi.getter
    def vendor(self) -> str:
        return pulumi.get(self, "vendor")


@pulumi.output_type
class GetMariadbBackupsBackupResult(dict):
    def __init__(__self__, *,
                 base_backups: Sequence['outputs.GetMariadbBackupsBackupBaseBackupResult'],
                 cluster_id: str,
                 earliest_recovery_target_time: str,
                 size: int):
        """
        :param Sequence['GetMariadbBackupsBackupBaseBackupArgs'] base_backups: The list of backups for the specified cluster
        :param str cluster_id: The unique ID of the cluster that was backed up
        :param str earliest_recovery_target_time: The oldest available timestamp to which you can restore
        :param int size: Size of all base backups in Mebibytes (MiB). This is at least the sum of all base backup sizes
        """
        pulumi.set(__self__, "base_backups", base_backups)
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "earliest_recovery_target_time", earliest_recovery_target_time)
        pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter(name="baseBackups")
    def base_backups(self) -> Sequence['outputs.GetMariadbBackupsBackupBaseBackupResult']:
        """
        The list of backups for the specified cluster
        """
        return pulumi.get(self, "base_backups")

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> str:
        """
        The unique ID of the cluster that was backed up
        """
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="earliestRecoveryTargetTime")
    def earliest_recovery_target_time(self) -> str:
        """
        The oldest available timestamp to which you can restore
        """
        return pulumi.get(self, "earliest_recovery_target_time")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        Size of all base backups in Mebibytes (MiB). This is at least the sum of all base backup sizes
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class GetMariadbBackupsBackupBaseBackupResult(dict):
    def __init__(__self__, *,
                 created: str,
                 size: int):
        """
        :param str created: The ISO 8601 creation timestamp
        :param int size: The size of the backup in Mebibytes (MiB). This is the size of the binary backup file that was stored
        """
        pulumi.set(__self__, "created", created)
        pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def created(self) -> str:
        """
        The ISO 8601 creation timestamp
        """
        return pulumi.get(self, "created")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        The size of the backup in Mebibytes (MiB). This is the size of the binary backup file that was stored
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class GetPgBackupsClusterBackupResult(dict):
    def __init__(__self__, *,
                 cluster_id: str,
                 earliest_recovery_target_time: str,
                 id: str,
                 is_active: bool,
                 location: str,
                 metadatas: Sequence['outputs.GetPgBackupsClusterBackupMetadataResult'],
                 size: int,
                 type: str,
                 version: str):
        """
        :param str cluster_id: The unique ID of the cluster
        :param str earliest_recovery_target_time: The oldest available timestamp to which you can restore.
        :param str id: The unique ID of the resource.
        :param bool is_active: Whether a cluster currently backs up data to this backup.
        :param str location: The Object Storage location where the backups will be stored.
        :param Sequence['GetPgBackupsClusterBackupMetadataArgs'] metadatas: Metadata of the resource
        :param int size: Size of all base backups including the wal size in MB.
        :param str version: The PostgreSQL version this backup was created from.
        """
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "earliest_recovery_target_time", earliest_recovery_target_time)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_active", is_active)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "metadatas", metadatas)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> str:
        """
        The unique ID of the cluster
        """
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="earliestRecoveryTargetTime")
    def earliest_recovery_target_time(self) -> str:
        """
        The oldest available timestamp to which you can restore.
        """
        return pulumi.get(self, "earliest_recovery_target_time")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The unique ID of the resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isActive")
    def is_active(self) -> bool:
        """
        Whether a cluster currently backs up data to this backup.
        """
        return pulumi.get(self, "is_active")

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        The Object Storage location where the backups will be stored.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def metadatas(self) -> Sequence['outputs.GetPgBackupsClusterBackupMetadataResult']:
        """
        Metadata of the resource
        """
        return pulumi.get(self, "metadatas")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        Size of all base backups including the wal size in MB.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        The PostgreSQL version this backup was created from.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetPgBackupsClusterBackupMetadataResult(dict):
    def __init__(__self__, *,
                 created_date: str):
        """
        :param str created_date: The ISO 8601 creation timestamp.
        """
        pulumi.set(__self__, "created_date", created_date)

    @property
    @pulumi.getter(name="createdDate")
    def created_date(self) -> str:
        """
        The ISO 8601 creation timestamp.
        """
        return pulumi.get(self, "created_date")


@pulumi.output_type
class GetPgDatabasesDatabaseResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str,
                 owner: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "owner", owner)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def owner(self) -> str:
        return pulumi.get(self, "owner")


@pulumi.output_type
class GetServersFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetServersServerResult(dict):
    def __init__(__self__, *,
                 availability_zone: str,
                 boot_cdrom: str,
                 boot_image: str,
                 boot_volume: str,
                 cdroms: Sequence['outputs.GetServersServerCdromResult'],
                 cores: int,
                 cpu_family: str,
                 id: str,
                 labels: Sequence['outputs.GetServersServerLabelResult'],
                 nics: Sequence['outputs.GetServersServerNicResult'],
                 ram: int,
                 token: str,
                 type: str,
                 vm_state: str,
                 volumes: Sequence['outputs.GetServersServerVolumeResult'],
                 name: Optional[str] = None,
                 template_uuid: Optional[str] = None):
        """
        :param str id: The unique ID of the server.
        """
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "boot_cdrom", boot_cdrom)
        pulumi.set(__self__, "boot_image", boot_image)
        pulumi.set(__self__, "boot_volume", boot_volume)
        pulumi.set(__self__, "cdroms", cdroms)
        pulumi.set(__self__, "cores", cores)
        pulumi.set(__self__, "cpu_family", cpu_family)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "nics", nics)
        pulumi.set(__self__, "ram", ram)
        pulumi.set(__self__, "token", token)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vm_state", vm_state)
        pulumi.set(__self__, "volumes", volumes)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if template_uuid is not None:
            pulumi.set(__self__, "template_uuid", template_uuid)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> str:
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="bootCdrom")
    def boot_cdrom(self) -> str:
        return pulumi.get(self, "boot_cdrom")

    @property
    @pulumi.getter(name="bootImage")
    def boot_image(self) -> str:
        return pulumi.get(self, "boot_image")

    @property
    @pulumi.getter(name="bootVolume")
    def boot_volume(self) -> str:
        return pulumi.get(self, "boot_volume")

    @property
    @pulumi.getter
    def cdroms(self) -> Sequence['outputs.GetServersServerCdromResult']:
        return pulumi.get(self, "cdroms")

    @property
    @pulumi.getter
    def cores(self) -> int:
        return pulumi.get(self, "cores")

    @property
    @pulumi.getter(name="cpuFamily")
    def cpu_family(self) -> str:
        return pulumi.get(self, "cpu_family")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The unique ID of the server.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def labels(self) -> Sequence['outputs.GetServersServerLabelResult']:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def nics(self) -> Sequence['outputs.GetServersServerNicResult']:
        return pulumi.get(self, "nics")

    @property
    @pulumi.getter
    def ram(self) -> int:
        return pulumi.get(self, "ram")

    @property
    @pulumi.getter
    def token(self) -> str:
        return pulumi.get(self, "token")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="vmState")
    def vm_state(self) -> str:
        return pulumi.get(self, "vm_state")

    @property
    @pulumi.getter
    def volumes(self) -> Sequence['outputs.GetServersServerVolumeResult']:
        return pulumi.get(self, "volumes")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="templateUuid")
    def template_uuid(self) -> Optional[str]:
        return pulumi.get(self, "template_uuid")


@pulumi.output_type
class GetServersServerCdromResult(dict):
    def __init__(__self__, *,
                 cloud_init: str,
                 cpu_hot_plug: bool,
                 cpu_hot_unplug: bool,
                 description: str,
                 disc_scsi_hot_plug: bool,
                 disc_scsi_hot_unplug: bool,
                 disc_virtio_hot_plug: bool,
                 disc_virtio_hot_unplug: bool,
                 id: str,
                 image_aliases: Sequence[str],
                 image_type: str,
                 licence_type: str,
                 location: str,
                 name: str,
                 nic_hot_plug: bool,
                 nic_hot_unplug: bool,
                 public: bool,
                 ram_hot_plug: bool,
                 ram_hot_unplug: bool,
                 size: float):
        pulumi.set(__self__, "cloud_init", cloud_init)
        pulumi.set(__self__, "cpu_hot_plug", cpu_hot_plug)
        pulumi.set(__self__, "cpu_hot_unplug", cpu_hot_unplug)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "disc_scsi_hot_plug", disc_scsi_hot_plug)
        pulumi.set(__self__, "disc_scsi_hot_unplug", disc_scsi_hot_unplug)
        pulumi.set(__self__, "disc_virtio_hot_plug", disc_virtio_hot_plug)
        pulumi.set(__self__, "disc_virtio_hot_unplug", disc_virtio_hot_unplug)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "image_aliases", image_aliases)
        pulumi.set(__self__, "image_type", image_type)
        pulumi.set(__self__, "licence_type", licence_type)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "nic_hot_plug", nic_hot_plug)
        pulumi.set(__self__, "nic_hot_unplug", nic_hot_unplug)
        pulumi.set(__self__, "public", public)
        pulumi.set(__self__, "ram_hot_plug", ram_hot_plug)
        pulumi.set(__self__, "ram_hot_unplug", ram_hot_unplug)
        pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter(name="cloudInit")
    def cloud_init(self) -> str:
        return pulumi.get(self, "cloud_init")

    @property
    @pulumi.getter(name="cpuHotPlug")
    def cpu_hot_plug(self) -> bool:
        return pulumi.get(self, "cpu_hot_plug")

    @property
    @pulumi.getter(name="cpuHotUnplug")
    def cpu_hot_unplug(self) -> bool:
        return pulumi.get(self, "cpu_hot_unplug")

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="discScsiHotPlug")
    def disc_scsi_hot_plug(self) -> bool:
        return pulumi.get(self, "disc_scsi_hot_plug")

    @property
    @pulumi.getter(name="discScsiHotUnplug")
    def disc_scsi_hot_unplug(self) -> bool:
        return pulumi.get(self, "disc_scsi_hot_unplug")

    @property
    @pulumi.getter(name="discVirtioHotPlug")
    def disc_virtio_hot_plug(self) -> bool:
        return pulumi.get(self, "disc_virtio_hot_plug")

    @property
    @pulumi.getter(name="discVirtioHotUnplug")
    def disc_virtio_hot_unplug(self) -> bool:
        return pulumi.get(self, "disc_virtio_hot_unplug")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="imageAliases")
    def image_aliases(self) -> Sequence[str]:
        return pulumi.get(self, "image_aliases")

    @property
    @pulumi.getter(name="imageType")
    def image_type(self) -> str:
        return pulumi.get(self, "image_type")

    @property
    @pulumi.getter(name="licenceType")
    def licence_type(self) -> str:
        return pulumi.get(self, "licence_type")

    @property
    @pulumi.getter
    def location(self) -> str:
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nicHotPlug")
    def nic_hot_plug(self) -> bool:
        return pulumi.get(self, "nic_hot_plug")

    @property
    @pulumi.getter(name="nicHotUnplug")
    def nic_hot_unplug(self) -> bool:
        return pulumi.get(self, "nic_hot_unplug")

    @property
    @pulumi.getter
    def public(self) -> bool:
        return pulumi.get(self, "public")

    @property
    @pulumi.getter(name="ramHotPlug")
    def ram_hot_plug(self) -> bool:
        return pulumi.get(self, "ram_hot_plug")

    @property
    @pulumi.getter(name="ramHotUnplug")
    def ram_hot_unplug(self) -> bool:
        return pulumi.get(self, "ram_hot_unplug")

    @property
    @pulumi.getter
    def size(self) -> float:
        return pulumi.get(self, "size")


@pulumi.output_type
class GetServersServerLabelResult(dict):
    def __init__(__self__, *,
                 id: str,
                 key: str,
                 value: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetServersServerNicResult(dict):
    def __init__(__self__, *,
                 device_number: int,
                 dhcp: bool,
                 firewall_active: bool,
                 firewall_rules: Sequence['outputs.GetServersServerNicFirewallRuleResult'],
                 firewall_type: str,
                 id: str,
                 ips: Sequence[str],
                 ipv6_cidr_block: str,
                 ipv6_ips: Sequence[str],
                 lan: int,
                 mac: str,
                 name: str,
                 pci_slot: int,
                 dhcpv6: Optional[bool] = None):
        pulumi.set(__self__, "device_number", device_number)
        pulumi.set(__self__, "dhcp", dhcp)
        pulumi.set(__self__, "firewall_active", firewall_active)
        pulumi.set(__self__, "firewall_rules", firewall_rules)
        pulumi.set(__self__, "firewall_type", firewall_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)
        pulumi.set(__self__, "ipv6_ips", ipv6_ips)
        pulumi.set(__self__, "lan", lan)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pci_slot", pci_slot)
        if dhcpv6 is not None:
            pulumi.set(__self__, "dhcpv6", dhcpv6)

    @property
    @pulumi.getter(name="deviceNumber")
    def device_number(self) -> int:
        return pulumi.get(self, "device_number")

    @property
    @pulumi.getter
    def dhcp(self) -> bool:
        return pulumi.get(self, "dhcp")

    @property
    @pulumi.getter(name="firewallActive")
    def firewall_active(self) -> bool:
        return pulumi.get(self, "firewall_active")

    @property
    @pulumi.getter(name="firewallRules")
    def firewall_rules(self) -> Sequence['outputs.GetServersServerNicFirewallRuleResult']:
        return pulumi.get(self, "firewall_rules")

    @property
    @pulumi.getter(name="firewallType")
    def firewall_type(self) -> str:
        return pulumi.get(self, "firewall_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ips(self) -> Sequence[str]:
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> str:
        return pulumi.get(self, "ipv6_cidr_block")

    @property
    @pulumi.getter(name="ipv6Ips")
    def ipv6_ips(self) -> Sequence[str]:
        return pulumi.get(self, "ipv6_ips")

    @property
    @pulumi.getter
    def lan(self) -> int:
        return pulumi.get(self, "lan")

    @property
    @pulumi.getter
    def mac(self) -> str:
        return pulumi.get(self, "mac")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="pciSlot")
    def pci_slot(self) -> int:
        return pulumi.get(self, "pci_slot")

    @property
    @pulumi.getter
    def dhcpv6(self) -> Optional[bool]:
        return pulumi.get(self, "dhcpv6")


@pulumi.output_type
class GetServersServerNicFirewallRuleResult(dict):
    def __init__(__self__, *,
                 icmp_code: int,
                 icmp_type: int,
                 id: str,
                 name: str,
                 port_range_end: int,
                 port_range_start: int,
                 protocol: str,
                 source_ip: str,
                 source_mac: str,
                 target_ip: str,
                 type: str):
        pulumi.set(__self__, "icmp_code", icmp_code)
        pulumi.set(__self__, "icmp_type", icmp_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port_range_end", port_range_end)
        pulumi.set(__self__, "port_range_start", port_range_start)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "source_ip", source_ip)
        pulumi.set(__self__, "source_mac", source_mac)
        pulumi.set(__self__, "target_ip", target_ip)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> int:
        return pulumi.get(self, "icmp_code")

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> int:
        return pulumi.get(self, "icmp_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="portRangeEnd")
    def port_range_end(self) -> int:
        return pulumi.get(self, "port_range_end")

    @property
    @pulumi.getter(name="portRangeStart")
    def port_range_start(self) -> int:
        return pulumi.get(self, "port_range_start")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> str:
        return pulumi.get(self, "source_ip")

    @property
    @pulumi.getter(name="sourceMac")
    def source_mac(self) -> str:
        return pulumi.get(self, "source_mac")

    @property
    @pulumi.getter(name="targetIp")
    def target_ip(self) -> str:
        return pulumi.get(self, "target_ip")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetServersServerVolumeResult(dict):
    def __init__(__self__, *,
                 availability_zone: str,
                 backup_unit_id: str,
                 boot_server: str,
                 bus: str,
                 cpu_hot_plug: bool,
                 device_number: int,
                 disc_virtio_hot_plug: bool,
                 disc_virtio_hot_unplug: bool,
                 disk_type: str,
                 id: str,
                 image_name: str,
                 image_password: str,
                 licence_type: str,
                 name: str,
                 nic_hot_plug: bool,
                 nic_hot_unplug: bool,
                 pci_slot: int,
                 ram_hot_plug: bool,
                 size: int,
                 ssh_keys: Sequence[str],
                 user_data: Optional[str] = None):
        """
        :param str boot_server: The UUID of the attached server.
        """
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "backup_unit_id", backup_unit_id)
        pulumi.set(__self__, "boot_server", boot_server)
        pulumi.set(__self__, "bus", bus)
        pulumi.set(__self__, "cpu_hot_plug", cpu_hot_plug)
        pulumi.set(__self__, "device_number", device_number)
        pulumi.set(__self__, "disc_virtio_hot_plug", disc_virtio_hot_plug)
        pulumi.set(__self__, "disc_virtio_hot_unplug", disc_virtio_hot_unplug)
        pulumi.set(__self__, "disk_type", disk_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "image_name", image_name)
        pulumi.set(__self__, "image_password", image_password)
        pulumi.set(__self__, "licence_type", licence_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "nic_hot_plug", nic_hot_plug)
        pulumi.set(__self__, "nic_hot_unplug", nic_hot_unplug)
        pulumi.set(__self__, "pci_slot", pci_slot)
        pulumi.set(__self__, "ram_hot_plug", ram_hot_plug)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "ssh_keys", ssh_keys)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> str:
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="backupUnitId")
    def backup_unit_id(self) -> str:
        return pulumi.get(self, "backup_unit_id")

    @property
    @pulumi.getter(name="bootServer")
    def boot_server(self) -> str:
        """
        The UUID of the attached server.
        """
        return pulumi.get(self, "boot_server")

    @property
    @pulumi.getter
    def bus(self) -> str:
        return pulumi.get(self, "bus")

    @property
    @pulumi.getter(name="cpuHotPlug")
    def cpu_hot_plug(self) -> bool:
        return pulumi.get(self, "cpu_hot_plug")

    @property
    @pulumi.getter(name="deviceNumber")
    def device_number(self) -> int:
        return pulumi.get(self, "device_number")

    @property
    @pulumi.getter(name="discVirtioHotPlug")
    def disc_virtio_hot_plug(self) -> bool:
        return pulumi.get(self, "disc_virtio_hot_plug")

    @property
    @pulumi.getter(name="discVirtioHotUnplug")
    def disc_virtio_hot_unplug(self) -> bool:
        return pulumi.get(self, "disc_virtio_hot_unplug")

    @property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> str:
        return pulumi.get(self, "disk_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="imageName")
    def image_name(self) -> str:
        return pulumi.get(self, "image_name")

    @property
    @pulumi.getter(name="imagePassword")
    def image_password(self) -> str:
        return pulumi.get(self, "image_password")

    @property
    @pulumi.getter(name="licenceType")
    def licence_type(self) -> str:
        return pulumi.get(self, "licence_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nicHotPlug")
    def nic_hot_plug(self) -> bool:
        return pulumi.get(self, "nic_hot_plug")

    @property
    @pulumi.getter(name="nicHotUnplug")
    def nic_hot_unplug(self) -> bool:
        return pulumi.get(self, "nic_hot_unplug")

    @property
    @pulumi.getter(name="pciSlot")
    def pci_slot(self) -> int:
        return pulumi.get(self, "pci_slot")

    @property
    @pulumi.getter(name="ramHotPlug")
    def ram_hot_plug(self) -> bool:
        return pulumi.get(self, "ram_hot_plug")

    @property
    @pulumi.getter
    def size(self) -> int:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Sequence[str]:
        return pulumi.get(self, "ssh_keys")

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[str]:
        return pulumi.get(self, "user_data")


@pulumi.output_type
class GetTargetGroupHealthCheckResult(dict):
    def __init__(__self__, *,
                 check_interval: int,
                 check_timeout: int,
                 retries: int):
        """
        :param int check_interval: The interval in milliseconds between consecutive health checks; default is 2000.
        :param int check_timeout: The maximum time in milliseconds to wait for a target to respond to a check. For target VMs with 'Check Interval' set, the lesser of the two  values is used once the TCP connection is established.
        :param int retries: The maximum number of attempts to reconnect to a target after a connection failure. Valid range is 0 to 65535, and default is three reconnection.
        """
        pulumi.set(__self__, "check_interval", check_interval)
        pulumi.set(__self__, "check_timeout", check_timeout)
        pulumi.set(__self__, "retries", retries)

    @property
    @pulumi.getter(name="checkInterval")
    def check_interval(self) -> int:
        """
        The interval in milliseconds between consecutive health checks; default is 2000.
        """
        return pulumi.get(self, "check_interval")

    @property
    @pulumi.getter(name="checkTimeout")
    def check_timeout(self) -> int:
        """
        The maximum time in milliseconds to wait for a target to respond to a check. For target VMs with 'Check Interval' set, the lesser of the two  values is used once the TCP connection is established.
        """
        return pulumi.get(self, "check_timeout")

    @property
    @pulumi.getter
    def retries(self) -> int:
        """
        The maximum number of attempts to reconnect to a target after a connection failure. Valid range is 0 to 65535, and default is three reconnection.
        """
        return pulumi.get(self, "retries")


@pulumi.output_type
class GetTargetGroupHttpHealthCheckResult(dict):
    def __init__(__self__, *,
                 match_type: str,
                 method: str,
                 negate: bool,
                 path: str,
                 regex: bool,
                 response: str):
        """
        :param str method: The method for the HTTP health check.
        :param str path: The path (destination URL) for the HTTP health check request; the default is /.
        :param str response: The response returned by the request, depending on the match type.
        """
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "negate", negate)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "regex", regex)
        pulumi.set(__self__, "response", response)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> str:
        return pulumi.get(self, "match_type")

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        The method for the HTTP health check.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def negate(self) -> bool:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The path (destination URL) for the HTTP health check request; the default is /.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def regex(self) -> bool:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def response(self) -> str:
        """
        The response returned by the request, depending on the match type.
        """
        return pulumi.get(self, "response")


@pulumi.output_type
class GetTargetGroupTargetResult(dict):
    def __init__(__self__, *,
                 health_check_enabled: bool,
                 ip: str,
                 maintenance_enabled: bool,
                 port: int,
                 proxy_protocol: str,
                 weight: int):
        """
        :param bool health_check_enabled: Makes the target available only if it accepts periodic health check TCP connection attempts; when turned off, the target is considered always available. The health check only consists of a connection attempt to the address and port of the target. Default is True.
        :param str ip: The IP of the balanced target VM.
        :param bool maintenance_enabled: Maintenance mode prevents the target from receiving balanced traffic.
        :param int port: The port of the balanced target service; valid range is 1 to 65535.
        :param str proxy_protocol: Proxy protocol version
        :param int weight: Traffic is distributed in proportion to target weight, relative to the combined weight of all targets. A target with higher weight receives a greater share of traffic. Valid range is 0 to 256 and default is 1; targets with weight of 0 do not participate in load balancing but still accept persistent connections. It is best use values in the middle of the range to leave room for later adjustments.
        """
        pulumi.set(__self__, "health_check_enabled", health_check_enabled)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "maintenance_enabled", maintenance_enabled)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "proxy_protocol", proxy_protocol)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="healthCheckEnabled")
    def health_check_enabled(self) -> bool:
        """
        Makes the target available only if it accepts periodic health check TCP connection attempts; when turned off, the target is considered always available. The health check only consists of a connection attempt to the address and port of the target. Default is True.
        """
        return pulumi.get(self, "health_check_enabled")

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        The IP of the balanced target VM.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="maintenanceEnabled")
    def maintenance_enabled(self) -> bool:
        """
        Maintenance mode prevents the target from receiving balanced traffic.
        """
        return pulumi.get(self, "maintenance_enabled")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port of the balanced target service; valid range is 1 to 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="proxyProtocol")
    def proxy_protocol(self) -> str:
        """
        Proxy protocol version
        """
        return pulumi.get(self, "proxy_protocol")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        Traffic is distributed in proportion to target weight, relative to the combined weight of all targets. A target with higher weight receives a greater share of traffic. Valid range is 0 to 256 and default is 1; targets with weight of 0 do not participate in load balancing but still accept persistent connections. It is best use values in the middle of the range to leave room for later adjustments.
        """
        return pulumi.get(self, "weight")


