# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'TargetGroupHealthCheck',
    'TargetGroupHttpHealthCheck',
    'TargetGroupTarget',
    'GetDataplatformNodePoolsNodePoolResult',
    'GetDataplatformNodePoolsNodePoolMaintenanceWindowResult',
    'GetInmemorydbSnapshotMetadataResult',
    'GetK8sClustersClusterResult',
    'GetK8sClustersClusterConfigResult',
    'GetK8sClustersClusterConfigClusterResult',
    'GetK8sClustersClusterConfigContextResult',
    'GetK8sClustersClusterConfigUserResult',
    'GetK8sClustersClusterMaintenanceWindowResult',
    'GetK8sClustersClusterS3BucketResult',
    'GetK8sClustersFilterResult',
    'GetK8sNodePoolNodesNodeResult',
    'GetLocationCpuArchitectureResult',
    'GetMariadbBackupsBackupResult',
    'GetMariadbBackupsBackupBaseBackupResult',
    'GetPgBackupsClusterBackupResult',
    'GetPgBackupsClusterBackupMetadataResult',
    'GetPgDatabasesDatabaseResult',
    'GetServersFilterResult',
    'GetServersServerResult',
    'GetServersServerCdromResult',
    'GetServersServerLabelResult',
    'GetServersServerNicResult',
    'GetServersServerNicFirewallRuleResult',
    'GetServersServerVolumeResult',
    'GetTargetGroupHealthCheckResult',
    'GetTargetGroupHttpHealthCheckResult',
    'GetTargetGroupTargetResult',
]

@pulumi.output_type
class TargetGroupHealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkInterval":
            suggest = "check_interval"
        elif key == "checkTimeout":
            suggest = "check_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetGroupHealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetGroupHealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetGroupHealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check_interval: Optional[int] = None,
                 check_timeout: Optional[int] = None,
                 retries: Optional[int] = None):
        """
        :param int check_interval: [int] The interval in milliseconds between consecutive health checks; default is 2000.
        :param int check_timeout: [int] The maximum time in milliseconds to wait for a target to respond to a check. For target VMs with 'Check Interval' set, the lesser of the two  values is used once the TCP connection is established.
        :param int retries: [int] The maximum number of attempts to reconnect to a target after a connection failure. Valid range is 0 to 65535, and default is three reconnection.
        """
        if check_interval is not None:
            pulumi.set(__self__, "check_interval", check_interval)
        if check_timeout is not None:
            pulumi.set(__self__, "check_timeout", check_timeout)
        if retries is not None:
            pulumi.set(__self__, "retries", retries)

    @property
    @pulumi.getter(name="checkInterval")
    def check_interval(self) -> Optional[int]:
        """
        [int] The interval in milliseconds between consecutive health checks; default is 2000.
        """
        return pulumi.get(self, "check_interval")

    @property
    @pulumi.getter(name="checkTimeout")
    def check_timeout(self) -> Optional[int]:
        """
        [int] The maximum time in milliseconds to wait for a target to respond to a check. For target VMs with 'Check Interval' set, the lesser of the two  values is used once the TCP connection is established.
        """
        return pulumi.get(self, "check_timeout")

    @property
    @pulumi.getter
    def retries(self) -> Optional[int]:
        """
        [int] The maximum number of attempts to reconnect to a target after a connection failure. Valid range is 0 to 65535, and default is three reconnection.
        """
        return pulumi.get(self, "retries")


@pulumi.output_type
class TargetGroupHttpHealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchType":
            suggest = "match_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetGroupHttpHealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetGroupHttpHealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetGroupHttpHealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_type: str,
                 response: str,
                 method: Optional[str] = None,
                 negate: Optional[bool] = None,
                 path: Optional[str] = None,
                 regex: Optional[bool] = None):
        """
        :param str match_type: [string]
        :param str response: [string] The response returned by the request, depending on the match type.
        :param str method: [string] The method for the HTTP health check.
        :param bool negate: [bool]
        :param str path: [string] The path (destination URL) for the HTTP health check request; the default is /.
        :param bool regex: [bool]
        """
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "response", response)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> str:
        """
        [string]
        """
        return pulumi.get(self, "match_type")

    @property
    @pulumi.getter
    def response(self) -> str:
        """
        [string] The response returned by the request, depending on the match type.
        """
        return pulumi.get(self, "response")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        [string] The method for the HTTP health check.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        [bool]
        """
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        [string] The path (destination URL) for the HTTP health check request; the default is /.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        """
        [bool]
        """
        return pulumi.get(self, "regex")


@pulumi.output_type
class TargetGroupTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "healthCheckEnabled":
            suggest = "health_check_enabled"
        elif key == "maintenanceEnabled":
            suggest = "maintenance_enabled"
        elif key == "proxyProtocol":
            suggest = "proxy_protocol"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetGroupTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetGroupTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetGroupTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip: str,
                 port: int,
                 weight: int,
                 health_check_enabled: Optional[bool] = None,
                 maintenance_enabled: Optional[bool] = None,
                 proxy_protocol: Optional[str] = None):
        """
        :param str ip: [string] The IP of the balanced target VM.
        :param int port: [int] The port of the balanced target service; valid range is 1 to 65535.
        :param int weight: [int] Traffic is distributed in proportion to target weight, relative to the combined weight of all targets. A target with higher weight receives a greater share of traffic. Valid range is 0 to 256 and default is 1; targets with weight of 0 do not participate in load balancing but still accept persistent connections. It is best use values in the middle of the range to leave room for later adjustments.
        :param bool health_check_enabled: [bool] Makes the target available only if it accepts periodic health check TCP connection attempts; when turned off, the target is considered always available. The health check only consists of a connection attempt to the address and port of the target. Default is True.
        :param bool maintenance_enabled: [bool] Maintenance mode prevents the target from receiving balanced traffic.
        :param str proxy_protocol: [string] The proxy protocol version. Accepted values are `none`, `v1`, `v2`, `v2ssl`. If unspecified, the default value of `none` is used.
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "weight", weight)
        if health_check_enabled is not None:
            pulumi.set(__self__, "health_check_enabled", health_check_enabled)
        if maintenance_enabled is not None:
            pulumi.set(__self__, "maintenance_enabled", maintenance_enabled)
        if proxy_protocol is not None:
            pulumi.set(__self__, "proxy_protocol", proxy_protocol)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        [string] The IP of the balanced target VM.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        [int] The port of the balanced target service; valid range is 1 to 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        [int] Traffic is distributed in proportion to target weight, relative to the combined weight of all targets. A target with higher weight receives a greater share of traffic. Valid range is 0 to 256 and default is 1; targets with weight of 0 do not participate in load balancing but still accept persistent connections. It is best use values in the middle of the range to leave room for later adjustments.
        """
        return pulumi.get(self, "weight")

    @property
    @pulumi.getter(name="healthCheckEnabled")
    def health_check_enabled(self) -> Optional[bool]:
        """
        [bool] Makes the target available only if it accepts periodic health check TCP connection attempts; when turned off, the target is considered always available. The health check only consists of a connection attempt to the address and port of the target. Default is True.
        """
        return pulumi.get(self, "health_check_enabled")

    @property
    @pulumi.getter(name="maintenanceEnabled")
    def maintenance_enabled(self) -> Optional[bool]:
        """
        [bool] Maintenance mode prevents the target from receiving balanced traffic.
        """
        return pulumi.get(self, "maintenance_enabled")

    @property
    @pulumi.getter(name="proxyProtocol")
    def proxy_protocol(self) -> Optional[str]:
        """
        [string] The proxy protocol version. Accepted values are `none`, `v1`, `v2`, `v2ssl`. If unspecified, the default value of `none` is used.
        """
        return pulumi.get(self, "proxy_protocol")


@pulumi.output_type
class GetDataplatformNodePoolsNodePoolResult(dict):
    def __init__(__self__, *,
                 annotations: Mapping[str, str],
                 availability_zone: str,
                 cores_count: int,
                 cpu_family: str,
                 datacenter_id: str,
                 id: str,
                 labels: Mapping[str, str],
                 maintenance_windows: Sequence['outputs.GetDataplatformNodePoolsNodePoolMaintenanceWindowResult'],
                 name: str,
                 node_count: int,
                 ram_size: int,
                 storage_size: int,
                 storage_type: str,
                 version: str):
        """
        :param Mapping[str, str] annotations: Key-value pairs attached to node pool resource as kubernetes annotations
        :param str availability_zone: The availability zone of the virtual datacenter region where the node pool resources should be provisioned.
        :param int cores_count: The number of CPU cores per node.
        :param str cpu_family: A valid CPU family name or `AUTO` if the platform shall choose the best fitting option. Available CPU architectures can be retrieved from the datacenter resource.
        :param str datacenter_id: The UUID of the virtual data center (VDC) in which the node pool is provisioned
        :param Mapping[str, str] labels: Key-value pairs attached to the node pool resource as kubernetes labels
        :param Sequence['GetDataplatformNodePoolsNodePoolMaintenanceWindowArgs'] maintenance_windows: Starting time of a weekly 4 hour-long window, during which maintenance might occur in hh:mm:ss format
        :param str name: Name of an existing cluster that you want to search for. Search by name is case-insensitive. The whole resource name is required if `partial_match` parameter is not set to true.
        :param int node_count: The number of nodes that make up the node pool.
        :param int ram_size: The RAM size for one node in MB. Must be set in multiples of 1024 MB, with a minimum size is of 2048 MB.
        :param int storage_size: The size of the volume in GB. The size must be greater than 10GB.
        :param str storage_type: The type of hardware for the volume.
        :param str version: The version of the Data Platform.
        """
        pulumi.set(__self__, "annotations", annotations)
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "cores_count", cores_count)
        pulumi.set(__self__, "cpu_family", cpu_family)
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "maintenance_windows", maintenance_windows)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "node_count", node_count)
        pulumi.set(__self__, "ram_size", ram_size)
        pulumi.set(__self__, "storage_size", storage_size)
        pulumi.set(__self__, "storage_type", storage_type)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def annotations(self) -> Mapping[str, str]:
        """
        Key-value pairs attached to node pool resource as kubernetes annotations
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> str:
        """
        The availability zone of the virtual datacenter region where the node pool resources should be provisioned.
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="coresCount")
    def cores_count(self) -> int:
        """
        The number of CPU cores per node.
        """
        return pulumi.get(self, "cores_count")

    @property
    @pulumi.getter(name="cpuFamily")
    def cpu_family(self) -> str:
        """
        A valid CPU family name or `AUTO` if the platform shall choose the best fitting option. Available CPU architectures can be retrieved from the datacenter resource.
        """
        return pulumi.get(self, "cpu_family")

    @property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> str:
        """
        The UUID of the virtual data center (VDC) in which the node pool is provisioned
        """
        return pulumi.get(self, "datacenter_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, str]:
        """
        Key-value pairs attached to the node pool resource as kubernetes labels
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Sequence['outputs.GetDataplatformNodePoolsNodePoolMaintenanceWindowResult']:
        """
        Starting time of a weekly 4 hour-long window, during which maintenance might occur in hh:mm:ss format
        """
        return pulumi.get(self, "maintenance_windows")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of an existing cluster that you want to search for. Search by name is case-insensitive. The whole resource name is required if `partial_match` parameter is not set to true.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> int:
        """
        The number of nodes that make up the node pool.
        """
        return pulumi.get(self, "node_count")

    @property
    @pulumi.getter(name="ramSize")
    def ram_size(self) -> int:
        """
        The RAM size for one node in MB. Must be set in multiples of 1024 MB, with a minimum size is of 2048 MB.
        """
        return pulumi.get(self, "ram_size")

    @property
    @pulumi.getter(name="storageSize")
    def storage_size(self) -> int:
        """
        The size of the volume in GB. The size must be greater than 10GB.
        """
        return pulumi.get(self, "storage_size")

    @property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> str:
        """
        The type of hardware for the volume.
        """
        return pulumi.get(self, "storage_type")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        The version of the Data Platform.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetDataplatformNodePoolsNodePoolMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 day_of_the_week: str,
                 time: str):
        """
        :param str time: Time at which the maintenance should start. Must conform to the 'HH:MM:SS' 24-hour format.
        """
        pulumi.set(__self__, "day_of_the_week", day_of_the_week)
        pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter(name="dayOfTheWeek")
    def day_of_the_week(self) -> str:
        return pulumi.get(self, "day_of_the_week")

    @property
    @pulumi.getter
    def time(self) -> str:
        """
        Time at which the maintenance should start. Must conform to the 'HH:MM:SS' 24-hour format.
        """
        return pulumi.get(self, "time")


@pulumi.output_type
class GetInmemorydbSnapshotMetadataResult(dict):
    def __init__(__self__, *,
                 created_date: str,
                 datacenter_id: str,
                 last_modified_date: str,
                 replica_set_id: str,
                 snapshot_time: str):
        """
        :param str created_date: The ISO 8601 creation timestamp.
        :param str datacenter_id: The ID of the datacenter the snapshot was created in. Please mind, that the snapshot is not available in other datacenters.
        :param str last_modified_date: The ISO 8601 modified timestamp.
        :param str replica_set_id: The ID of the InMemoryDB replica set the snapshot is taken from.
        :param str snapshot_time: The time the snapshot was dumped from the replica set.
        """
        pulumi.set(__self__, "created_date", created_date)
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "last_modified_date", last_modified_date)
        pulumi.set(__self__, "replica_set_id", replica_set_id)
        pulumi.set(__self__, "snapshot_time", snapshot_time)

    @property
    @pulumi.getter(name="createdDate")
    def created_date(self) -> str:
        """
        The ISO 8601 creation timestamp.
        """
        return pulumi.get(self, "created_date")

    @property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> str:
        """
        The ID of the datacenter the snapshot was created in. Please mind, that the snapshot is not available in other datacenters.
        """
        return pulumi.get(self, "datacenter_id")

    @property
    @pulumi.getter(name="lastModifiedDate")
    def last_modified_date(self) -> str:
        """
        The ISO 8601 modified timestamp.
        """
        return pulumi.get(self, "last_modified_date")

    @property
    @pulumi.getter(name="replicaSetId")
    def replica_set_id(self) -> str:
        """
        The ID of the InMemoryDB replica set the snapshot is taken from.
        """
        return pulumi.get(self, "replica_set_id")

    @property
    @pulumi.getter(name="snapshotTime")
    def snapshot_time(self) -> str:
        """
        The time the snapshot was dumped from the replica set.
        """
        return pulumi.get(self, "snapshot_time")


@pulumi.output_type
class GetK8sClustersClusterResult(dict):
    def __init__(__self__, *,
                 api_subnet_allow_lists: Sequence[str],
                 available_upgrade_versions: Sequence[str],
                 ca_crt: str,
                 configs: Sequence['outputs.GetK8sClustersClusterConfigResult'],
                 k8s_version: str,
                 kube_config: str,
                 location: str,
                 maintenance_windows: Sequence['outputs.GetK8sClustersClusterMaintenanceWindowResult'],
                 nat_gateway_ip: str,
                 node_pools: Sequence[str],
                 node_subnet: str,
                 public: bool,
                 s3_buckets: Sequence['outputs.GetK8sClustersClusterS3BucketResult'],
                 server: str,
                 state: str,
                 user_tokens: Mapping[str, str],
                 viable_node_pool_versions: Sequence[str],
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param Sequence[str] api_subnet_allow_lists: Access to the K8s API server is restricted to these CIDRs. Cluster-internal traffic is not affected by this restriction. If no allowlist is specified, access is not restricted. If an IP without subnet mask is provided, the default value will be used: 32 for IPv4 and 128 for IPv6.
        :param Sequence[str] available_upgrade_versions: A list of available versions for upgrading the cluster
        :param Sequence['GetK8sClustersClusterMaintenanceWindowArgs'] maintenance_windows: A maintenance window comprise of a day of the week and a time for maintenance to be allowed
        :param str nat_gateway_ip: The NAT gateway IP of the cluster if the cluster is private.
        :param str node_subnet: The node subnet of the cluster, if the cluster is private.
        :param bool public: The indicator if the cluster is public or private.
        :param Sequence['GetK8sClustersClusterS3BucketArgs'] s3_buckets: List of Object Storage bucket configured for K8s usage. For now it contains only an Object Storage bucket used to store K8s API audit logs.
        :param Sequence[str] viable_node_pool_versions: A list of versions that may be used for node pools under this cluster
        """
        pulumi.set(__self__, "api_subnet_allow_lists", api_subnet_allow_lists)
        pulumi.set(__self__, "available_upgrade_versions", available_upgrade_versions)
        pulumi.set(__self__, "ca_crt", ca_crt)
        pulumi.set(__self__, "configs", configs)
        pulumi.set(__self__, "k8s_version", k8s_version)
        pulumi.set(__self__, "kube_config", kube_config)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "maintenance_windows", maintenance_windows)
        pulumi.set(__self__, "nat_gateway_ip", nat_gateway_ip)
        pulumi.set(__self__, "node_pools", node_pools)
        pulumi.set(__self__, "node_subnet", node_subnet)
        pulumi.set(__self__, "public", public)
        pulumi.set(__self__, "s3_buckets", s3_buckets)
        pulumi.set(__self__, "server", server)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "user_tokens", user_tokens)
        pulumi.set(__self__, "viable_node_pool_versions", viable_node_pool_versions)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="apiSubnetAllowLists")
    def api_subnet_allow_lists(self) -> Sequence[str]:
        """
        Access to the K8s API server is restricted to these CIDRs. Cluster-internal traffic is not affected by this restriction. If no allowlist is specified, access is not restricted. If an IP without subnet mask is provided, the default value will be used: 32 for IPv4 and 128 for IPv6.
        """
        return pulumi.get(self, "api_subnet_allow_lists")

    @property
    @pulumi.getter(name="availableUpgradeVersions")
    def available_upgrade_versions(self) -> Sequence[str]:
        """
        A list of available versions for upgrading the cluster
        """
        return pulumi.get(self, "available_upgrade_versions")

    @property
    @pulumi.getter(name="caCrt")
    def ca_crt(self) -> str:
        return pulumi.get(self, "ca_crt")

    @property
    @pulumi.getter
    def configs(self) -> Sequence['outputs.GetK8sClustersClusterConfigResult']:
        return pulumi.get(self, "configs")

    @property
    @pulumi.getter(name="k8sVersion")
    def k8s_version(self) -> str:
        return pulumi.get(self, "k8s_version")

    @property
    @pulumi.getter(name="kubeConfig")
    def kube_config(self) -> str:
        return pulumi.get(self, "kube_config")

    @property
    @pulumi.getter
    def location(self) -> str:
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Sequence['outputs.GetK8sClustersClusterMaintenanceWindowResult']:
        """
        A maintenance window comprise of a day of the week and a time for maintenance to be allowed
        """
        return pulumi.get(self, "maintenance_windows")

    @property
    @pulumi.getter(name="natGatewayIp")
    def nat_gateway_ip(self) -> str:
        """
        The NAT gateway IP of the cluster if the cluster is private.
        """
        return pulumi.get(self, "nat_gateway_ip")

    @property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Sequence[str]:
        return pulumi.get(self, "node_pools")

    @property
    @pulumi.getter(name="nodeSubnet")
    def node_subnet(self) -> str:
        """
        The node subnet of the cluster, if the cluster is private.
        """
        return pulumi.get(self, "node_subnet")

    @property
    @pulumi.getter
    def public(self) -> bool:
        """
        The indicator if the cluster is public or private.
        """
        return pulumi.get(self, "public")

    @property
    @pulumi.getter(name="s3Buckets")
    def s3_buckets(self) -> Sequence['outputs.GetK8sClustersClusterS3BucketResult']:
        """
        List of Object Storage bucket configured for K8s usage. For now it contains only an Object Storage bucket used to store K8s API audit logs.
        """
        return pulumi.get(self, "s3_buckets")

    @property
    @pulumi.getter
    def server(self) -> str:
        return pulumi.get(self, "server")

    @property
    @pulumi.getter
    def state(self) -> str:
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="userTokens")
    def user_tokens(self) -> Mapping[str, str]:
        return pulumi.get(self, "user_tokens")

    @property
    @pulumi.getter(name="viableNodePoolVersions")
    def viable_node_pool_versions(self) -> Sequence[str]:
        """
        A list of versions that may be used for node pools under this cluster
        """
        return pulumi.get(self, "viable_node_pool_versions")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetK8sClustersClusterConfigResult(dict):
    def __init__(__self__, *,
                 api_version: str,
                 clusters: Sequence['outputs.GetK8sClustersClusterConfigClusterResult'],
                 contexts: Sequence['outputs.GetK8sClustersClusterConfigContextResult'],
                 current_context: str,
                 kind: str,
                 users: Sequence['outputs.GetK8sClustersClusterConfigUserResult']):
        pulumi.set(__self__, "api_version", api_version)
        pulumi.set(__self__, "clusters", clusters)
        pulumi.set(__self__, "contexts", contexts)
        pulumi.set(__self__, "current_context", current_context)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> str:
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter
    def clusters(self) -> Sequence['outputs.GetK8sClustersClusterConfigClusterResult']:
        return pulumi.get(self, "clusters")

    @property
    @pulumi.getter
    def contexts(self) -> Sequence['outputs.GetK8sClustersClusterConfigContextResult']:
        return pulumi.get(self, "contexts")

    @property
    @pulumi.getter(name="currentContext")
    def current_context(self) -> str:
        return pulumi.get(self, "current_context")

    @property
    @pulumi.getter
    def kind(self) -> str:
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def users(self) -> Sequence['outputs.GetK8sClustersClusterConfigUserResult']:
        return pulumi.get(self, "users")


@pulumi.output_type
class GetK8sClustersClusterConfigClusterResult(dict):
    def __init__(__self__, *,
                 cluster: Mapping[str, str],
                 name: str):
        pulumi.set(__self__, "cluster", cluster)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def cluster(self) -> Mapping[str, str]:
        return pulumi.get(self, "cluster")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetK8sClustersClusterConfigContextResult(dict):
    def __init__(__self__, *,
                 context: Mapping[str, str],
                 name: str):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def context(self) -> Mapping[str, str]:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetK8sClustersClusterConfigUserResult(dict):
    def __init__(__self__, *,
                 name: str,
                 user: Mapping[str, str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def user(self) -> Mapping[str, str]:
        return pulumi.get(self, "user")


@pulumi.output_type
class GetK8sClustersClusterMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 day_of_the_week: str,
                 time: str):
        """
        :param str day_of_the_week: Day of the week when maintenance is allowed
        :param str time: A clock time in the day when maintenance is allowed
        """
        pulumi.set(__self__, "day_of_the_week", day_of_the_week)
        pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter(name="dayOfTheWeek")
    def day_of_the_week(self) -> str:
        """
        Day of the week when maintenance is allowed
        """
        return pulumi.get(self, "day_of_the_week")

    @property
    @pulumi.getter
    def time(self) -> str:
        """
        A clock time in the day when maintenance is allowed
        """
        return pulumi.get(self, "time")


@pulumi.output_type
class GetK8sClustersClusterS3BucketResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the Object Storage bucket
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Object Storage bucket
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetK8sClustersFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetK8sNodePoolNodesNodeResult(dict):
    def __init__(__self__, *,
                 k8s_version: str,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 private_ip: Optional[str] = None,
                 public_ip: Optional[str] = None):
        """
        :param str k8s_version: The kubernetes version
        :param str name: The kubernetes node name
        :param str private_ip: A valid private IP
        :param str public_ip: A valid public IP
        """
        pulumi.set(__self__, "k8s_version", k8s_version)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if private_ip is not None:
            pulumi.set(__self__, "private_ip", private_ip)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)

    @property
    @pulumi.getter(name="k8sVersion")
    def k8s_version(self) -> str:
        """
        The kubernetes version
        """
        return pulumi.get(self, "k8s_version")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The kubernetes node name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[str]:
        """
        A valid private IP
        """
        return pulumi.get(self, "private_ip")

    @property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[str]:
        """
        A valid public IP
        """
        return pulumi.get(self, "public_ip")


@pulumi.output_type
class GetLocationCpuArchitectureResult(dict):
    def __init__(__self__, *,
                 cpu_family: str,
                 max_cores: int,
                 max_ram: int,
                 vendor: str):
        """
        :param str cpu_family: A valid CPU family name.
        :param int max_cores: The maximum number of cores available.
        :param int max_ram: The maximum number of RAM in MB.
        :param str vendor: A valid CPU vendor name.
        """
        pulumi.set(__self__, "cpu_family", cpu_family)
        pulumi.set(__self__, "max_cores", max_cores)
        pulumi.set(__self__, "max_ram", max_ram)
        pulumi.set(__self__, "vendor", vendor)

    @property
    @pulumi.getter(name="cpuFamily")
    def cpu_family(self) -> str:
        """
        A valid CPU family name.
        """
        return pulumi.get(self, "cpu_family")

    @property
    @pulumi.getter(name="maxCores")
    def max_cores(self) -> int:
        """
        The maximum number of cores available.
        """
        return pulumi.get(self, "max_cores")

    @property
    @pulumi.getter(name="maxRam")
    def max_ram(self) -> int:
        """
        The maximum number of RAM in MB.
        """
        return pulumi.get(self, "max_ram")

    @property
    @pulumi.getter
    def vendor(self) -> str:
        """
        A valid CPU vendor name.
        """
        return pulumi.get(self, "vendor")


@pulumi.output_type
class GetMariadbBackupsBackupResult(dict):
    def __init__(__self__, *,
                 base_backups: Sequence['outputs.GetMariadbBackupsBackupBaseBackupResult'],
                 cluster_id: str,
                 earliest_recovery_target_time: str,
                 size: int):
        """
        :param Sequence['GetMariadbBackupsBackupBaseBackupArgs'] base_backups: The list of backups for the specified cluster
        :param str cluster_id: The unique ID of the cluster that was backed up
        :param str earliest_recovery_target_time: The oldest available timestamp to which you can restore
        :param int size: Size of all base backups in Mebibytes (MiB). This is at least the sum of all base backup sizes
        """
        pulumi.set(__self__, "base_backups", base_backups)
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "earliest_recovery_target_time", earliest_recovery_target_time)
        pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter(name="baseBackups")
    def base_backups(self) -> Sequence['outputs.GetMariadbBackupsBackupBaseBackupResult']:
        """
        The list of backups for the specified cluster
        """
        return pulumi.get(self, "base_backups")

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> str:
        """
        The unique ID of the cluster that was backed up
        """
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="earliestRecoveryTargetTime")
    def earliest_recovery_target_time(self) -> str:
        """
        The oldest available timestamp to which you can restore
        """
        return pulumi.get(self, "earliest_recovery_target_time")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        Size of all base backups in Mebibytes (MiB). This is at least the sum of all base backup sizes
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class GetMariadbBackupsBackupBaseBackupResult(dict):
    def __init__(__self__, *,
                 created: str,
                 size: int):
        """
        :param str created: The ISO 8601 creation timestamp
        :param int size: The size of the backup in Mebibytes (MiB). This is the size of the binary backup file that was stored
        """
        pulumi.set(__self__, "created", created)
        pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def created(self) -> str:
        """
        The ISO 8601 creation timestamp
        """
        return pulumi.get(self, "created")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        The size of the backup in Mebibytes (MiB). This is the size of the binary backup file that was stored
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class GetPgBackupsClusterBackupResult(dict):
    def __init__(__self__, *,
                 cluster_id: str,
                 earliest_recovery_target_time: str,
                 id: str,
                 is_active: bool,
                 location: str,
                 metadatas: Sequence['outputs.GetPgBackupsClusterBackupMetadataResult'],
                 size: int,
                 type: str,
                 version: str):
        """
        :param str cluster_id: The unique ID of the cluster
        :param str earliest_recovery_target_time: The oldest available timestamp to which you can restore.
        :param str id: The unique ID of the resource.
        :param bool is_active: Whether a cluster currently backs up data to this backup.
        :param str location: The Object Storage location where the backups will be stored.
        :param Sequence['GetPgBackupsClusterBackupMetadataArgs'] metadatas: Metadata of the resource
        :param int size: Size of all base backups including the wal size in MB.
        :param str version: The PostgreSQL version this backup was created from.
        """
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "earliest_recovery_target_time", earliest_recovery_target_time)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_active", is_active)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "metadatas", metadatas)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> str:
        """
        The unique ID of the cluster
        """
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="earliestRecoveryTargetTime")
    def earliest_recovery_target_time(self) -> str:
        """
        The oldest available timestamp to which you can restore.
        """
        return pulumi.get(self, "earliest_recovery_target_time")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The unique ID of the resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isActive")
    def is_active(self) -> bool:
        """
        Whether a cluster currently backs up data to this backup.
        """
        return pulumi.get(self, "is_active")

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        The Object Storage location where the backups will be stored.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def metadatas(self) -> Sequence['outputs.GetPgBackupsClusterBackupMetadataResult']:
        """
        Metadata of the resource
        """
        return pulumi.get(self, "metadatas")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        Size of all base backups including the wal size in MB.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        The PostgreSQL version this backup was created from.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetPgBackupsClusterBackupMetadataResult(dict):
    def __init__(__self__, *,
                 created_date: str):
        """
        :param str created_date: The ISO 8601 creation timestamp.
        """
        pulumi.set(__self__, "created_date", created_date)

    @property
    @pulumi.getter(name="createdDate")
    def created_date(self) -> str:
        """
        The ISO 8601 creation timestamp.
        """
        return pulumi.get(self, "created_date")


@pulumi.output_type
class GetPgDatabasesDatabaseResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str,
                 owner: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "owner", owner)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def owner(self) -> str:
        return pulumi.get(self, "owner")


@pulumi.output_type
class GetServersFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetServersServerResult(dict):
    def __init__(__self__, *,
                 availability_zone: str,
                 boot_cdrom: str,
                 boot_image: str,
                 boot_volume: str,
                 cdroms: Sequence['outputs.GetServersServerCdromResult'],
                 cores: int,
                 cpu_family: str,
                 id: str,
                 labels: Sequence['outputs.GetServersServerLabelResult'],
                 nics: Sequence['outputs.GetServersServerNicResult'],
                 ram: int,
                 token: str,
                 type: str,
                 vm_state: str,
                 volumes: Sequence['outputs.GetServersServerVolumeResult'],
                 name: Optional[str] = None,
                 template_uuid: Optional[str] = None):
        """
        :param str id: The unique ID of the server.
        """
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "boot_cdrom", boot_cdrom)
        pulumi.set(__self__, "boot_image", boot_image)
        pulumi.set(__self__, "boot_volume", boot_volume)
        pulumi.set(__self__, "cdroms", cdroms)
        pulumi.set(__self__, "cores", cores)
        pulumi.set(__self__, "cpu_family", cpu_family)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "nics", nics)
        pulumi.set(__self__, "ram", ram)
        pulumi.set(__self__, "token", token)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vm_state", vm_state)
        pulumi.set(__self__, "volumes", volumes)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if template_uuid is not None:
            pulumi.set(__self__, "template_uuid", template_uuid)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> str:
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="bootCdrom")
    def boot_cdrom(self) -> str:
        return pulumi.get(self, "boot_cdrom")

    @property
    @pulumi.getter(name="bootImage")
    def boot_image(self) -> str:
        return pulumi.get(self, "boot_image")

    @property
    @pulumi.getter(name="bootVolume")
    def boot_volume(self) -> str:
        return pulumi.get(self, "boot_volume")

    @property
    @pulumi.getter
    def cdroms(self) -> Sequence['outputs.GetServersServerCdromResult']:
        return pulumi.get(self, "cdroms")

    @property
    @pulumi.getter
    def cores(self) -> int:
        return pulumi.get(self, "cores")

    @property
    @pulumi.getter(name="cpuFamily")
    def cpu_family(self) -> str:
        return pulumi.get(self, "cpu_family")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The unique ID of the server.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def labels(self) -> Sequence['outputs.GetServersServerLabelResult']:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def nics(self) -> Sequence['outputs.GetServersServerNicResult']:
        return pulumi.get(self, "nics")

    @property
    @pulumi.getter
    def ram(self) -> int:
        return pulumi.get(self, "ram")

    @property
    @pulumi.getter
    def token(self) -> str:
        return pulumi.get(self, "token")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="vmState")
    def vm_state(self) -> str:
        return pulumi.get(self, "vm_state")

    @property
    @pulumi.getter
    def volumes(self) -> Sequence['outputs.GetServersServerVolumeResult']:
        return pulumi.get(self, "volumes")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="templateUuid")
    def template_uuid(self) -> Optional[str]:
        return pulumi.get(self, "template_uuid")


@pulumi.output_type
class GetServersServerCdromResult(dict):
    def __init__(__self__, *,
                 cloud_init: str,
                 cpu_hot_plug: bool,
                 cpu_hot_unplug: bool,
                 description: str,
                 disc_scsi_hot_plug: bool,
                 disc_scsi_hot_unplug: bool,
                 disc_virtio_hot_plug: bool,
                 disc_virtio_hot_unplug: bool,
                 id: str,
                 image_aliases: Sequence[str],
                 image_type: str,
                 licence_type: str,
                 location: str,
                 name: str,
                 nic_hot_plug: bool,
                 nic_hot_unplug: bool,
                 public: bool,
                 ram_hot_plug: bool,
                 ram_hot_unplug: bool,
                 size: float):
        pulumi.set(__self__, "cloud_init", cloud_init)
        pulumi.set(__self__, "cpu_hot_plug", cpu_hot_plug)
        pulumi.set(__self__, "cpu_hot_unplug", cpu_hot_unplug)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "disc_scsi_hot_plug", disc_scsi_hot_plug)
        pulumi.set(__self__, "disc_scsi_hot_unplug", disc_scsi_hot_unplug)
        pulumi.set(__self__, "disc_virtio_hot_plug", disc_virtio_hot_plug)
        pulumi.set(__self__, "disc_virtio_hot_unplug", disc_virtio_hot_unplug)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "image_aliases", image_aliases)
        pulumi.set(__self__, "image_type", image_type)
        pulumi.set(__self__, "licence_type", licence_type)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "nic_hot_plug", nic_hot_plug)
        pulumi.set(__self__, "nic_hot_unplug", nic_hot_unplug)
        pulumi.set(__self__, "public", public)
        pulumi.set(__self__, "ram_hot_plug", ram_hot_plug)
        pulumi.set(__self__, "ram_hot_unplug", ram_hot_unplug)
        pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter(name="cloudInit")
    def cloud_init(self) -> str:
        return pulumi.get(self, "cloud_init")

    @property
    @pulumi.getter(name="cpuHotPlug")
    def cpu_hot_plug(self) -> bool:
        return pulumi.get(self, "cpu_hot_plug")

    @property
    @pulumi.getter(name="cpuHotUnplug")
    def cpu_hot_unplug(self) -> bool:
        return pulumi.get(self, "cpu_hot_unplug")

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="discScsiHotPlug")
    def disc_scsi_hot_plug(self) -> bool:
        return pulumi.get(self, "disc_scsi_hot_plug")

    @property
    @pulumi.getter(name="discScsiHotUnplug")
    def disc_scsi_hot_unplug(self) -> bool:
        return pulumi.get(self, "disc_scsi_hot_unplug")

    @property
    @pulumi.getter(name="discVirtioHotPlug")
    def disc_virtio_hot_plug(self) -> bool:
        return pulumi.get(self, "disc_virtio_hot_plug")

    @property
    @pulumi.getter(name="discVirtioHotUnplug")
    def disc_virtio_hot_unplug(self) -> bool:
        return pulumi.get(self, "disc_virtio_hot_unplug")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="imageAliases")
    def image_aliases(self) -> Sequence[str]:
        return pulumi.get(self, "image_aliases")

    @property
    @pulumi.getter(name="imageType")
    def image_type(self) -> str:
        return pulumi.get(self, "image_type")

    @property
    @pulumi.getter(name="licenceType")
    def licence_type(self) -> str:
        return pulumi.get(self, "licence_type")

    @property
    @pulumi.getter
    def location(self) -> str:
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nicHotPlug")
    def nic_hot_plug(self) -> bool:
        return pulumi.get(self, "nic_hot_plug")

    @property
    @pulumi.getter(name="nicHotUnplug")
    def nic_hot_unplug(self) -> bool:
        return pulumi.get(self, "nic_hot_unplug")

    @property
    @pulumi.getter
    def public(self) -> bool:
        return pulumi.get(self, "public")

    @property
    @pulumi.getter(name="ramHotPlug")
    def ram_hot_plug(self) -> bool:
        return pulumi.get(self, "ram_hot_plug")

    @property
    @pulumi.getter(name="ramHotUnplug")
    def ram_hot_unplug(self) -> bool:
        return pulumi.get(self, "ram_hot_unplug")

    @property
    @pulumi.getter
    def size(self) -> float:
        return pulumi.get(self, "size")


@pulumi.output_type
class GetServersServerLabelResult(dict):
    def __init__(__self__, *,
                 id: str,
                 key: str,
                 value: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetServersServerNicResult(dict):
    def __init__(__self__, *,
                 device_number: int,
                 dhcp: bool,
                 firewall_active: bool,
                 firewall_rules: Sequence['outputs.GetServersServerNicFirewallRuleResult'],
                 firewall_type: str,
                 id: str,
                 ips: Sequence[str],
                 ipv6_cidr_block: str,
                 ipv6_ips: Sequence[str],
                 lan: int,
                 mac: str,
                 name: str,
                 pci_slot: int,
                 dhcpv6: Optional[bool] = None):
        pulumi.set(__self__, "device_number", device_number)
        pulumi.set(__self__, "dhcp", dhcp)
        pulumi.set(__self__, "firewall_active", firewall_active)
        pulumi.set(__self__, "firewall_rules", firewall_rules)
        pulumi.set(__self__, "firewall_type", firewall_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)
        pulumi.set(__self__, "ipv6_ips", ipv6_ips)
        pulumi.set(__self__, "lan", lan)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pci_slot", pci_slot)
        if dhcpv6 is not None:
            pulumi.set(__self__, "dhcpv6", dhcpv6)

    @property
    @pulumi.getter(name="deviceNumber")
    def device_number(self) -> int:
        return pulumi.get(self, "device_number")

    @property
    @pulumi.getter
    def dhcp(self) -> bool:
        return pulumi.get(self, "dhcp")

    @property
    @pulumi.getter(name="firewallActive")
    def firewall_active(self) -> bool:
        return pulumi.get(self, "firewall_active")

    @property
    @pulumi.getter(name="firewallRules")
    def firewall_rules(self) -> Sequence['outputs.GetServersServerNicFirewallRuleResult']:
        return pulumi.get(self, "firewall_rules")

    @property
    @pulumi.getter(name="firewallType")
    def firewall_type(self) -> str:
        return pulumi.get(self, "firewall_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ips(self) -> Sequence[str]:
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> str:
        return pulumi.get(self, "ipv6_cidr_block")

    @property
    @pulumi.getter(name="ipv6Ips")
    def ipv6_ips(self) -> Sequence[str]:
        return pulumi.get(self, "ipv6_ips")

    @property
    @pulumi.getter
    def lan(self) -> int:
        return pulumi.get(self, "lan")

    @property
    @pulumi.getter
    def mac(self) -> str:
        return pulumi.get(self, "mac")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="pciSlot")
    def pci_slot(self) -> int:
        return pulumi.get(self, "pci_slot")

    @property
    @pulumi.getter
    def dhcpv6(self) -> Optional[bool]:
        return pulumi.get(self, "dhcpv6")


@pulumi.output_type
class GetServersServerNicFirewallRuleResult(dict):
    def __init__(__self__, *,
                 icmp_code: int,
                 icmp_type: int,
                 id: str,
                 name: str,
                 port_range_end: int,
                 port_range_start: int,
                 protocol: str,
                 source_ip: str,
                 source_mac: str,
                 target_ip: str,
                 type: str):
        pulumi.set(__self__, "icmp_code", icmp_code)
        pulumi.set(__self__, "icmp_type", icmp_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port_range_end", port_range_end)
        pulumi.set(__self__, "port_range_start", port_range_start)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "source_ip", source_ip)
        pulumi.set(__self__, "source_mac", source_mac)
        pulumi.set(__self__, "target_ip", target_ip)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> int:
        return pulumi.get(self, "icmp_code")

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> int:
        return pulumi.get(self, "icmp_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="portRangeEnd")
    def port_range_end(self) -> int:
        return pulumi.get(self, "port_range_end")

    @property
    @pulumi.getter(name="portRangeStart")
    def port_range_start(self) -> int:
        return pulumi.get(self, "port_range_start")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> str:
        return pulumi.get(self, "source_ip")

    @property
    @pulumi.getter(name="sourceMac")
    def source_mac(self) -> str:
        return pulumi.get(self, "source_mac")

    @property
    @pulumi.getter(name="targetIp")
    def target_ip(self) -> str:
        return pulumi.get(self, "target_ip")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetServersServerVolumeResult(dict):
    def __init__(__self__, *,
                 availability_zone: str,
                 backup_unit_id: str,
                 boot_server: str,
                 bus: str,
                 cpu_hot_plug: bool,
                 device_number: int,
                 disc_virtio_hot_plug: bool,
                 disc_virtio_hot_unplug: bool,
                 disk_type: str,
                 id: str,
                 image_name: str,
                 image_password: str,
                 licence_type: str,
                 name: str,
                 nic_hot_plug: bool,
                 nic_hot_unplug: bool,
                 pci_slot: int,
                 ram_hot_plug: bool,
                 size: int,
                 ssh_keys: Sequence[str],
                 user_data: Optional[str] = None):
        """
        :param str boot_server: The UUID of the attached server.
        """
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "backup_unit_id", backup_unit_id)
        pulumi.set(__self__, "boot_server", boot_server)
        pulumi.set(__self__, "bus", bus)
        pulumi.set(__self__, "cpu_hot_plug", cpu_hot_plug)
        pulumi.set(__self__, "device_number", device_number)
        pulumi.set(__self__, "disc_virtio_hot_plug", disc_virtio_hot_plug)
        pulumi.set(__self__, "disc_virtio_hot_unplug", disc_virtio_hot_unplug)
        pulumi.set(__self__, "disk_type", disk_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "image_name", image_name)
        pulumi.set(__self__, "image_password", image_password)
        pulumi.set(__self__, "licence_type", licence_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "nic_hot_plug", nic_hot_plug)
        pulumi.set(__self__, "nic_hot_unplug", nic_hot_unplug)
        pulumi.set(__self__, "pci_slot", pci_slot)
        pulumi.set(__self__, "ram_hot_plug", ram_hot_plug)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "ssh_keys", ssh_keys)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> str:
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="backupUnitId")
    def backup_unit_id(self) -> str:
        return pulumi.get(self, "backup_unit_id")

    @property
    @pulumi.getter(name="bootServer")
    def boot_server(self) -> str:
        """
        The UUID of the attached server.
        """
        return pulumi.get(self, "boot_server")

    @property
    @pulumi.getter
    def bus(self) -> str:
        return pulumi.get(self, "bus")

    @property
    @pulumi.getter(name="cpuHotPlug")
    def cpu_hot_plug(self) -> bool:
        return pulumi.get(self, "cpu_hot_plug")

    @property
    @pulumi.getter(name="deviceNumber")
    def device_number(self) -> int:
        return pulumi.get(self, "device_number")

    @property
    @pulumi.getter(name="discVirtioHotPlug")
    def disc_virtio_hot_plug(self) -> bool:
        return pulumi.get(self, "disc_virtio_hot_plug")

    @property
    @pulumi.getter(name="discVirtioHotUnplug")
    def disc_virtio_hot_unplug(self) -> bool:
        return pulumi.get(self, "disc_virtio_hot_unplug")

    @property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> str:
        return pulumi.get(self, "disk_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="imageName")
    def image_name(self) -> str:
        return pulumi.get(self, "image_name")

    @property
    @pulumi.getter(name="imagePassword")
    def image_password(self) -> str:
        return pulumi.get(self, "image_password")

    @property
    @pulumi.getter(name="licenceType")
    def licence_type(self) -> str:
        return pulumi.get(self, "licence_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nicHotPlug")
    def nic_hot_plug(self) -> bool:
        return pulumi.get(self, "nic_hot_plug")

    @property
    @pulumi.getter(name="nicHotUnplug")
    def nic_hot_unplug(self) -> bool:
        return pulumi.get(self, "nic_hot_unplug")

    @property
    @pulumi.getter(name="pciSlot")
    def pci_slot(self) -> int:
        return pulumi.get(self, "pci_slot")

    @property
    @pulumi.getter(name="ramHotPlug")
    def ram_hot_plug(self) -> bool:
        return pulumi.get(self, "ram_hot_plug")

    @property
    @pulumi.getter
    def size(self) -> int:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Sequence[str]:
        return pulumi.get(self, "ssh_keys")

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[str]:
        return pulumi.get(self, "user_data")


@pulumi.output_type
class GetTargetGroupHealthCheckResult(dict):
    def __init__(__self__, *,
                 check_interval: int,
                 check_timeout: int,
                 retries: int):
        """
        :param int check_interval: The interval in milliseconds between consecutive health checks; default is 2000.
        :param int check_timeout: The maximum time in milliseconds to wait for a target to respond to a check. For target VMs with 'Check Interval' set, the lesser of the two  values is used once the TCP connection is established.
        :param int retries: The maximum number of attempts to reconnect to a target after a connection failure. Valid range is 0 to 65535, and default is three reconnection.
        """
        pulumi.set(__self__, "check_interval", check_interval)
        pulumi.set(__self__, "check_timeout", check_timeout)
        pulumi.set(__self__, "retries", retries)

    @property
    @pulumi.getter(name="checkInterval")
    def check_interval(self) -> int:
        """
        The interval in milliseconds between consecutive health checks; default is 2000.
        """
        return pulumi.get(self, "check_interval")

    @property
    @pulumi.getter(name="checkTimeout")
    def check_timeout(self) -> int:
        """
        The maximum time in milliseconds to wait for a target to respond to a check. For target VMs with 'Check Interval' set, the lesser of the two  values is used once the TCP connection is established.
        """
        return pulumi.get(self, "check_timeout")

    @property
    @pulumi.getter
    def retries(self) -> int:
        """
        The maximum number of attempts to reconnect to a target after a connection failure. Valid range is 0 to 65535, and default is three reconnection.
        """
        return pulumi.get(self, "retries")


@pulumi.output_type
class GetTargetGroupHttpHealthCheckResult(dict):
    def __init__(__self__, *,
                 match_type: str,
                 method: str,
                 negate: bool,
                 path: str,
                 regex: bool,
                 response: str):
        """
        :param str method: The method for the HTTP health check.
        :param str path: The path (destination URL) for the HTTP health check request; the default is /.
        :param str response: The response returned by the request, depending on the match type.
        """
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "negate", negate)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "regex", regex)
        pulumi.set(__self__, "response", response)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> str:
        return pulumi.get(self, "match_type")

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        The method for the HTTP health check.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def negate(self) -> bool:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The path (destination URL) for the HTTP health check request; the default is /.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def regex(self) -> bool:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def response(self) -> str:
        """
        The response returned by the request, depending on the match type.
        """
        return pulumi.get(self, "response")


@pulumi.output_type
class GetTargetGroupTargetResult(dict):
    def __init__(__self__, *,
                 health_check_enabled: bool,
                 ip: str,
                 maintenance_enabled: bool,
                 port: int,
                 proxy_protocol: str,
                 weight: int):
        """
        :param bool health_check_enabled: Makes the target available only if it accepts periodic health check TCP connection attempts; when turned off, the target is considered always available. The health check only consists of a connection attempt to the address and port of the target. Default is True.
        :param str ip: The IP of the balanced target VM.
        :param bool maintenance_enabled: Maintenance mode prevents the target from receiving balanced traffic.
        :param int port: The port of the balanced target service; valid range is 1 to 65535.
        :param str proxy_protocol: The proxy protocol version.
        :param int weight: Traffic is distributed in proportion to target weight, relative to the combined weight of all targets. A target with higher weight receives a greater share of traffic. Valid range is 0 to 256 and default is 1; targets with weight of 0 do not participate in load balancing but still accept persistent connections. It is best use values in the middle of the range to leave room for later adjustments.
        """
        pulumi.set(__self__, "health_check_enabled", health_check_enabled)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "maintenance_enabled", maintenance_enabled)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "proxy_protocol", proxy_protocol)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="healthCheckEnabled")
    def health_check_enabled(self) -> bool:
        """
        Makes the target available only if it accepts periodic health check TCP connection attempts; when turned off, the target is considered always available. The health check only consists of a connection attempt to the address and port of the target. Default is True.
        """
        return pulumi.get(self, "health_check_enabled")

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        The IP of the balanced target VM.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="maintenanceEnabled")
    def maintenance_enabled(self) -> bool:
        """
        Maintenance mode prevents the target from receiving balanced traffic.
        """
        return pulumi.get(self, "maintenance_enabled")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port of the balanced target service; valid range is 1 to 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="proxyProtocol")
    def proxy_protocol(self) -> str:
        """
        The proxy protocol version.
        """
        return pulumi.get(self, "proxy_protocol")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        Traffic is distributed in proportion to target weight, relative to the combined weight of all targets. A target with higher weight receives a greater share of traffic. Valid range is 0 to 256 and default is 1; targets with weight of 0 do not participate in load balancing but still accept persistent connections. It is best use values in the middle of the range to leave room for later adjustments.
        """
        return pulumi.get(self, "weight")


