# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'ApplicationLoadbalancerFlowlogArgs',
    'ApplicationLoadbalancerForwardingruleHttpRuleArgs',
    'ApplicationLoadbalancerForwardingruleHttpRuleConditionArgs',
    'LoggingPipelineLogArgs',
    'LoggingPipelineLogDestinationArgs',
    'NetworkloadbalancerFlowlogArgs',
    'NetworkloadbalancerForwardingruleHealthCheckArgs',
    'NetworkloadbalancerForwardingruleTargetArgs',
    'NetworkloadbalancerForwardingruleTargetHealthCheckArgs',
    'TargetGroupHealthCheckArgs',
    'TargetGroupHttpHealthCheckArgs',
    'TargetGroupTargetArgs',
    'GetIpblockIpConsumerArgs',
    'GetK8sClustersFilterArgs',
    'GetMongoUserRoleArgs',
    'GetNfsShareClientGroupArgs',
    'GetNfsShareClientGroupNfArgs',
    'GetServersFilterArgs',
]

@pulumi.input_type
class ApplicationLoadbalancerFlowlogArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 bucket: pulumi.Input[str],
                 direction: pulumi.Input[str],
                 name: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: [string] Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL. Immutable, forces re-creation.
        :param pulumi.Input[str] bucket: [string] Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist. Immutable, forces re-creation.
        :param pulumi.Input[str] direction: [string] Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, forces re-creation.
        :param pulumi.Input[str] name: [string] Specifies the name of the flow log.
               
               ⚠️ **Note:**: Removing the `flowlog` forces re-creation of the application load balancer resource.
        :param pulumi.Input[str] id: The resource's unique identifier.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "name", name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        [string] Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL. Immutable, forces re-creation.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        [string] Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist. Immutable, forces re-creation.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def direction(self) -> pulumi.Input[str]:
        """
        [string] Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, forces re-creation.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: pulumi.Input[str]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        [string] Specifies the name of the flow log.

        ⚠️ **Note:**: Removing the `flowlog` forces re-creation of the application load balancer resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The resource's unique identifier.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class ApplicationLoadbalancerForwardingruleHttpRuleArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationLoadbalancerForwardingruleHttpRuleConditionArgs']]]] = None,
                 content_type: Optional[pulumi.Input[str]] = None,
                 drop_query: Optional[pulumi.Input[bool]] = None,
                 location: Optional[pulumi.Input[str]] = None,
                 response_message: Optional[pulumi.Input[str]] = None,
                 status_code: Optional[pulumi.Input[int]] = None,
                 target_group: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: [string] The unique name of the Application Load Balancer HTTP rule.
        :param pulumi.Input[str] type: [string] Type of the Http Rule condition.
        :param pulumi.Input[Sequence[pulumi.Input['ApplicationLoadbalancerForwardingruleHttpRuleConditionArgs']]] conditions: [list] - An array of items in the collection.The action is only performed if each and every condition is met; if no conditions are set, the rule will always be performed.
        :param pulumi.Input[str] content_type: [string] Valid only for STATIC actions.
        :param pulumi.Input[bool] drop_query: [bool] Default is false; valid only for REDIRECT actions.
        :param pulumi.Input[str] location: [string] The location for redirecting; mandatory and valid only for REDIRECT actions.
        :param pulumi.Input[str] response_message: [string] The response message of the request; mandatory for STATIC action.
        :param pulumi.Input[int] status_code: [int] Valid only for REDIRECT and STATIC actions. For REDIRECT actions, default is 301 and possible values are 301, 302, 303, 307, and 308. For STATIC actions, default is 503 and valid range is 200 to 599.
        :param pulumi.Input[str] target_group: [string] The UUID of the target group; mandatory for FORWARD action.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if drop_query is not None:
            pulumi.set(__self__, "drop_query", drop_query)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if response_message is not None:
            pulumi.set(__self__, "response_message", response_message)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if target_group is not None:
            pulumi.set(__self__, "target_group", target_group)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        [string] The unique name of the Application Load Balancer HTTP rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        [string] Type of the Http Rule condition.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationLoadbalancerForwardingruleHttpRuleConditionArgs']]]]:
        """
        [list] - An array of items in the collection.The action is only performed if each and every condition is met; if no conditions are set, the rule will always be performed.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationLoadbalancerForwardingruleHttpRuleConditionArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[str]]:
        """
        [string] Valid only for STATIC actions.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_type", value)

    @property
    @pulumi.getter(name="dropQuery")
    def drop_query(self) -> Optional[pulumi.Input[bool]]:
        """
        [bool] Default is false; valid only for REDIRECT actions.
        """
        return pulumi.get(self, "drop_query")

    @drop_query.setter
    def drop_query(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "drop_query", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The location for redirecting; mandatory and valid only for REDIRECT actions.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter(name="responseMessage")
    def response_message(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The response message of the request; mandatory for STATIC action.
        """
        return pulumi.get(self, "response_message")

    @response_message.setter
    def response_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "response_message", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[int]]:
        """
        [int] Valid only for REDIRECT and STATIC actions. For REDIRECT actions, default is 301 and possible values are 301, 302, 303, 307, and 308. For STATIC actions, default is 503 and valid range is 200 to 599.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "status_code", value)

    @property
    @pulumi.getter(name="targetGroup")
    def target_group(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The UUID of the target group; mandatory for FORWARD action.
        """
        return pulumi.get(self, "target_group")

    @target_group.setter
    def target_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_group", value)


@pulumi.input_type
class ApplicationLoadbalancerForwardingruleHttpRuleConditionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 condition: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 negate: Optional[pulumi.Input[bool]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: [string] Type of the Http Rule condition.
        :param pulumi.Input[str] condition: [string] Matching rule for the HTTP rule condition attribute; mandatory for HEADER, PATH, QUERY, METHOD, HOST, and COOKIE types; must be null when type is SOURCE_IP.
        :param pulumi.Input[str] key: [string] Must be null when type is PATH, METHOD, HOST, or SOURCE_IP. Key can only be set when type is COOKIES, HEADER, or QUERY.
        :param pulumi.Input[bool] negate: [bool] Specifies whether the condition is negated or not; the default is False.
        :param pulumi.Input[str] value: [string] Mandatory for conditions CONTAINS, EQUALS, MATCHES, STARTS_WITH, ENDS_WITH; must be null when condition is EXISTS; should be a valid CIDR if provided and if type is SOURCE_IP.
        """
        pulumi.set(__self__, "type", type)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        [string] Type of the Http Rule condition.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        """
        [string] Matching rule for the HTTP rule condition attribute; mandatory for HEADER, PATH, QUERY, METHOD, HOST, and COOKIE types; must be null when type is SOURCE_IP.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        [string] Must be null when type is PATH, METHOD, HOST, or SOURCE_IP. Key can only be set when type is COOKIES, HEADER, or QUERY.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def negate(self) -> Optional[pulumi.Input[bool]]:
        """
        [bool] Specifies whether the condition is negated or not; the default is False.
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        [string] Mandatory for conditions CONTAINS, EQUALS, MATCHES, STARTS_WITH, ENDS_WITH; must be null when condition is EXISTS; should be a valid CIDR if provided and if type is SOURCE_IP.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class LoggingPipelineLogArgs:
    def __init__(__self__, *,
                 protocol: pulumi.Input[str],
                 source: pulumi.Input[str],
                 tag: pulumi.Input[str],
                 destinations: Optional[pulumi.Input[Sequence[pulumi.Input['LoggingPipelineLogDestinationArgs']]]] = None,
                 public: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] protocol: [string] "Protocol to use as intake. Possible values are: http, tcp."
        :param pulumi.Input[str] source: [string] The source parser to be used.
        :param pulumi.Input[str] tag: [string] The tag is used to distinguish different pipelines. Must be unique amongst the pipeline's array items.
        :param pulumi.Input[Sequence[pulumi.Input['LoggingPipelineLogDestinationArgs']]] destinations: [list] The configuration of the logs datastore, a list that contains elements with the following structure:
        :param pulumi.Input[bool] public: [bool]
        """
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "tag", tag)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if public is not None:
            pulumi.set(__self__, "public", public)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        [string] "Protocol to use as intake. Possible values are: http, tcp."
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[str]:
        """
        [string] The source parser to be used.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def tag(self) -> pulumi.Input[str]:
        """
        [string] The tag is used to distinguish different pipelines. Must be unique amongst the pipeline's array items.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: pulumi.Input[str]):
        pulumi.set(self, "tag", value)

    @property
    @pulumi.getter
    def destinations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoggingPipelineLogDestinationArgs']]]]:
        """
        [list] The configuration of the logs datastore, a list that contains elements with the following structure:
        """
        return pulumi.get(self, "destinations")

    @destinations.setter
    def destinations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoggingPipelineLogDestinationArgs']]]]):
        pulumi.set(self, "destinations", value)

    @property
    @pulumi.getter
    def public(self) -> Optional[pulumi.Input[bool]]:
        """
        [bool]
        """
        return pulumi.get(self, "public")

    @public.setter
    def public(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "public", value)


@pulumi.input_type
class LoggingPipelineLogDestinationArgs:
    def __init__(__self__, *,
                 retention_in_days: Optional[pulumi.Input[int]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] retention_in_days: [int] Defines the number of days a log record should be kept in loki. Works with loki destination type only. Can be one of: 7, 14, 30.
        :param pulumi.Input[str] type: [string] The internal output stream to send logs to.
        """
        if retention_in_days is not None:
            pulumi.set(__self__, "retention_in_days", retention_in_days)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        [int] Defines the number of days a log record should be kept in loki. Works with loki destination type only. Can be one of: 7, 14, 30.
        """
        return pulumi.get(self, "retention_in_days")

    @retention_in_days.setter
    def retention_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retention_in_days", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The internal output stream to send logs to.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class NetworkloadbalancerFlowlogArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 bucket: pulumi.Input[str],
                 direction: pulumi.Input[str],
                 name: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: [string] Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL. Immutable, forces re-creation.
        :param pulumi.Input[str] bucket: [string] Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist. Immutable, forces re-creation.
        :param pulumi.Input[str] direction: [string] Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, forces re-creation.
        :param pulumi.Input[str] name: [string] Specifies the name of the flow log.
               
               ⚠️ **Note:**: Removing the `flowlog` forces re-creation of the network load balancer resource.
        :param pulumi.Input[str] id: The resource's unique identifier.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "name", name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        [string] Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL. Immutable, forces re-creation.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        [string] Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist. Immutable, forces re-creation.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def direction(self) -> pulumi.Input[str]:
        """
        [string] Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, forces re-creation.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: pulumi.Input[str]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        [string] Specifies the name of the flow log.

        ⚠️ **Note:**: Removing the `flowlog` forces re-creation of the network load balancer resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The resource's unique identifier.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class NetworkloadbalancerForwardingruleHealthCheckArgs:
    def __init__(__self__, *,
                 client_timeout: Optional[pulumi.Input[int]] = None,
                 connect_timeout: Optional[pulumi.Input[int]] = None,
                 retries: Optional[pulumi.Input[int]] = None,
                 target_timeout: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] client_timeout: [int] ClientTimeout is expressed in milliseconds. This inactivity timeout applies when the client is expected to acknowledge or send data. If unset the default of 50 seconds will be used.
        :param pulumi.Input[int] connect_timeout: [int] It specifies the maximum time (in milliseconds) to wait for a connection attempt to a target VM to succeed. If unset, the default of 5 seconds will be used.
        :param pulumi.Input[int] retries: [int] Retries specifies the number of retries to perform on a target VM after a connection failure. If unset, the default value of 3 will be used.
        :param pulumi.Input[int] target_timeout: [int] TargetTimeout specifies the maximum inactivity time (in milliseconds) on the target VM side. If unset, the default of 50 seconds will be used.
        """
        if client_timeout is not None:
            pulumi.set(__self__, "client_timeout", client_timeout)
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if retries is not None:
            pulumi.set(__self__, "retries", retries)
        if target_timeout is not None:
            pulumi.set(__self__, "target_timeout", target_timeout)

    @property
    @pulumi.getter(name="clientTimeout")
    def client_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        [int] ClientTimeout is expressed in milliseconds. This inactivity timeout applies when the client is expected to acknowledge or send data. If unset the default of 50 seconds will be used.
        """
        return pulumi.get(self, "client_timeout")

    @client_timeout.setter
    def client_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "client_timeout", value)

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        [int] It specifies the maximum time (in milliseconds) to wait for a connection attempt to a target VM to succeed. If unset, the default of 5 seconds will be used.
        """
        return pulumi.get(self, "connect_timeout")

    @connect_timeout.setter
    def connect_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "connect_timeout", value)

    @property
    @pulumi.getter
    def retries(self) -> Optional[pulumi.Input[int]]:
        """
        [int] Retries specifies the number of retries to perform on a target VM after a connection failure. If unset, the default value of 3 will be used.
        """
        return pulumi.get(self, "retries")

    @retries.setter
    def retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retries", value)

    @property
    @pulumi.getter(name="targetTimeout")
    def target_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        [int] TargetTimeout specifies the maximum inactivity time (in milliseconds) on the target VM side. If unset, the default of 50 seconds will be used.
        """
        return pulumi.get(self, "target_timeout")

    @target_timeout.setter
    def target_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "target_timeout", value)


@pulumi.input_type
class NetworkloadbalancerForwardingruleTargetArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[str],
                 port: pulumi.Input[int],
                 weight: pulumi.Input[int],
                 health_check: Optional[pulumi.Input['NetworkloadbalancerForwardingruleTargetHealthCheckArgs']] = None,
                 proxy_protocol: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ip: [string] IP of a balanced target VM.
        :param pulumi.Input[int] port: [int] Port of the balanced target service. (range: 1 to 65535).
        :param pulumi.Input[int] weight: [int] Weight parameter is used to adjust the target VM's weight relative to other target VMs.
        :param pulumi.Input['NetworkloadbalancerForwardingruleTargetHealthCheckArgs'] health_check: Health check attributes for Network Load Balancer forwarding rule target.
        :param pulumi.Input[str] proxy_protocol: [string] The proxy protocol version. Accepted values are `none`, `v1`, `v2`, `v2ssl`. If unspecified, the default value of `none` is used.
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "weight", weight)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if proxy_protocol is not None:
            pulumi.set(__self__, "proxy_protocol", proxy_protocol)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        [string] IP of a balanced target VM.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        [int] Port of the balanced target service. (range: 1 to 65535).
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def weight(self) -> pulumi.Input[int]:
        """
        [int] Weight parameter is used to adjust the target VM's weight relative to other target VMs.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[int]):
        pulumi.set(self, "weight", value)

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional[pulumi.Input['NetworkloadbalancerForwardingruleTargetHealthCheckArgs']]:
        """
        Health check attributes for Network Load Balancer forwarding rule target.
        """
        return pulumi.get(self, "health_check")

    @health_check.setter
    def health_check(self, value: Optional[pulumi.Input['NetworkloadbalancerForwardingruleTargetHealthCheckArgs']]):
        pulumi.set(self, "health_check", value)

    @property
    @pulumi.getter(name="proxyProtocol")
    def proxy_protocol(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The proxy protocol version. Accepted values are `none`, `v1`, `v2`, `v2ssl`. If unspecified, the default value of `none` is used.
        """
        return pulumi.get(self, "proxy_protocol")

    @proxy_protocol.setter
    def proxy_protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy_protocol", value)


@pulumi.input_type
class NetworkloadbalancerForwardingruleTargetHealthCheckArgs:
    def __init__(__self__, *,
                 check: Optional[pulumi.Input[bool]] = None,
                 check_interval: Optional[pulumi.Input[int]] = None,
                 maintenance: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] check: [boolean] Check specifies whether the target VM's health is checked.
        :param pulumi.Input[int] check_interval: [int] CheckInterval determines the duration (in milliseconds) between consecutive health checks. If unspecified a default of 2000 ms is used.
        :param pulumi.Input[bool] maintenance: [boolean] Maintenance specifies if a target VM should be marked as down, even if it is not.
        """
        if check is not None:
            pulumi.set(__self__, "check", check)
        if check_interval is not None:
            pulumi.set(__self__, "check_interval", check_interval)
        if maintenance is not None:
            pulumi.set(__self__, "maintenance", maintenance)

    @property
    @pulumi.getter
    def check(self) -> Optional[pulumi.Input[bool]]:
        """
        [boolean] Check specifies whether the target VM's health is checked.
        """
        return pulumi.get(self, "check")

    @check.setter
    def check(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "check", value)

    @property
    @pulumi.getter(name="checkInterval")
    def check_interval(self) -> Optional[pulumi.Input[int]]:
        """
        [int] CheckInterval determines the duration (in milliseconds) between consecutive health checks. If unspecified a default of 2000 ms is used.
        """
        return pulumi.get(self, "check_interval")

    @check_interval.setter
    def check_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "check_interval", value)

    @property
    @pulumi.getter
    def maintenance(self) -> Optional[pulumi.Input[bool]]:
        """
        [boolean] Maintenance specifies if a target VM should be marked as down, even if it is not.
        """
        return pulumi.get(self, "maintenance")

    @maintenance.setter
    def maintenance(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "maintenance", value)


@pulumi.input_type
class TargetGroupHealthCheckArgs:
    def __init__(__self__, *,
                 check_interval: Optional[pulumi.Input[int]] = None,
                 check_timeout: Optional[pulumi.Input[int]] = None,
                 retries: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] check_interval: [int] The interval in milliseconds between consecutive health checks; default is 2000.
        :param pulumi.Input[int] check_timeout: [int] The maximum time in milliseconds to wait for a target to respond to a check. For target VMs with 'Check Interval' set, the lesser of the two  values is used once the TCP connection is established.
        :param pulumi.Input[int] retries: [int] The maximum number of attempts to reconnect to a target after a connection failure. Valid range is 0 to 65535, and default is three reconnection.
        """
        if check_interval is not None:
            pulumi.set(__self__, "check_interval", check_interval)
        if check_timeout is not None:
            pulumi.set(__self__, "check_timeout", check_timeout)
        if retries is not None:
            pulumi.set(__self__, "retries", retries)

    @property
    @pulumi.getter(name="checkInterval")
    def check_interval(self) -> Optional[pulumi.Input[int]]:
        """
        [int] The interval in milliseconds between consecutive health checks; default is 2000.
        """
        return pulumi.get(self, "check_interval")

    @check_interval.setter
    def check_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "check_interval", value)

    @property
    @pulumi.getter(name="checkTimeout")
    def check_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        [int] The maximum time in milliseconds to wait for a target to respond to a check. For target VMs with 'Check Interval' set, the lesser of the two  values is used once the TCP connection is established.
        """
        return pulumi.get(self, "check_timeout")

    @check_timeout.setter
    def check_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "check_timeout", value)

    @property
    @pulumi.getter
    def retries(self) -> Optional[pulumi.Input[int]]:
        """
        [int] The maximum number of attempts to reconnect to a target after a connection failure. Valid range is 0 to 65535, and default is three reconnection.
        """
        return pulumi.get(self, "retries")

    @retries.setter
    def retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retries", value)


@pulumi.input_type
class TargetGroupHttpHealthCheckArgs:
    def __init__(__self__, *,
                 match_type: pulumi.Input[str],
                 response: pulumi.Input[str],
                 method: Optional[pulumi.Input[str]] = None,
                 negate: Optional[pulumi.Input[bool]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 regex: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] match_type: [string]
        :param pulumi.Input[str] response: [string] The response returned by the request, depending on the match type.
        :param pulumi.Input[str] method: [string] The method for the HTTP health check.
        :param pulumi.Input[bool] negate: [bool]
        :param pulumi.Input[str] path: [string] The path (destination URL) for the HTTP health check request; the default is /.
        :param pulumi.Input[bool] regex: [bool]
        """
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "response", response)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> pulumi.Input[str]:
        """
        [string]
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_type", value)

    @property
    @pulumi.getter
    def response(self) -> pulumi.Input[str]:
        """
        [string] The response returned by the request, depending on the match type.
        """
        return pulumi.get(self, "response")

    @response.setter
    def response(self, value: pulumi.Input[str]):
        pulumi.set(self, "response", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The method for the HTTP health check.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def negate(self) -> Optional[pulumi.Input[bool]]:
        """
        [bool]
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The path (destination URL) for the HTTP health check request; the default is /.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[bool]]:
        """
        [bool]
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class TargetGroupTargetArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[str],
                 port: pulumi.Input[int],
                 weight: pulumi.Input[int],
                 health_check_enabled: Optional[pulumi.Input[bool]] = None,
                 maintenance_enabled: Optional[pulumi.Input[bool]] = None,
                 proxy_protocol: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ip: [string] The IP of the balanced target VM.
        :param pulumi.Input[int] port: [int] The port of the balanced target service; valid range is 1 to 65535.
        :param pulumi.Input[int] weight: [int] Traffic is distributed in proportion to target weight, relative to the combined weight of all targets. A target with higher weight receives a greater share of traffic. Valid range is 0 to 256 and default is 1; targets with weight of 0 do not participate in load balancing but still accept persistent connections. It is best use values in the middle of the range to leave room for later adjustments.
        :param pulumi.Input[bool] health_check_enabled: [bool] Makes the target available only if it accepts periodic health check TCP connection attempts; when turned off, the target is considered always available. The health check only consists of a connection attempt to the address and port of the target. Default is True.
        :param pulumi.Input[bool] maintenance_enabled: [bool] Maintenance mode prevents the target from receiving balanced traffic.
        :param pulumi.Input[str] proxy_protocol: [string] The proxy protocol version. Accepted values are `none`, `v1`, `v2`, `v2ssl`. If unspecified, the default value of `none` is used.
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "weight", weight)
        if health_check_enabled is not None:
            pulumi.set(__self__, "health_check_enabled", health_check_enabled)
        if maintenance_enabled is not None:
            pulumi.set(__self__, "maintenance_enabled", maintenance_enabled)
        if proxy_protocol is not None:
            pulumi.set(__self__, "proxy_protocol", proxy_protocol)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        [string] The IP of the balanced target VM.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        [int] The port of the balanced target service; valid range is 1 to 65535.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def weight(self) -> pulumi.Input[int]:
        """
        [int] Traffic is distributed in proportion to target weight, relative to the combined weight of all targets. A target with higher weight receives a greater share of traffic. Valid range is 0 to 256 and default is 1; targets with weight of 0 do not participate in load balancing but still accept persistent connections. It is best use values in the middle of the range to leave room for later adjustments.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[int]):
        pulumi.set(self, "weight", value)

    @property
    @pulumi.getter(name="healthCheckEnabled")
    def health_check_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        [bool] Makes the target available only if it accepts periodic health check TCP connection attempts; when turned off, the target is considered always available. The health check only consists of a connection attempt to the address and port of the target. Default is True.
        """
        return pulumi.get(self, "health_check_enabled")

    @health_check_enabled.setter
    def health_check_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "health_check_enabled", value)

    @property
    @pulumi.getter(name="maintenanceEnabled")
    def maintenance_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        [bool] Maintenance mode prevents the target from receiving balanced traffic.
        """
        return pulumi.get(self, "maintenance_enabled")

    @maintenance_enabled.setter
    def maintenance_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "maintenance_enabled", value)

    @property
    @pulumi.getter(name="proxyProtocol")
    def proxy_protocol(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The proxy protocol version. Accepted values are `none`, `v1`, `v2`, `v2ssl`. If unspecified, the default value of `none` is used.
        """
        return pulumi.get(self, "proxy_protocol")

    @proxy_protocol.setter
    def proxy_protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy_protocol", value)


@pulumi.input_type
class GetIpblockIpConsumerArgs:
    def __init__(__self__, *,
                 datacenter_id: str,
                 datacenter_name: str,
                 ip: str,
                 k8s_cluster_uuid: str,
                 k8s_nodepool_uuid: str,
                 mac: str,
                 nic_id: str,
                 server_id: str,
                 server_name: str):
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "datacenter_name", datacenter_name)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "k8s_cluster_uuid", k8s_cluster_uuid)
        pulumi.set(__self__, "k8s_nodepool_uuid", k8s_nodepool_uuid)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "nic_id", nic_id)
        pulumi.set(__self__, "server_id", server_id)
        pulumi.set(__self__, "server_name", server_name)

    @property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> str:
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: str):
        pulumi.set(self, "datacenter_id", value)

    @property
    @pulumi.getter(name="datacenterName")
    def datacenter_name(self) -> str:
        return pulumi.get(self, "datacenter_name")

    @datacenter_name.setter
    def datacenter_name(self, value: str):
        pulumi.set(self, "datacenter_name", value)

    @property
    @pulumi.getter
    def ip(self) -> str:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: str):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="k8sClusterUuid")
    def k8s_cluster_uuid(self) -> str:
        return pulumi.get(self, "k8s_cluster_uuid")

    @k8s_cluster_uuid.setter
    def k8s_cluster_uuid(self, value: str):
        pulumi.set(self, "k8s_cluster_uuid", value)

    @property
    @pulumi.getter(name="k8sNodepoolUuid")
    def k8s_nodepool_uuid(self) -> str:
        return pulumi.get(self, "k8s_nodepool_uuid")

    @k8s_nodepool_uuid.setter
    def k8s_nodepool_uuid(self, value: str):
        pulumi.set(self, "k8s_nodepool_uuid", value)

    @property
    @pulumi.getter
    def mac(self) -> str:
        return pulumi.get(self, "mac")

    @mac.setter
    def mac(self, value: str):
        pulumi.set(self, "mac", value)

    @property
    @pulumi.getter(name="nicId")
    def nic_id(self) -> str:
        return pulumi.get(self, "nic_id")

    @nic_id.setter
    def nic_id(self, value: str):
        pulumi.set(self, "nic_id", value)

    @property
    @pulumi.getter(name="serverId")
    def server_id(self) -> str:
        return pulumi.get(self, "server_id")

    @server_id.setter
    def server_id(self, value: str):
        pulumi.set(self, "server_id", value)

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> str:
        return pulumi.get(self, "server_name")

    @server_name.setter
    def server_name(self, value: str):
        pulumi.set(self, "server_name", value)


@pulumi.input_type
class GetK8sClustersFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 value: str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


@pulumi.input_type
class GetMongoUserRoleArgs:
    def __init__(__self__, *,
                 database: str,
                 role: str):
        """
        :param str role: A list of mongodb user roles. Examples: read, readWrite, readAnyDatabase
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def database(self) -> str:
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: str):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        A list of mongodb user roles. Examples: read, readWrite, readAnyDatabase
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: str):
        pulumi.set(self, "role", value)


@pulumi.input_type
class GetNfsShareClientGroupArgs:
    def __init__(__self__, *,
                 description: str,
                 hosts: Sequence[str],
                 ip_networks: Sequence[str],
                 nfs: Sequence['GetNfsShareClientGroupNfArgs']):
        """
        :param str description: Optional description for the clients groups.
        :param Sequence[str] hosts: A singular host allowed to connect to the share. The host can be specified as IP address and can be either IPv4 or IPv6.
        :param Sequence[str] ip_networks: The allowed host or network to which the export is being shared. The IP address can be either IPv4 or IPv6 and has to be given with CIDR notation.
        :param Sequence['GetNfsShareClientGroupNfArgs'] nfs: The NFS configuration for the client group. Each NFS configuration supports the following:
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "hosts", hosts)
        pulumi.set(__self__, "ip_networks", ip_networks)
        pulumi.set(__self__, "nfs", nfs)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Optional description for the clients groups.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: str):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def hosts(self) -> Sequence[str]:
        """
        A singular host allowed to connect to the share. The host can be specified as IP address and can be either IPv4 or IPv6.
        """
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: Sequence[str]):
        pulumi.set(self, "hosts", value)

    @property
    @pulumi.getter(name="ipNetworks")
    def ip_networks(self) -> Sequence[str]:
        """
        The allowed host or network to which the export is being shared. The IP address can be either IPv4 or IPv6 and has to be given with CIDR notation.
        """
        return pulumi.get(self, "ip_networks")

    @ip_networks.setter
    def ip_networks(self, value: Sequence[str]):
        pulumi.set(self, "ip_networks", value)

    @property
    @pulumi.getter
    def nfs(self) -> Sequence['GetNfsShareClientGroupNfArgs']:
        """
        The NFS configuration for the client group. Each NFS configuration supports the following:
        """
        return pulumi.get(self, "nfs")

    @nfs.setter
    def nfs(self, value: Sequence['GetNfsShareClientGroupNfArgs']):
        pulumi.set(self, "nfs", value)


@pulumi.input_type
class GetNfsShareClientGroupNfArgs:
    def __init__(__self__, *,
                 squash: str):
        """
        :param str squash: The squash mode for the export. The squash mode can be: none - No squash mode. no mapping, root-anonymous - Map root user to anonymous uid, all-anonymous - Map all users to anonymous uid.
        """
        pulumi.set(__self__, "squash", squash)

    @property
    @pulumi.getter
    def squash(self) -> str:
        """
        The squash mode for the export. The squash mode can be: none - No squash mode. no mapping, root-anonymous - Map root user to anonymous uid, all-anonymous - Map all users to anonymous uid.
        """
        return pulumi.get(self, "squash")

    @squash.setter
    def squash(self, value: str):
        pulumi.set(self, "squash", value)


@pulumi.input_type
class GetServersFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 value: str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


