# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'ApigatewayCustomDomainArgs',
    'ApigatewayRouteUpstreamArgs',
    'AutoscalingGroupPolicyArgs',
    'AutoscalingGroupPolicyScaleInActionArgs',
    'AutoscalingGroupPolicyScaleOutActionArgs',
    'AutoscalingGroupReplicaConfigurationArgs',
    'AutoscalingGroupReplicaConfigurationNicArgs',
    'AutoscalingGroupReplicaConfigurationNicFirewallRuleArgs',
    'AutoscalingGroupReplicaConfigurationNicFlowLogArgs',
    'AutoscalingGroupReplicaConfigurationNicTargetGroupArgs',
    'AutoscalingGroupReplicaConfigurationVolumeArgs',
    'KafkaClusterConnectionsArgs',
    'LoggingPipelineLogArgs',
    'LoggingPipelineLogDestinationArgs',
    'NetworkloadbalancerFlowlogArgs',
    'NetworkloadbalancerForwardingruleHealthCheckArgs',
    'NetworkloadbalancerForwardingruleTargetArgs',
    'NetworkloadbalancerForwardingruleTargetHealthCheckArgs',
    'TargetGroupHealthCheckArgs',
    'TargetGroupHttpHealthCheckArgs',
    'TargetGroupTargetArgs',
    'GetIpblockIpConsumerArgs',
    'GetK8sClustersFilterArgs',
    'GetMongoUserRoleArgs',
    'GetNfsShareClientGroupArgs',
    'GetNfsShareClientGroupNfArgs',
    'GetServersFilterArgs',
]

@pulumi.input_type
class ApigatewayCustomDomainArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 certificate_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: [string] The domain name. Externally reachable.
        :param pulumi.Input[str] certificate_id: [string] The certificate ID for the domain. Must be a valid certificate in UUID form.
        """
        pulumi.set(__self__, "name", name)
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        [string] The domain name. Externally reachable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The certificate ID for the domain. Must be a valid certificate in UUID form.
        """
        return pulumi.get(self, "certificate_id")

    @certificate_id.setter
    def certificate_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_id", value)


@pulumi.input_type
class ApigatewayRouteUpstreamArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[str],
                 loadbalancer: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 scheme: Optional[pulumi.Input[str]] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] host: [string] The host of the upstream.
        :param pulumi.Input[str] loadbalancer: [string] The load balancer algorithm. Default value: `roundrobin`.
        :param pulumi.Input[int] port: [int] The port of the upstream. Default value: `80`.
        :param pulumi.Input[str] scheme: [string] The target URL of the upstream. Default value: `http`.
        :param pulumi.Input[int] weight: [int] Weight with which to split traffic to the upstream. Default value: `100`.
        """
        pulumi.set(__self__, "host", host)
        if loadbalancer is not None:
            pulumi.set(__self__, "loadbalancer", loadbalancer)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        [string] The host of the upstream.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def loadbalancer(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The load balancer algorithm. Default value: `roundrobin`.
        """
        return pulumi.get(self, "loadbalancer")

    @loadbalancer.setter
    def loadbalancer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "loadbalancer", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        [int] The port of the upstream. Default value: `80`.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The target URL of the upstream. Default value: `http`.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scheme", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        """
        [int] Weight with which to split traffic to the upstream. Default value: `100`.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class AutoscalingGroupPolicyArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 scale_in_action: pulumi.Input['AutoscalingGroupPolicyScaleInActionArgs'],
                 scale_in_threshold: pulumi.Input[int],
                 scale_out_action: pulumi.Input['AutoscalingGroupPolicyScaleOutActionArgs'],
                 scale_out_threshold: pulumi.Input[int],
                 unit: pulumi.Input[str],
                 range: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric: [string] The Metric that should trigger the scaling actions. Metric values are checked at fixed intervals. Possible values: `INSTANCE_CPU_UTILIZATION_AVERAGE`, `INSTANCE_NETWORK_IN_BYTES`, `INSTANCE_NETWORK_IN_PACKETS`, `INSTANCE_NETWORK_OUT_BYTES`, `INSTANCE_NETWORK_OUT_PACKETS`
        :param pulumi.Input['AutoscalingGroupPolicyScaleInActionArgs'] scale_in_action: [list] Specifies the action to take when the `scaleInThreshold` is exceeded. Hereby, scaling in is always about removing VMs that are currently associated with this autoscaling group. Default termination policy is OLDEST_SERVER_FIRST.
        :param pulumi.Input[int] scale_in_threshold: [int] A lower threshold on the value of `metric`. Will be used with `less than` (<) operator. Exceeding this will start a Scale-In Action as specified by the `scaleInAction` property. The value must have a higher minimum delta to the `scaleOutThreshold` depending on the `metric` to avoid competitive actions at the same time.
        :param pulumi.Input['AutoscalingGroupPolicyScaleOutActionArgs'] scale_out_action: [list] Specifies the action to take when the `scaleOutThreshold` is exceeded. Hereby, scaling out is always about adding new VMs to this autoscaling group.
        :param pulumi.Input[int] scale_out_threshold: [int] The upper threshold for the value of the `metric`. Used with the `greater than` (>) operator. A scale-out action is triggered when this value is exceeded, specified by the `scaleOutAction` property. The value must have a lower minimum delta to the `scaleInThreshold`, depending on the metric, to avoid competing for actions simultaneously. If `properties.policy.unit=TOTAL`, a value >= 40 must be chosen.
        :param pulumi.Input[str] unit: [string] Units of the applied Metric. Possible values are: `PER_HOUR`, `PER_MINUTE`, `PER_SECOND`, `TOTAL`.
        :param pulumi.Input[str] range: [string] Defines the time range, for which the samples will be aggregated. Default is 120s. *Note that when you set it to values like 5m the API will automatically transform it in PT5M, so the plan will show you a diff in state that should be ignored.*
        """
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "scale_in_action", scale_in_action)
        pulumi.set(__self__, "scale_in_threshold", scale_in_threshold)
        pulumi.set(__self__, "scale_out_action", scale_out_action)
        pulumi.set(__self__, "scale_out_threshold", scale_out_threshold)
        pulumi.set(__self__, "unit", unit)
        if range is not None:
            pulumi.set(__self__, "range", range)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        [string] The Metric that should trigger the scaling actions. Metric values are checked at fixed intervals. Possible values: `INSTANCE_CPU_UTILIZATION_AVERAGE`, `INSTANCE_NETWORK_IN_BYTES`, `INSTANCE_NETWORK_IN_PACKETS`, `INSTANCE_NETWORK_OUT_BYTES`, `INSTANCE_NETWORK_OUT_PACKETS`
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="scaleInAction")
    def scale_in_action(self) -> pulumi.Input['AutoscalingGroupPolicyScaleInActionArgs']:
        """
        [list] Specifies the action to take when the `scaleInThreshold` is exceeded. Hereby, scaling in is always about removing VMs that are currently associated with this autoscaling group. Default termination policy is OLDEST_SERVER_FIRST.
        """
        return pulumi.get(self, "scale_in_action")

    @scale_in_action.setter
    def scale_in_action(self, value: pulumi.Input['AutoscalingGroupPolicyScaleInActionArgs']):
        pulumi.set(self, "scale_in_action", value)

    @property
    @pulumi.getter(name="scaleInThreshold")
    def scale_in_threshold(self) -> pulumi.Input[int]:
        """
        [int] A lower threshold on the value of `metric`. Will be used with `less than` (<) operator. Exceeding this will start a Scale-In Action as specified by the `scaleInAction` property. The value must have a higher minimum delta to the `scaleOutThreshold` depending on the `metric` to avoid competitive actions at the same time.
        """
        return pulumi.get(self, "scale_in_threshold")

    @scale_in_threshold.setter
    def scale_in_threshold(self, value: pulumi.Input[int]):
        pulumi.set(self, "scale_in_threshold", value)

    @property
    @pulumi.getter(name="scaleOutAction")
    def scale_out_action(self) -> pulumi.Input['AutoscalingGroupPolicyScaleOutActionArgs']:
        """
        [list] Specifies the action to take when the `scaleOutThreshold` is exceeded. Hereby, scaling out is always about adding new VMs to this autoscaling group.
        """
        return pulumi.get(self, "scale_out_action")

    @scale_out_action.setter
    def scale_out_action(self, value: pulumi.Input['AutoscalingGroupPolicyScaleOutActionArgs']):
        pulumi.set(self, "scale_out_action", value)

    @property
    @pulumi.getter(name="scaleOutThreshold")
    def scale_out_threshold(self) -> pulumi.Input[int]:
        """
        [int] The upper threshold for the value of the `metric`. Used with the `greater than` (>) operator. A scale-out action is triggered when this value is exceeded, specified by the `scaleOutAction` property. The value must have a lower minimum delta to the `scaleInThreshold`, depending on the metric, to avoid competing for actions simultaneously. If `properties.policy.unit=TOTAL`, a value >= 40 must be chosen.
        """
        return pulumi.get(self, "scale_out_threshold")

    @scale_out_threshold.setter
    def scale_out_threshold(self, value: pulumi.Input[int]):
        pulumi.set(self, "scale_out_threshold", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[str]:
        """
        [string] Units of the applied Metric. Possible values are: `PER_HOUR`, `PER_MINUTE`, `PER_SECOND`, `TOTAL`.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def range(self) -> Optional[pulumi.Input[str]]:
        """
        [string] Defines the time range, for which the samples will be aggregated. Default is 120s. *Note that when you set it to values like 5m the API will automatically transform it in PT5M, so the plan will show you a diff in state that should be ignored.*
        """
        return pulumi.get(self, "range")

    @range.setter
    def range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "range", value)


@pulumi.input_type
class AutoscalingGroupPolicyScaleInActionArgs:
    def __init__(__self__, *,
                 amount: pulumi.Input[int],
                 amount_type: pulumi.Input[str],
                 delete_volumes: pulumi.Input[bool],
                 cooldown_period: Optional[pulumi.Input[str]] = None,
                 termination_policy_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] amount: [int] When `amountType=ABSOLUTE` specifies the absolute number of VMs that are added. The value must be between 1 to 10. `amountType=PERCENTAGE` specifies the percentage value that is applied to the current number of replicas of the VM Auto Scaling Group. The value must be between 1 to 200. At least one VM is always added.
        :param pulumi.Input[str] amount_type: [string] The type for the given amount. Possible values are: `ABSOLUTE`, `PERCENTAGE`.
        :param pulumi.Input[bool] delete_volumes: [bool] If set to `true`, when deleting a replica during scale in, any attached volume will also be deleted. When set to `false`, all volumes remain in the datacenter and must be deleted manually. Note that every scale-out creates new volumes. When they are not deleted, they will eventually use all of your contracts resource limits. At this point, scaling out would not be possible anymore.
        :param pulumi.Input[str] cooldown_period: [string] Minimum time to pass after this Scaling action has started, until the next Scaling action will be started. Additionally, if a Scaling action is currently in progress, no second Scaling action will be started for the same autoscaling group. Instead, the Metric will be re-evaluated after the current Scaling action is completed (either successfully or with failures). This is validated with a minimum value of 2 minutes and a maximum of 24 hours currently. Default value is 5 minutes if not given. *Note that when you set it to values like 5m the API will automatically transform it in PT5M, so the plan will show you a diff in state that should be ignored.*
        :param pulumi.Input[str] termination_policy_type: [string] The type of the termination policy for the autoscaling group so that a specific pattern is followed for Scaling-In replicas. Default termination policy is `OLDEST_SERVER_FIRST`. Possible values are: `OLDEST_SERVER_FIRST`, `NEWEST_SERVER_FIRST`, `RANDOM`
        """
        pulumi.set(__self__, "amount", amount)
        pulumi.set(__self__, "amount_type", amount_type)
        pulumi.set(__self__, "delete_volumes", delete_volumes)
        if cooldown_period is not None:
            pulumi.set(__self__, "cooldown_period", cooldown_period)
        if termination_policy_type is not None:
            pulumi.set(__self__, "termination_policy_type", termination_policy_type)

    @property
    @pulumi.getter
    def amount(self) -> pulumi.Input[int]:
        """
        [int] When `amountType=ABSOLUTE` specifies the absolute number of VMs that are added. The value must be between 1 to 10. `amountType=PERCENTAGE` specifies the percentage value that is applied to the current number of replicas of the VM Auto Scaling Group. The value must be between 1 to 200. At least one VM is always added.
        """
        return pulumi.get(self, "amount")

    @amount.setter
    def amount(self, value: pulumi.Input[int]):
        pulumi.set(self, "amount", value)

    @property
    @pulumi.getter(name="amountType")
    def amount_type(self) -> pulumi.Input[str]:
        """
        [string] The type for the given amount. Possible values are: `ABSOLUTE`, `PERCENTAGE`.
        """
        return pulumi.get(self, "amount_type")

    @amount_type.setter
    def amount_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "amount_type", value)

    @property
    @pulumi.getter(name="deleteVolumes")
    def delete_volumes(self) -> pulumi.Input[bool]:
        """
        [bool] If set to `true`, when deleting a replica during scale in, any attached volume will also be deleted. When set to `false`, all volumes remain in the datacenter and must be deleted manually. Note that every scale-out creates new volumes. When they are not deleted, they will eventually use all of your contracts resource limits. At this point, scaling out would not be possible anymore.
        """
        return pulumi.get(self, "delete_volumes")

    @delete_volumes.setter
    def delete_volumes(self, value: pulumi.Input[bool]):
        pulumi.set(self, "delete_volumes", value)

    @property
    @pulumi.getter(name="cooldownPeriod")
    def cooldown_period(self) -> Optional[pulumi.Input[str]]:
        """
        [string] Minimum time to pass after this Scaling action has started, until the next Scaling action will be started. Additionally, if a Scaling action is currently in progress, no second Scaling action will be started for the same autoscaling group. Instead, the Metric will be re-evaluated after the current Scaling action is completed (either successfully or with failures). This is validated with a minimum value of 2 minutes and a maximum of 24 hours currently. Default value is 5 minutes if not given. *Note that when you set it to values like 5m the API will automatically transform it in PT5M, so the plan will show you a diff in state that should be ignored.*
        """
        return pulumi.get(self, "cooldown_period")

    @cooldown_period.setter
    def cooldown_period(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cooldown_period", value)

    @property
    @pulumi.getter(name="terminationPolicyType")
    def termination_policy_type(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The type of the termination policy for the autoscaling group so that a specific pattern is followed for Scaling-In replicas. Default termination policy is `OLDEST_SERVER_FIRST`. Possible values are: `OLDEST_SERVER_FIRST`, `NEWEST_SERVER_FIRST`, `RANDOM`
        """
        return pulumi.get(self, "termination_policy_type")

    @termination_policy_type.setter
    def termination_policy_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "termination_policy_type", value)


@pulumi.input_type
class AutoscalingGroupPolicyScaleOutActionArgs:
    def __init__(__self__, *,
                 amount: pulumi.Input[int],
                 amount_type: pulumi.Input[str],
                 cooldown_period: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] amount: [int] When `amountType=ABSOLUTE` specifies the absolute number of VMs that are added. The value must be between 1 to 10. `amountType=PERCENTAGE` specifies the percentage value that is applied to the current number of replicas of the VM Auto Scaling Group. The value must be between 1 to 200. At least one VM is always added.
        :param pulumi.Input[str] amount_type: [string] The type for the given amount. Possible values are: `ABSOLUTE`, `PERCENTAGE`.
        :param pulumi.Input[str] cooldown_period: [string] Minimum time to pass after this Scaling action has started, until the next Scaling action will be started. Additionally, if a Scaling action is currently in progress, no second Scaling action will be started for the same autoscaling group. Instead, the Metric will be re-evaluated after the current Scaling action is completed (either successfully or with failures). This is validated with a minimum value of 2 minutes and a maximum of 24 hours currently. Default value is 5 minutes if not given. *Note that when you set it to values like 5m the API will automatically transform it in PT5M, so the plan will show you a diff in state that should be ignored.*
        """
        pulumi.set(__self__, "amount", amount)
        pulumi.set(__self__, "amount_type", amount_type)
        if cooldown_period is not None:
            pulumi.set(__self__, "cooldown_period", cooldown_period)

    @property
    @pulumi.getter
    def amount(self) -> pulumi.Input[int]:
        """
        [int] When `amountType=ABSOLUTE` specifies the absolute number of VMs that are added. The value must be between 1 to 10. `amountType=PERCENTAGE` specifies the percentage value that is applied to the current number of replicas of the VM Auto Scaling Group. The value must be between 1 to 200. At least one VM is always added.
        """
        return pulumi.get(self, "amount")

    @amount.setter
    def amount(self, value: pulumi.Input[int]):
        pulumi.set(self, "amount", value)

    @property
    @pulumi.getter(name="amountType")
    def amount_type(self) -> pulumi.Input[str]:
        """
        [string] The type for the given amount. Possible values are: `ABSOLUTE`, `PERCENTAGE`.
        """
        return pulumi.get(self, "amount_type")

    @amount_type.setter
    def amount_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "amount_type", value)

    @property
    @pulumi.getter(name="cooldownPeriod")
    def cooldown_period(self) -> Optional[pulumi.Input[str]]:
        """
        [string] Minimum time to pass after this Scaling action has started, until the next Scaling action will be started. Additionally, if a Scaling action is currently in progress, no second Scaling action will be started for the same autoscaling group. Instead, the Metric will be re-evaluated after the current Scaling action is completed (either successfully or with failures). This is validated with a minimum value of 2 minutes and a maximum of 24 hours currently. Default value is 5 minutes if not given. *Note that when you set it to values like 5m the API will automatically transform it in PT5M, so the plan will show you a diff in state that should be ignored.*
        """
        return pulumi.get(self, "cooldown_period")

    @cooldown_period.setter
    def cooldown_period(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cooldown_period", value)


@pulumi.input_type
class AutoscalingGroupReplicaConfigurationArgs:
    def __init__(__self__, *,
                 availability_zone: pulumi.Input[str],
                 cores: pulumi.Input[int],
                 ram: pulumi.Input[int],
                 cpu_family: Optional[pulumi.Input[str]] = None,
                 nics: Optional[pulumi.Input[Sequence[pulumi.Input['AutoscalingGroupReplicaConfigurationNicArgs']]]] = None,
                 volumes: Optional[pulumi.Input[Sequence[pulumi.Input['AutoscalingGroupReplicaConfigurationVolumeArgs']]]] = None):
        """
        :param pulumi.Input[str] availability_zone: [string] The zone where the VMs are created using this configuration. Possible values are: `AUTO`, `ZONE_1`, `ZONE_2`.
        :param pulumi.Input[int] cores: [int] The total number of cores for the VMs.
        :param pulumi.Input[int] ram: [int] The amount of memory for the VMs in MB, e.g. 2048. Size must be specified in multiples of 256 MB with a minimum of 256 MB; however, if you set ramHotPlug to TRUE then you must use a minimum of 1024 MB. If you set the RAM size more than 240GB, then ramHotPlug will be set to FALSE and can not be set to TRUE unless RAM size not set to less than 240GB.
        :param pulumi.Input[str] cpu_family: [string] PU family for the VMs created using this configuration. If null, the VM will be created with the default CPU family for the assigned location. Possible values are: `INTEL_SKYLAKE`, `INTEL_XEON`.
        :param pulumi.Input[Sequence[pulumi.Input['AutoscalingGroupReplicaConfigurationNicArgs']]] nics: Set of NICs associated with this Replica.
        :param pulumi.Input[Sequence[pulumi.Input['AutoscalingGroupReplicaConfigurationVolumeArgs']]] volumes: [list] List of volumes associated with this Replica.
        """
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "cores", cores)
        pulumi.set(__self__, "ram", ram)
        if cpu_family is not None:
            pulumi.set(__self__, "cpu_family", cpu_family)
        if nics is not None:
            pulumi.set(__self__, "nics", nics)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> pulumi.Input[str]:
        """
        [string] The zone where the VMs are created using this configuration. Possible values are: `AUTO`, `ZONE_1`, `ZONE_2`.
        """
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: pulumi.Input[str]):
        pulumi.set(self, "availability_zone", value)

    @property
    @pulumi.getter
    def cores(self) -> pulumi.Input[int]:
        """
        [int] The total number of cores for the VMs.
        """
        return pulumi.get(self, "cores")

    @cores.setter
    def cores(self, value: pulumi.Input[int]):
        pulumi.set(self, "cores", value)

    @property
    @pulumi.getter
    def ram(self) -> pulumi.Input[int]:
        """
        [int] The amount of memory for the VMs in MB, e.g. 2048. Size must be specified in multiples of 256 MB with a minimum of 256 MB; however, if you set ramHotPlug to TRUE then you must use a minimum of 1024 MB. If you set the RAM size more than 240GB, then ramHotPlug will be set to FALSE and can not be set to TRUE unless RAM size not set to less than 240GB.
        """
        return pulumi.get(self, "ram")

    @ram.setter
    def ram(self, value: pulumi.Input[int]):
        pulumi.set(self, "ram", value)

    @property
    @pulumi.getter(name="cpuFamily")
    def cpu_family(self) -> Optional[pulumi.Input[str]]:
        """
        [string] PU family for the VMs created using this configuration. If null, the VM will be created with the default CPU family for the assigned location. Possible values are: `INTEL_SKYLAKE`, `INTEL_XEON`.
        """
        return pulumi.get(self, "cpu_family")

    @cpu_family.setter
    def cpu_family(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cpu_family", value)

    @property
    @pulumi.getter
    def nics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutoscalingGroupReplicaConfigurationNicArgs']]]]:
        """
        Set of NICs associated with this Replica.
        """
        return pulumi.get(self, "nics")

    @nics.setter
    def nics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutoscalingGroupReplicaConfigurationNicArgs']]]]):
        pulumi.set(self, "nics", value)

    @property
    @pulumi.getter
    def volumes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutoscalingGroupReplicaConfigurationVolumeArgs']]]]:
        """
        [list] List of volumes associated with this Replica.
        """
        return pulumi.get(self, "volumes")

    @volumes.setter
    def volumes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutoscalingGroupReplicaConfigurationVolumeArgs']]]]):
        pulumi.set(self, "volumes", value)


@pulumi.input_type
class AutoscalingGroupReplicaConfigurationNicArgs:
    def __init__(__self__, *,
                 lan: pulumi.Input[int],
                 name: pulumi.Input[str],
                 dhcp: Optional[pulumi.Input[bool]] = None,
                 firewall_active: Optional[pulumi.Input[bool]] = None,
                 firewall_rules: Optional[pulumi.Input[Sequence[pulumi.Input['AutoscalingGroupReplicaConfigurationNicFirewallRuleArgs']]]] = None,
                 firewall_type: Optional[pulumi.Input[str]] = None,
                 flow_logs: Optional[pulumi.Input[Sequence[pulumi.Input['AutoscalingGroupReplicaConfigurationNicFlowLogArgs']]]] = None,
                 target_group: Optional[pulumi.Input['AutoscalingGroupReplicaConfigurationNicTargetGroupArgs']] = None):
        """
        :param pulumi.Input[int] lan: [int] Lan ID for this replica Nic.
        :param pulumi.Input[str] name: [string] Name for this replica volume.
        :param pulumi.Input[bool] dhcp: [bool] Dhcp flag for this replica Nic. This is an optional attribute with default value of `true` if not given in the request payload or given as null.
        :param pulumi.Input[bool] firewall_active: [bool] Firewall active flag.
        :param pulumi.Input[Sequence[pulumi.Input['AutoscalingGroupReplicaConfigurationNicFirewallRuleArgs']]] firewall_rules: List of all firewall rules for the specified NIC.
        :param pulumi.Input[str] firewall_type: [string] The type of firewall rules that will be allowed on the NIC. Valid values: INGRESS EGRESS BIDIRECTIONAL. If not specified, the default INGRESS value is used.
        :param pulumi.Input[Sequence[pulumi.Input['AutoscalingGroupReplicaConfigurationNicFlowLogArgs']]] flow_logs: [list] Only 1 flow log can be configured. Only the name field can change as part of an update. Flow logs holistically capture network information such as source and destination IP addresses, source and destination ports, number of packets, amount of bytes, the start and end time of the recording, and the type of protocol – and log the extent to which your instances are being accessed.
        :param pulumi.Input['AutoscalingGroupReplicaConfigurationNicTargetGroupArgs'] target_group: [list] In order to link VM to ALB, target group must be provided
        """
        pulumi.set(__self__, "lan", lan)
        pulumi.set(__self__, "name", name)
        if dhcp is not None:
            pulumi.set(__self__, "dhcp", dhcp)
        if firewall_active is not None:
            pulumi.set(__self__, "firewall_active", firewall_active)
        if firewall_rules is not None:
            pulumi.set(__self__, "firewall_rules", firewall_rules)
        if firewall_type is not None:
            pulumi.set(__self__, "firewall_type", firewall_type)
        if flow_logs is not None:
            pulumi.set(__self__, "flow_logs", flow_logs)
        if target_group is not None:
            pulumi.set(__self__, "target_group", target_group)

    @property
    @pulumi.getter
    def lan(self) -> pulumi.Input[int]:
        """
        [int] Lan ID for this replica Nic.
        """
        return pulumi.get(self, "lan")

    @lan.setter
    def lan(self, value: pulumi.Input[int]):
        pulumi.set(self, "lan", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        [string] Name for this replica volume.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def dhcp(self) -> Optional[pulumi.Input[bool]]:
        """
        [bool] Dhcp flag for this replica Nic. This is an optional attribute with default value of `true` if not given in the request payload or given as null.
        """
        return pulumi.get(self, "dhcp")

    @dhcp.setter
    def dhcp(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dhcp", value)

    @property
    @pulumi.getter(name="firewallActive")
    def firewall_active(self) -> Optional[pulumi.Input[bool]]:
        """
        [bool] Firewall active flag.
        """
        return pulumi.get(self, "firewall_active")

    @firewall_active.setter
    def firewall_active(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "firewall_active", value)

    @property
    @pulumi.getter(name="firewallRules")
    def firewall_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutoscalingGroupReplicaConfigurationNicFirewallRuleArgs']]]]:
        """
        List of all firewall rules for the specified NIC.
        """
        return pulumi.get(self, "firewall_rules")

    @firewall_rules.setter
    def firewall_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutoscalingGroupReplicaConfigurationNicFirewallRuleArgs']]]]):
        pulumi.set(self, "firewall_rules", value)

    @property
    @pulumi.getter(name="firewallType")
    def firewall_type(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The type of firewall rules that will be allowed on the NIC. Valid values: INGRESS EGRESS BIDIRECTIONAL. If not specified, the default INGRESS value is used.
        """
        return pulumi.get(self, "firewall_type")

    @firewall_type.setter
    def firewall_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "firewall_type", value)

    @property
    @pulumi.getter(name="flowLogs")
    def flow_logs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutoscalingGroupReplicaConfigurationNicFlowLogArgs']]]]:
        """
        [list] Only 1 flow log can be configured. Only the name field can change as part of an update. Flow logs holistically capture network information such as source and destination IP addresses, source and destination ports, number of packets, amount of bytes, the start and end time of the recording, and the type of protocol – and log the extent to which your instances are being accessed.
        """
        return pulumi.get(self, "flow_logs")

    @flow_logs.setter
    def flow_logs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutoscalingGroupReplicaConfigurationNicFlowLogArgs']]]]):
        pulumi.set(self, "flow_logs", value)

    @property
    @pulumi.getter(name="targetGroup")
    def target_group(self) -> Optional[pulumi.Input['AutoscalingGroupReplicaConfigurationNicTargetGroupArgs']]:
        """
        [list] In order to link VM to ALB, target group must be provided
        """
        return pulumi.get(self, "target_group")

    @target_group.setter
    def target_group(self, value: Optional[pulumi.Input['AutoscalingGroupReplicaConfigurationNicTargetGroupArgs']]):
        pulumi.set(self, "target_group", value)


@pulumi.input_type
class AutoscalingGroupReplicaConfigurationNicFirewallRuleArgs:
    def __init__(__self__, *,
                 protocol: pulumi.Input[str],
                 icmp_code: Optional[pulumi.Input[int]] = None,
                 icmp_type: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 port_range_end: Optional[pulumi.Input[int]] = None,
                 port_range_start: Optional[pulumi.Input[int]] = None,
                 source_ip: Optional[pulumi.Input[str]] = None,
                 source_mac: Optional[pulumi.Input[str]] = None,
                 target_ip: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] protocol: [string] The protocol for the rule: TCP, UDP, ICMP, ANY. Property cannot be modified after creation (disallowed in update requests).
        :param pulumi.Input[int] icmp_code: [int] Defines the allowed code (from 0 to 254) if protocol ICMP is chosen.
        :param pulumi.Input[int] icmp_type: [string] Defines the allowed code (from 0 to 254) if protocol ICMP is chosen. Value null allows all codes.
        :param pulumi.Input[str] name: [string] Name for this replica volume.
        :param pulumi.Input[int] port_range_end: [int] Defines the end range of the allowed port (from 1 to 65534) if the protocol TCP or UDP is chosen. Leave portRangeStart and portRangeEnd null to allow all ports.
        :param pulumi.Input[int] port_range_start: [int] Defines the start range of the allowed port (from 1 to 65534) if protocol TCP or UDP is chosen. Leave portRangeStart and portRangeEnd null to allow all ports.
        :param pulumi.Input[str] source_ip: [string] Only traffic originating from the respective IPv4 address is allowed. Value null allows all source IPs.
        :param pulumi.Input[str] source_mac: [string] Only traffic originating from the respective MAC address is allowed. Valid format: aa:bb:cc:dd:ee:ff. Value null allows all source MAC address. Valid format: aa:bb:cc:dd:ee:ff.
        :param pulumi.Input[str] target_ip: [string] In case the target NIC has multiple IP addresses, only traffic directed to the respective IP address of the NIC is allowed. Value null allows all target IPs.
        :param pulumi.Input[str] type: [string] Storage Type for this replica volume. Possible values: `SSD`, `HDD`, `SSD_STANDARD` or `SSD_PREMIUM`.
        """
        pulumi.set(__self__, "protocol", protocol)
        if icmp_code is not None:
            pulumi.set(__self__, "icmp_code", icmp_code)
        if icmp_type is not None:
            pulumi.set(__self__, "icmp_type", icmp_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_range_end is not None:
            pulumi.set(__self__, "port_range_end", port_range_end)
        if port_range_start is not None:
            pulumi.set(__self__, "port_range_start", port_range_start)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)
        if source_mac is not None:
            pulumi.set(__self__, "source_mac", source_mac)
        if target_ip is not None:
            pulumi.set(__self__, "target_ip", target_ip)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        [string] The protocol for the rule: TCP, UDP, ICMP, ANY. Property cannot be modified after creation (disallowed in update requests).
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> Optional[pulumi.Input[int]]:
        """
        [int] Defines the allowed code (from 0 to 254) if protocol ICMP is chosen.
        """
        return pulumi.get(self, "icmp_code")

    @icmp_code.setter
    def icmp_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "icmp_code", value)

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[pulumi.Input[int]]:
        """
        [string] Defines the allowed code (from 0 to 254) if protocol ICMP is chosen. Value null allows all codes.
        """
        return pulumi.get(self, "icmp_type")

    @icmp_type.setter
    def icmp_type(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "icmp_type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        [string] Name for this replica volume.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="portRangeEnd")
    def port_range_end(self) -> Optional[pulumi.Input[int]]:
        """
        [int] Defines the end range of the allowed port (from 1 to 65534) if the protocol TCP or UDP is chosen. Leave portRangeStart and portRangeEnd null to allow all ports.
        """
        return pulumi.get(self, "port_range_end")

    @port_range_end.setter
    def port_range_end(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port_range_end", value)

    @property
    @pulumi.getter(name="portRangeStart")
    def port_range_start(self) -> Optional[pulumi.Input[int]]:
        """
        [int] Defines the start range of the allowed port (from 1 to 65534) if protocol TCP or UDP is chosen. Leave portRangeStart and portRangeEnd null to allow all ports.
        """
        return pulumi.get(self, "port_range_start")

    @port_range_start.setter
    def port_range_start(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port_range_start", value)

    @property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional[pulumi.Input[str]]:
        """
        [string] Only traffic originating from the respective IPv4 address is allowed. Value null allows all source IPs.
        """
        return pulumi.get(self, "source_ip")

    @source_ip.setter
    def source_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_ip", value)

    @property
    @pulumi.getter(name="sourceMac")
    def source_mac(self) -> Optional[pulumi.Input[str]]:
        """
        [string] Only traffic originating from the respective MAC address is allowed. Valid format: aa:bb:cc:dd:ee:ff. Value null allows all source MAC address. Valid format: aa:bb:cc:dd:ee:ff.
        """
        return pulumi.get(self, "source_mac")

    @source_mac.setter
    def source_mac(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_mac", value)

    @property
    @pulumi.getter(name="targetIp")
    def target_ip(self) -> Optional[pulumi.Input[str]]:
        """
        [string] In case the target NIC has multiple IP addresses, only traffic directed to the respective IP address of the NIC is allowed. Value null allows all target IPs.
        """
        return pulumi.get(self, "target_ip")

    @target_ip.setter
    def target_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_ip", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        [string] Storage Type for this replica volume. Possible values: `SSD`, `HDD`, `SSD_STANDARD` or `SSD_PREMIUM`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class AutoscalingGroupReplicaConfigurationNicFlowLogArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 bucket: pulumi.Input[str],
                 direction: pulumi.Input[str],
                 name: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: [string] Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL. Immutable, forces re-creation.
        :param pulumi.Input[str] bucket: [string] Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist. Immutable, forces re-creation.
        :param pulumi.Input[str] direction: [string] Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, forces re-creation.
        :param pulumi.Input[str] name: [string] Name for this replica volume.
        :param pulumi.Input[str] id: The resource's unique identifier.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "name", name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        [string] Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL. Immutable, forces re-creation.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        [string] Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist. Immutable, forces re-creation.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def direction(self) -> pulumi.Input[str]:
        """
        [string] Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, forces re-creation.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: pulumi.Input[str]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        [string] Name for this replica volume.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The resource's unique identifier.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class AutoscalingGroupReplicaConfigurationNicTargetGroupArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[int],
                 target_group_id: pulumi.Input[str],
                 weight: pulumi.Input[int]):
        """
        :param pulumi.Input[int] port: [int] The port of the target group.
        :param pulumi.Input[str] target_group_id: [string] The ID of the target group.
        :param pulumi.Input[int] weight: [int] The weight of the target group.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "target_group_id", target_group_id)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        [int] The port of the target group.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="targetGroupId")
    def target_group_id(self) -> pulumi.Input[str]:
        """
        [string] The ID of the target group.
        """
        return pulumi.get(self, "target_group_id")

    @target_group_id.setter
    def target_group_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_group_id", value)

    @property
    @pulumi.getter
    def weight(self) -> pulumi.Input[int]:
        """
        [int] The weight of the target group.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[int]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class AutoscalingGroupReplicaConfigurationVolumeArgs:
    def __init__(__self__, *,
                 boot_order: pulumi.Input[str],
                 name: pulumi.Input[str],
                 size: pulumi.Input[int],
                 type: pulumi.Input[str],
                 backup_unit_id: Optional[pulumi.Input[str]] = None,
                 bus: Optional[pulumi.Input[str]] = None,
                 image: Optional[pulumi.Input[str]] = None,
                 image_alias: Optional[pulumi.Input[str]] = None,
                 image_password: Optional[pulumi.Input[str]] = None,
                 ssh_keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 user_data: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] boot_order: [string] Determines whether the volume will be used as a boot volume. Set to NONE, the volume will not be used as boot volume. Set to PRIMARY, the volume will be used as boot volume and set to AUTO will delegate the decision to the provisioning engine to decide whether to use the volume as boot volume.
               Notice that exactly one volume can be set to PRIMARY or all of them set to AUTO.
        :param pulumi.Input[str] name: [string] Name for this replica volume.
        :param pulumi.Input[int] size: [int] Name for this replica volume.
        :param pulumi.Input[str] type: [string] Storage Type for this replica volume. Possible values: `SSD`, `HDD`, `SSD_STANDARD` or `SSD_PREMIUM`.
        :param pulumi.Input[str] backup_unit_id: [string] The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either `public image` or `imageAlias` in conjunction with this property.
        :param pulumi.Input[str] bus: [string] The bus type of the volume. Default setting is `VIRTIO`. The bus type `IDE` is also supported.
        :param pulumi.Input[str] image: [string] The image installed on the volume. Only the UUID of the image is presently supported.
        :param pulumi.Input[str] image_alias: [string] The image installed on the volume. Must be an `imageAlias` as specified via the images API. Note that one of `image` or `imageAlias` must be set, but not both.
        :param pulumi.Input[str] image_password: [string] Image password for this replica volume.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ssh_keys: List of ssh keys, supports values or paths to files. Cannot be changed at update.
        :param pulumi.Input[str] user_data: [string] User-data (Cloud Init) for this replica volume. Make sure you provide a Cloud Init compatible image in conjunction with this parameter.
        """
        pulumi.set(__self__, "boot_order", boot_order)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)
        if backup_unit_id is not None:
            pulumi.set(__self__, "backup_unit_id", backup_unit_id)
        if bus is not None:
            pulumi.set(__self__, "bus", bus)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if image_alias is not None:
            pulumi.set(__self__, "image_alias", image_alias)
        if image_password is not None:
            pulumi.set(__self__, "image_password", image_password)
        if ssh_keys is not None:
            pulumi.set(__self__, "ssh_keys", ssh_keys)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)

    @property
    @pulumi.getter(name="bootOrder")
    def boot_order(self) -> pulumi.Input[str]:
        """
        [string] Determines whether the volume will be used as a boot volume. Set to NONE, the volume will not be used as boot volume. Set to PRIMARY, the volume will be used as boot volume and set to AUTO will delegate the decision to the provisioning engine to decide whether to use the volume as boot volume.
        Notice that exactly one volume can be set to PRIMARY or all of them set to AUTO.
        """
        return pulumi.get(self, "boot_order")

    @boot_order.setter
    def boot_order(self, value: pulumi.Input[str]):
        pulumi.set(self, "boot_order", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        [string] Name for this replica volume.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[int]:
        """
        [int] Name for this replica volume.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[int]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        [string] Storage Type for this replica volume. Possible values: `SSD`, `HDD`, `SSD_STANDARD` or `SSD_PREMIUM`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="backupUnitId")
    def backup_unit_id(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either `public image` or `imageAlias` in conjunction with this property.
        """
        return pulumi.get(self, "backup_unit_id")

    @backup_unit_id.setter
    def backup_unit_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_unit_id", value)

    @property
    @pulumi.getter
    def bus(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The bus type of the volume. Default setting is `VIRTIO`. The bus type `IDE` is also supported.
        """
        return pulumi.get(self, "bus")

    @bus.setter
    def bus(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bus", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The image installed on the volume. Only the UUID of the image is presently supported.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="imageAlias")
    def image_alias(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The image installed on the volume. Must be an `imageAlias` as specified via the images API. Note that one of `image` or `imageAlias` must be set, but not both.
        """
        return pulumi.get(self, "image_alias")

    @image_alias.setter
    def image_alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_alias", value)

    @property
    @pulumi.getter(name="imagePassword")
    def image_password(self) -> Optional[pulumi.Input[str]]:
        """
        [string] Image password for this replica volume.
        """
        return pulumi.get(self, "image_password")

    @image_password.setter
    def image_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_password", value)

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of ssh keys, supports values or paths to files. Cannot be changed at update.
        """
        return pulumi.get(self, "ssh_keys")

    @ssh_keys.setter
    def ssh_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ssh_keys", value)

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[pulumi.Input[str]]:
        """
        [string] User-data (Cloud Init) for this replica volume. Make sure you provide a Cloud Init compatible image in conjunction with this parameter.
        """
        return pulumi.get(self, "user_data")

    @user_data.setter
    def user_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_data", value)


@pulumi.input_type
class KafkaClusterConnectionsArgs:
    def __init__(__self__, *,
                 broker_addresses: pulumi.Input[Sequence[pulumi.Input[str]]],
                 datacenter_id: pulumi.Input[str],
                 lan_id: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] broker_addresses: [list] IP address and port of cluster brokers.
        :param pulumi.Input[str] datacenter_id: [string] The datacenter to connect your instance to.
        :param pulumi.Input[str] lan_id: [string] The numeric LAN ID to connect your instance to.
        """
        pulumi.set(__self__, "broker_addresses", broker_addresses)
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "lan_id", lan_id)

    @property
    @pulumi.getter(name="brokerAddresses")
    def broker_addresses(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        [list] IP address and port of cluster brokers.
        """
        return pulumi.get(self, "broker_addresses")

    @broker_addresses.setter
    def broker_addresses(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "broker_addresses", value)

    @property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> pulumi.Input[str]:
        """
        [string] The datacenter to connect your instance to.
        """
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "datacenter_id", value)

    @property
    @pulumi.getter(name="lanId")
    def lan_id(self) -> pulumi.Input[str]:
        """
        [string] The numeric LAN ID to connect your instance to.
        """
        return pulumi.get(self, "lan_id")

    @lan_id.setter
    def lan_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "lan_id", value)


@pulumi.input_type
class LoggingPipelineLogArgs:
    def __init__(__self__, *,
                 protocol: pulumi.Input[str],
                 source: pulumi.Input[str],
                 tag: pulumi.Input[str],
                 destinations: Optional[pulumi.Input[Sequence[pulumi.Input['LoggingPipelineLogDestinationArgs']]]] = None,
                 public: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] protocol: [string] "Protocol to use as intake. Possible values are: http, tcp."
        :param pulumi.Input[str] source: [string] The source parser to be used.
        :param pulumi.Input[str] tag: [string] The tag is used to distinguish different pipelines. Must be unique amongst the pipeline's array items.
        :param pulumi.Input[Sequence[pulumi.Input['LoggingPipelineLogDestinationArgs']]] destinations: [list] The configuration of the logs datastore, a list that contains elements with the following structure:
        :param pulumi.Input[bool] public: [bool]
        """
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "tag", tag)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if public is not None:
            pulumi.set(__self__, "public", public)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        [string] "Protocol to use as intake. Possible values are: http, tcp."
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[str]:
        """
        [string] The source parser to be used.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def tag(self) -> pulumi.Input[str]:
        """
        [string] The tag is used to distinguish different pipelines. Must be unique amongst the pipeline's array items.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: pulumi.Input[str]):
        pulumi.set(self, "tag", value)

    @property
    @pulumi.getter
    def destinations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoggingPipelineLogDestinationArgs']]]]:
        """
        [list] The configuration of the logs datastore, a list that contains elements with the following structure:
        """
        return pulumi.get(self, "destinations")

    @destinations.setter
    def destinations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoggingPipelineLogDestinationArgs']]]]):
        pulumi.set(self, "destinations", value)

    @property
    @pulumi.getter
    def public(self) -> Optional[pulumi.Input[bool]]:
        """
        [bool]
        """
        return pulumi.get(self, "public")

    @public.setter
    def public(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "public", value)


@pulumi.input_type
class LoggingPipelineLogDestinationArgs:
    def __init__(__self__, *,
                 retention_in_days: Optional[pulumi.Input[int]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] retention_in_days: [int] Defines the number of days a log record should be kept in loki. Works with loki destination type only. Can be one of: 7, 14, 30.
        :param pulumi.Input[str] type: [string] The internal output stream to send logs to.
        """
        if retention_in_days is not None:
            pulumi.set(__self__, "retention_in_days", retention_in_days)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        [int] Defines the number of days a log record should be kept in loki. Works with loki destination type only. Can be one of: 7, 14, 30.
        """
        return pulumi.get(self, "retention_in_days")

    @retention_in_days.setter
    def retention_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retention_in_days", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The internal output stream to send logs to.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class NetworkloadbalancerFlowlogArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 bucket: pulumi.Input[str],
                 direction: pulumi.Input[str],
                 name: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: [string] Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL. Immutable, forces re-creation.
        :param pulumi.Input[str] bucket: [string] Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist. Immutable, forces re-creation.
        :param pulumi.Input[str] direction: [string] Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, forces re-creation.
        :param pulumi.Input[str] name: [string] Specifies the name of the flow log.
               
               ⚠️ **Note:**: Removing the `flowlog` forces re-creation of the network load balancer resource.
        :param pulumi.Input[str] id: The resource's unique identifier.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "name", name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        [string] Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL. Immutable, forces re-creation.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        [string] Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist. Immutable, forces re-creation.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def direction(self) -> pulumi.Input[str]:
        """
        [string] Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, forces re-creation.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: pulumi.Input[str]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        [string] Specifies the name of the flow log.

        ⚠️ **Note:**: Removing the `flowlog` forces re-creation of the network load balancer resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The resource's unique identifier.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class NetworkloadbalancerForwardingruleHealthCheckArgs:
    def __init__(__self__, *,
                 client_timeout: Optional[pulumi.Input[int]] = None,
                 connect_timeout: Optional[pulumi.Input[int]] = None,
                 retries: Optional[pulumi.Input[int]] = None,
                 target_timeout: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] client_timeout: [int] ClientTimeout is expressed in milliseconds. This inactivity timeout applies when the client is expected to acknowledge or send data. If unset the default of 50 seconds will be used.
        :param pulumi.Input[int] connect_timeout: [int] It specifies the maximum time (in milliseconds) to wait for a connection attempt to a target VM to succeed. If unset, the default of 5 seconds will be used.
        :param pulumi.Input[int] retries: [int] Retries specifies the number of retries to perform on a target VM after a connection failure. If unset, the default value of 3 will be used.
        :param pulumi.Input[int] target_timeout: [int] TargetTimeout specifies the maximum inactivity time (in milliseconds) on the target VM side. If unset, the default of 50 seconds will be used.
        """
        if client_timeout is not None:
            pulumi.set(__self__, "client_timeout", client_timeout)
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if retries is not None:
            pulumi.set(__self__, "retries", retries)
        if target_timeout is not None:
            pulumi.set(__self__, "target_timeout", target_timeout)

    @property
    @pulumi.getter(name="clientTimeout")
    def client_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        [int] ClientTimeout is expressed in milliseconds. This inactivity timeout applies when the client is expected to acknowledge or send data. If unset the default of 50 seconds will be used.
        """
        return pulumi.get(self, "client_timeout")

    @client_timeout.setter
    def client_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "client_timeout", value)

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        [int] It specifies the maximum time (in milliseconds) to wait for a connection attempt to a target VM to succeed. If unset, the default of 5 seconds will be used.
        """
        return pulumi.get(self, "connect_timeout")

    @connect_timeout.setter
    def connect_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "connect_timeout", value)

    @property
    @pulumi.getter
    def retries(self) -> Optional[pulumi.Input[int]]:
        """
        [int] Retries specifies the number of retries to perform on a target VM after a connection failure. If unset, the default value of 3 will be used.
        """
        return pulumi.get(self, "retries")

    @retries.setter
    def retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retries", value)

    @property
    @pulumi.getter(name="targetTimeout")
    def target_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        [int] TargetTimeout specifies the maximum inactivity time (in milliseconds) on the target VM side. If unset, the default of 50 seconds will be used.
        """
        return pulumi.get(self, "target_timeout")

    @target_timeout.setter
    def target_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "target_timeout", value)


@pulumi.input_type
class NetworkloadbalancerForwardingruleTargetArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[str],
                 port: pulumi.Input[int],
                 weight: pulumi.Input[int],
                 health_check: Optional[pulumi.Input['NetworkloadbalancerForwardingruleTargetHealthCheckArgs']] = None,
                 proxy_protocol: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ip: [string] IP of a balanced target VM.
        :param pulumi.Input[int] port: [int] Port of the balanced target service. (range: 1 to 65535).
        :param pulumi.Input[int] weight: [int] Weight parameter is used to adjust the target VM's weight relative to other target VMs.
        :param pulumi.Input['NetworkloadbalancerForwardingruleTargetHealthCheckArgs'] health_check: Health check attributes for Network Load Balancer forwarding rule target.
        :param pulumi.Input[str] proxy_protocol: [string] The proxy protocol version. Accepted values are `none`, `v1`, `v2`, `v2ssl`. If unspecified, the default value of `none` is used.
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "weight", weight)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if proxy_protocol is not None:
            pulumi.set(__self__, "proxy_protocol", proxy_protocol)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        [string] IP of a balanced target VM.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        [int] Port of the balanced target service. (range: 1 to 65535).
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def weight(self) -> pulumi.Input[int]:
        """
        [int] Weight parameter is used to adjust the target VM's weight relative to other target VMs.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[int]):
        pulumi.set(self, "weight", value)

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional[pulumi.Input['NetworkloadbalancerForwardingruleTargetHealthCheckArgs']]:
        """
        Health check attributes for Network Load Balancer forwarding rule target.
        """
        return pulumi.get(self, "health_check")

    @health_check.setter
    def health_check(self, value: Optional[pulumi.Input['NetworkloadbalancerForwardingruleTargetHealthCheckArgs']]):
        pulumi.set(self, "health_check", value)

    @property
    @pulumi.getter(name="proxyProtocol")
    def proxy_protocol(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The proxy protocol version. Accepted values are `none`, `v1`, `v2`, `v2ssl`. If unspecified, the default value of `none` is used.
        """
        return pulumi.get(self, "proxy_protocol")

    @proxy_protocol.setter
    def proxy_protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy_protocol", value)


@pulumi.input_type
class NetworkloadbalancerForwardingruleTargetHealthCheckArgs:
    def __init__(__self__, *,
                 check: Optional[pulumi.Input[bool]] = None,
                 check_interval: Optional[pulumi.Input[int]] = None,
                 maintenance: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] check: [boolean] Check specifies whether the target VM's health is checked.
        :param pulumi.Input[int] check_interval: [int] CheckInterval determines the duration (in milliseconds) between consecutive health checks. If unspecified a default of 2000 ms is used.
        :param pulumi.Input[bool] maintenance: [boolean] Maintenance specifies if a target VM should be marked as down, even if it is not.
        """
        if check is not None:
            pulumi.set(__self__, "check", check)
        if check_interval is not None:
            pulumi.set(__self__, "check_interval", check_interval)
        if maintenance is not None:
            pulumi.set(__self__, "maintenance", maintenance)

    @property
    @pulumi.getter
    def check(self) -> Optional[pulumi.Input[bool]]:
        """
        [boolean] Check specifies whether the target VM's health is checked.
        """
        return pulumi.get(self, "check")

    @check.setter
    def check(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "check", value)

    @property
    @pulumi.getter(name="checkInterval")
    def check_interval(self) -> Optional[pulumi.Input[int]]:
        """
        [int] CheckInterval determines the duration (in milliseconds) between consecutive health checks. If unspecified a default of 2000 ms is used.
        """
        return pulumi.get(self, "check_interval")

    @check_interval.setter
    def check_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "check_interval", value)

    @property
    @pulumi.getter
    def maintenance(self) -> Optional[pulumi.Input[bool]]:
        """
        [boolean] Maintenance specifies if a target VM should be marked as down, even if it is not.
        """
        return pulumi.get(self, "maintenance")

    @maintenance.setter
    def maintenance(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "maintenance", value)


@pulumi.input_type
class TargetGroupHealthCheckArgs:
    def __init__(__self__, *,
                 check_interval: Optional[pulumi.Input[int]] = None,
                 check_timeout: Optional[pulumi.Input[int]] = None,
                 retries: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] check_interval: [int] The interval in milliseconds between consecutive health checks; default is 2000.
        :param pulumi.Input[int] check_timeout: [int] The maximum time in milliseconds to wait for a target to respond to a check. For target VMs with 'Check Interval' set, the lesser of the two  values is used once the TCP connection is established.
        :param pulumi.Input[int] retries: [int] The maximum number of attempts to reconnect to a target after a connection failure. Valid range is 0 to 65535, and default is three reconnection.
        """
        if check_interval is not None:
            pulumi.set(__self__, "check_interval", check_interval)
        if check_timeout is not None:
            pulumi.set(__self__, "check_timeout", check_timeout)
        if retries is not None:
            pulumi.set(__self__, "retries", retries)

    @property
    @pulumi.getter(name="checkInterval")
    def check_interval(self) -> Optional[pulumi.Input[int]]:
        """
        [int] The interval in milliseconds between consecutive health checks; default is 2000.
        """
        return pulumi.get(self, "check_interval")

    @check_interval.setter
    def check_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "check_interval", value)

    @property
    @pulumi.getter(name="checkTimeout")
    def check_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        [int] The maximum time in milliseconds to wait for a target to respond to a check. For target VMs with 'Check Interval' set, the lesser of the two  values is used once the TCP connection is established.
        """
        return pulumi.get(self, "check_timeout")

    @check_timeout.setter
    def check_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "check_timeout", value)

    @property
    @pulumi.getter
    def retries(self) -> Optional[pulumi.Input[int]]:
        """
        [int] The maximum number of attempts to reconnect to a target after a connection failure. Valid range is 0 to 65535, and default is three reconnection.
        """
        return pulumi.get(self, "retries")

    @retries.setter
    def retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retries", value)


@pulumi.input_type
class TargetGroupHttpHealthCheckArgs:
    def __init__(__self__, *,
                 match_type: pulumi.Input[str],
                 response: pulumi.Input[str],
                 method: Optional[pulumi.Input[str]] = None,
                 negate: Optional[pulumi.Input[bool]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 regex: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] match_type: [string]
        :param pulumi.Input[str] response: [string] The response returned by the request, depending on the match type.
        :param pulumi.Input[str] method: [string] The method for the HTTP health check.
        :param pulumi.Input[bool] negate: [bool]
        :param pulumi.Input[str] path: [string] The path (destination URL) for the HTTP health check request; the default is /.
        :param pulumi.Input[bool] regex: [bool]
        """
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "response", response)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> pulumi.Input[str]:
        """
        [string]
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_type", value)

    @property
    @pulumi.getter
    def response(self) -> pulumi.Input[str]:
        """
        [string] The response returned by the request, depending on the match type.
        """
        return pulumi.get(self, "response")

    @response.setter
    def response(self, value: pulumi.Input[str]):
        pulumi.set(self, "response", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The method for the HTTP health check.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def negate(self) -> Optional[pulumi.Input[bool]]:
        """
        [bool]
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The path (destination URL) for the HTTP health check request; the default is /.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[bool]]:
        """
        [bool]
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class TargetGroupTargetArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[str],
                 port: pulumi.Input[int],
                 weight: pulumi.Input[int],
                 health_check_enabled: Optional[pulumi.Input[bool]] = None,
                 maintenance_enabled: Optional[pulumi.Input[bool]] = None,
                 proxy_protocol: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ip: [string] The IP of the balanced target VM.
        :param pulumi.Input[int] port: [int] The port of the balanced target service; valid range is 1 to 65535.
        :param pulumi.Input[int] weight: [int] Traffic is distributed in proportion to target weight, relative to the combined weight of all targets. A target with higher weight receives a greater share of traffic. Valid range is 0 to 256 and default is 1; targets with weight of 0 do not participate in load balancing but still accept persistent connections. It is best use values in the middle of the range to leave room for later adjustments.
        :param pulumi.Input[bool] health_check_enabled: [bool] Makes the target available only if it accepts periodic health check TCP connection attempts; when turned off, the target is considered always available. The health check only consists of a connection attempt to the address and port of the target. Default is True.
        :param pulumi.Input[bool] maintenance_enabled: [bool] Maintenance mode prevents the target from receiving balanced traffic.
        :param pulumi.Input[str] proxy_protocol: [string] The proxy protocol version. Accepted values are `none`, `v1`, `v2`, `v2ssl`. If unspecified, the default value of `none` is used.
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "weight", weight)
        if health_check_enabled is not None:
            pulumi.set(__self__, "health_check_enabled", health_check_enabled)
        if maintenance_enabled is not None:
            pulumi.set(__self__, "maintenance_enabled", maintenance_enabled)
        if proxy_protocol is not None:
            pulumi.set(__self__, "proxy_protocol", proxy_protocol)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        [string] The IP of the balanced target VM.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        [int] The port of the balanced target service; valid range is 1 to 65535.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def weight(self) -> pulumi.Input[int]:
        """
        [int] Traffic is distributed in proportion to target weight, relative to the combined weight of all targets. A target with higher weight receives a greater share of traffic. Valid range is 0 to 256 and default is 1; targets with weight of 0 do not participate in load balancing but still accept persistent connections. It is best use values in the middle of the range to leave room for later adjustments.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[int]):
        pulumi.set(self, "weight", value)

    @property
    @pulumi.getter(name="healthCheckEnabled")
    def health_check_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        [bool] Makes the target available only if it accepts periodic health check TCP connection attempts; when turned off, the target is considered always available. The health check only consists of a connection attempt to the address and port of the target. Default is True.
        """
        return pulumi.get(self, "health_check_enabled")

    @health_check_enabled.setter
    def health_check_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "health_check_enabled", value)

    @property
    @pulumi.getter(name="maintenanceEnabled")
    def maintenance_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        [bool] Maintenance mode prevents the target from receiving balanced traffic.
        """
        return pulumi.get(self, "maintenance_enabled")

    @maintenance_enabled.setter
    def maintenance_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "maintenance_enabled", value)

    @property
    @pulumi.getter(name="proxyProtocol")
    def proxy_protocol(self) -> Optional[pulumi.Input[str]]:
        """
        [string] The proxy protocol version. Accepted values are `none`, `v1`, `v2`, `v2ssl`. If unspecified, the default value of `none` is used.
        """
        return pulumi.get(self, "proxy_protocol")

    @proxy_protocol.setter
    def proxy_protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy_protocol", value)


@pulumi.input_type
class GetIpblockIpConsumerArgs:
    def __init__(__self__, *,
                 datacenter_id: str,
                 datacenter_name: str,
                 ip: str,
                 k8s_cluster_uuid: str,
                 k8s_nodepool_uuid: str,
                 mac: str,
                 nic_id: str,
                 server_id: str,
                 server_name: str):
        pulumi.set(__self__, "datacenter_id", datacenter_id)
        pulumi.set(__self__, "datacenter_name", datacenter_name)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "k8s_cluster_uuid", k8s_cluster_uuid)
        pulumi.set(__self__, "k8s_nodepool_uuid", k8s_nodepool_uuid)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "nic_id", nic_id)
        pulumi.set(__self__, "server_id", server_id)
        pulumi.set(__self__, "server_name", server_name)

    @property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> str:
        return pulumi.get(self, "datacenter_id")

    @datacenter_id.setter
    def datacenter_id(self, value: str):
        pulumi.set(self, "datacenter_id", value)

    @property
    @pulumi.getter(name="datacenterName")
    def datacenter_name(self) -> str:
        return pulumi.get(self, "datacenter_name")

    @datacenter_name.setter
    def datacenter_name(self, value: str):
        pulumi.set(self, "datacenter_name", value)

    @property
    @pulumi.getter
    def ip(self) -> str:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: str):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="k8sClusterUuid")
    def k8s_cluster_uuid(self) -> str:
        return pulumi.get(self, "k8s_cluster_uuid")

    @k8s_cluster_uuid.setter
    def k8s_cluster_uuid(self, value: str):
        pulumi.set(self, "k8s_cluster_uuid", value)

    @property
    @pulumi.getter(name="k8sNodepoolUuid")
    def k8s_nodepool_uuid(self) -> str:
        return pulumi.get(self, "k8s_nodepool_uuid")

    @k8s_nodepool_uuid.setter
    def k8s_nodepool_uuid(self, value: str):
        pulumi.set(self, "k8s_nodepool_uuid", value)

    @property
    @pulumi.getter
    def mac(self) -> str:
        return pulumi.get(self, "mac")

    @mac.setter
    def mac(self, value: str):
        pulumi.set(self, "mac", value)

    @property
    @pulumi.getter(name="nicId")
    def nic_id(self) -> str:
        return pulumi.get(self, "nic_id")

    @nic_id.setter
    def nic_id(self, value: str):
        pulumi.set(self, "nic_id", value)

    @property
    @pulumi.getter(name="serverId")
    def server_id(self) -> str:
        return pulumi.get(self, "server_id")

    @server_id.setter
    def server_id(self, value: str):
        pulumi.set(self, "server_id", value)

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> str:
        return pulumi.get(self, "server_name")

    @server_name.setter
    def server_name(self, value: str):
        pulumi.set(self, "server_name", value)


@pulumi.input_type
class GetK8sClustersFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 value: str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


@pulumi.input_type
class GetMongoUserRoleArgs:
    def __init__(__self__, *,
                 database: str,
                 role: str):
        """
        :param str role: A list of mongodb user roles. Examples: read, readWrite, readAnyDatabase
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def database(self) -> str:
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: str):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        A list of mongodb user roles. Examples: read, readWrite, readAnyDatabase
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: str):
        pulumi.set(self, "role", value)


@pulumi.input_type
class GetNfsShareClientGroupArgs:
    def __init__(__self__, *,
                 description: str,
                 hosts: Sequence[str],
                 ip_networks: Sequence[str],
                 nfs: Sequence['GetNfsShareClientGroupNfArgs']):
        """
        :param str description: Optional description for the clients groups.
        :param Sequence[str] hosts: A singular host allowed to connect to the share. The host can be specified as IP address and can be either IPv4 or IPv6.
        :param Sequence[str] ip_networks: The allowed host or network to which the export is being shared. The IP address can be either IPv4 or IPv6 and has to be given with CIDR notation.
        :param Sequence['GetNfsShareClientGroupNfArgs'] nfs: The NFS configuration for the client group. Each NFS configuration supports the following:
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "hosts", hosts)
        pulumi.set(__self__, "ip_networks", ip_networks)
        pulumi.set(__self__, "nfs", nfs)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Optional description for the clients groups.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: str):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def hosts(self) -> Sequence[str]:
        """
        A singular host allowed to connect to the share. The host can be specified as IP address and can be either IPv4 or IPv6.
        """
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: Sequence[str]):
        pulumi.set(self, "hosts", value)

    @property
    @pulumi.getter(name="ipNetworks")
    def ip_networks(self) -> Sequence[str]:
        """
        The allowed host or network to which the export is being shared. The IP address can be either IPv4 or IPv6 and has to be given with CIDR notation.
        """
        return pulumi.get(self, "ip_networks")

    @ip_networks.setter
    def ip_networks(self, value: Sequence[str]):
        pulumi.set(self, "ip_networks", value)

    @property
    @pulumi.getter
    def nfs(self) -> Sequence['GetNfsShareClientGroupNfArgs']:
        """
        The NFS configuration for the client group. Each NFS configuration supports the following:
        """
        return pulumi.get(self, "nfs")

    @nfs.setter
    def nfs(self, value: Sequence['GetNfsShareClientGroupNfArgs']):
        pulumi.set(self, "nfs", value)


@pulumi.input_type
class GetNfsShareClientGroupNfArgs:
    def __init__(__self__, *,
                 squash: str):
        """
        :param str squash: The squash mode for the export. The squash mode can be: none - No squash mode. no mapping, root-anonymous - Map root user to anonymous uid, all-anonymous - Map all users to anonymous uid.
        """
        pulumi.set(__self__, "squash", squash)

    @property
    @pulumi.getter
    def squash(self) -> str:
        """
        The squash mode for the export. The squash mode can be: none - No squash mode. no mapping, root-anonymous - Map root user to anonymous uid, all-anonymous - Map all users to anonymous uid.
        """
        return pulumi.get(self, "squash")

    @squash.setter
    def squash(self, value: str):
        pulumi.set(self, "squash", value)


@pulumi.input_type
class GetServersFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 value: str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


