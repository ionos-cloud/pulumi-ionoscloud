// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;
using Pulumi;

namespace Ionoscloud.Pulumi.Ionoscloud.Compute
{
    /// <summary>
    /// Manages a **Cross Connect** on IonosCloud.
    /// Cross Connect allows you to connect virtual data centers (VDC) with each other using a private LAN.
    /// The VDCs to be connected need to belong to the same IONOS Cloud contract and location.
    /// You can only use private LANs for a Cross Connect connection. A LAN can only be a part of one Cross Connect.
    /// 
    /// The IP addresses of the NICs used for the Cross Connect connection may not be used in more than one NIC and they need to belong to the same IP range.
    /// 
    /// ## Example Usage
    /// 
    /// To connect two datacenters we need 2 lans defined, one in each datacenter. After, we reference the cross-connect through which we want the connection to be established.
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Ionoscloud = Ionoscloud.Pulumi.Ionoscloud;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var crossConnectTestResource = new Ionoscloud.Compute.Crossconnect("CrossConnectTestResource", new()
    ///     {
    ///         Name = "CrossConnectTestResource",
    ///         Description = "CrossConnectTestResource",
    ///     });
    /// 
    ///     var dc1 = new Ionoscloud.Compute.Datacenter("dc1", new()
    ///     {
    ///         Location = "de/txl",
    ///         Name = "dc1",
    ///     });
    /// 
    ///     var dc2 = new Ionoscloud.Compute.Datacenter("dc2", new()
    ///     {
    ///         Location = "de/txl",
    ///         Name = "dc2",
    ///     });
    /// 
    ///     var dc1lan = new Ionoscloud.Compute.Lan("dc1lan", new()
    ///     {
    ///         DatacenterId = dc1.Id,
    ///         Public = false,
    ///         Name = "dc1lan",
    ///         Pcc = crossConnectTestResource.Id,
    ///     });
    /// 
    ///     var dc2lan = new Ionoscloud.Compute.Lan("dc2lan", new()
    ///     {
    ///         DatacenterId = dc2.Id,
    ///         Public = false,
    ///         Name = "dc2lan",
    ///         Pcc = crossConnectTestResource.Id,
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Import
    /// 
    /// A Cross Connect resource can be imported using its `resource id`, e.g.
    /// 
    /// ```sh
    /// $ pulumi import ionoscloud:compute/crossconnect:Crossconnect demo ionoscloud_private_crossconnect_uuid
    /// ```
    /// 
    /// This can be helpful when you want to import cross-connects which you have already created manually or using other means, outside of pulumi.
    /// </summary>
    [IonoscloudResourceType("ionoscloud:compute/crossconnect:Crossconnect")]
    public partial class Crossconnect : global::Pulumi.CustomResource
    {
        /// <summary>
        /// A list containing all the connectable datacenters
        /// </summary>
        [Output("connectableDatacenters")]
        public Output<ImmutableArray<Outputs.CrossconnectConnectableDatacenter>> ConnectableDatacenters { get; private set; } = null!;

        /// <summary>
        /// [string] A short description for the cross-connection.
        /// - `connectable datacenters` - (Computed) A list containing all the connectable datacenters
        /// </summary>
        [Output("description")]
        public Output<string?> Description { get; private set; } = null!;

        /// <summary>
        /// [string] The name of the cross-connection.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// Lists LAN's joined to this cross connect
        /// </summary>
        [Output("peers")]
        public Output<ImmutableArray<Outputs.CrossconnectPeer>> Peers { get; private set; } = null!;


        /// <summary>
        /// Create a Crossconnect resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Crossconnect(string name, CrossconnectArgs? args = null, CustomResourceOptions? options = null)
            : base("ionoscloud:compute/crossconnect:Crossconnect", name, args ?? new CrossconnectArgs(), MakeResourceOptions(options, ""))
        {
        }

        private Crossconnect(string name, Input<string> id, CrossconnectState? state = null, CustomResourceOptions? options = null)
            : base("ionoscloud:compute/crossconnect:Crossconnect", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing Crossconnect resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static Crossconnect Get(string name, Input<string> id, CrossconnectState? state = null, CustomResourceOptions? options = null)
        {
            return new Crossconnect(name, id, state, options);
        }
    }

    public sealed class CrossconnectArgs : global::Pulumi.ResourceArgs
    {
        [Input("connectableDatacenters")]
        private InputList<Inputs.CrossconnectConnectableDatacenterArgs>? _connectableDatacenters;

        /// <summary>
        /// A list containing all the connectable datacenters
        /// </summary>
        public InputList<Inputs.CrossconnectConnectableDatacenterArgs> ConnectableDatacenters
        {
            get => _connectableDatacenters ?? (_connectableDatacenters = new InputList<Inputs.CrossconnectConnectableDatacenterArgs>());
            set => _connectableDatacenters = value;
        }

        /// <summary>
        /// [string] A short description for the cross-connection.
        /// - `connectable datacenters` - (Computed) A list containing all the connectable datacenters
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// [string] The name of the cross-connection.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("peers")]
        private InputList<Inputs.CrossconnectPeerArgs>? _peers;

        /// <summary>
        /// Lists LAN's joined to this cross connect
        /// </summary>
        public InputList<Inputs.CrossconnectPeerArgs> Peers
        {
            get => _peers ?? (_peers = new InputList<Inputs.CrossconnectPeerArgs>());
            set => _peers = value;
        }

        public CrossconnectArgs()
        {
        }
        public static new CrossconnectArgs Empty => new CrossconnectArgs();
    }

    public sealed class CrossconnectState : global::Pulumi.ResourceArgs
    {
        [Input("connectableDatacenters")]
        private InputList<Inputs.CrossconnectConnectableDatacenterGetArgs>? _connectableDatacenters;

        /// <summary>
        /// A list containing all the connectable datacenters
        /// </summary>
        public InputList<Inputs.CrossconnectConnectableDatacenterGetArgs> ConnectableDatacenters
        {
            get => _connectableDatacenters ?? (_connectableDatacenters = new InputList<Inputs.CrossconnectConnectableDatacenterGetArgs>());
            set => _connectableDatacenters = value;
        }

        /// <summary>
        /// [string] A short description for the cross-connection.
        /// - `connectable datacenters` - (Computed) A list containing all the connectable datacenters
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// [string] The name of the cross-connection.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("peers")]
        private InputList<Inputs.CrossconnectPeerGetArgs>? _peers;

        /// <summary>
        /// Lists LAN's joined to this cross connect
        /// </summary>
        public InputList<Inputs.CrossconnectPeerGetArgs> Peers
        {
            get => _peers ?? (_peers = new InputList<Inputs.CrossconnectPeerGetArgs>());
            set => _peers = value;
        }

        public CrossconnectState()
        {
        }
        public static new CrossconnectState Empty => new CrossconnectState();
    }
}
