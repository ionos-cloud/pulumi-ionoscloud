// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;
using Pulumi;

namespace Ionoscloud.Pulumi.Ionoscloud.Compute
{
    /// <summary>
    /// Manages a **NIC** on IonosCloud.
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Ionoscloud = Pulumi.Ionoscloud;
    /// using Random = Pulumi.Random;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var example = new Ionoscloud.Compute.Datacenter("example", new()
    ///     {
    ///         Name = "Datacenter Example",
    ///         Location = "us/las",
    ///         Description = "Datacenter Description",
    ///         SecAuthProtection = false,
    ///     });
    /// 
    ///     var exampleIPBlock = new Ionoscloud.Compute.IPBlock("example", new()
    ///     {
    ///         Location = example.Location,
    ///         Size = 2,
    ///         Name = "IP Block Example",
    ///     });
    /// 
    ///     var exampleLan = new Ionoscloud.Compute.Lan("example", new()
    ///     {
    ///         DatacenterId = example.Id,
    ///         Public = true,
    ///         Name = "Lan",
    ///     });
    /// 
    ///     var serverImagePassword = new Random.Index.Password("server_image_password", new()
    ///     {
    ///         Length = 16,
    ///         Special = false,
    ///     });
    /// 
    ///     var exampleServer = new Ionoscloud.Compute.Server("example", new()
    ///     {
    ///         Name = "Server Example",
    ///         DatacenterId = example.Id,
    ///         Cores = 1,
    ///         Ram = 1024,
    ///         AvailabilityZone = "ZONE_1",
    ///         CpuFamily = "INTEL_XEON",
    ///         ImageName = "Ubuntu-20.04",
    ///         ImagePassword = serverImagePassword.Result,
    ///         Volume = new Ionoscloud.Compute.Inputs.ServerVolumeArgs
    ///         {
    ///             Name = "system",
    ///             Size = 14,
    ///             DiskType = "SSD",
    ///         },
    ///         Nic = new Ionoscloud.Compute.Inputs.ServerNicArgs
    ///         {
    ///             Lan = 1,
    ///             Dhcp = true,
    ///             FirewallActive = true,
    ///         },
    ///     });
    /// 
    ///     var exampleNic = new Ionoscloud.Compute.Nic("example", new()
    ///     {
    ///         DatacenterId = example.Id,
    ///         ServerId = exampleServer.Id,
    ///         Lan = exampleLan.Id,
    ///         Name = "NIC",
    ///         Dhcp = true,
    ///         FirewallActive = true,
    ///         FirewallType = "INGRESS",
    ///         Ips = new[]
    ///         {
    ///             exampleIPBlock.Ips.Apply(ips =&gt; ips[0]),
    ///             exampleIPBlock.Ips.Apply(ips =&gt; ips[1]),
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ### With IPv6
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Ionoscloud = Pulumi.Ionoscloud;
    /// using Random = Pulumi.Random;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var example = new Ionoscloud.Compute.Datacenter("example", new()
    ///     {
    ///         Name = "Datacenter Example",
    ///         Location = "us/las",
    ///         Description = "Datacenter Description",
    ///         SecAuthProtection = false,
    ///     });
    /// 
    ///     var exampleLan = new Ionoscloud.Compute.Lan("example", new()
    ///     {
    ///         DatacenterId = example.Id,
    ///         Public = true,
    ///         Name = "IPv6 Enabled LAN",
    ///         Ipv6CidrBlock = "ipv6_cidr_block_from_dc",
    ///     });
    /// 
    ///     var serverImagePassword = new Random.Index.Password("server_image_password", new()
    ///     {
    ///         Length = 16,
    ///         Special = false,
    ///     });
    /// 
    ///     var exampleServer = new Ionoscloud.Compute.Server("example", new()
    ///     {
    ///         Name = "Server Example",
    ///         DatacenterId = example.Id,
    ///         Cores = 1,
    ///         Ram = 1024,
    ///         AvailabilityZone = "ZONE_1",
    ///         CpuFamily = "INTEL_XEON",
    ///         ImageName = "Ubuntu-20.04",
    ///         ImagePassword = serverImagePassword.Result,
    ///         Volume = new Ionoscloud.Compute.Inputs.ServerVolumeArgs
    ///         {
    ///             Name = "system",
    ///             Size = 14,
    ///             DiskType = "SSD",
    ///         },
    ///         Nic = new Ionoscloud.Compute.Inputs.ServerNicArgs
    ///         {
    ///             Lan = 1,
    ///             Dhcp = true,
    ///             FirewallActive = true,
    ///         },
    ///     });
    /// 
    ///     var exampleNic = new Ionoscloud.Compute.Nic("example", new()
    ///     {
    ///         DatacenterId = example.Id,
    ///         ServerId = exampleServer.Id,
    ///         Lan = exampleLan.Id,
    ///         Name = "IPv6 Enabled NIC",
    ///         Dhcp = true,
    ///         FirewallActive = true,
    ///         FirewallType = "INGRESS",
    ///         Dhcpv6 = false,
    ///         Ipv6CidrBlock = "ipv6_cidr_block_from_lan",
    ///         Ipv6Ips = new[]
    ///         {
    ///             "ipv6_ip1",
    ///             "ipv6_ip2",
    ///             "ipv6_ip3",
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// ## Example configuring Flowlog
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Ionoscloud = Pulumi.Ionoscloud;
    /// using Random = Pulumi.Random;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var example = new Ionoscloud.Compute.Datacenter("example", new()
    ///     {
    ///         Name = "Datacenter Example",
    ///         Location = "us/las",
    ///         Description = "Datacenter Description",
    ///         SecAuthProtection = false,
    ///     });
    /// 
    ///     var exampleLan = new Ionoscloud.Compute.Lan("example", new()
    ///     {
    ///         DatacenterId = example.Id,
    ///         Public = true,
    ///         Name = "IPv6 Enabled LAN",
    ///         Ipv6CidrBlock = "ipv6_cidr_block_from_dc",
    ///     });
    /// 
    ///     var serverImagePassword = new Random.Index.Password("server_image_password", new()
    ///     {
    ///         Length = 16,
    ///         Special = false,
    ///     });
    /// 
    ///     var exampleServer = new Ionoscloud.Compute.Server("example", new()
    ///     {
    ///         Name = "Server Example",
    ///         DatacenterId = example.Id,
    ///         Cores = 1,
    ///         Ram = 1024,
    ///         AvailabilityZone = "ZONE_1",
    ///         CpuFamily = "INTEL_XEON",
    ///         ImageName = "Ubuntu-20.04",
    ///         ImagePassword = serverImagePassword.Result,
    ///         Volume = new Ionoscloud.Compute.Inputs.ServerVolumeArgs
    ///         {
    ///             Name = "system",
    ///             Size = 14,
    ///             DiskType = "SSD",
    ///         },
    ///         Nic = new Ionoscloud.Compute.Inputs.ServerNicArgs
    ///         {
    ///             Lan = 1,
    ///             Dhcp = true,
    ///             FirewallActive = true,
    ///         },
    ///     });
    /// 
    ///     var exampleNic = new Ionoscloud.Compute.Nic("example", new()
    ///     {
    ///         DatacenterId = example.Id,
    ///         ServerId = exampleServer.Id,
    ///         Lan = exampleLan.Id,
    ///         Name = "IPV6 and Flowlog Enabled NIC",
    ///         Dhcp = true,
    ///         FirewallActive = true,
    ///         FirewallType = "INGRESS",
    ///         Dhcpv6 = false,
    ///         Ipv6CidrBlock = "ipv6_cidr_block_from_lan",
    ///         Ipv6Ips = new[]
    ///         {
    ///             "ipv6_ip1",
    ///             "ipv6_ip2",
    ///             "ipv6_ip3",
    ///         },
    ///         Flowlog = new Ionoscloud.Compute.Inputs.NicFlowlogArgs
    ///         {
    ///             Action = "ACCEPTED",
    ///             Bucket = "flowlog-bucket",
    ///             Direction = "INGRESS",
    ///             Name = "flowlog",
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// This will configure flowlog for accepted ingress traffic and will log it into an existing IONOS Object Storage bucket named `flowlog-bucket`. Any s3 compatible client can be used to create it. Adding a flowlog does not force re-creation of the NIC, but changing any other field than
    /// `name` will. Deleting a flowlog will also force NIC re-creation.
    /// 
    /// ## Working with load balancers
    /// 
    /// Please be aware that when using a NIC in a load balancer, the load balancer will
    /// change the NIC's ID behind the scenes, therefore the plan will always report this change
    /// trying to revert the state to the one specified by your file.
    /// In order to prevent this, use the "lifecycle meta-argument" when declaring your NIC,
    /// in order to ignore changes to the `lan` attribute:
    /// 
    /// Here's an example:
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Ionoscloud = Pulumi.Ionoscloud;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var example = new Ionoscloud.Compute.Nic("example", new()
    ///     {
    ///         DatacenterId = foobar.Id,
    ///         ServerId = exampleIonoscloudServer.Id,
    ///         Lan = 2,
    ///         Dhcp = true,
    ///         FirewallActive = true,
    ///         Name = "updated",
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Import
    /// 
    /// Resource **Nic** can be imported using the `resource id`, e.g.
    /// 
    /// ```sh
    /// $ pulumi import ionoscloud:compute/nic:Nic mynic datacenter uuid/server uuid/nic uuid
    /// ```
    /// </summary>
    [IonoscloudResourceType("ionoscloud:compute/nic:Nic")]
    public partial class Nic : global::Pulumi.CustomResource
    {
        /// <summary>
        /// [string] The ID of a Virtual Data Center.
        /// </summary>
        [Output("datacenterId")]
        public Output<string> DatacenterId { get; private set; } = null!;

        /// <summary>
        /// The Logical Unit Number (LUN) of the storage volume. Null if this NIC was created from CloudAPI and no DCD changes were done on the Datacenter.
        /// </summary>
        [Output("deviceNumber")]
        public Output<int> DeviceNumber { get; private set; } = null!;

        /// <summary>
        /// [Boolean] Indicates if the NIC should get an IP address using DHCP (true) or not (false).
        /// </summary>
        [Output("dhcp")]
        public Output<bool?> Dhcp { get; private set; } = null!;

        /// <summary>
        /// [Boolean] Indicates if the NIC should get an IPv6 address using DHCP (true) or not (false).
        /// </summary>
        [Output("dhcpv6")]
        public Output<bool?> Dhcpv6 { get; private set; } = null!;

        /// <summary>
        /// [Boolean] If this resource is set to true and is nested under a server resource firewall, with open SSH port, resource must be nested under the NIC.
        /// </summary>
        [Output("firewallActive")]
        public Output<bool?> FirewallActive { get; private set; } = null!;

        /// <summary>
        /// [String] The type of firewall rules that will be allowed on the NIC. If it is not specified it will take the default value INGRESS
        /// </summary>
        [Output("firewallType")]
        public Output<string> FirewallType { get; private set; } = null!;

        /// <summary>
        /// Only 1 flow log can be configured. Only the name field can change as part of an update. Flow logs holistically capture network information such as source and destination IP addresses, source and destination ports, number of packets, amount of bytes, the start and end time of the recording, and the type of protocol – and log the extent to which your instances are being accessed.
        /// </summary>
        [Output("flowlog")]
        public Output<Outputs.NicFlowlog?> Flowlog { get; private set; } = null!;

        /// <summary>
        /// [list] Collection of IP addresses assigned to a NIC. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.
        /// </summary>
        [Output("ips")]
        public Output<ImmutableArray<string>> Ips { get; private set; } = null!;

        /// <summary>
        /// Automatically assigned /80 IPv6 CIDR block if the NIC is connected to an IPv6 enabled LAN. You can also specify an /80 IPv6 CIDR block for the NIC on your own, which must be inside the /64 IPv6 CIDR block of the LAN and unique.
        /// </summary>
        [Output("ipv6CidrBlock")]
        public Output<string> Ipv6CidrBlock { get; private set; } = null!;

        /// <summary>
        /// [list] Collection of IPv6 addresses assigned to a NIC. Explicitly assigned public IPs need to come from the NIC's Ipv6 CIDR block, Passing value null or empty array will assign an IPv6 address automatically from the NIC's CIDR block.
        /// </summary>
        [Output("ipv6Ips")]
        public Output<ImmutableArray<string>> Ipv6Ips { get; private set; } = null!;

        /// <summary>
        /// [integer] The LAN ID the NIC will sit on.
        /// </summary>
        [Output("lan")]
        public Output<int> Lan { get; private set; } = null!;

        /// <summary>
        /// The MAC address of the NIC. Can be set on creation only. If not set, one will be assigned automatically by the API. Immutable, update forces re-creation.
        /// </summary>
        [Output("mac")]
        public Output<string> Mac { get; private set; } = null!;

        /// <summary>
        /// [string] The name of the LAN.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// The PCI slot number of the Nic.
        /// </summary>
        [Output("pciSlot")]
        public Output<int> PciSlot { get; private set; } = null!;

        /// <summary>
        /// The list of Security Group IDs for the resource. 
        /// 
        /// ⚠️ **Note:**: Removing the `flowlog` forces re-creation of the NIC resource.
        /// </summary>
        [Output("securityGroupsIds")]
        public Output<ImmutableArray<string>> SecurityGroupsIds { get; private set; } = null!;

        /// <summary>
        /// [string] The ID of a server.
        /// </summary>
        [Output("serverId")]
        public Output<string> ServerId { get; private set; } = null!;


        /// <summary>
        /// Create a Nic resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Nic(string name, NicArgs args, CustomResourceOptions? options = null)
            : base("ionoscloud:compute/nic:Nic", name, args ?? new NicArgs(), MakeResourceOptions(options, ""))
        {
        }

        private Nic(string name, Input<string> id, NicState? state = null, CustomResourceOptions? options = null)
            : base("ionoscloud:compute/nic:Nic", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing Nic resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static Nic Get(string name, Input<string> id, NicState? state = null, CustomResourceOptions? options = null)
        {
            return new Nic(name, id, state, options);
        }
    }

    public sealed class NicArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// [string] The ID of a Virtual Data Center.
        /// </summary>
        [Input("datacenterId", required: true)]
        public Input<string> DatacenterId { get; set; } = null!;

        /// <summary>
        /// [Boolean] Indicates if the NIC should get an IP address using DHCP (true) or not (false).
        /// </summary>
        [Input("dhcp")]
        public Input<bool>? Dhcp { get; set; }

        /// <summary>
        /// [Boolean] Indicates if the NIC should get an IPv6 address using DHCP (true) or not (false).
        /// </summary>
        [Input("dhcpv6")]
        public Input<bool>? Dhcpv6 { get; set; }

        /// <summary>
        /// [Boolean] If this resource is set to true and is nested under a server resource firewall, with open SSH port, resource must be nested under the NIC.
        /// </summary>
        [Input("firewallActive")]
        public Input<bool>? FirewallActive { get; set; }

        /// <summary>
        /// [String] The type of firewall rules that will be allowed on the NIC. If it is not specified it will take the default value INGRESS
        /// </summary>
        [Input("firewallType")]
        public Input<string>? FirewallType { get; set; }

        /// <summary>
        /// Only 1 flow log can be configured. Only the name field can change as part of an update. Flow logs holistically capture network information such as source and destination IP addresses, source and destination ports, number of packets, amount of bytes, the start and end time of the recording, and the type of protocol – and log the extent to which your instances are being accessed.
        /// </summary>
        [Input("flowlog")]
        public Input<Inputs.NicFlowlogArgs>? Flowlog { get; set; }

        [Input("ips")]
        private InputList<string>? _ips;

        /// <summary>
        /// [list] Collection of IP addresses assigned to a NIC. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.
        /// </summary>
        public InputList<string> Ips
        {
            get => _ips ?? (_ips = new InputList<string>());
            set => _ips = value;
        }

        /// <summary>
        /// Automatically assigned /80 IPv6 CIDR block if the NIC is connected to an IPv6 enabled LAN. You can also specify an /80 IPv6 CIDR block for the NIC on your own, which must be inside the /64 IPv6 CIDR block of the LAN and unique.
        /// </summary>
        [Input("ipv6CidrBlock")]
        public Input<string>? Ipv6CidrBlock { get; set; }

        [Input("ipv6Ips")]
        private InputList<string>? _ipv6Ips;

        /// <summary>
        /// [list] Collection of IPv6 addresses assigned to a NIC. Explicitly assigned public IPs need to come from the NIC's Ipv6 CIDR block, Passing value null or empty array will assign an IPv6 address automatically from the NIC's CIDR block.
        /// </summary>
        public InputList<string> Ipv6Ips
        {
            get => _ipv6Ips ?? (_ipv6Ips = new InputList<string>());
            set => _ipv6Ips = value;
        }

        /// <summary>
        /// [integer] The LAN ID the NIC will sit on.
        /// </summary>
        [Input("lan", required: true)]
        public Input<int> Lan { get; set; } = null!;

        /// <summary>
        /// The MAC address of the NIC. Can be set on creation only. If not set, one will be assigned automatically by the API. Immutable, update forces re-creation.
        /// </summary>
        [Input("mac")]
        public Input<string>? Mac { get; set; }

        /// <summary>
        /// [string] The name of the LAN.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("securityGroupsIds")]
        private InputList<string>? _securityGroupsIds;

        /// <summary>
        /// The list of Security Group IDs for the resource. 
        /// 
        /// ⚠️ **Note:**: Removing the `flowlog` forces re-creation of the NIC resource.
        /// </summary>
        public InputList<string> SecurityGroupsIds
        {
            get => _securityGroupsIds ?? (_securityGroupsIds = new InputList<string>());
            set => _securityGroupsIds = value;
        }

        /// <summary>
        /// [string] The ID of a server.
        /// </summary>
        [Input("serverId", required: true)]
        public Input<string> ServerId { get; set; } = null!;

        public NicArgs()
        {
        }
        public static new NicArgs Empty => new NicArgs();
    }

    public sealed class NicState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// [string] The ID of a Virtual Data Center.
        /// </summary>
        [Input("datacenterId")]
        public Input<string>? DatacenterId { get; set; }

        /// <summary>
        /// The Logical Unit Number (LUN) of the storage volume. Null if this NIC was created from CloudAPI and no DCD changes were done on the Datacenter.
        /// </summary>
        [Input("deviceNumber")]
        public Input<int>? DeviceNumber { get; set; }

        /// <summary>
        /// [Boolean] Indicates if the NIC should get an IP address using DHCP (true) or not (false).
        /// </summary>
        [Input("dhcp")]
        public Input<bool>? Dhcp { get; set; }

        /// <summary>
        /// [Boolean] Indicates if the NIC should get an IPv6 address using DHCP (true) or not (false).
        /// </summary>
        [Input("dhcpv6")]
        public Input<bool>? Dhcpv6 { get; set; }

        /// <summary>
        /// [Boolean] If this resource is set to true and is nested under a server resource firewall, with open SSH port, resource must be nested under the NIC.
        /// </summary>
        [Input("firewallActive")]
        public Input<bool>? FirewallActive { get; set; }

        /// <summary>
        /// [String] The type of firewall rules that will be allowed on the NIC. If it is not specified it will take the default value INGRESS
        /// </summary>
        [Input("firewallType")]
        public Input<string>? FirewallType { get; set; }

        /// <summary>
        /// Only 1 flow log can be configured. Only the name field can change as part of an update. Flow logs holistically capture network information such as source and destination IP addresses, source and destination ports, number of packets, amount of bytes, the start and end time of the recording, and the type of protocol – and log the extent to which your instances are being accessed.
        /// </summary>
        [Input("flowlog")]
        public Input<Inputs.NicFlowlogGetArgs>? Flowlog { get; set; }

        [Input("ips")]
        private InputList<string>? _ips;

        /// <summary>
        /// [list] Collection of IP addresses assigned to a NIC. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.
        /// </summary>
        public InputList<string> Ips
        {
            get => _ips ?? (_ips = new InputList<string>());
            set => _ips = value;
        }

        /// <summary>
        /// Automatically assigned /80 IPv6 CIDR block if the NIC is connected to an IPv6 enabled LAN. You can also specify an /80 IPv6 CIDR block for the NIC on your own, which must be inside the /64 IPv6 CIDR block of the LAN and unique.
        /// </summary>
        [Input("ipv6CidrBlock")]
        public Input<string>? Ipv6CidrBlock { get; set; }

        [Input("ipv6Ips")]
        private InputList<string>? _ipv6Ips;

        /// <summary>
        /// [list] Collection of IPv6 addresses assigned to a NIC. Explicitly assigned public IPs need to come from the NIC's Ipv6 CIDR block, Passing value null or empty array will assign an IPv6 address automatically from the NIC's CIDR block.
        /// </summary>
        public InputList<string> Ipv6Ips
        {
            get => _ipv6Ips ?? (_ipv6Ips = new InputList<string>());
            set => _ipv6Ips = value;
        }

        /// <summary>
        /// [integer] The LAN ID the NIC will sit on.
        /// </summary>
        [Input("lan")]
        public Input<int>? Lan { get; set; }

        /// <summary>
        /// The MAC address of the NIC. Can be set on creation only. If not set, one will be assigned automatically by the API. Immutable, update forces re-creation.
        /// </summary>
        [Input("mac")]
        public Input<string>? Mac { get; set; }

        /// <summary>
        /// [string] The name of the LAN.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The PCI slot number of the Nic.
        /// </summary>
        [Input("pciSlot")]
        public Input<int>? PciSlot { get; set; }

        [Input("securityGroupsIds")]
        private InputList<string>? _securityGroupsIds;

        /// <summary>
        /// The list of Security Group IDs for the resource. 
        /// 
        /// ⚠️ **Note:**: Removing the `flowlog` forces re-creation of the NIC resource.
        /// </summary>
        public InputList<string> SecurityGroupsIds
        {
            get => _securityGroupsIds ?? (_securityGroupsIds = new InputList<string>());
            set => _securityGroupsIds = value;
        }

        /// <summary>
        /// [string] The ID of a server.
        /// </summary>
        [Input("serverId")]
        public Input<string>? ServerId { get; set; }

        public NicState()
        {
        }
        public static new NicState Empty => new NicState();
    }
}
