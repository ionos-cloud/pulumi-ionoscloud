// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package nsg

import (
	"context"
	"reflect"

	"errors"
	"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages a **Network Security Group Rule** on IonosCloud.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute"
//	"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/nsg"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			example, err := compute.NewDatacenter(ctx, "example", &compute.DatacenterArgs{
//				Name:     pulumi.String("Datacenter NSG Example"),
//				Location: pulumi.String("de/txl"),
//			})
//			if err != nil {
//				return err
//			}
//			exampleNsg, err := nsg.NewNsg(ctx, "example", &nsg.NsgArgs{
//				Name:         pulumi.String("Example NSG"),
//				Description:  pulumi.String("Example NSG Description"),
//				DatacenterId: example.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = nsg.NewFirewall(ctx, "example", &nsg.FirewallArgs{
//				NsgId:        exampleNsg.ID(),
//				DatacenterId: example.ID(),
//				Protocol:     pulumi.String("TCP"),
//				Name:         pulumi.String("SG Rule"),
//				SourceMac:    pulumi.String("00:0a:95:9d:68:15"),
//				SourceIp:     pulumi.String("22.231.113.11"),
//				TargetIp:     pulumi.String("22.231.113.75"),
//				Type:         pulumi.String("EGRESS"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Resource Server can be imported using the `resource id`, `nsg id` and `datacenter id`, e.g.
//
// ```sh
// $ pulumi import ionoscloud:nsg/firewall:Firewall mynsg datacenter uuid/nsg uuid/firewall uuid
// ```
//
// Or by using an `import` block.
//
// hcl
//
// import {
//
//	to = ionoscloud_nsg.imported
//
//	id = "datacenter uuid/nsg uuid/firewall uuid"
//
// }
//
// resource "ionoscloud_nsg_firewallrule" "imported" {
//
//	nsg_id            = ionoscloud_nsg.example.id
//
//	datacenter_id     = ionoscloud_datacenter.example.id
//
//	protocol          = protocol of the imported rule
//
// }
type Firewall struct {
	pulumi.CustomResourceState

	// [string] The ID of a Virtual Data Center.
	DatacenterId pulumi.StringOutput `pulumi:"datacenterId"`
	// [int] Defines the allowed code (from 0 to 254) if protocol ICMP is chosen.
	IcmpCode pulumi.StringPtrOutput `pulumi:"icmpCode"`
	// [string] Defines the allowed code (from 0 to 254) if protocol ICMP is chosen. Value null allows all codes.
	IcmpType pulumi.StringPtrOutput `pulumi:"icmpType"`
	// [string] The name of the firewall rule.
	Name pulumi.StringOutput `pulumi:"name"`
	// [string] The ID of a Network Security Group.
	NsgId pulumi.StringOutput `pulumi:"nsgId"`
	// [int] Defines the end range of the allowed port (from 1 to 65534) if the protocol TCP or UDP is chosen. Leave portRangeStart and portRangeEnd null to allow all ports.
	PortRangeEnd pulumi.IntPtrOutput `pulumi:"portRangeEnd"`
	// [int] Defines the start range of the allowed port (from 1 to 65534) if protocol TCP or UDP is chosen. Leave portRangeStart and portRangeEnd null to allow all ports.
	PortRangeStart pulumi.IntPtrOutput `pulumi:"portRangeStart"`
	// [string] The protocol for the rule: TCP, UDP, ICMP, ANY. Property cannot be modified after creation (disallowed in update requests).
	Protocol pulumi.StringOutput `pulumi:"protocol"`
	// (computed)[string] Only traffic originating from the respective IPv4 address is allowed. Value null allows all source IPs.
	SourceIp pulumi.StringOutput `pulumi:"sourceIp"`
	// [string] Only traffic originating from the respective MAC address is allowed. Valid format: aa:bb:cc:dd:ee:ff. Value null allows all source MAC address. Valid format: aa:bb:cc:dd:ee:ff.
	SourceMac pulumi.StringPtrOutput `pulumi:"sourceMac"`
	// (Computed)[string] In case the target NIC has multiple IP addresses, only traffic directed to the respective IP address of the NIC is allowed. Value null allows all target IPs.
	TargetIp pulumi.StringOutput `pulumi:"targetIp"`
	// (Computed)[string] The type of firewall rule. If is not specified, it will take the default value INGRESS.
	Type pulumi.StringOutput `pulumi:"type"`
}

// NewFirewall registers a new resource with the given unique name, arguments, and options.
func NewFirewall(ctx *pulumi.Context,
	name string, args *FirewallArgs, opts ...pulumi.ResourceOption) (*Firewall, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.DatacenterId == nil {
		return nil, errors.New("invalid value for required argument 'DatacenterId'")
	}
	if args.NsgId == nil {
		return nil, errors.New("invalid value for required argument 'NsgId'")
	}
	if args.Protocol == nil {
		return nil, errors.New("invalid value for required argument 'Protocol'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Firewall
	err := ctx.RegisterResource("ionoscloud:nsg/firewall:Firewall", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetFirewall gets an existing Firewall resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetFirewall(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *FirewallState, opts ...pulumi.ResourceOption) (*Firewall, error) {
	var resource Firewall
	err := ctx.ReadResource("ionoscloud:nsg/firewall:Firewall", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Firewall resources.
type firewallState struct {
	// [string] The ID of a Virtual Data Center.
	DatacenterId *string `pulumi:"datacenterId"`
	// [int] Defines the allowed code (from 0 to 254) if protocol ICMP is chosen.
	IcmpCode *string `pulumi:"icmpCode"`
	// [string] Defines the allowed code (from 0 to 254) if protocol ICMP is chosen. Value null allows all codes.
	IcmpType *string `pulumi:"icmpType"`
	// [string] The name of the firewall rule.
	Name *string `pulumi:"name"`
	// [string] The ID of a Network Security Group.
	NsgId *string `pulumi:"nsgId"`
	// [int] Defines the end range of the allowed port (from 1 to 65534) if the protocol TCP or UDP is chosen. Leave portRangeStart and portRangeEnd null to allow all ports.
	PortRangeEnd *int `pulumi:"portRangeEnd"`
	// [int] Defines the start range of the allowed port (from 1 to 65534) if protocol TCP or UDP is chosen. Leave portRangeStart and portRangeEnd null to allow all ports.
	PortRangeStart *int `pulumi:"portRangeStart"`
	// [string] The protocol for the rule: TCP, UDP, ICMP, ANY. Property cannot be modified after creation (disallowed in update requests).
	Protocol *string `pulumi:"protocol"`
	// (computed)[string] Only traffic originating from the respective IPv4 address is allowed. Value null allows all source IPs.
	SourceIp *string `pulumi:"sourceIp"`
	// [string] Only traffic originating from the respective MAC address is allowed. Valid format: aa:bb:cc:dd:ee:ff. Value null allows all source MAC address. Valid format: aa:bb:cc:dd:ee:ff.
	SourceMac *string `pulumi:"sourceMac"`
	// (Computed)[string] In case the target NIC has multiple IP addresses, only traffic directed to the respective IP address of the NIC is allowed. Value null allows all target IPs.
	TargetIp *string `pulumi:"targetIp"`
	// (Computed)[string] The type of firewall rule. If is not specified, it will take the default value INGRESS.
	Type *string `pulumi:"type"`
}

type FirewallState struct {
	// [string] The ID of a Virtual Data Center.
	DatacenterId pulumi.StringPtrInput
	// [int] Defines the allowed code (from 0 to 254) if protocol ICMP is chosen.
	IcmpCode pulumi.StringPtrInput
	// [string] Defines the allowed code (from 0 to 254) if protocol ICMP is chosen. Value null allows all codes.
	IcmpType pulumi.StringPtrInput
	// [string] The name of the firewall rule.
	Name pulumi.StringPtrInput
	// [string] The ID of a Network Security Group.
	NsgId pulumi.StringPtrInput
	// [int] Defines the end range of the allowed port (from 1 to 65534) if the protocol TCP or UDP is chosen. Leave portRangeStart and portRangeEnd null to allow all ports.
	PortRangeEnd pulumi.IntPtrInput
	// [int] Defines the start range of the allowed port (from 1 to 65534) if protocol TCP or UDP is chosen. Leave portRangeStart and portRangeEnd null to allow all ports.
	PortRangeStart pulumi.IntPtrInput
	// [string] The protocol for the rule: TCP, UDP, ICMP, ANY. Property cannot be modified after creation (disallowed in update requests).
	Protocol pulumi.StringPtrInput
	// (computed)[string] Only traffic originating from the respective IPv4 address is allowed. Value null allows all source IPs.
	SourceIp pulumi.StringPtrInput
	// [string] Only traffic originating from the respective MAC address is allowed. Valid format: aa:bb:cc:dd:ee:ff. Value null allows all source MAC address. Valid format: aa:bb:cc:dd:ee:ff.
	SourceMac pulumi.StringPtrInput
	// (Computed)[string] In case the target NIC has multiple IP addresses, only traffic directed to the respective IP address of the NIC is allowed. Value null allows all target IPs.
	TargetIp pulumi.StringPtrInput
	// (Computed)[string] The type of firewall rule. If is not specified, it will take the default value INGRESS.
	Type pulumi.StringPtrInput
}

func (FirewallState) ElementType() reflect.Type {
	return reflect.TypeOf((*firewallState)(nil)).Elem()
}

type firewallArgs struct {
	// [string] The ID of a Virtual Data Center.
	DatacenterId string `pulumi:"datacenterId"`
	// [int] Defines the allowed code (from 0 to 254) if protocol ICMP is chosen.
	IcmpCode *string `pulumi:"icmpCode"`
	// [string] Defines the allowed code (from 0 to 254) if protocol ICMP is chosen. Value null allows all codes.
	IcmpType *string `pulumi:"icmpType"`
	// [string] The name of the firewall rule.
	Name *string `pulumi:"name"`
	// [string] The ID of a Network Security Group.
	NsgId string `pulumi:"nsgId"`
	// [int] Defines the end range of the allowed port (from 1 to 65534) if the protocol TCP or UDP is chosen. Leave portRangeStart and portRangeEnd null to allow all ports.
	PortRangeEnd *int `pulumi:"portRangeEnd"`
	// [int] Defines the start range of the allowed port (from 1 to 65534) if protocol TCP or UDP is chosen. Leave portRangeStart and portRangeEnd null to allow all ports.
	PortRangeStart *int `pulumi:"portRangeStart"`
	// [string] The protocol for the rule: TCP, UDP, ICMP, ANY. Property cannot be modified after creation (disallowed in update requests).
	Protocol string `pulumi:"protocol"`
	// (computed)[string] Only traffic originating from the respective IPv4 address is allowed. Value null allows all source IPs.
	SourceIp *string `pulumi:"sourceIp"`
	// [string] Only traffic originating from the respective MAC address is allowed. Valid format: aa:bb:cc:dd:ee:ff. Value null allows all source MAC address. Valid format: aa:bb:cc:dd:ee:ff.
	SourceMac *string `pulumi:"sourceMac"`
	// (Computed)[string] In case the target NIC has multiple IP addresses, only traffic directed to the respective IP address of the NIC is allowed. Value null allows all target IPs.
	TargetIp *string `pulumi:"targetIp"`
	// (Computed)[string] The type of firewall rule. If is not specified, it will take the default value INGRESS.
	Type *string `pulumi:"type"`
}

// The set of arguments for constructing a Firewall resource.
type FirewallArgs struct {
	// [string] The ID of a Virtual Data Center.
	DatacenterId pulumi.StringInput
	// [int] Defines the allowed code (from 0 to 254) if protocol ICMP is chosen.
	IcmpCode pulumi.StringPtrInput
	// [string] Defines the allowed code (from 0 to 254) if protocol ICMP is chosen. Value null allows all codes.
	IcmpType pulumi.StringPtrInput
	// [string] The name of the firewall rule.
	Name pulumi.StringPtrInput
	// [string] The ID of a Network Security Group.
	NsgId pulumi.StringInput
	// [int] Defines the end range of the allowed port (from 1 to 65534) if the protocol TCP or UDP is chosen. Leave portRangeStart and portRangeEnd null to allow all ports.
	PortRangeEnd pulumi.IntPtrInput
	// [int] Defines the start range of the allowed port (from 1 to 65534) if protocol TCP or UDP is chosen. Leave portRangeStart and portRangeEnd null to allow all ports.
	PortRangeStart pulumi.IntPtrInput
	// [string] The protocol for the rule: TCP, UDP, ICMP, ANY. Property cannot be modified after creation (disallowed in update requests).
	Protocol pulumi.StringInput
	// (computed)[string] Only traffic originating from the respective IPv4 address is allowed. Value null allows all source IPs.
	SourceIp pulumi.StringPtrInput
	// [string] Only traffic originating from the respective MAC address is allowed. Valid format: aa:bb:cc:dd:ee:ff. Value null allows all source MAC address. Valid format: aa:bb:cc:dd:ee:ff.
	SourceMac pulumi.StringPtrInput
	// (Computed)[string] In case the target NIC has multiple IP addresses, only traffic directed to the respective IP address of the NIC is allowed. Value null allows all target IPs.
	TargetIp pulumi.StringPtrInput
	// (Computed)[string] The type of firewall rule. If is not specified, it will take the default value INGRESS.
	Type pulumi.StringPtrInput
}

func (FirewallArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*firewallArgs)(nil)).Elem()
}

type FirewallInput interface {
	pulumi.Input

	ToFirewallOutput() FirewallOutput
	ToFirewallOutputWithContext(ctx context.Context) FirewallOutput
}

func (*Firewall) ElementType() reflect.Type {
	return reflect.TypeOf((**Firewall)(nil)).Elem()
}

func (i *Firewall) ToFirewallOutput() FirewallOutput {
	return i.ToFirewallOutputWithContext(context.Background())
}

func (i *Firewall) ToFirewallOutputWithContext(ctx context.Context) FirewallOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallOutput)
}

// FirewallArrayInput is an input type that accepts FirewallArray and FirewallArrayOutput values.
// You can construct a concrete instance of `FirewallArrayInput` via:
//
//	FirewallArray{ FirewallArgs{...} }
type FirewallArrayInput interface {
	pulumi.Input

	ToFirewallArrayOutput() FirewallArrayOutput
	ToFirewallArrayOutputWithContext(context.Context) FirewallArrayOutput
}

type FirewallArray []FirewallInput

func (FirewallArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Firewall)(nil)).Elem()
}

func (i FirewallArray) ToFirewallArrayOutput() FirewallArrayOutput {
	return i.ToFirewallArrayOutputWithContext(context.Background())
}

func (i FirewallArray) ToFirewallArrayOutputWithContext(ctx context.Context) FirewallArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallArrayOutput)
}

// FirewallMapInput is an input type that accepts FirewallMap and FirewallMapOutput values.
// You can construct a concrete instance of `FirewallMapInput` via:
//
//	FirewallMap{ "key": FirewallArgs{...} }
type FirewallMapInput interface {
	pulumi.Input

	ToFirewallMapOutput() FirewallMapOutput
	ToFirewallMapOutputWithContext(context.Context) FirewallMapOutput
}

type FirewallMap map[string]FirewallInput

func (FirewallMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Firewall)(nil)).Elem()
}

func (i FirewallMap) ToFirewallMapOutput() FirewallMapOutput {
	return i.ToFirewallMapOutputWithContext(context.Background())
}

func (i FirewallMap) ToFirewallMapOutputWithContext(ctx context.Context) FirewallMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallMapOutput)
}

type FirewallOutput struct{ *pulumi.OutputState }

func (FirewallOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Firewall)(nil)).Elem()
}

func (o FirewallOutput) ToFirewallOutput() FirewallOutput {
	return o
}

func (o FirewallOutput) ToFirewallOutputWithContext(ctx context.Context) FirewallOutput {
	return o
}

// [string] The ID of a Virtual Data Center.
func (o FirewallOutput) DatacenterId() pulumi.StringOutput {
	return o.ApplyT(func(v *Firewall) pulumi.StringOutput { return v.DatacenterId }).(pulumi.StringOutput)
}

// [int] Defines the allowed code (from 0 to 254) if protocol ICMP is chosen.
func (o FirewallOutput) IcmpCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Firewall) pulumi.StringPtrOutput { return v.IcmpCode }).(pulumi.StringPtrOutput)
}

// [string] Defines the allowed code (from 0 to 254) if protocol ICMP is chosen. Value null allows all codes.
func (o FirewallOutput) IcmpType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Firewall) pulumi.StringPtrOutput { return v.IcmpType }).(pulumi.StringPtrOutput)
}

// [string] The name of the firewall rule.
func (o FirewallOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Firewall) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// [string] The ID of a Network Security Group.
func (o FirewallOutput) NsgId() pulumi.StringOutput {
	return o.ApplyT(func(v *Firewall) pulumi.StringOutput { return v.NsgId }).(pulumi.StringOutput)
}

// [int] Defines the end range of the allowed port (from 1 to 65534) if the protocol TCP or UDP is chosen. Leave portRangeStart and portRangeEnd null to allow all ports.
func (o FirewallOutput) PortRangeEnd() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Firewall) pulumi.IntPtrOutput { return v.PortRangeEnd }).(pulumi.IntPtrOutput)
}

// [int] Defines the start range of the allowed port (from 1 to 65534) if protocol TCP or UDP is chosen. Leave portRangeStart and portRangeEnd null to allow all ports.
func (o FirewallOutput) PortRangeStart() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Firewall) pulumi.IntPtrOutput { return v.PortRangeStart }).(pulumi.IntPtrOutput)
}

// [string] The protocol for the rule: TCP, UDP, ICMP, ANY. Property cannot be modified after creation (disallowed in update requests).
func (o FirewallOutput) Protocol() pulumi.StringOutput {
	return o.ApplyT(func(v *Firewall) pulumi.StringOutput { return v.Protocol }).(pulumi.StringOutput)
}

// (computed)[string] Only traffic originating from the respective IPv4 address is allowed. Value null allows all source IPs.
func (o FirewallOutput) SourceIp() pulumi.StringOutput {
	return o.ApplyT(func(v *Firewall) pulumi.StringOutput { return v.SourceIp }).(pulumi.StringOutput)
}

// [string] Only traffic originating from the respective MAC address is allowed. Valid format: aa:bb:cc:dd:ee:ff. Value null allows all source MAC address. Valid format: aa:bb:cc:dd:ee:ff.
func (o FirewallOutput) SourceMac() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Firewall) pulumi.StringPtrOutput { return v.SourceMac }).(pulumi.StringPtrOutput)
}

// (Computed)[string] In case the target NIC has multiple IP addresses, only traffic directed to the respective IP address of the NIC is allowed. Value null allows all target IPs.
func (o FirewallOutput) TargetIp() pulumi.StringOutput {
	return o.ApplyT(func(v *Firewall) pulumi.StringOutput { return v.TargetIp }).(pulumi.StringOutput)
}

// (Computed)[string] The type of firewall rule. If is not specified, it will take the default value INGRESS.
func (o FirewallOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v *Firewall) pulumi.StringOutput { return v.Type }).(pulumi.StringOutput)
}

type FirewallArrayOutput struct{ *pulumi.OutputState }

func (FirewallArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Firewall)(nil)).Elem()
}

func (o FirewallArrayOutput) ToFirewallArrayOutput() FirewallArrayOutput {
	return o
}

func (o FirewallArrayOutput) ToFirewallArrayOutputWithContext(ctx context.Context) FirewallArrayOutput {
	return o
}

func (o FirewallArrayOutput) Index(i pulumi.IntInput) FirewallOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Firewall {
		return vs[0].([]*Firewall)[vs[1].(int)]
	}).(FirewallOutput)
}

type FirewallMapOutput struct{ *pulumi.OutputState }

func (FirewallMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Firewall)(nil)).Elem()
}

func (o FirewallMapOutput) ToFirewallMapOutput() FirewallMapOutput {
	return o
}

func (o FirewallMapOutput) ToFirewallMapOutputWithContext(ctx context.Context) FirewallMapOutput {
	return o
}

func (o FirewallMapOutput) MapIndex(k pulumi.StringInput) FirewallOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Firewall {
		return vs[0].(map[string]*Firewall)[vs[1].(string)]
	}).(FirewallOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallInput)(nil)).Elem(), &Firewall{})
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallArrayInput)(nil)).Elem(), FirewallArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallMapInput)(nil)).Elem(), FirewallMap{})
	pulumi.RegisterOutputType(FirewallOutput{})
	pulumi.RegisterOutputType(FirewallArrayOutput{})
	pulumi.RegisterOutputType(FirewallMapOutput{})
}
