// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package nlb

import (
	"context"
	"reflect"

	"errors"
	"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages a **Network Load Balancer**  on IonosCloud.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute"
//	"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/nlb"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			exampleDatacenter, err := compute.NewDatacenter(ctx, "exampleDatacenter", &compute.DatacenterArgs{
//				Location:          pulumi.String("us/las"),
//				Description:       pulumi.String("Datacenter Description"),
//				SecAuthProtection: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			example1, err := compute.NewLan(ctx, "example1", &compute.LanArgs{
//				DatacenterId: exampleDatacenter.ID(),
//				Public:       pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			example2, err := compute.NewLan(ctx, "example2", &compute.LanArgs{
//				DatacenterId: exampleDatacenter.ID(),
//				Public:       pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = nlb.NewBalancer(ctx, "exampleBalancer", &nlb.BalancerArgs{
//				DatacenterId: exampleDatacenter.ID(),
//				ListenerLan:  example1.ID(),
//				TargetLan:    example2.ID(),
//				Ips: pulumi.StringArray{
//					pulumi.String("10.12.118.224"),
//				},
//				LbPrivateIps: pulumi.StringArray{
//					pulumi.String("10.13.72.225/24"),
//				},
//				CentralLogging: pulumi.Bool(true),
//				LoggingFormat:  pulumi.String("%{+Q}o %{-Q}ci - - [%trg] %r %ST %B \"\" \"\" %cp %ms %ft %b %s %TR %Tw %Tc %Tr %Ta %tsc %ac %fc %bc %sc %rc %sq %bq %CC %CS %hrl %hsl"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Example configuring Flowlog
//
// ```go
// package main
//
// import (
//
//	"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/nlb"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := nlb.NewBalancer(ctx, "example", &nlb.BalancerArgs{
//				DatacenterId: pulumi.Any(ionoscloud_datacenter.Example.Id),
//				ListenerLan:  pulumi.Any(ionoscloud_lan.Example1.Id),
//				TargetLan:    pulumi.Any(ionoscloud_lan.Example2.Id),
//				Ips: pulumi.StringArray{
//					pulumi.String("10.12.118.224"),
//				},
//				LbPrivateIps: pulumi.StringArray{
//					pulumi.String("10.13.72.225/24"),
//				},
//				Flowlog: &nlb.BalancerFlowlogArgs{
//					Action:    pulumi.String("ALL"),
//					Bucket:    pulumi.String("flowlog-bucket"),
//					Direction: pulumi.String("INGRESS"),
//					Name:      pulumi.String("flowlog"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// This will configure flowlog for ALL(rejected and accepted) ingress traffic and will log it into an existing ionos bucket named `flowlog-bucket`. Any s3 compatible client can be used to create it. Adding a flowlog does not force re-creation or the nic, but changing any other field than
// `name` will. Deleting a flowlog will also force nic re-creation.
//
// ## Import
//
// A Network Load Balancer resource can be imported using its `resource id` and the `datacenter id` e.g.
//
// ```sh
// $ pulumi import ionoscloud:nlb/balancer:Balancer my_networkloadbalancer {datacenter uuid}/{networkloadbalancer uuid}
// ```
type Balancer struct {
	pulumi.CustomResourceState

	// [bool] Turn logging on and off for this product. Default value is 'false'.
	CentralLogging pulumi.BoolPtrOutput `pulumi:"centralLogging"`
	// [string] A Datacenter's UUID.
	DatacenterId pulumi.StringOutput `pulumi:"datacenterId"`
	// [list] Only 1 flow log can be configured. Only the name field can change as part of an update. Flow logs holistically capture network information such as source and destination IP addresses, source and destination ports, number of packets, amount of bytes, the start and end time of the recording, and the type of protocol – and log the extent to which your instances are being accessed.
	Flowlog BalancerFlowlogPtrOutput `pulumi:"flowlog"`
	// [list] Collection of IP addresses of the Network Load Balancer. (inbound and outbound) IP of the listenerLan must be a customer reserved IP for the public load balancer and private IP for the private load balancer.
	Ips pulumi.StringArrayOutput `pulumi:"ips"`
	// [list] Collection of private IP addresses with subnet mask of the Network Load Balancer. IPs must contain valid subnet mask. If user will not provide any IP then the system will generate one IP with /24 subnet.
	LbPrivateIps pulumi.StringArrayOutput `pulumi:"lbPrivateIps"`
	// [int] Id of the listening LAN. (inbound)
	ListenerLan pulumi.IntOutput `pulumi:"listenerLan"`
	// Specifies the format of the logs.
	LoggingFormat pulumi.StringPtrOutput `pulumi:"loggingFormat"`
	// [string] A name of that Network Load Balancer.
	Name pulumi.StringOutput `pulumi:"name"`
	// [int] Id of the balanced private target LAN. (outbound)
	TargetLan pulumi.IntOutput `pulumi:"targetLan"`
}

// NewBalancer registers a new resource with the given unique name, arguments, and options.
func NewBalancer(ctx *pulumi.Context,
	name string, args *BalancerArgs, opts ...pulumi.ResourceOption) (*Balancer, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.DatacenterId == nil {
		return nil, errors.New("invalid value for required argument 'DatacenterId'")
	}
	if args.ListenerLan == nil {
		return nil, errors.New("invalid value for required argument 'ListenerLan'")
	}
	if args.TargetLan == nil {
		return nil, errors.New("invalid value for required argument 'TargetLan'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Balancer
	err := ctx.RegisterResource("ionoscloud:nlb/balancer:Balancer", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetBalancer gets an existing Balancer resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetBalancer(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *BalancerState, opts ...pulumi.ResourceOption) (*Balancer, error) {
	var resource Balancer
	err := ctx.ReadResource("ionoscloud:nlb/balancer:Balancer", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Balancer resources.
type balancerState struct {
	// [bool] Turn logging on and off for this product. Default value is 'false'.
	CentralLogging *bool `pulumi:"centralLogging"`
	// [string] A Datacenter's UUID.
	DatacenterId *string `pulumi:"datacenterId"`
	// [list] Only 1 flow log can be configured. Only the name field can change as part of an update. Flow logs holistically capture network information such as source and destination IP addresses, source and destination ports, number of packets, amount of bytes, the start and end time of the recording, and the type of protocol – and log the extent to which your instances are being accessed.
	Flowlog *BalancerFlowlog `pulumi:"flowlog"`
	// [list] Collection of IP addresses of the Network Load Balancer. (inbound and outbound) IP of the listenerLan must be a customer reserved IP for the public load balancer and private IP for the private load balancer.
	Ips []string `pulumi:"ips"`
	// [list] Collection of private IP addresses with subnet mask of the Network Load Balancer. IPs must contain valid subnet mask. If user will not provide any IP then the system will generate one IP with /24 subnet.
	LbPrivateIps []string `pulumi:"lbPrivateIps"`
	// [int] Id of the listening LAN. (inbound)
	ListenerLan *int `pulumi:"listenerLan"`
	// Specifies the format of the logs.
	LoggingFormat *string `pulumi:"loggingFormat"`
	// [string] A name of that Network Load Balancer.
	Name *string `pulumi:"name"`
	// [int] Id of the balanced private target LAN. (outbound)
	TargetLan *int `pulumi:"targetLan"`
}

type BalancerState struct {
	// [bool] Turn logging on and off for this product. Default value is 'false'.
	CentralLogging pulumi.BoolPtrInput
	// [string] A Datacenter's UUID.
	DatacenterId pulumi.StringPtrInput
	// [list] Only 1 flow log can be configured. Only the name field can change as part of an update. Flow logs holistically capture network information such as source and destination IP addresses, source and destination ports, number of packets, amount of bytes, the start and end time of the recording, and the type of protocol – and log the extent to which your instances are being accessed.
	Flowlog BalancerFlowlogPtrInput
	// [list] Collection of IP addresses of the Network Load Balancer. (inbound and outbound) IP of the listenerLan must be a customer reserved IP for the public load balancer and private IP for the private load balancer.
	Ips pulumi.StringArrayInput
	// [list] Collection of private IP addresses with subnet mask of the Network Load Balancer. IPs must contain valid subnet mask. If user will not provide any IP then the system will generate one IP with /24 subnet.
	LbPrivateIps pulumi.StringArrayInput
	// [int] Id of the listening LAN. (inbound)
	ListenerLan pulumi.IntPtrInput
	// Specifies the format of the logs.
	LoggingFormat pulumi.StringPtrInput
	// [string] A name of that Network Load Balancer.
	Name pulumi.StringPtrInput
	// [int] Id of the balanced private target LAN. (outbound)
	TargetLan pulumi.IntPtrInput
}

func (BalancerState) ElementType() reflect.Type {
	return reflect.TypeOf((*balancerState)(nil)).Elem()
}

type balancerArgs struct {
	// [bool] Turn logging on and off for this product. Default value is 'false'.
	CentralLogging *bool `pulumi:"centralLogging"`
	// [string] A Datacenter's UUID.
	DatacenterId string `pulumi:"datacenterId"`
	// [list] Only 1 flow log can be configured. Only the name field can change as part of an update. Flow logs holistically capture network information such as source and destination IP addresses, source and destination ports, number of packets, amount of bytes, the start and end time of the recording, and the type of protocol – and log the extent to which your instances are being accessed.
	Flowlog *BalancerFlowlog `pulumi:"flowlog"`
	// [list] Collection of IP addresses of the Network Load Balancer. (inbound and outbound) IP of the listenerLan must be a customer reserved IP for the public load balancer and private IP for the private load balancer.
	Ips []string `pulumi:"ips"`
	// [list] Collection of private IP addresses with subnet mask of the Network Load Balancer. IPs must contain valid subnet mask. If user will not provide any IP then the system will generate one IP with /24 subnet.
	LbPrivateIps []string `pulumi:"lbPrivateIps"`
	// [int] Id of the listening LAN. (inbound)
	ListenerLan int `pulumi:"listenerLan"`
	// Specifies the format of the logs.
	LoggingFormat *string `pulumi:"loggingFormat"`
	// [string] A name of that Network Load Balancer.
	Name *string `pulumi:"name"`
	// [int] Id of the balanced private target LAN. (outbound)
	TargetLan int `pulumi:"targetLan"`
}

// The set of arguments for constructing a Balancer resource.
type BalancerArgs struct {
	// [bool] Turn logging on and off for this product. Default value is 'false'.
	CentralLogging pulumi.BoolPtrInput
	// [string] A Datacenter's UUID.
	DatacenterId pulumi.StringInput
	// [list] Only 1 flow log can be configured. Only the name field can change as part of an update. Flow logs holistically capture network information such as source and destination IP addresses, source and destination ports, number of packets, amount of bytes, the start and end time of the recording, and the type of protocol – and log the extent to which your instances are being accessed.
	Flowlog BalancerFlowlogPtrInput
	// [list] Collection of IP addresses of the Network Load Balancer. (inbound and outbound) IP of the listenerLan must be a customer reserved IP for the public load balancer and private IP for the private load balancer.
	Ips pulumi.StringArrayInput
	// [list] Collection of private IP addresses with subnet mask of the Network Load Balancer. IPs must contain valid subnet mask. If user will not provide any IP then the system will generate one IP with /24 subnet.
	LbPrivateIps pulumi.StringArrayInput
	// [int] Id of the listening LAN. (inbound)
	ListenerLan pulumi.IntInput
	// Specifies the format of the logs.
	LoggingFormat pulumi.StringPtrInput
	// [string] A name of that Network Load Balancer.
	Name pulumi.StringPtrInput
	// [int] Id of the balanced private target LAN. (outbound)
	TargetLan pulumi.IntInput
}

func (BalancerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*balancerArgs)(nil)).Elem()
}

type BalancerInput interface {
	pulumi.Input

	ToBalancerOutput() BalancerOutput
	ToBalancerOutputWithContext(ctx context.Context) BalancerOutput
}

func (*Balancer) ElementType() reflect.Type {
	return reflect.TypeOf((**Balancer)(nil)).Elem()
}

func (i *Balancer) ToBalancerOutput() BalancerOutput {
	return i.ToBalancerOutputWithContext(context.Background())
}

func (i *Balancer) ToBalancerOutputWithContext(ctx context.Context) BalancerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BalancerOutput)
}

// BalancerArrayInput is an input type that accepts BalancerArray and BalancerArrayOutput values.
// You can construct a concrete instance of `BalancerArrayInput` via:
//
//	BalancerArray{ BalancerArgs{...} }
type BalancerArrayInput interface {
	pulumi.Input

	ToBalancerArrayOutput() BalancerArrayOutput
	ToBalancerArrayOutputWithContext(context.Context) BalancerArrayOutput
}

type BalancerArray []BalancerInput

func (BalancerArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Balancer)(nil)).Elem()
}

func (i BalancerArray) ToBalancerArrayOutput() BalancerArrayOutput {
	return i.ToBalancerArrayOutputWithContext(context.Background())
}

func (i BalancerArray) ToBalancerArrayOutputWithContext(ctx context.Context) BalancerArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BalancerArrayOutput)
}

// BalancerMapInput is an input type that accepts BalancerMap and BalancerMapOutput values.
// You can construct a concrete instance of `BalancerMapInput` via:
//
//	BalancerMap{ "key": BalancerArgs{...} }
type BalancerMapInput interface {
	pulumi.Input

	ToBalancerMapOutput() BalancerMapOutput
	ToBalancerMapOutputWithContext(context.Context) BalancerMapOutput
}

type BalancerMap map[string]BalancerInput

func (BalancerMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Balancer)(nil)).Elem()
}

func (i BalancerMap) ToBalancerMapOutput() BalancerMapOutput {
	return i.ToBalancerMapOutputWithContext(context.Background())
}

func (i BalancerMap) ToBalancerMapOutputWithContext(ctx context.Context) BalancerMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BalancerMapOutput)
}

type BalancerOutput struct{ *pulumi.OutputState }

func (BalancerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Balancer)(nil)).Elem()
}

func (o BalancerOutput) ToBalancerOutput() BalancerOutput {
	return o
}

func (o BalancerOutput) ToBalancerOutputWithContext(ctx context.Context) BalancerOutput {
	return o
}

// [bool] Turn logging on and off for this product. Default value is 'false'.
func (o BalancerOutput) CentralLogging() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Balancer) pulumi.BoolPtrOutput { return v.CentralLogging }).(pulumi.BoolPtrOutput)
}

// [string] A Datacenter's UUID.
func (o BalancerOutput) DatacenterId() pulumi.StringOutput {
	return o.ApplyT(func(v *Balancer) pulumi.StringOutput { return v.DatacenterId }).(pulumi.StringOutput)
}

// [list] Only 1 flow log can be configured. Only the name field can change as part of an update. Flow logs holistically capture network information such as source and destination IP addresses, source and destination ports, number of packets, amount of bytes, the start and end time of the recording, and the type of protocol – and log the extent to which your instances are being accessed.
func (o BalancerOutput) Flowlog() BalancerFlowlogPtrOutput {
	return o.ApplyT(func(v *Balancer) BalancerFlowlogPtrOutput { return v.Flowlog }).(BalancerFlowlogPtrOutput)
}

// [list] Collection of IP addresses of the Network Load Balancer. (inbound and outbound) IP of the listenerLan must be a customer reserved IP for the public load balancer and private IP for the private load balancer.
func (o BalancerOutput) Ips() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Balancer) pulumi.StringArrayOutput { return v.Ips }).(pulumi.StringArrayOutput)
}

// [list] Collection of private IP addresses with subnet mask of the Network Load Balancer. IPs must contain valid subnet mask. If user will not provide any IP then the system will generate one IP with /24 subnet.
func (o BalancerOutput) LbPrivateIps() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Balancer) pulumi.StringArrayOutput { return v.LbPrivateIps }).(pulumi.StringArrayOutput)
}

// [int] Id of the listening LAN. (inbound)
func (o BalancerOutput) ListenerLan() pulumi.IntOutput {
	return o.ApplyT(func(v *Balancer) pulumi.IntOutput { return v.ListenerLan }).(pulumi.IntOutput)
}

// Specifies the format of the logs.
func (o BalancerOutput) LoggingFormat() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Balancer) pulumi.StringPtrOutput { return v.LoggingFormat }).(pulumi.StringPtrOutput)
}

// [string] A name of that Network Load Balancer.
func (o BalancerOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Balancer) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// [int] Id of the balanced private target LAN. (outbound)
func (o BalancerOutput) TargetLan() pulumi.IntOutput {
	return o.ApplyT(func(v *Balancer) pulumi.IntOutput { return v.TargetLan }).(pulumi.IntOutput)
}

type BalancerArrayOutput struct{ *pulumi.OutputState }

func (BalancerArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Balancer)(nil)).Elem()
}

func (o BalancerArrayOutput) ToBalancerArrayOutput() BalancerArrayOutput {
	return o
}

func (o BalancerArrayOutput) ToBalancerArrayOutputWithContext(ctx context.Context) BalancerArrayOutput {
	return o
}

func (o BalancerArrayOutput) Index(i pulumi.IntInput) BalancerOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Balancer {
		return vs[0].([]*Balancer)[vs[1].(int)]
	}).(BalancerOutput)
}

type BalancerMapOutput struct{ *pulumi.OutputState }

func (BalancerMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Balancer)(nil)).Elem()
}

func (o BalancerMapOutput) ToBalancerMapOutput() BalancerMapOutput {
	return o
}

func (o BalancerMapOutput) ToBalancerMapOutputWithContext(ctx context.Context) BalancerMapOutput {
	return o
}

func (o BalancerMapOutput) MapIndex(k pulumi.StringInput) BalancerOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Balancer {
		return vs[0].(map[string]*Balancer)[vs[1].(string)]
	}).(BalancerOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*BalancerInput)(nil)).Elem(), &Balancer{})
	pulumi.RegisterInputType(reflect.TypeOf((*BalancerArrayInput)(nil)).Elem(), BalancerArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*BalancerMapInput)(nil)).Elem(), BalancerMap{})
	pulumi.RegisterOutputType(BalancerOutput{})
	pulumi.RegisterOutputType(BalancerArrayOutput{})
	pulumi.RegisterOutputType(BalancerMapOutput{})
}
