// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package alb

import (
	"context"
	"reflect"

	"errors"
	"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type Balancer struct {
	pulumi.CustomResourceState

	// Turn logging on and off for this product. Default value is 'false'.
	CentralLogging pulumi.BoolPtrOutput `pulumi:"centralLogging"`
	DatacenterId   pulumi.StringOutput  `pulumi:"datacenterId"`
	// Only 1 flow log can be configured. Only the name field can change as part of an update. Flow logs holistically capture
	// network information such as source and destination IP addresses, source and destination ports, number of packets, amount
	// of bytes, the start and end time of the recording, and the type of protocol – and log the extent to which your
	// instances are being accessed.
	Flowlog BalancerFlowlogPtrOutput `pulumi:"flowlog"`
	// Collection of the Application Load Balancer IP addresses. (Inbound and outbound) IPs of the listenerLan are
	// customer-reserved public IPs for the public Load Balancers, and private IPs for the private Load Balancers.
	Ips pulumi.StringArrayOutput `pulumi:"ips"`
	// Collection of private IP addresses with the subnet mask of the Application Load Balancer. IPs must contain valid a
	// subnet mask. If no IP is provided, the system will generate an IP with /24 subnet.
	LbPrivateIps pulumi.StringArrayOutput `pulumi:"lbPrivateIps"`
	// ID of the listening (inbound) LAN.
	ListenerLan pulumi.IntOutput `pulumi:"listenerLan"`
	// Specifies the format of the logs.
	LoggingFormat pulumi.StringPtrOutput `pulumi:"loggingFormat"`
	// The name of the Application Load Balancer.
	Name pulumi.StringOutput `pulumi:"name"`
	// ID of the balanced private target LAN (outbound).
	TargetLan pulumi.IntOutput `pulumi:"targetLan"`
}

// NewBalancer registers a new resource with the given unique name, arguments, and options.
func NewBalancer(ctx *pulumi.Context,
	name string, args *BalancerArgs, opts ...pulumi.ResourceOption) (*Balancer, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.DatacenterId == nil {
		return nil, errors.New("invalid value for required argument 'DatacenterId'")
	}
	if args.ListenerLan == nil {
		return nil, errors.New("invalid value for required argument 'ListenerLan'")
	}
	if args.TargetLan == nil {
		return nil, errors.New("invalid value for required argument 'TargetLan'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Balancer
	err := ctx.RegisterResource("ionoscloud:alb/balancer:Balancer", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetBalancer gets an existing Balancer resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetBalancer(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *BalancerState, opts ...pulumi.ResourceOption) (*Balancer, error) {
	var resource Balancer
	err := ctx.ReadResource("ionoscloud:alb/balancer:Balancer", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Balancer resources.
type balancerState struct {
	// Turn logging on and off for this product. Default value is 'false'.
	CentralLogging *bool   `pulumi:"centralLogging"`
	DatacenterId   *string `pulumi:"datacenterId"`
	// Only 1 flow log can be configured. Only the name field can change as part of an update. Flow logs holistically capture
	// network information such as source and destination IP addresses, source and destination ports, number of packets, amount
	// of bytes, the start and end time of the recording, and the type of protocol – and log the extent to which your
	// instances are being accessed.
	Flowlog *BalancerFlowlog `pulumi:"flowlog"`
	// Collection of the Application Load Balancer IP addresses. (Inbound and outbound) IPs of the listenerLan are
	// customer-reserved public IPs for the public Load Balancers, and private IPs for the private Load Balancers.
	Ips []string `pulumi:"ips"`
	// Collection of private IP addresses with the subnet mask of the Application Load Balancer. IPs must contain valid a
	// subnet mask. If no IP is provided, the system will generate an IP with /24 subnet.
	LbPrivateIps []string `pulumi:"lbPrivateIps"`
	// ID of the listening (inbound) LAN.
	ListenerLan *int `pulumi:"listenerLan"`
	// Specifies the format of the logs.
	LoggingFormat *string `pulumi:"loggingFormat"`
	// The name of the Application Load Balancer.
	Name *string `pulumi:"name"`
	// ID of the balanced private target LAN (outbound).
	TargetLan *int `pulumi:"targetLan"`
}

type BalancerState struct {
	// Turn logging on and off for this product. Default value is 'false'.
	CentralLogging pulumi.BoolPtrInput
	DatacenterId   pulumi.StringPtrInput
	// Only 1 flow log can be configured. Only the name field can change as part of an update. Flow logs holistically capture
	// network information such as source and destination IP addresses, source and destination ports, number of packets, amount
	// of bytes, the start and end time of the recording, and the type of protocol – and log the extent to which your
	// instances are being accessed.
	Flowlog BalancerFlowlogPtrInput
	// Collection of the Application Load Balancer IP addresses. (Inbound and outbound) IPs of the listenerLan are
	// customer-reserved public IPs for the public Load Balancers, and private IPs for the private Load Balancers.
	Ips pulumi.StringArrayInput
	// Collection of private IP addresses with the subnet mask of the Application Load Balancer. IPs must contain valid a
	// subnet mask. If no IP is provided, the system will generate an IP with /24 subnet.
	LbPrivateIps pulumi.StringArrayInput
	// ID of the listening (inbound) LAN.
	ListenerLan pulumi.IntPtrInput
	// Specifies the format of the logs.
	LoggingFormat pulumi.StringPtrInput
	// The name of the Application Load Balancer.
	Name pulumi.StringPtrInput
	// ID of the balanced private target LAN (outbound).
	TargetLan pulumi.IntPtrInput
}

func (BalancerState) ElementType() reflect.Type {
	return reflect.TypeOf((*balancerState)(nil)).Elem()
}

type balancerArgs struct {
	// Turn logging on and off for this product. Default value is 'false'.
	CentralLogging *bool  `pulumi:"centralLogging"`
	DatacenterId   string `pulumi:"datacenterId"`
	// Only 1 flow log can be configured. Only the name field can change as part of an update. Flow logs holistically capture
	// network information such as source and destination IP addresses, source and destination ports, number of packets, amount
	// of bytes, the start and end time of the recording, and the type of protocol – and log the extent to which your
	// instances are being accessed.
	Flowlog *BalancerFlowlog `pulumi:"flowlog"`
	// Collection of the Application Load Balancer IP addresses. (Inbound and outbound) IPs of the listenerLan are
	// customer-reserved public IPs for the public Load Balancers, and private IPs for the private Load Balancers.
	Ips []string `pulumi:"ips"`
	// Collection of private IP addresses with the subnet mask of the Application Load Balancer. IPs must contain valid a
	// subnet mask. If no IP is provided, the system will generate an IP with /24 subnet.
	LbPrivateIps []string `pulumi:"lbPrivateIps"`
	// ID of the listening (inbound) LAN.
	ListenerLan int `pulumi:"listenerLan"`
	// Specifies the format of the logs.
	LoggingFormat *string `pulumi:"loggingFormat"`
	// The name of the Application Load Balancer.
	Name *string `pulumi:"name"`
	// ID of the balanced private target LAN (outbound).
	TargetLan int `pulumi:"targetLan"`
}

// The set of arguments for constructing a Balancer resource.
type BalancerArgs struct {
	// Turn logging on and off for this product. Default value is 'false'.
	CentralLogging pulumi.BoolPtrInput
	DatacenterId   pulumi.StringInput
	// Only 1 flow log can be configured. Only the name field can change as part of an update. Flow logs holistically capture
	// network information such as source and destination IP addresses, source and destination ports, number of packets, amount
	// of bytes, the start and end time of the recording, and the type of protocol – and log the extent to which your
	// instances are being accessed.
	Flowlog BalancerFlowlogPtrInput
	// Collection of the Application Load Balancer IP addresses. (Inbound and outbound) IPs of the listenerLan are
	// customer-reserved public IPs for the public Load Balancers, and private IPs for the private Load Balancers.
	Ips pulumi.StringArrayInput
	// Collection of private IP addresses with the subnet mask of the Application Load Balancer. IPs must contain valid a
	// subnet mask. If no IP is provided, the system will generate an IP with /24 subnet.
	LbPrivateIps pulumi.StringArrayInput
	// ID of the listening (inbound) LAN.
	ListenerLan pulumi.IntInput
	// Specifies the format of the logs.
	LoggingFormat pulumi.StringPtrInput
	// The name of the Application Load Balancer.
	Name pulumi.StringPtrInput
	// ID of the balanced private target LAN (outbound).
	TargetLan pulumi.IntInput
}

func (BalancerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*balancerArgs)(nil)).Elem()
}

type BalancerInput interface {
	pulumi.Input

	ToBalancerOutput() BalancerOutput
	ToBalancerOutputWithContext(ctx context.Context) BalancerOutput
}

func (*Balancer) ElementType() reflect.Type {
	return reflect.TypeOf((**Balancer)(nil)).Elem()
}

func (i *Balancer) ToBalancerOutput() BalancerOutput {
	return i.ToBalancerOutputWithContext(context.Background())
}

func (i *Balancer) ToBalancerOutputWithContext(ctx context.Context) BalancerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BalancerOutput)
}

// BalancerArrayInput is an input type that accepts BalancerArray and BalancerArrayOutput values.
// You can construct a concrete instance of `BalancerArrayInput` via:
//
//	BalancerArray{ BalancerArgs{...} }
type BalancerArrayInput interface {
	pulumi.Input

	ToBalancerArrayOutput() BalancerArrayOutput
	ToBalancerArrayOutputWithContext(context.Context) BalancerArrayOutput
}

type BalancerArray []BalancerInput

func (BalancerArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Balancer)(nil)).Elem()
}

func (i BalancerArray) ToBalancerArrayOutput() BalancerArrayOutput {
	return i.ToBalancerArrayOutputWithContext(context.Background())
}

func (i BalancerArray) ToBalancerArrayOutputWithContext(ctx context.Context) BalancerArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BalancerArrayOutput)
}

// BalancerMapInput is an input type that accepts BalancerMap and BalancerMapOutput values.
// You can construct a concrete instance of `BalancerMapInput` via:
//
//	BalancerMap{ "key": BalancerArgs{...} }
type BalancerMapInput interface {
	pulumi.Input

	ToBalancerMapOutput() BalancerMapOutput
	ToBalancerMapOutputWithContext(context.Context) BalancerMapOutput
}

type BalancerMap map[string]BalancerInput

func (BalancerMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Balancer)(nil)).Elem()
}

func (i BalancerMap) ToBalancerMapOutput() BalancerMapOutput {
	return i.ToBalancerMapOutputWithContext(context.Background())
}

func (i BalancerMap) ToBalancerMapOutputWithContext(ctx context.Context) BalancerMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BalancerMapOutput)
}

type BalancerOutput struct{ *pulumi.OutputState }

func (BalancerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Balancer)(nil)).Elem()
}

func (o BalancerOutput) ToBalancerOutput() BalancerOutput {
	return o
}

func (o BalancerOutput) ToBalancerOutputWithContext(ctx context.Context) BalancerOutput {
	return o
}

// Turn logging on and off for this product. Default value is 'false'.
func (o BalancerOutput) CentralLogging() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Balancer) pulumi.BoolPtrOutput { return v.CentralLogging }).(pulumi.BoolPtrOutput)
}

func (o BalancerOutput) DatacenterId() pulumi.StringOutput {
	return o.ApplyT(func(v *Balancer) pulumi.StringOutput { return v.DatacenterId }).(pulumi.StringOutput)
}

// Only 1 flow log can be configured. Only the name field can change as part of an update. Flow logs holistically capture
// network information such as source and destination IP addresses, source and destination ports, number of packets, amount
// of bytes, the start and end time of the recording, and the type of protocol – and log the extent to which your
// instances are being accessed.
func (o BalancerOutput) Flowlog() BalancerFlowlogPtrOutput {
	return o.ApplyT(func(v *Balancer) BalancerFlowlogPtrOutput { return v.Flowlog }).(BalancerFlowlogPtrOutput)
}

// Collection of the Application Load Balancer IP addresses. (Inbound and outbound) IPs of the listenerLan are
// customer-reserved public IPs for the public Load Balancers, and private IPs for the private Load Balancers.
func (o BalancerOutput) Ips() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Balancer) pulumi.StringArrayOutput { return v.Ips }).(pulumi.StringArrayOutput)
}

// Collection of private IP addresses with the subnet mask of the Application Load Balancer. IPs must contain valid a
// subnet mask. If no IP is provided, the system will generate an IP with /24 subnet.
func (o BalancerOutput) LbPrivateIps() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Balancer) pulumi.StringArrayOutput { return v.LbPrivateIps }).(pulumi.StringArrayOutput)
}

// ID of the listening (inbound) LAN.
func (o BalancerOutput) ListenerLan() pulumi.IntOutput {
	return o.ApplyT(func(v *Balancer) pulumi.IntOutput { return v.ListenerLan }).(pulumi.IntOutput)
}

// Specifies the format of the logs.
func (o BalancerOutput) LoggingFormat() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Balancer) pulumi.StringPtrOutput { return v.LoggingFormat }).(pulumi.StringPtrOutput)
}

// The name of the Application Load Balancer.
func (o BalancerOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Balancer) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// ID of the balanced private target LAN (outbound).
func (o BalancerOutput) TargetLan() pulumi.IntOutput {
	return o.ApplyT(func(v *Balancer) pulumi.IntOutput { return v.TargetLan }).(pulumi.IntOutput)
}

type BalancerArrayOutput struct{ *pulumi.OutputState }

func (BalancerArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Balancer)(nil)).Elem()
}

func (o BalancerArrayOutput) ToBalancerArrayOutput() BalancerArrayOutput {
	return o
}

func (o BalancerArrayOutput) ToBalancerArrayOutputWithContext(ctx context.Context) BalancerArrayOutput {
	return o
}

func (o BalancerArrayOutput) Index(i pulumi.IntInput) BalancerOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Balancer {
		return vs[0].([]*Balancer)[vs[1].(int)]
	}).(BalancerOutput)
}

type BalancerMapOutput struct{ *pulumi.OutputState }

func (BalancerMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Balancer)(nil)).Elem()
}

func (o BalancerMapOutput) ToBalancerMapOutput() BalancerMapOutput {
	return o
}

func (o BalancerMapOutput) ToBalancerMapOutputWithContext(ctx context.Context) BalancerMapOutput {
	return o
}

func (o BalancerMapOutput) MapIndex(k pulumi.StringInput) BalancerOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Balancer {
		return vs[0].(map[string]*Balancer)[vs[1].(string)]
	}).(BalancerOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*BalancerInput)(nil)).Elem(), &Balancer{})
	pulumi.RegisterInputType(reflect.TypeOf((*BalancerArrayInput)(nil)).Elem(), BalancerArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*BalancerMapInput)(nil)).Elem(), BalancerMap{})
	pulumi.RegisterOutputType(BalancerOutput{})
	pulumi.RegisterOutputType(BalancerArrayOutput{})
	pulumi.RegisterOutputType(BalancerMapOutput{})
}
