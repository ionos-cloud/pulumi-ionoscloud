// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package ionoscloud

import (
	"context"
	"reflect"

	"errors"
	"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages a **Network Load Balancer**  on IonosCloud.
//
// ## Example Usage
//
// <!--Start PulumiCodeChooser -->
// ```go
// package main
//
// import (
//
//	"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud"
//	"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			exampleDatacenter, err := compute.NewDatacenter(ctx, "exampleDatacenter", &compute.DatacenterArgs{
//				Location:          pulumi.String("us/las"),
//				Description:       pulumi.String("Datacenter Description"),
//				SecAuthProtection: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			example1, err := compute.NewLan(ctx, "example1", &compute.LanArgs{
//				DatacenterId: exampleDatacenter.ID(),
//				Public:       pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			example2, err := compute.NewLan(ctx, "example2", &compute.LanArgs{
//				DatacenterId: exampleDatacenter.ID(),
//				Public:       pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = ionoscloud.NewNetworkloadbalancer(ctx, "exampleNetworkloadbalancer", &ionoscloud.NetworkloadbalancerArgs{
//				DatacenterId: exampleDatacenter.ID(),
//				ListenerLan:  example1.ID(),
//				TargetLan:    example2.ID(),
//				Ips: pulumi.StringArray{
//					pulumi.String("10.12.118.224"),
//				},
//				LbPrivateIps: pulumi.StringArray{
//					pulumi.String("10.13.72.225/24"),
//				},
//				CentralLogging: pulumi.Bool(true),
//				LoggingFormat:  pulumi.String("%{+Q}o %{-Q}ci - - [%trg] %r %ST %B \"\" \"\" %cp %ms %ft %b %s %TR %Tw %Tc %Tr %Ta %tsc %ac %fc %bc %sc %rc %sq %bq %CC %CS %hrl %hsl"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// <!--End PulumiCodeChooser -->
//
// ## Example configuring Flowlog
//
// <!--Start PulumiCodeChooser -->
// ```go
// package main
//
// import (
//
//	"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := ionoscloud.NewNetworkloadbalancer(ctx, "example", &ionoscloud.NetworkloadbalancerArgs{
//				DatacenterId: pulumi.Any(ionoscloud_datacenter.Example.Id),
//				ListenerLan:  pulumi.Any(ionoscloud_lan.Example1.Id),
//				TargetLan:    pulumi.Any(ionoscloud_lan.Example2.Id),
//				Ips: pulumi.StringArray{
//					pulumi.String("10.12.118.224"),
//				},
//				LbPrivateIps: pulumi.StringArray{
//					pulumi.String("10.13.72.225/24"),
//				},
//				Flowlog: &ionoscloud.NetworkloadbalancerFlowlogArgs{
//					Action:    pulumi.String("ALL"),
//					Bucket:    pulumi.String("flowlog-bucket"),
//					Direction: pulumi.String("INGRESS"),
//					Name:      pulumi.String("flowlog"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// <!--End PulumiCodeChooser -->
//
// This will configure flowlog for ALL(rejected and accepted) ingress traffic and will log it into an existing ionos bucket named `flowlog-bucket`. Any s3 compatible client can be used to create it. Adding a flowlog does not force re-creation or the nic, but changing any other field than
// `name` will. Deleting a flowlog will also force nic re-creation.
//
// ## Import
//
// A Network Load Balancer resource can be imported using its `resource id` and the `datacenter id` e.g.
//
// ```sh
// $ pulumi import ionoscloud:index/networkloadbalancer:Networkloadbalancer my_networkloadbalancer {datacenter uuid}/{networkloadbalancer uuid}
// ```
type Networkloadbalancer struct {
	pulumi.CustomResourceState

	// [bool] Turn logging on and off for this product. Default value is 'false'.
	CentralLogging pulumi.BoolPtrOutput `pulumi:"centralLogging"`
	// [string] A Datacenter's UUID.
	DatacenterId pulumi.StringOutput `pulumi:"datacenterId"`
	// [list] Only 1 flow log can be configured. Only the name field can change as part of an update. Flow logs holistically capture network information such as source and destination IP addresses, source and destination ports, number of packets, amount of bytes, the start and end time of the recording, and the type of protocol – and log the extent to which your instances are being accessed.
	Flowlog NetworkloadbalancerFlowlogPtrOutput `pulumi:"flowlog"`
	// [list] Collection of IP addresses of the Network Load Balancer. (inbound and outbound) IP of the listenerLan must be a customer reserved IP for the public load balancer and private IP for the private load balancer.
	Ips pulumi.StringArrayOutput `pulumi:"ips"`
	// [list] Collection of private IP addresses with subnet mask of the Network Load Balancer. IPs must contain valid subnet mask. If user will not provide any IP then the system will generate one IP with /24 subnet.
	LbPrivateIps pulumi.StringArrayOutput `pulumi:"lbPrivateIps"`
	// [int] Id of the listening LAN. (inbound)
	ListenerLan pulumi.IntOutput `pulumi:"listenerLan"`
	// Specifies the format of the logs.
	LoggingFormat pulumi.StringPtrOutput `pulumi:"loggingFormat"`
	// [string] Specifies the name of the flow log.
	//
	// ⚠️ **Note:**: Removing the `flowlog` forces re-creation of the network load balancer resource.
	Name pulumi.StringOutput `pulumi:"name"`
	// [int] Id of the balanced private target LAN. (outbound)
	TargetLan pulumi.IntOutput `pulumi:"targetLan"`
}

// NewNetworkloadbalancer registers a new resource with the given unique name, arguments, and options.
func NewNetworkloadbalancer(ctx *pulumi.Context,
	name string, args *NetworkloadbalancerArgs, opts ...pulumi.ResourceOption) (*Networkloadbalancer, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.DatacenterId == nil {
		return nil, errors.New("invalid value for required argument 'DatacenterId'")
	}
	if args.ListenerLan == nil {
		return nil, errors.New("invalid value for required argument 'ListenerLan'")
	}
	if args.TargetLan == nil {
		return nil, errors.New("invalid value for required argument 'TargetLan'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Networkloadbalancer
	err := ctx.RegisterResource("ionoscloud:index/networkloadbalancer:Networkloadbalancer", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetNetworkloadbalancer gets an existing Networkloadbalancer resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetNetworkloadbalancer(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *NetworkloadbalancerState, opts ...pulumi.ResourceOption) (*Networkloadbalancer, error) {
	var resource Networkloadbalancer
	err := ctx.ReadResource("ionoscloud:index/networkloadbalancer:Networkloadbalancer", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Networkloadbalancer resources.
type networkloadbalancerState struct {
	// [bool] Turn logging on and off for this product. Default value is 'false'.
	CentralLogging *bool `pulumi:"centralLogging"`
	// [string] A Datacenter's UUID.
	DatacenterId *string `pulumi:"datacenterId"`
	// [list] Only 1 flow log can be configured. Only the name field can change as part of an update. Flow logs holistically capture network information such as source and destination IP addresses, source and destination ports, number of packets, amount of bytes, the start and end time of the recording, and the type of protocol – and log the extent to which your instances are being accessed.
	Flowlog *NetworkloadbalancerFlowlog `pulumi:"flowlog"`
	// [list] Collection of IP addresses of the Network Load Balancer. (inbound and outbound) IP of the listenerLan must be a customer reserved IP for the public load balancer and private IP for the private load balancer.
	Ips []string `pulumi:"ips"`
	// [list] Collection of private IP addresses with subnet mask of the Network Load Balancer. IPs must contain valid subnet mask. If user will not provide any IP then the system will generate one IP with /24 subnet.
	LbPrivateIps []string `pulumi:"lbPrivateIps"`
	// [int] Id of the listening LAN. (inbound)
	ListenerLan *int `pulumi:"listenerLan"`
	// Specifies the format of the logs.
	LoggingFormat *string `pulumi:"loggingFormat"`
	// [string] Specifies the name of the flow log.
	//
	// ⚠️ **Note:**: Removing the `flowlog` forces re-creation of the network load balancer resource.
	Name *string `pulumi:"name"`
	// [int] Id of the balanced private target LAN. (outbound)
	TargetLan *int `pulumi:"targetLan"`
}

type NetworkloadbalancerState struct {
	// [bool] Turn logging on and off for this product. Default value is 'false'.
	CentralLogging pulumi.BoolPtrInput
	// [string] A Datacenter's UUID.
	DatacenterId pulumi.StringPtrInput
	// [list] Only 1 flow log can be configured. Only the name field can change as part of an update. Flow logs holistically capture network information such as source and destination IP addresses, source and destination ports, number of packets, amount of bytes, the start and end time of the recording, and the type of protocol – and log the extent to which your instances are being accessed.
	Flowlog NetworkloadbalancerFlowlogPtrInput
	// [list] Collection of IP addresses of the Network Load Balancer. (inbound and outbound) IP of the listenerLan must be a customer reserved IP for the public load balancer and private IP for the private load balancer.
	Ips pulumi.StringArrayInput
	// [list] Collection of private IP addresses with subnet mask of the Network Load Balancer. IPs must contain valid subnet mask. If user will not provide any IP then the system will generate one IP with /24 subnet.
	LbPrivateIps pulumi.StringArrayInput
	// [int] Id of the listening LAN. (inbound)
	ListenerLan pulumi.IntPtrInput
	// Specifies the format of the logs.
	LoggingFormat pulumi.StringPtrInput
	// [string] Specifies the name of the flow log.
	//
	// ⚠️ **Note:**: Removing the `flowlog` forces re-creation of the network load balancer resource.
	Name pulumi.StringPtrInput
	// [int] Id of the balanced private target LAN. (outbound)
	TargetLan pulumi.IntPtrInput
}

func (NetworkloadbalancerState) ElementType() reflect.Type {
	return reflect.TypeOf((*networkloadbalancerState)(nil)).Elem()
}

type networkloadbalancerArgs struct {
	// [bool] Turn logging on and off for this product. Default value is 'false'.
	CentralLogging *bool `pulumi:"centralLogging"`
	// [string] A Datacenter's UUID.
	DatacenterId string `pulumi:"datacenterId"`
	// [list] Only 1 flow log can be configured. Only the name field can change as part of an update. Flow logs holistically capture network information such as source and destination IP addresses, source and destination ports, number of packets, amount of bytes, the start and end time of the recording, and the type of protocol – and log the extent to which your instances are being accessed.
	Flowlog *NetworkloadbalancerFlowlog `pulumi:"flowlog"`
	// [list] Collection of IP addresses of the Network Load Balancer. (inbound and outbound) IP of the listenerLan must be a customer reserved IP for the public load balancer and private IP for the private load balancer.
	Ips []string `pulumi:"ips"`
	// [list] Collection of private IP addresses with subnet mask of the Network Load Balancer. IPs must contain valid subnet mask. If user will not provide any IP then the system will generate one IP with /24 subnet.
	LbPrivateIps []string `pulumi:"lbPrivateIps"`
	// [int] Id of the listening LAN. (inbound)
	ListenerLan int `pulumi:"listenerLan"`
	// Specifies the format of the logs.
	LoggingFormat *string `pulumi:"loggingFormat"`
	// [string] Specifies the name of the flow log.
	//
	// ⚠️ **Note:**: Removing the `flowlog` forces re-creation of the network load balancer resource.
	Name *string `pulumi:"name"`
	// [int] Id of the balanced private target LAN. (outbound)
	TargetLan int `pulumi:"targetLan"`
}

// The set of arguments for constructing a Networkloadbalancer resource.
type NetworkloadbalancerArgs struct {
	// [bool] Turn logging on and off for this product. Default value is 'false'.
	CentralLogging pulumi.BoolPtrInput
	// [string] A Datacenter's UUID.
	DatacenterId pulumi.StringInput
	// [list] Only 1 flow log can be configured. Only the name field can change as part of an update. Flow logs holistically capture network information such as source and destination IP addresses, source and destination ports, number of packets, amount of bytes, the start and end time of the recording, and the type of protocol – and log the extent to which your instances are being accessed.
	Flowlog NetworkloadbalancerFlowlogPtrInput
	// [list] Collection of IP addresses of the Network Load Balancer. (inbound and outbound) IP of the listenerLan must be a customer reserved IP for the public load balancer and private IP for the private load balancer.
	Ips pulumi.StringArrayInput
	// [list] Collection of private IP addresses with subnet mask of the Network Load Balancer. IPs must contain valid subnet mask. If user will not provide any IP then the system will generate one IP with /24 subnet.
	LbPrivateIps pulumi.StringArrayInput
	// [int] Id of the listening LAN. (inbound)
	ListenerLan pulumi.IntInput
	// Specifies the format of the logs.
	LoggingFormat pulumi.StringPtrInput
	// [string] Specifies the name of the flow log.
	//
	// ⚠️ **Note:**: Removing the `flowlog` forces re-creation of the network load balancer resource.
	Name pulumi.StringPtrInput
	// [int] Id of the balanced private target LAN. (outbound)
	TargetLan pulumi.IntInput
}

func (NetworkloadbalancerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*networkloadbalancerArgs)(nil)).Elem()
}

type NetworkloadbalancerInput interface {
	pulumi.Input

	ToNetworkloadbalancerOutput() NetworkloadbalancerOutput
	ToNetworkloadbalancerOutputWithContext(ctx context.Context) NetworkloadbalancerOutput
}

func (*Networkloadbalancer) ElementType() reflect.Type {
	return reflect.TypeOf((**Networkloadbalancer)(nil)).Elem()
}

func (i *Networkloadbalancer) ToNetworkloadbalancerOutput() NetworkloadbalancerOutput {
	return i.ToNetworkloadbalancerOutputWithContext(context.Background())
}

func (i *Networkloadbalancer) ToNetworkloadbalancerOutputWithContext(ctx context.Context) NetworkloadbalancerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkloadbalancerOutput)
}

// NetworkloadbalancerArrayInput is an input type that accepts NetworkloadbalancerArray and NetworkloadbalancerArrayOutput values.
// You can construct a concrete instance of `NetworkloadbalancerArrayInput` via:
//
//	NetworkloadbalancerArray{ NetworkloadbalancerArgs{...} }
type NetworkloadbalancerArrayInput interface {
	pulumi.Input

	ToNetworkloadbalancerArrayOutput() NetworkloadbalancerArrayOutput
	ToNetworkloadbalancerArrayOutputWithContext(context.Context) NetworkloadbalancerArrayOutput
}

type NetworkloadbalancerArray []NetworkloadbalancerInput

func (NetworkloadbalancerArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Networkloadbalancer)(nil)).Elem()
}

func (i NetworkloadbalancerArray) ToNetworkloadbalancerArrayOutput() NetworkloadbalancerArrayOutput {
	return i.ToNetworkloadbalancerArrayOutputWithContext(context.Background())
}

func (i NetworkloadbalancerArray) ToNetworkloadbalancerArrayOutputWithContext(ctx context.Context) NetworkloadbalancerArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkloadbalancerArrayOutput)
}

// NetworkloadbalancerMapInput is an input type that accepts NetworkloadbalancerMap and NetworkloadbalancerMapOutput values.
// You can construct a concrete instance of `NetworkloadbalancerMapInput` via:
//
//	NetworkloadbalancerMap{ "key": NetworkloadbalancerArgs{...} }
type NetworkloadbalancerMapInput interface {
	pulumi.Input

	ToNetworkloadbalancerMapOutput() NetworkloadbalancerMapOutput
	ToNetworkloadbalancerMapOutputWithContext(context.Context) NetworkloadbalancerMapOutput
}

type NetworkloadbalancerMap map[string]NetworkloadbalancerInput

func (NetworkloadbalancerMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Networkloadbalancer)(nil)).Elem()
}

func (i NetworkloadbalancerMap) ToNetworkloadbalancerMapOutput() NetworkloadbalancerMapOutput {
	return i.ToNetworkloadbalancerMapOutputWithContext(context.Background())
}

func (i NetworkloadbalancerMap) ToNetworkloadbalancerMapOutputWithContext(ctx context.Context) NetworkloadbalancerMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkloadbalancerMapOutput)
}

type NetworkloadbalancerOutput struct{ *pulumi.OutputState }

func (NetworkloadbalancerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Networkloadbalancer)(nil)).Elem()
}

func (o NetworkloadbalancerOutput) ToNetworkloadbalancerOutput() NetworkloadbalancerOutput {
	return o
}

func (o NetworkloadbalancerOutput) ToNetworkloadbalancerOutputWithContext(ctx context.Context) NetworkloadbalancerOutput {
	return o
}

// [bool] Turn logging on and off for this product. Default value is 'false'.
func (o NetworkloadbalancerOutput) CentralLogging() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Networkloadbalancer) pulumi.BoolPtrOutput { return v.CentralLogging }).(pulumi.BoolPtrOutput)
}

// [string] A Datacenter's UUID.
func (o NetworkloadbalancerOutput) DatacenterId() pulumi.StringOutput {
	return o.ApplyT(func(v *Networkloadbalancer) pulumi.StringOutput { return v.DatacenterId }).(pulumi.StringOutput)
}

// [list] Only 1 flow log can be configured. Only the name field can change as part of an update. Flow logs holistically capture network information such as source and destination IP addresses, source and destination ports, number of packets, amount of bytes, the start and end time of the recording, and the type of protocol – and log the extent to which your instances are being accessed.
func (o NetworkloadbalancerOutput) Flowlog() NetworkloadbalancerFlowlogPtrOutput {
	return o.ApplyT(func(v *Networkloadbalancer) NetworkloadbalancerFlowlogPtrOutput { return v.Flowlog }).(NetworkloadbalancerFlowlogPtrOutput)
}

// [list] Collection of IP addresses of the Network Load Balancer. (inbound and outbound) IP of the listenerLan must be a customer reserved IP for the public load balancer and private IP for the private load balancer.
func (o NetworkloadbalancerOutput) Ips() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Networkloadbalancer) pulumi.StringArrayOutput { return v.Ips }).(pulumi.StringArrayOutput)
}

// [list] Collection of private IP addresses with subnet mask of the Network Load Balancer. IPs must contain valid subnet mask. If user will not provide any IP then the system will generate one IP with /24 subnet.
func (o NetworkloadbalancerOutput) LbPrivateIps() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Networkloadbalancer) pulumi.StringArrayOutput { return v.LbPrivateIps }).(pulumi.StringArrayOutput)
}

// [int] Id of the listening LAN. (inbound)
func (o NetworkloadbalancerOutput) ListenerLan() pulumi.IntOutput {
	return o.ApplyT(func(v *Networkloadbalancer) pulumi.IntOutput { return v.ListenerLan }).(pulumi.IntOutput)
}

// Specifies the format of the logs.
func (o NetworkloadbalancerOutput) LoggingFormat() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Networkloadbalancer) pulumi.StringPtrOutput { return v.LoggingFormat }).(pulumi.StringPtrOutput)
}

// [string] Specifies the name of the flow log.
//
// ⚠️ **Note:**: Removing the `flowlog` forces re-creation of the network load balancer resource.
func (o NetworkloadbalancerOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Networkloadbalancer) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// [int] Id of the balanced private target LAN. (outbound)
func (o NetworkloadbalancerOutput) TargetLan() pulumi.IntOutput {
	return o.ApplyT(func(v *Networkloadbalancer) pulumi.IntOutput { return v.TargetLan }).(pulumi.IntOutput)
}

type NetworkloadbalancerArrayOutput struct{ *pulumi.OutputState }

func (NetworkloadbalancerArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Networkloadbalancer)(nil)).Elem()
}

func (o NetworkloadbalancerArrayOutput) ToNetworkloadbalancerArrayOutput() NetworkloadbalancerArrayOutput {
	return o
}

func (o NetworkloadbalancerArrayOutput) ToNetworkloadbalancerArrayOutputWithContext(ctx context.Context) NetworkloadbalancerArrayOutput {
	return o
}

func (o NetworkloadbalancerArrayOutput) Index(i pulumi.IntInput) NetworkloadbalancerOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Networkloadbalancer {
		return vs[0].([]*Networkloadbalancer)[vs[1].(int)]
	}).(NetworkloadbalancerOutput)
}

type NetworkloadbalancerMapOutput struct{ *pulumi.OutputState }

func (NetworkloadbalancerMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Networkloadbalancer)(nil)).Elem()
}

func (o NetworkloadbalancerMapOutput) ToNetworkloadbalancerMapOutput() NetworkloadbalancerMapOutput {
	return o
}

func (o NetworkloadbalancerMapOutput) ToNetworkloadbalancerMapOutputWithContext(ctx context.Context) NetworkloadbalancerMapOutput {
	return o
}

func (o NetworkloadbalancerMapOutput) MapIndex(k pulumi.StringInput) NetworkloadbalancerOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Networkloadbalancer {
		return vs[0].(map[string]*Networkloadbalancer)[vs[1].(string)]
	}).(NetworkloadbalancerOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkloadbalancerInput)(nil)).Elem(), &Networkloadbalancer{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkloadbalancerArrayInput)(nil)).Elem(), NetworkloadbalancerArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkloadbalancerMapInput)(nil)).Elem(), NetworkloadbalancerMap{})
	pulumi.RegisterOutputType(NetworkloadbalancerOutput{})
	pulumi.RegisterOutputType(NetworkloadbalancerArrayOutput{})
	pulumi.RegisterOutputType(NetworkloadbalancerMapOutput{})
}
