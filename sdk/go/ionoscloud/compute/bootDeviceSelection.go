// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package compute

import (
	"context"
	"reflect"

	"errors"
	"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages the selection of a boot device for IonosCloud Servers.
//
// ## Example Usage
//
// The boot device of a `compute.Server`, `compute.VCPUServer` or `compute.CubeServer` can be selected with this resource.
// Deleting this resource will revert the boot device back to the default volume, which is the first inline volume created together with the server.
// This resource also allows switching between a `volume` and a `getImage` CDROM. Note that CDROM images are detached after they are no longer set as boot devices.
//
// ### Select an external volume
// <!--Start PulumiCodeChooser -->
// ```go
// package main
//
// import (
//
//	"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			exampleServer, err := compute.NewServer(ctx, "exampleServer", &compute.ServerArgs{
//				AvailabilityZone: pulumi.String("ZONE_2"),
//				ImageName:        pulumi.String("ubuntu:latest"),
//				Cores:            pulumi.Int(2),
//				Ram:              pulumi.Int(2048),
//				ImagePassword:    pulumi.Any(random_password.Server_image_password.Result),
//				DatacenterId:     pulumi.Any(ionoscloud_datacenter.Example.Id),
//				Volume: &compute.ServerVolumeArgs{
//					Name:             pulumi.String("Inline Updated"),
//					Size:             pulumi.Int(20),
//					DiskType:         pulumi.String("SSD Standard"),
//					Bus:              pulumi.String("VIRTIO"),
//					AvailabilityZone: pulumi.String("AUTO"),
//				},
//				Nic: &compute.ServerNicArgs{
//					Lan:            pulumi.Any(ionoscloud_lan.Example.Id),
//					Name:           pulumi.String("Nic Example"),
//					Dhcp:           pulumi.Bool(true),
//					FirewallActive: pulumi.Bool(true),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			exampleVolume, err := compute.NewVolume(ctx, "exampleVolume", &compute.VolumeArgs{
//				ServerId:         exampleServer.ID(),
//				DatacenterId:     pulumi.Any(ionoscloud_datacenter.Example.Id),
//				Size:             pulumi.Int(10),
//				DiskType:         pulumi.String("HDD"),
//				AvailabilityZone: pulumi.String("AUTO"),
//				ImageName:        pulumi.String("debian:latest"),
//				ImagePassword:    pulumi.Any(random_password.Server_image_password.Result),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewBootDeviceSelection(ctx, "exampleBootDeviceSelection", &compute.BootDeviceSelectionArgs{
//				DatacenterId: pulumi.Any(ionoscloud_datacenter.Example.Id),
//				ServerId:     exampleServer.ID(),
//				BootDeviceId: exampleVolume.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// <!--End PulumiCodeChooser -->
//
// ### Select an inline volume again
// <!--Start PulumiCodeChooser -->
// ```go
// package main
//
// import (
//
//	"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			exampleServer, err := compute.NewServer(ctx, "exampleServer", &compute.ServerArgs{
//				AvailabilityZone: pulumi.String("ZONE_2"),
//				ImageName:        pulumi.String("ubuntu:latest"),
//				Cores:            pulumi.Int(2),
//				Ram:              pulumi.Int(2048),
//				ImagePassword:    pulumi.Any(random_password.Server_image_password.Result),
//				DatacenterId:     pulumi.Any(ionoscloud_datacenter.Example.Id),
//				Volume: &compute.ServerVolumeArgs{
//					Name:             pulumi.String("Inline Updated"),
//					Size:             pulumi.Int(20),
//					DiskType:         pulumi.String("SSD Standard"),
//					Bus:              pulumi.String("VIRTIO"),
//					AvailabilityZone: pulumi.String("AUTO"),
//				},
//				Nic: &compute.ServerNicArgs{
//					Lan:            pulumi.Any(ionoscloud_lan.Example.Id),
//					Name:           pulumi.String("Nic Example"),
//					Dhcp:           pulumi.Bool(true),
//					FirewallActive: pulumi.Bool(true),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewBootDeviceSelection(ctx, "exampleBootDeviceSelection", &compute.BootDeviceSelectionArgs{
//				DatacenterId: pulumi.Any(ionoscloud_datacenter.Example.Id),
//				ServerId:     exampleServer.ID(),
//				BootDeviceId: exampleServer.InlineVolumeIds.ApplyT(func(inlineVolumeIds []string) (string, error) {
//					return inlineVolumeIds[0], nil
//				}).(pulumi.StringOutput),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewVolume(ctx, "exampleVolume", &compute.VolumeArgs{
//				ServerId:         exampleServer.ID(),
//				DatacenterId:     pulumi.Any(ionoscloud_datacenter.Example.Id),
//				Size:             pulumi.Int(10),
//				DiskType:         pulumi.String("HDD"),
//				AvailabilityZone: pulumi.String("AUTO"),
//				ImageName:        pulumi.String("debian:latest"),
//				ImagePassword:    pulumi.Any(random_password.Server_image_password.Result),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// <!--End PulumiCodeChooser -->
//
// ### Select a CDROM image
// <!--Start PulumiCodeChooser -->
// ```go
// package main
//
// import (
//
//	"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud"
//	"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			exampleServer, err := compute.NewServer(ctx, "exampleServer", &compute.ServerArgs{
//				AvailabilityZone: pulumi.String("ZONE_2"),
//				ImageName:        pulumi.String("ubuntu:latest"),
//				Cores:            pulumi.Int(2),
//				Ram:              pulumi.Int(2048),
//				ImagePassword:    pulumi.Any(random_password.Server_image_password.Result),
//				DatacenterId:     pulumi.Any(ionoscloud_datacenter.Example.Id),
//				Volume: &compute.ServerVolumeArgs{
//					Name:             pulumi.String("Inline Updated"),
//					Size:             pulumi.Int(20),
//					DiskType:         pulumi.String("SSD Standard"),
//					Bus:              pulumi.String("VIRTIO"),
//					AvailabilityZone: pulumi.String("AUTO"),
//				},
//				Nic: &compute.ServerNicArgs{
//					Lan:            pulumi.Any(ionoscloud_lan.Example.Id),
//					Name:           pulumi.String("Nic Example"),
//					Dhcp:           pulumi.Bool(true),
//					FirewallActive: pulumi.Bool(true),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			exampleImage, err := ionoscloud.GetImage(ctx, &ionoscloud.GetImageArgs{
//				Name:     pulumi.StringRef("ubuntu-20.04"),
//				Location: pulumi.StringRef("de/txl"),
//				Type:     pulumi.StringRef("CDROM"),
//			}, nil)
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewBootDeviceSelection(ctx, "exampleBootDeviceSelection", &compute.BootDeviceSelectionArgs{
//				DatacenterId: pulumi.Any(ionoscloud_datacenter.Example.Id),
//				ServerId: exampleServer.InlineVolumeIds.ApplyT(func(inlineVolumeIds []string) (string, error) {
//					return inlineVolumeIds[0], nil
//				}).(pulumi.StringOutput),
//				BootDeviceId: pulumi.String(exampleImage.Id),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewVolume(ctx, "exampleVolume", &compute.VolumeArgs{
//				ServerId:         exampleServer.ID(),
//				DatacenterId:     pulumi.Any(ionoscloud_datacenter.Example.Id),
//				Size:             pulumi.Int(10),
//				DiskType:         pulumi.String("HDD"),
//				AvailabilityZone: pulumi.String("AUTO"),
//				ImageName:        pulumi.String("debian:latest"),
//				ImagePassword:    pulumi.Any(random_password.Server_image_password.Result),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// <!--End PulumiCodeChooser -->
//
// ### Perform a network boot
// <!--Start PulumiCodeChooser -->
// ```go
// package main
//
// import (
//
//	"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud"
//	"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			exampleServer, err := compute.NewServer(ctx, "exampleServer", &compute.ServerArgs{
//				AvailabilityZone: pulumi.String("ZONE_2"),
//				ImageName:        pulumi.String("ubuntu:latest"),
//				Cores:            pulumi.Int(2),
//				Ram:              pulumi.Int(2048),
//				ImagePassword:    pulumi.Any(random_password.Server_image_password.Result),
//				DatacenterId:     pulumi.Any(ionoscloud_datacenter.Example.Id),
//				Volume: &compute.ServerVolumeArgs{
//					Name:             pulumi.String("Inline volume"),
//					Size:             pulumi.Int(20),
//					DiskType:         pulumi.String("SSD Standard"),
//					Bus:              pulumi.String("VIRTIO"),
//					AvailabilityZone: pulumi.String("AUTO"),
//				},
//				Nic: &compute.ServerNicArgs{
//					Lan:            pulumi.Any(ionoscloud_lan.Example.Id),
//					Name:           pulumi.String("Nic Example"),
//					Dhcp:           pulumi.Bool(true),
//					FirewallActive: pulumi.Bool(true),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewBootDeviceSelection(ctx, "exampleBootDeviceSelection", &compute.BootDeviceSelectionArgs{
//				DatacenterId: pulumi.Any(ionoscloud_datacenter.Example.Id),
//				ServerId: exampleServer.InlineVolumeIds.ApplyT(func(inlineVolumeIds []string) (string, error) {
//					return inlineVolumeIds[0], nil
//				}).(pulumi.StringOutput),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewVolume(ctx, "exampleVolume", &compute.VolumeArgs{
//				ServerId:         exampleServer.ID(),
//				DatacenterId:     pulumi.Any(ionoscloud_datacenter.Example.Id),
//				Size:             pulumi.Int(10),
//				DiskType:         pulumi.String("HDD"),
//				AvailabilityZone: pulumi.String("AUTO"),
//				ImageName:        pulumi.String("debian:latest"),
//				ImagePassword:    pulumi.Any(random_password.Server_image_password.Result),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = ionoscloud.GetImage(ctx, &ionoscloud.GetImageArgs{
//				Name:     pulumi.StringRef("ubuntu-20.04"),
//				Location: pulumi.StringRef("de/txl"),
//				Type:     pulumi.StringRef("CDROM"),
//			}, nil)
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// <!--End PulumiCodeChooser -->
type BootDeviceSelection struct {
	pulumi.CustomResourceState

	// [string] The ID of a bootable device such as a volume or an image data source. If this field is omitted from the configuration, the VM will be restarted with no primary boot device, and it will enter the PXE shell for network booting.
	// ***Note***: If the network booting process started by the PXE shell fails, the VM will still boot into the image of the attached storage as a fallback. This behavior imitates the "Boot from Network" option from [DCD](https://dcd.ionos.com/).
	BootDeviceId pulumi.StringPtrOutput `pulumi:"bootDeviceId"`
	// [string] The ID of a Virtual Data Center.
	DatacenterId pulumi.StringOutput `pulumi:"datacenterId"`
	// ID of the first attached volume of the Server, which will be the default boot volume.
	DefaultBootVolumeId pulumi.StringOutput `pulumi:"defaultBootVolumeId"`
	// [string] The ID of a server.
	ServerId pulumi.StringOutput `pulumi:"serverId"`
}

// NewBootDeviceSelection registers a new resource with the given unique name, arguments, and options.
func NewBootDeviceSelection(ctx *pulumi.Context,
	name string, args *BootDeviceSelectionArgs, opts ...pulumi.ResourceOption) (*BootDeviceSelection, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.DatacenterId == nil {
		return nil, errors.New("invalid value for required argument 'DatacenterId'")
	}
	if args.ServerId == nil {
		return nil, errors.New("invalid value for required argument 'ServerId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource BootDeviceSelection
	err := ctx.RegisterResource("ionoscloud:compute/bootDeviceSelection:BootDeviceSelection", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetBootDeviceSelection gets an existing BootDeviceSelection resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetBootDeviceSelection(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *BootDeviceSelectionState, opts ...pulumi.ResourceOption) (*BootDeviceSelection, error) {
	var resource BootDeviceSelection
	err := ctx.ReadResource("ionoscloud:compute/bootDeviceSelection:BootDeviceSelection", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering BootDeviceSelection resources.
type bootDeviceSelectionState struct {
	// [string] The ID of a bootable device such as a volume or an image data source. If this field is omitted from the configuration, the VM will be restarted with no primary boot device, and it will enter the PXE shell for network booting.
	// ***Note***: If the network booting process started by the PXE shell fails, the VM will still boot into the image of the attached storage as a fallback. This behavior imitates the "Boot from Network" option from [DCD](https://dcd.ionos.com/).
	BootDeviceId *string `pulumi:"bootDeviceId"`
	// [string] The ID of a Virtual Data Center.
	DatacenterId *string `pulumi:"datacenterId"`
	// ID of the first attached volume of the Server, which will be the default boot volume.
	DefaultBootVolumeId *string `pulumi:"defaultBootVolumeId"`
	// [string] The ID of a server.
	ServerId *string `pulumi:"serverId"`
}

type BootDeviceSelectionState struct {
	// [string] The ID of a bootable device such as a volume or an image data source. If this field is omitted from the configuration, the VM will be restarted with no primary boot device, and it will enter the PXE shell for network booting.
	// ***Note***: If the network booting process started by the PXE shell fails, the VM will still boot into the image of the attached storage as a fallback. This behavior imitates the "Boot from Network" option from [DCD](https://dcd.ionos.com/).
	BootDeviceId pulumi.StringPtrInput
	// [string] The ID of a Virtual Data Center.
	DatacenterId pulumi.StringPtrInput
	// ID of the first attached volume of the Server, which will be the default boot volume.
	DefaultBootVolumeId pulumi.StringPtrInput
	// [string] The ID of a server.
	ServerId pulumi.StringPtrInput
}

func (BootDeviceSelectionState) ElementType() reflect.Type {
	return reflect.TypeOf((*bootDeviceSelectionState)(nil)).Elem()
}

type bootDeviceSelectionArgs struct {
	// [string] The ID of a bootable device such as a volume or an image data source. If this field is omitted from the configuration, the VM will be restarted with no primary boot device, and it will enter the PXE shell for network booting.
	// ***Note***: If the network booting process started by the PXE shell fails, the VM will still boot into the image of the attached storage as a fallback. This behavior imitates the "Boot from Network" option from [DCD](https://dcd.ionos.com/).
	BootDeviceId *string `pulumi:"bootDeviceId"`
	// [string] The ID of a Virtual Data Center.
	DatacenterId string `pulumi:"datacenterId"`
	// [string] The ID of a server.
	ServerId string `pulumi:"serverId"`
}

// The set of arguments for constructing a BootDeviceSelection resource.
type BootDeviceSelectionArgs struct {
	// [string] The ID of a bootable device such as a volume or an image data source. If this field is omitted from the configuration, the VM will be restarted with no primary boot device, and it will enter the PXE shell for network booting.
	// ***Note***: If the network booting process started by the PXE shell fails, the VM will still boot into the image of the attached storage as a fallback. This behavior imitates the "Boot from Network" option from [DCD](https://dcd.ionos.com/).
	BootDeviceId pulumi.StringPtrInput
	// [string] The ID of a Virtual Data Center.
	DatacenterId pulumi.StringInput
	// [string] The ID of a server.
	ServerId pulumi.StringInput
}

func (BootDeviceSelectionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*bootDeviceSelectionArgs)(nil)).Elem()
}

type BootDeviceSelectionInput interface {
	pulumi.Input

	ToBootDeviceSelectionOutput() BootDeviceSelectionOutput
	ToBootDeviceSelectionOutputWithContext(ctx context.Context) BootDeviceSelectionOutput
}

func (*BootDeviceSelection) ElementType() reflect.Type {
	return reflect.TypeOf((**BootDeviceSelection)(nil)).Elem()
}

func (i *BootDeviceSelection) ToBootDeviceSelectionOutput() BootDeviceSelectionOutput {
	return i.ToBootDeviceSelectionOutputWithContext(context.Background())
}

func (i *BootDeviceSelection) ToBootDeviceSelectionOutputWithContext(ctx context.Context) BootDeviceSelectionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BootDeviceSelectionOutput)
}

// BootDeviceSelectionArrayInput is an input type that accepts BootDeviceSelectionArray and BootDeviceSelectionArrayOutput values.
// You can construct a concrete instance of `BootDeviceSelectionArrayInput` via:
//
//	BootDeviceSelectionArray{ BootDeviceSelectionArgs{...} }
type BootDeviceSelectionArrayInput interface {
	pulumi.Input

	ToBootDeviceSelectionArrayOutput() BootDeviceSelectionArrayOutput
	ToBootDeviceSelectionArrayOutputWithContext(context.Context) BootDeviceSelectionArrayOutput
}

type BootDeviceSelectionArray []BootDeviceSelectionInput

func (BootDeviceSelectionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*BootDeviceSelection)(nil)).Elem()
}

func (i BootDeviceSelectionArray) ToBootDeviceSelectionArrayOutput() BootDeviceSelectionArrayOutput {
	return i.ToBootDeviceSelectionArrayOutputWithContext(context.Background())
}

func (i BootDeviceSelectionArray) ToBootDeviceSelectionArrayOutputWithContext(ctx context.Context) BootDeviceSelectionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BootDeviceSelectionArrayOutput)
}

// BootDeviceSelectionMapInput is an input type that accepts BootDeviceSelectionMap and BootDeviceSelectionMapOutput values.
// You can construct a concrete instance of `BootDeviceSelectionMapInput` via:
//
//	BootDeviceSelectionMap{ "key": BootDeviceSelectionArgs{...} }
type BootDeviceSelectionMapInput interface {
	pulumi.Input

	ToBootDeviceSelectionMapOutput() BootDeviceSelectionMapOutput
	ToBootDeviceSelectionMapOutputWithContext(context.Context) BootDeviceSelectionMapOutput
}

type BootDeviceSelectionMap map[string]BootDeviceSelectionInput

func (BootDeviceSelectionMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*BootDeviceSelection)(nil)).Elem()
}

func (i BootDeviceSelectionMap) ToBootDeviceSelectionMapOutput() BootDeviceSelectionMapOutput {
	return i.ToBootDeviceSelectionMapOutputWithContext(context.Background())
}

func (i BootDeviceSelectionMap) ToBootDeviceSelectionMapOutputWithContext(ctx context.Context) BootDeviceSelectionMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BootDeviceSelectionMapOutput)
}

type BootDeviceSelectionOutput struct{ *pulumi.OutputState }

func (BootDeviceSelectionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BootDeviceSelection)(nil)).Elem()
}

func (o BootDeviceSelectionOutput) ToBootDeviceSelectionOutput() BootDeviceSelectionOutput {
	return o
}

func (o BootDeviceSelectionOutput) ToBootDeviceSelectionOutputWithContext(ctx context.Context) BootDeviceSelectionOutput {
	return o
}

// [string] The ID of a bootable device such as a volume or an image data source. If this field is omitted from the configuration, the VM will be restarted with no primary boot device, and it will enter the PXE shell for network booting.
// ***Note***: If the network booting process started by the PXE shell fails, the VM will still boot into the image of the attached storage as a fallback. This behavior imitates the "Boot from Network" option from [DCD](https://dcd.ionos.com/).
func (o BootDeviceSelectionOutput) BootDeviceId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BootDeviceSelection) pulumi.StringPtrOutput { return v.BootDeviceId }).(pulumi.StringPtrOutput)
}

// [string] The ID of a Virtual Data Center.
func (o BootDeviceSelectionOutput) DatacenterId() pulumi.StringOutput {
	return o.ApplyT(func(v *BootDeviceSelection) pulumi.StringOutput { return v.DatacenterId }).(pulumi.StringOutput)
}

// ID of the first attached volume of the Server, which will be the default boot volume.
func (o BootDeviceSelectionOutput) DefaultBootVolumeId() pulumi.StringOutput {
	return o.ApplyT(func(v *BootDeviceSelection) pulumi.StringOutput { return v.DefaultBootVolumeId }).(pulumi.StringOutput)
}

// [string] The ID of a server.
func (o BootDeviceSelectionOutput) ServerId() pulumi.StringOutput {
	return o.ApplyT(func(v *BootDeviceSelection) pulumi.StringOutput { return v.ServerId }).(pulumi.StringOutput)
}

type BootDeviceSelectionArrayOutput struct{ *pulumi.OutputState }

func (BootDeviceSelectionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*BootDeviceSelection)(nil)).Elem()
}

func (o BootDeviceSelectionArrayOutput) ToBootDeviceSelectionArrayOutput() BootDeviceSelectionArrayOutput {
	return o
}

func (o BootDeviceSelectionArrayOutput) ToBootDeviceSelectionArrayOutputWithContext(ctx context.Context) BootDeviceSelectionArrayOutput {
	return o
}

func (o BootDeviceSelectionArrayOutput) Index(i pulumi.IntInput) BootDeviceSelectionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *BootDeviceSelection {
		return vs[0].([]*BootDeviceSelection)[vs[1].(int)]
	}).(BootDeviceSelectionOutput)
}

type BootDeviceSelectionMapOutput struct{ *pulumi.OutputState }

func (BootDeviceSelectionMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*BootDeviceSelection)(nil)).Elem()
}

func (o BootDeviceSelectionMapOutput) ToBootDeviceSelectionMapOutput() BootDeviceSelectionMapOutput {
	return o
}

func (o BootDeviceSelectionMapOutput) ToBootDeviceSelectionMapOutputWithContext(ctx context.Context) BootDeviceSelectionMapOutput {
	return o
}

func (o BootDeviceSelectionMapOutput) MapIndex(k pulumi.StringInput) BootDeviceSelectionOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *BootDeviceSelection {
		return vs[0].(map[string]*BootDeviceSelection)[vs[1].(string)]
	}).(BootDeviceSelectionOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*BootDeviceSelectionInput)(nil)).Elem(), &BootDeviceSelection{})
	pulumi.RegisterInputType(reflect.TypeOf((*BootDeviceSelectionArrayInput)(nil)).Elem(), BootDeviceSelectionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*BootDeviceSelectionMapInput)(nil)).Elem(), BootDeviceSelectionMap{})
	pulumi.RegisterOutputType(BootDeviceSelectionOutput{})
	pulumi.RegisterOutputType(BootDeviceSelectionArrayOutput{})
	pulumi.RegisterOutputType(BootDeviceSelectionMapOutput{})
}
