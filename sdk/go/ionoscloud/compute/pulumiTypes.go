// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package compute

import (
	"context"
	"reflect"

	"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = internal.GetEnvOrDefault

type CrossconnectConnectableDatacenter struct {
	// The UUID of the connectable datacenter
	Id *string `pulumi:"id"`
	// The physical location of the connectable datacenter
	Location *string `pulumi:"location"`
	// [string] The name of the cross-connection.
	Name *string `pulumi:"name"`
}

// CrossconnectConnectableDatacenterInput is an input type that accepts CrossconnectConnectableDatacenterArgs and CrossconnectConnectableDatacenterOutput values.
// You can construct a concrete instance of `CrossconnectConnectableDatacenterInput` via:
//
//	CrossconnectConnectableDatacenterArgs{...}
type CrossconnectConnectableDatacenterInput interface {
	pulumi.Input

	ToCrossconnectConnectableDatacenterOutput() CrossconnectConnectableDatacenterOutput
	ToCrossconnectConnectableDatacenterOutputWithContext(context.Context) CrossconnectConnectableDatacenterOutput
}

type CrossconnectConnectableDatacenterArgs struct {
	// The UUID of the connectable datacenter
	Id pulumi.StringPtrInput `pulumi:"id"`
	// The physical location of the connectable datacenter
	Location pulumi.StringPtrInput `pulumi:"location"`
	// [string] The name of the cross-connection.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (CrossconnectConnectableDatacenterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CrossconnectConnectableDatacenter)(nil)).Elem()
}

func (i CrossconnectConnectableDatacenterArgs) ToCrossconnectConnectableDatacenterOutput() CrossconnectConnectableDatacenterOutput {
	return i.ToCrossconnectConnectableDatacenterOutputWithContext(context.Background())
}

func (i CrossconnectConnectableDatacenterArgs) ToCrossconnectConnectableDatacenterOutputWithContext(ctx context.Context) CrossconnectConnectableDatacenterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CrossconnectConnectableDatacenterOutput)
}

// CrossconnectConnectableDatacenterArrayInput is an input type that accepts CrossconnectConnectableDatacenterArray and CrossconnectConnectableDatacenterArrayOutput values.
// You can construct a concrete instance of `CrossconnectConnectableDatacenterArrayInput` via:
//
//	CrossconnectConnectableDatacenterArray{ CrossconnectConnectableDatacenterArgs{...} }
type CrossconnectConnectableDatacenterArrayInput interface {
	pulumi.Input

	ToCrossconnectConnectableDatacenterArrayOutput() CrossconnectConnectableDatacenterArrayOutput
	ToCrossconnectConnectableDatacenterArrayOutputWithContext(context.Context) CrossconnectConnectableDatacenterArrayOutput
}

type CrossconnectConnectableDatacenterArray []CrossconnectConnectableDatacenterInput

func (CrossconnectConnectableDatacenterArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CrossconnectConnectableDatacenter)(nil)).Elem()
}

func (i CrossconnectConnectableDatacenterArray) ToCrossconnectConnectableDatacenterArrayOutput() CrossconnectConnectableDatacenterArrayOutput {
	return i.ToCrossconnectConnectableDatacenterArrayOutputWithContext(context.Background())
}

func (i CrossconnectConnectableDatacenterArray) ToCrossconnectConnectableDatacenterArrayOutputWithContext(ctx context.Context) CrossconnectConnectableDatacenterArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CrossconnectConnectableDatacenterArrayOutput)
}

type CrossconnectConnectableDatacenterOutput struct{ *pulumi.OutputState }

func (CrossconnectConnectableDatacenterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CrossconnectConnectableDatacenter)(nil)).Elem()
}

func (o CrossconnectConnectableDatacenterOutput) ToCrossconnectConnectableDatacenterOutput() CrossconnectConnectableDatacenterOutput {
	return o
}

func (o CrossconnectConnectableDatacenterOutput) ToCrossconnectConnectableDatacenterOutputWithContext(ctx context.Context) CrossconnectConnectableDatacenterOutput {
	return o
}

// The UUID of the connectable datacenter
func (o CrossconnectConnectableDatacenterOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CrossconnectConnectableDatacenter) *string { return v.Id }).(pulumi.StringPtrOutput)
}

// The physical location of the connectable datacenter
func (o CrossconnectConnectableDatacenterOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CrossconnectConnectableDatacenter) *string { return v.Location }).(pulumi.StringPtrOutput)
}

// [string] The name of the cross-connection.
func (o CrossconnectConnectableDatacenterOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CrossconnectConnectableDatacenter) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type CrossconnectConnectableDatacenterArrayOutput struct{ *pulumi.OutputState }

func (CrossconnectConnectableDatacenterArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CrossconnectConnectableDatacenter)(nil)).Elem()
}

func (o CrossconnectConnectableDatacenterArrayOutput) ToCrossconnectConnectableDatacenterArrayOutput() CrossconnectConnectableDatacenterArrayOutput {
	return o
}

func (o CrossconnectConnectableDatacenterArrayOutput) ToCrossconnectConnectableDatacenterArrayOutputWithContext(ctx context.Context) CrossconnectConnectableDatacenterArrayOutput {
	return o
}

func (o CrossconnectConnectableDatacenterArrayOutput) Index(i pulumi.IntInput) CrossconnectConnectableDatacenterOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) CrossconnectConnectableDatacenter {
		return vs[0].([]CrossconnectConnectableDatacenter)[vs[1].(int)]
	}).(CrossconnectConnectableDatacenterOutput)
}

type CrossconnectPeer struct {
	// The id of the cross-connected datacenter
	DatacenterId *string `pulumi:"datacenterId"`
	// The name of the cross-connected datacenter
	DatacenterName *string `pulumi:"datacenterName"`
	// The id of the cross-connected LAN
	LanId *string `pulumi:"lanId"`
	// The name of the cross-connected LAN
	LanName *string `pulumi:"lanName"`
	// The location of the cross-connected datacenter
	Location *string `pulumi:"location"`
}

// CrossconnectPeerInput is an input type that accepts CrossconnectPeerArgs and CrossconnectPeerOutput values.
// You can construct a concrete instance of `CrossconnectPeerInput` via:
//
//	CrossconnectPeerArgs{...}
type CrossconnectPeerInput interface {
	pulumi.Input

	ToCrossconnectPeerOutput() CrossconnectPeerOutput
	ToCrossconnectPeerOutputWithContext(context.Context) CrossconnectPeerOutput
}

type CrossconnectPeerArgs struct {
	// The id of the cross-connected datacenter
	DatacenterId pulumi.StringPtrInput `pulumi:"datacenterId"`
	// The name of the cross-connected datacenter
	DatacenterName pulumi.StringPtrInput `pulumi:"datacenterName"`
	// The id of the cross-connected LAN
	LanId pulumi.StringPtrInput `pulumi:"lanId"`
	// The name of the cross-connected LAN
	LanName pulumi.StringPtrInput `pulumi:"lanName"`
	// The location of the cross-connected datacenter
	Location pulumi.StringPtrInput `pulumi:"location"`
}

func (CrossconnectPeerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CrossconnectPeer)(nil)).Elem()
}

func (i CrossconnectPeerArgs) ToCrossconnectPeerOutput() CrossconnectPeerOutput {
	return i.ToCrossconnectPeerOutputWithContext(context.Background())
}

func (i CrossconnectPeerArgs) ToCrossconnectPeerOutputWithContext(ctx context.Context) CrossconnectPeerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CrossconnectPeerOutput)
}

// CrossconnectPeerArrayInput is an input type that accepts CrossconnectPeerArray and CrossconnectPeerArrayOutput values.
// You can construct a concrete instance of `CrossconnectPeerArrayInput` via:
//
//	CrossconnectPeerArray{ CrossconnectPeerArgs{...} }
type CrossconnectPeerArrayInput interface {
	pulumi.Input

	ToCrossconnectPeerArrayOutput() CrossconnectPeerArrayOutput
	ToCrossconnectPeerArrayOutputWithContext(context.Context) CrossconnectPeerArrayOutput
}

type CrossconnectPeerArray []CrossconnectPeerInput

func (CrossconnectPeerArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CrossconnectPeer)(nil)).Elem()
}

func (i CrossconnectPeerArray) ToCrossconnectPeerArrayOutput() CrossconnectPeerArrayOutput {
	return i.ToCrossconnectPeerArrayOutputWithContext(context.Background())
}

func (i CrossconnectPeerArray) ToCrossconnectPeerArrayOutputWithContext(ctx context.Context) CrossconnectPeerArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CrossconnectPeerArrayOutput)
}

type CrossconnectPeerOutput struct{ *pulumi.OutputState }

func (CrossconnectPeerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CrossconnectPeer)(nil)).Elem()
}

func (o CrossconnectPeerOutput) ToCrossconnectPeerOutput() CrossconnectPeerOutput {
	return o
}

func (o CrossconnectPeerOutput) ToCrossconnectPeerOutputWithContext(ctx context.Context) CrossconnectPeerOutput {
	return o
}

// The id of the cross-connected datacenter
func (o CrossconnectPeerOutput) DatacenterId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CrossconnectPeer) *string { return v.DatacenterId }).(pulumi.StringPtrOutput)
}

// The name of the cross-connected datacenter
func (o CrossconnectPeerOutput) DatacenterName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CrossconnectPeer) *string { return v.DatacenterName }).(pulumi.StringPtrOutput)
}

// The id of the cross-connected LAN
func (o CrossconnectPeerOutput) LanId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CrossconnectPeer) *string { return v.LanId }).(pulumi.StringPtrOutput)
}

// The name of the cross-connected LAN
func (o CrossconnectPeerOutput) LanName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CrossconnectPeer) *string { return v.LanName }).(pulumi.StringPtrOutput)
}

// The location of the cross-connected datacenter
func (o CrossconnectPeerOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CrossconnectPeer) *string { return v.Location }).(pulumi.StringPtrOutput)
}

type CrossconnectPeerArrayOutput struct{ *pulumi.OutputState }

func (CrossconnectPeerArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CrossconnectPeer)(nil)).Elem()
}

func (o CrossconnectPeerArrayOutput) ToCrossconnectPeerArrayOutput() CrossconnectPeerArrayOutput {
	return o
}

func (o CrossconnectPeerArrayOutput) ToCrossconnectPeerArrayOutputWithContext(ctx context.Context) CrossconnectPeerArrayOutput {
	return o
}

func (o CrossconnectPeerArrayOutput) Index(i pulumi.IntInput) CrossconnectPeerOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) CrossconnectPeer {
		return vs[0].([]CrossconnectPeer)[vs[1].(int)]
	}).(CrossconnectPeerOutput)
}

type CubeServerNic struct {
	DeviceNumber *int  `pulumi:"deviceNumber"`
	Dhcp         *bool `pulumi:"dhcp"`
	// Indicates whether this NIC receives an IPv6 address through DHCP.
	Dhcpv6         *bool                  `pulumi:"dhcpv6"`
	Firewall       *CubeServerNicFirewall `pulumi:"firewall"`
	FirewallActive *bool                  `pulumi:"firewallActive"`
	FirewallType   *string                `pulumi:"firewallType"`
	Ips            []string               `pulumi:"ips"`
	// IPv6 CIDR block assigned to the NIC.
	Ipv6CidrBlock *string `pulumi:"ipv6CidrBlock"`
	// Collection for IPv6 addresses assigned to a nic. Explicitly assigned IPv6 addresses need to come from inside the IPv6 CIDR block assigned to the nic.
	Ipv6Ips []string `pulumi:"ipv6Ips"`
	Lan     int      `pulumi:"lan"`
	Mac     *string  `pulumi:"mac"`
	// [string] The name of the server.
	Name    *string `pulumi:"name"`
	PciSlot *int    `pulumi:"pciSlot"`
}

// CubeServerNicInput is an input type that accepts CubeServerNicArgs and CubeServerNicOutput values.
// You can construct a concrete instance of `CubeServerNicInput` via:
//
//	CubeServerNicArgs{...}
type CubeServerNicInput interface {
	pulumi.Input

	ToCubeServerNicOutput() CubeServerNicOutput
	ToCubeServerNicOutputWithContext(context.Context) CubeServerNicOutput
}

type CubeServerNicArgs struct {
	DeviceNumber pulumi.IntPtrInput  `pulumi:"deviceNumber"`
	Dhcp         pulumi.BoolPtrInput `pulumi:"dhcp"`
	// Indicates whether this NIC receives an IPv6 address through DHCP.
	Dhcpv6         pulumi.BoolPtrInput           `pulumi:"dhcpv6"`
	Firewall       CubeServerNicFirewallPtrInput `pulumi:"firewall"`
	FirewallActive pulumi.BoolPtrInput           `pulumi:"firewallActive"`
	FirewallType   pulumi.StringPtrInput         `pulumi:"firewallType"`
	Ips            pulumi.StringArrayInput       `pulumi:"ips"`
	// IPv6 CIDR block assigned to the NIC.
	Ipv6CidrBlock pulumi.StringPtrInput `pulumi:"ipv6CidrBlock"`
	// Collection for IPv6 addresses assigned to a nic. Explicitly assigned IPv6 addresses need to come from inside the IPv6 CIDR block assigned to the nic.
	Ipv6Ips pulumi.StringArrayInput `pulumi:"ipv6Ips"`
	Lan     pulumi.IntInput         `pulumi:"lan"`
	Mac     pulumi.StringPtrInput   `pulumi:"mac"`
	// [string] The name of the server.
	Name    pulumi.StringPtrInput `pulumi:"name"`
	PciSlot pulumi.IntPtrInput    `pulumi:"pciSlot"`
}

func (CubeServerNicArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CubeServerNic)(nil)).Elem()
}

func (i CubeServerNicArgs) ToCubeServerNicOutput() CubeServerNicOutput {
	return i.ToCubeServerNicOutputWithContext(context.Background())
}

func (i CubeServerNicArgs) ToCubeServerNicOutputWithContext(ctx context.Context) CubeServerNicOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CubeServerNicOutput)
}

func (i CubeServerNicArgs) ToCubeServerNicPtrOutput() CubeServerNicPtrOutput {
	return i.ToCubeServerNicPtrOutputWithContext(context.Background())
}

func (i CubeServerNicArgs) ToCubeServerNicPtrOutputWithContext(ctx context.Context) CubeServerNicPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CubeServerNicOutput).ToCubeServerNicPtrOutputWithContext(ctx)
}

// CubeServerNicPtrInput is an input type that accepts CubeServerNicArgs, CubeServerNicPtr and CubeServerNicPtrOutput values.
// You can construct a concrete instance of `CubeServerNicPtrInput` via:
//
//	        CubeServerNicArgs{...}
//
//	or:
//
//	        nil
type CubeServerNicPtrInput interface {
	pulumi.Input

	ToCubeServerNicPtrOutput() CubeServerNicPtrOutput
	ToCubeServerNicPtrOutputWithContext(context.Context) CubeServerNicPtrOutput
}

type cubeServerNicPtrType CubeServerNicArgs

func CubeServerNicPtr(v *CubeServerNicArgs) CubeServerNicPtrInput {
	return (*cubeServerNicPtrType)(v)
}

func (*cubeServerNicPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CubeServerNic)(nil)).Elem()
}

func (i *cubeServerNicPtrType) ToCubeServerNicPtrOutput() CubeServerNicPtrOutput {
	return i.ToCubeServerNicPtrOutputWithContext(context.Background())
}

func (i *cubeServerNicPtrType) ToCubeServerNicPtrOutputWithContext(ctx context.Context) CubeServerNicPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CubeServerNicPtrOutput)
}

type CubeServerNicOutput struct{ *pulumi.OutputState }

func (CubeServerNicOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CubeServerNic)(nil)).Elem()
}

func (o CubeServerNicOutput) ToCubeServerNicOutput() CubeServerNicOutput {
	return o
}

func (o CubeServerNicOutput) ToCubeServerNicOutputWithContext(ctx context.Context) CubeServerNicOutput {
	return o
}

func (o CubeServerNicOutput) ToCubeServerNicPtrOutput() CubeServerNicPtrOutput {
	return o.ToCubeServerNicPtrOutputWithContext(context.Background())
}

func (o CubeServerNicOutput) ToCubeServerNicPtrOutputWithContext(ctx context.Context) CubeServerNicPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CubeServerNic) *CubeServerNic {
		return &v
	}).(CubeServerNicPtrOutput)
}

func (o CubeServerNicOutput) DeviceNumber() pulumi.IntPtrOutput {
	return o.ApplyT(func(v CubeServerNic) *int { return v.DeviceNumber }).(pulumi.IntPtrOutput)
}

func (o CubeServerNicOutput) Dhcp() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v CubeServerNic) *bool { return v.Dhcp }).(pulumi.BoolPtrOutput)
}

// Indicates whether this NIC receives an IPv6 address through DHCP.
func (o CubeServerNicOutput) Dhcpv6() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v CubeServerNic) *bool { return v.Dhcpv6 }).(pulumi.BoolPtrOutput)
}

func (o CubeServerNicOutput) Firewall() CubeServerNicFirewallPtrOutput {
	return o.ApplyT(func(v CubeServerNic) *CubeServerNicFirewall { return v.Firewall }).(CubeServerNicFirewallPtrOutput)
}

func (o CubeServerNicOutput) FirewallActive() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v CubeServerNic) *bool { return v.FirewallActive }).(pulumi.BoolPtrOutput)
}

func (o CubeServerNicOutput) FirewallType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CubeServerNic) *string { return v.FirewallType }).(pulumi.StringPtrOutput)
}

func (o CubeServerNicOutput) Ips() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CubeServerNic) []string { return v.Ips }).(pulumi.StringArrayOutput)
}

// IPv6 CIDR block assigned to the NIC.
func (o CubeServerNicOutput) Ipv6CidrBlock() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CubeServerNic) *string { return v.Ipv6CidrBlock }).(pulumi.StringPtrOutput)
}

// Collection for IPv6 addresses assigned to a nic. Explicitly assigned IPv6 addresses need to come from inside the IPv6 CIDR block assigned to the nic.
func (o CubeServerNicOutput) Ipv6Ips() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CubeServerNic) []string { return v.Ipv6Ips }).(pulumi.StringArrayOutput)
}

func (o CubeServerNicOutput) Lan() pulumi.IntOutput {
	return o.ApplyT(func(v CubeServerNic) int { return v.Lan }).(pulumi.IntOutput)
}

func (o CubeServerNicOutput) Mac() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CubeServerNic) *string { return v.Mac }).(pulumi.StringPtrOutput)
}

// [string] The name of the server.
func (o CubeServerNicOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CubeServerNic) *string { return v.Name }).(pulumi.StringPtrOutput)
}

func (o CubeServerNicOutput) PciSlot() pulumi.IntPtrOutput {
	return o.ApplyT(func(v CubeServerNic) *int { return v.PciSlot }).(pulumi.IntPtrOutput)
}

type CubeServerNicPtrOutput struct{ *pulumi.OutputState }

func (CubeServerNicPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CubeServerNic)(nil)).Elem()
}

func (o CubeServerNicPtrOutput) ToCubeServerNicPtrOutput() CubeServerNicPtrOutput {
	return o
}

func (o CubeServerNicPtrOutput) ToCubeServerNicPtrOutputWithContext(ctx context.Context) CubeServerNicPtrOutput {
	return o
}

func (o CubeServerNicPtrOutput) Elem() CubeServerNicOutput {
	return o.ApplyT(func(v *CubeServerNic) CubeServerNic {
		if v != nil {
			return *v
		}
		var ret CubeServerNic
		return ret
	}).(CubeServerNicOutput)
}

func (o CubeServerNicPtrOutput) DeviceNumber() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *CubeServerNic) *int {
		if v == nil {
			return nil
		}
		return v.DeviceNumber
	}).(pulumi.IntPtrOutput)
}

func (o CubeServerNicPtrOutput) Dhcp() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *CubeServerNic) *bool {
		if v == nil {
			return nil
		}
		return v.Dhcp
	}).(pulumi.BoolPtrOutput)
}

// Indicates whether this NIC receives an IPv6 address through DHCP.
func (o CubeServerNicPtrOutput) Dhcpv6() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *CubeServerNic) *bool {
		if v == nil {
			return nil
		}
		return v.Dhcpv6
	}).(pulumi.BoolPtrOutput)
}

func (o CubeServerNicPtrOutput) Firewall() CubeServerNicFirewallPtrOutput {
	return o.ApplyT(func(v *CubeServerNic) *CubeServerNicFirewall {
		if v == nil {
			return nil
		}
		return v.Firewall
	}).(CubeServerNicFirewallPtrOutput)
}

func (o CubeServerNicPtrOutput) FirewallActive() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *CubeServerNic) *bool {
		if v == nil {
			return nil
		}
		return v.FirewallActive
	}).(pulumi.BoolPtrOutput)
}

func (o CubeServerNicPtrOutput) FirewallType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CubeServerNic) *string {
		if v == nil {
			return nil
		}
		return v.FirewallType
	}).(pulumi.StringPtrOutput)
}

func (o CubeServerNicPtrOutput) Ips() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CubeServerNic) []string {
		if v == nil {
			return nil
		}
		return v.Ips
	}).(pulumi.StringArrayOutput)
}

// IPv6 CIDR block assigned to the NIC.
func (o CubeServerNicPtrOutput) Ipv6CidrBlock() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CubeServerNic) *string {
		if v == nil {
			return nil
		}
		return v.Ipv6CidrBlock
	}).(pulumi.StringPtrOutput)
}

// Collection for IPv6 addresses assigned to a nic. Explicitly assigned IPv6 addresses need to come from inside the IPv6 CIDR block assigned to the nic.
func (o CubeServerNicPtrOutput) Ipv6Ips() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CubeServerNic) []string {
		if v == nil {
			return nil
		}
		return v.Ipv6Ips
	}).(pulumi.StringArrayOutput)
}

func (o CubeServerNicPtrOutput) Lan() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *CubeServerNic) *int {
		if v == nil {
			return nil
		}
		return &v.Lan
	}).(pulumi.IntPtrOutput)
}

func (o CubeServerNicPtrOutput) Mac() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CubeServerNic) *string {
		if v == nil {
			return nil
		}
		return v.Mac
	}).(pulumi.StringPtrOutput)
}

// [string] The name of the server.
func (o CubeServerNicPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CubeServerNic) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

func (o CubeServerNicPtrOutput) PciSlot() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *CubeServerNic) *int {
		if v == nil {
			return nil
		}
		return v.PciSlot
	}).(pulumi.IntPtrOutput)
}

type CubeServerNicFirewall struct {
	IcmpCode *string `pulumi:"icmpCode"`
	IcmpType *string `pulumi:"icmpType"`
	// [string] The name of the server.
	Name           *string `pulumi:"name"`
	PortRangeEnd   *int    `pulumi:"portRangeEnd"`
	PortRangeStart *int    `pulumi:"portRangeStart"`
	Protocol       string  `pulumi:"protocol"`
	SourceIp       *string `pulumi:"sourceIp"`
	SourceMac      *string `pulumi:"sourceMac"`
	TargetIp       *string `pulumi:"targetIp"`
	Type           *string `pulumi:"type"`
}

// CubeServerNicFirewallInput is an input type that accepts CubeServerNicFirewallArgs and CubeServerNicFirewallOutput values.
// You can construct a concrete instance of `CubeServerNicFirewallInput` via:
//
//	CubeServerNicFirewallArgs{...}
type CubeServerNicFirewallInput interface {
	pulumi.Input

	ToCubeServerNicFirewallOutput() CubeServerNicFirewallOutput
	ToCubeServerNicFirewallOutputWithContext(context.Context) CubeServerNicFirewallOutput
}

type CubeServerNicFirewallArgs struct {
	IcmpCode pulumi.StringPtrInput `pulumi:"icmpCode"`
	IcmpType pulumi.StringPtrInput `pulumi:"icmpType"`
	// [string] The name of the server.
	Name           pulumi.StringPtrInput `pulumi:"name"`
	PortRangeEnd   pulumi.IntPtrInput    `pulumi:"portRangeEnd"`
	PortRangeStart pulumi.IntPtrInput    `pulumi:"portRangeStart"`
	Protocol       pulumi.StringInput    `pulumi:"protocol"`
	SourceIp       pulumi.StringPtrInput `pulumi:"sourceIp"`
	SourceMac      pulumi.StringPtrInput `pulumi:"sourceMac"`
	TargetIp       pulumi.StringPtrInput `pulumi:"targetIp"`
	Type           pulumi.StringPtrInput `pulumi:"type"`
}

func (CubeServerNicFirewallArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CubeServerNicFirewall)(nil)).Elem()
}

func (i CubeServerNicFirewallArgs) ToCubeServerNicFirewallOutput() CubeServerNicFirewallOutput {
	return i.ToCubeServerNicFirewallOutputWithContext(context.Background())
}

func (i CubeServerNicFirewallArgs) ToCubeServerNicFirewallOutputWithContext(ctx context.Context) CubeServerNicFirewallOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CubeServerNicFirewallOutput)
}

func (i CubeServerNicFirewallArgs) ToCubeServerNicFirewallPtrOutput() CubeServerNicFirewallPtrOutput {
	return i.ToCubeServerNicFirewallPtrOutputWithContext(context.Background())
}

func (i CubeServerNicFirewallArgs) ToCubeServerNicFirewallPtrOutputWithContext(ctx context.Context) CubeServerNicFirewallPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CubeServerNicFirewallOutput).ToCubeServerNicFirewallPtrOutputWithContext(ctx)
}

// CubeServerNicFirewallPtrInput is an input type that accepts CubeServerNicFirewallArgs, CubeServerNicFirewallPtr and CubeServerNicFirewallPtrOutput values.
// You can construct a concrete instance of `CubeServerNicFirewallPtrInput` via:
//
//	        CubeServerNicFirewallArgs{...}
//
//	or:
//
//	        nil
type CubeServerNicFirewallPtrInput interface {
	pulumi.Input

	ToCubeServerNicFirewallPtrOutput() CubeServerNicFirewallPtrOutput
	ToCubeServerNicFirewallPtrOutputWithContext(context.Context) CubeServerNicFirewallPtrOutput
}

type cubeServerNicFirewallPtrType CubeServerNicFirewallArgs

func CubeServerNicFirewallPtr(v *CubeServerNicFirewallArgs) CubeServerNicFirewallPtrInput {
	return (*cubeServerNicFirewallPtrType)(v)
}

func (*cubeServerNicFirewallPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CubeServerNicFirewall)(nil)).Elem()
}

func (i *cubeServerNicFirewallPtrType) ToCubeServerNicFirewallPtrOutput() CubeServerNicFirewallPtrOutput {
	return i.ToCubeServerNicFirewallPtrOutputWithContext(context.Background())
}

func (i *cubeServerNicFirewallPtrType) ToCubeServerNicFirewallPtrOutputWithContext(ctx context.Context) CubeServerNicFirewallPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CubeServerNicFirewallPtrOutput)
}

type CubeServerNicFirewallOutput struct{ *pulumi.OutputState }

func (CubeServerNicFirewallOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CubeServerNicFirewall)(nil)).Elem()
}

func (o CubeServerNicFirewallOutput) ToCubeServerNicFirewallOutput() CubeServerNicFirewallOutput {
	return o
}

func (o CubeServerNicFirewallOutput) ToCubeServerNicFirewallOutputWithContext(ctx context.Context) CubeServerNicFirewallOutput {
	return o
}

func (o CubeServerNicFirewallOutput) ToCubeServerNicFirewallPtrOutput() CubeServerNicFirewallPtrOutput {
	return o.ToCubeServerNicFirewallPtrOutputWithContext(context.Background())
}

func (o CubeServerNicFirewallOutput) ToCubeServerNicFirewallPtrOutputWithContext(ctx context.Context) CubeServerNicFirewallPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CubeServerNicFirewall) *CubeServerNicFirewall {
		return &v
	}).(CubeServerNicFirewallPtrOutput)
}

func (o CubeServerNicFirewallOutput) IcmpCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CubeServerNicFirewall) *string { return v.IcmpCode }).(pulumi.StringPtrOutput)
}

func (o CubeServerNicFirewallOutput) IcmpType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CubeServerNicFirewall) *string { return v.IcmpType }).(pulumi.StringPtrOutput)
}

// [string] The name of the server.
func (o CubeServerNicFirewallOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CubeServerNicFirewall) *string { return v.Name }).(pulumi.StringPtrOutput)
}

func (o CubeServerNicFirewallOutput) PortRangeEnd() pulumi.IntPtrOutput {
	return o.ApplyT(func(v CubeServerNicFirewall) *int { return v.PortRangeEnd }).(pulumi.IntPtrOutput)
}

func (o CubeServerNicFirewallOutput) PortRangeStart() pulumi.IntPtrOutput {
	return o.ApplyT(func(v CubeServerNicFirewall) *int { return v.PortRangeStart }).(pulumi.IntPtrOutput)
}

func (o CubeServerNicFirewallOutput) Protocol() pulumi.StringOutput {
	return o.ApplyT(func(v CubeServerNicFirewall) string { return v.Protocol }).(pulumi.StringOutput)
}

func (o CubeServerNicFirewallOutput) SourceIp() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CubeServerNicFirewall) *string { return v.SourceIp }).(pulumi.StringPtrOutput)
}

func (o CubeServerNicFirewallOutput) SourceMac() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CubeServerNicFirewall) *string { return v.SourceMac }).(pulumi.StringPtrOutput)
}

func (o CubeServerNicFirewallOutput) TargetIp() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CubeServerNicFirewall) *string { return v.TargetIp }).(pulumi.StringPtrOutput)
}

func (o CubeServerNicFirewallOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CubeServerNicFirewall) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type CubeServerNicFirewallPtrOutput struct{ *pulumi.OutputState }

func (CubeServerNicFirewallPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CubeServerNicFirewall)(nil)).Elem()
}

func (o CubeServerNicFirewallPtrOutput) ToCubeServerNicFirewallPtrOutput() CubeServerNicFirewallPtrOutput {
	return o
}

func (o CubeServerNicFirewallPtrOutput) ToCubeServerNicFirewallPtrOutputWithContext(ctx context.Context) CubeServerNicFirewallPtrOutput {
	return o
}

func (o CubeServerNicFirewallPtrOutput) Elem() CubeServerNicFirewallOutput {
	return o.ApplyT(func(v *CubeServerNicFirewall) CubeServerNicFirewall {
		if v != nil {
			return *v
		}
		var ret CubeServerNicFirewall
		return ret
	}).(CubeServerNicFirewallOutput)
}

func (o CubeServerNicFirewallPtrOutput) IcmpCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CubeServerNicFirewall) *string {
		if v == nil {
			return nil
		}
		return v.IcmpCode
	}).(pulumi.StringPtrOutput)
}

func (o CubeServerNicFirewallPtrOutput) IcmpType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CubeServerNicFirewall) *string {
		if v == nil {
			return nil
		}
		return v.IcmpType
	}).(pulumi.StringPtrOutput)
}

// [string] The name of the server.
func (o CubeServerNicFirewallPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CubeServerNicFirewall) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

func (o CubeServerNicFirewallPtrOutput) PortRangeEnd() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *CubeServerNicFirewall) *int {
		if v == nil {
			return nil
		}
		return v.PortRangeEnd
	}).(pulumi.IntPtrOutput)
}

func (o CubeServerNicFirewallPtrOutput) PortRangeStart() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *CubeServerNicFirewall) *int {
		if v == nil {
			return nil
		}
		return v.PortRangeStart
	}).(pulumi.IntPtrOutput)
}

func (o CubeServerNicFirewallPtrOutput) Protocol() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CubeServerNicFirewall) *string {
		if v == nil {
			return nil
		}
		return &v.Protocol
	}).(pulumi.StringPtrOutput)
}

func (o CubeServerNicFirewallPtrOutput) SourceIp() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CubeServerNicFirewall) *string {
		if v == nil {
			return nil
		}
		return v.SourceIp
	}).(pulumi.StringPtrOutput)
}

func (o CubeServerNicFirewallPtrOutput) SourceMac() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CubeServerNicFirewall) *string {
		if v == nil {
			return nil
		}
		return v.SourceMac
	}).(pulumi.StringPtrOutput)
}

func (o CubeServerNicFirewallPtrOutput) TargetIp() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CubeServerNicFirewall) *string {
		if v == nil {
			return nil
		}
		return v.TargetIp
	}).(pulumi.StringPtrOutput)
}

func (o CubeServerNicFirewallPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CubeServerNicFirewall) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

type CubeServerVolume struct {
	// [string] The availability zone in which the server should exist. This property is immutable.
	AvailabilityZone *string `pulumi:"availabilityZone"`
	// The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
	BackupUnitId *string `pulumi:"backupUnitId"`
	// The UUID of the attached server.
	BootServer          *string `pulumi:"bootServer"`
	Bus                 *string `pulumi:"bus"`
	CpuHotPlug          *bool   `pulumi:"cpuHotPlug"`
	DeviceNumber        *int    `pulumi:"deviceNumber"`
	DiscVirtioHotPlug   *bool   `pulumi:"discVirtioHotPlug"`
	DiscVirtioHotUnplug *bool   `pulumi:"discVirtioHotUnplug"`
	DiskType            string  `pulumi:"diskType"`
	// [string] Required if `sshKeyPath` is not provided.
	//
	// > **⚠ WARNING**
	// >
	// > Image_name under volume level is deprecated, please use imageName under server level
	//
	// > **⚠ WARNING**
	// >
	// > For creating a **CUBE** server, you can not set `volume.size` argument.
	//
	// Deprecated: Please use imagePassword under server level
	ImagePassword *string `pulumi:"imagePassword"`
	// [string] Sets the OS type of the server.
	LicenceType *string `pulumi:"licenceType"`
	// [string] The name of the server.
	Name         *string `pulumi:"name"`
	NicHotPlug   *bool   `pulumi:"nicHotPlug"`
	NicHotUnplug *bool   `pulumi:"nicHotUnplug"`
	PciSlot      *int    `pulumi:"pciSlot"`
	RamHotPlug   *bool   `pulumi:"ramHotPlug"`
	// [list] List of paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images. Required for IonosCloud Linux images. Required if `imagePassword` is not provided.
	//
	// Deprecated: Please use sshKeyPath under server level
	SshKeyPaths []string `pulumi:"sshKeyPaths"`
	// The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
	UserData *string `pulumi:"userData"`
}

// CubeServerVolumeInput is an input type that accepts CubeServerVolumeArgs and CubeServerVolumeOutput values.
// You can construct a concrete instance of `CubeServerVolumeInput` via:
//
//	CubeServerVolumeArgs{...}
type CubeServerVolumeInput interface {
	pulumi.Input

	ToCubeServerVolumeOutput() CubeServerVolumeOutput
	ToCubeServerVolumeOutputWithContext(context.Context) CubeServerVolumeOutput
}

type CubeServerVolumeArgs struct {
	// [string] The availability zone in which the server should exist. This property is immutable.
	AvailabilityZone pulumi.StringPtrInput `pulumi:"availabilityZone"`
	// The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
	BackupUnitId pulumi.StringPtrInput `pulumi:"backupUnitId"`
	// The UUID of the attached server.
	BootServer          pulumi.StringPtrInput `pulumi:"bootServer"`
	Bus                 pulumi.StringPtrInput `pulumi:"bus"`
	CpuHotPlug          pulumi.BoolPtrInput   `pulumi:"cpuHotPlug"`
	DeviceNumber        pulumi.IntPtrInput    `pulumi:"deviceNumber"`
	DiscVirtioHotPlug   pulumi.BoolPtrInput   `pulumi:"discVirtioHotPlug"`
	DiscVirtioHotUnplug pulumi.BoolPtrInput   `pulumi:"discVirtioHotUnplug"`
	DiskType            pulumi.StringInput    `pulumi:"diskType"`
	// [string] Required if `sshKeyPath` is not provided.
	//
	// > **⚠ WARNING**
	// >
	// > Image_name under volume level is deprecated, please use imageName under server level
	//
	// > **⚠ WARNING**
	// >
	// > For creating a **CUBE** server, you can not set `volume.size` argument.
	//
	// Deprecated: Please use imagePassword under server level
	ImagePassword pulumi.StringPtrInput `pulumi:"imagePassword"`
	// [string] Sets the OS type of the server.
	LicenceType pulumi.StringPtrInput `pulumi:"licenceType"`
	// [string] The name of the server.
	Name         pulumi.StringPtrInput `pulumi:"name"`
	NicHotPlug   pulumi.BoolPtrInput   `pulumi:"nicHotPlug"`
	NicHotUnplug pulumi.BoolPtrInput   `pulumi:"nicHotUnplug"`
	PciSlot      pulumi.IntPtrInput    `pulumi:"pciSlot"`
	RamHotPlug   pulumi.BoolPtrInput   `pulumi:"ramHotPlug"`
	// [list] List of paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images. Required for IonosCloud Linux images. Required if `imagePassword` is not provided.
	//
	// Deprecated: Please use sshKeyPath under server level
	SshKeyPaths pulumi.StringArrayInput `pulumi:"sshKeyPaths"`
	// The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
	UserData pulumi.StringPtrInput `pulumi:"userData"`
}

func (CubeServerVolumeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CubeServerVolume)(nil)).Elem()
}

func (i CubeServerVolumeArgs) ToCubeServerVolumeOutput() CubeServerVolumeOutput {
	return i.ToCubeServerVolumeOutputWithContext(context.Background())
}

func (i CubeServerVolumeArgs) ToCubeServerVolumeOutputWithContext(ctx context.Context) CubeServerVolumeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CubeServerVolumeOutput)
}

func (i CubeServerVolumeArgs) ToCubeServerVolumePtrOutput() CubeServerVolumePtrOutput {
	return i.ToCubeServerVolumePtrOutputWithContext(context.Background())
}

func (i CubeServerVolumeArgs) ToCubeServerVolumePtrOutputWithContext(ctx context.Context) CubeServerVolumePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CubeServerVolumeOutput).ToCubeServerVolumePtrOutputWithContext(ctx)
}

// CubeServerVolumePtrInput is an input type that accepts CubeServerVolumeArgs, CubeServerVolumePtr and CubeServerVolumePtrOutput values.
// You can construct a concrete instance of `CubeServerVolumePtrInput` via:
//
//	        CubeServerVolumeArgs{...}
//
//	or:
//
//	        nil
type CubeServerVolumePtrInput interface {
	pulumi.Input

	ToCubeServerVolumePtrOutput() CubeServerVolumePtrOutput
	ToCubeServerVolumePtrOutputWithContext(context.Context) CubeServerVolumePtrOutput
}

type cubeServerVolumePtrType CubeServerVolumeArgs

func CubeServerVolumePtr(v *CubeServerVolumeArgs) CubeServerVolumePtrInput {
	return (*cubeServerVolumePtrType)(v)
}

func (*cubeServerVolumePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CubeServerVolume)(nil)).Elem()
}

func (i *cubeServerVolumePtrType) ToCubeServerVolumePtrOutput() CubeServerVolumePtrOutput {
	return i.ToCubeServerVolumePtrOutputWithContext(context.Background())
}

func (i *cubeServerVolumePtrType) ToCubeServerVolumePtrOutputWithContext(ctx context.Context) CubeServerVolumePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CubeServerVolumePtrOutput)
}

type CubeServerVolumeOutput struct{ *pulumi.OutputState }

func (CubeServerVolumeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CubeServerVolume)(nil)).Elem()
}

func (o CubeServerVolumeOutput) ToCubeServerVolumeOutput() CubeServerVolumeOutput {
	return o
}

func (o CubeServerVolumeOutput) ToCubeServerVolumeOutputWithContext(ctx context.Context) CubeServerVolumeOutput {
	return o
}

func (o CubeServerVolumeOutput) ToCubeServerVolumePtrOutput() CubeServerVolumePtrOutput {
	return o.ToCubeServerVolumePtrOutputWithContext(context.Background())
}

func (o CubeServerVolumeOutput) ToCubeServerVolumePtrOutputWithContext(ctx context.Context) CubeServerVolumePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CubeServerVolume) *CubeServerVolume {
		return &v
	}).(CubeServerVolumePtrOutput)
}

// [string] The availability zone in which the server should exist. This property is immutable.
func (o CubeServerVolumeOutput) AvailabilityZone() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CubeServerVolume) *string { return v.AvailabilityZone }).(pulumi.StringPtrOutput)
}

// The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
func (o CubeServerVolumeOutput) BackupUnitId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CubeServerVolume) *string { return v.BackupUnitId }).(pulumi.StringPtrOutput)
}

// The UUID of the attached server.
func (o CubeServerVolumeOutput) BootServer() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CubeServerVolume) *string { return v.BootServer }).(pulumi.StringPtrOutput)
}

func (o CubeServerVolumeOutput) Bus() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CubeServerVolume) *string { return v.Bus }).(pulumi.StringPtrOutput)
}

func (o CubeServerVolumeOutput) CpuHotPlug() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v CubeServerVolume) *bool { return v.CpuHotPlug }).(pulumi.BoolPtrOutput)
}

func (o CubeServerVolumeOutput) DeviceNumber() pulumi.IntPtrOutput {
	return o.ApplyT(func(v CubeServerVolume) *int { return v.DeviceNumber }).(pulumi.IntPtrOutput)
}

func (o CubeServerVolumeOutput) DiscVirtioHotPlug() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v CubeServerVolume) *bool { return v.DiscVirtioHotPlug }).(pulumi.BoolPtrOutput)
}

func (o CubeServerVolumeOutput) DiscVirtioHotUnplug() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v CubeServerVolume) *bool { return v.DiscVirtioHotUnplug }).(pulumi.BoolPtrOutput)
}

func (o CubeServerVolumeOutput) DiskType() pulumi.StringOutput {
	return o.ApplyT(func(v CubeServerVolume) string { return v.DiskType }).(pulumi.StringOutput)
}

// [string] Required if `sshKeyPath` is not provided.
//
// > **⚠ WARNING**
// >
// > Image_name under volume level is deprecated, please use imageName under server level
//
// > **⚠ WARNING**
// >
// > For creating a **CUBE** server, you can not set `volume.size` argument.
//
// Deprecated: Please use imagePassword under server level
func (o CubeServerVolumeOutput) ImagePassword() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CubeServerVolume) *string { return v.ImagePassword }).(pulumi.StringPtrOutput)
}

// [string] Sets the OS type of the server.
func (o CubeServerVolumeOutput) LicenceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CubeServerVolume) *string { return v.LicenceType }).(pulumi.StringPtrOutput)
}

// [string] The name of the server.
func (o CubeServerVolumeOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CubeServerVolume) *string { return v.Name }).(pulumi.StringPtrOutput)
}

func (o CubeServerVolumeOutput) NicHotPlug() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v CubeServerVolume) *bool { return v.NicHotPlug }).(pulumi.BoolPtrOutput)
}

func (o CubeServerVolumeOutput) NicHotUnplug() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v CubeServerVolume) *bool { return v.NicHotUnplug }).(pulumi.BoolPtrOutput)
}

func (o CubeServerVolumeOutput) PciSlot() pulumi.IntPtrOutput {
	return o.ApplyT(func(v CubeServerVolume) *int { return v.PciSlot }).(pulumi.IntPtrOutput)
}

func (o CubeServerVolumeOutput) RamHotPlug() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v CubeServerVolume) *bool { return v.RamHotPlug }).(pulumi.BoolPtrOutput)
}

// [list] List of paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images. Required for IonosCloud Linux images. Required if `imagePassword` is not provided.
//
// Deprecated: Please use sshKeyPath under server level
func (o CubeServerVolumeOutput) SshKeyPaths() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CubeServerVolume) []string { return v.SshKeyPaths }).(pulumi.StringArrayOutput)
}

// The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
func (o CubeServerVolumeOutput) UserData() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CubeServerVolume) *string { return v.UserData }).(pulumi.StringPtrOutput)
}

type CubeServerVolumePtrOutput struct{ *pulumi.OutputState }

func (CubeServerVolumePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CubeServerVolume)(nil)).Elem()
}

func (o CubeServerVolumePtrOutput) ToCubeServerVolumePtrOutput() CubeServerVolumePtrOutput {
	return o
}

func (o CubeServerVolumePtrOutput) ToCubeServerVolumePtrOutputWithContext(ctx context.Context) CubeServerVolumePtrOutput {
	return o
}

func (o CubeServerVolumePtrOutput) Elem() CubeServerVolumeOutput {
	return o.ApplyT(func(v *CubeServerVolume) CubeServerVolume {
		if v != nil {
			return *v
		}
		var ret CubeServerVolume
		return ret
	}).(CubeServerVolumeOutput)
}

// [string] The availability zone in which the server should exist. This property is immutable.
func (o CubeServerVolumePtrOutput) AvailabilityZone() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CubeServerVolume) *string {
		if v == nil {
			return nil
		}
		return v.AvailabilityZone
	}).(pulumi.StringPtrOutput)
}

// The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
func (o CubeServerVolumePtrOutput) BackupUnitId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CubeServerVolume) *string {
		if v == nil {
			return nil
		}
		return v.BackupUnitId
	}).(pulumi.StringPtrOutput)
}

// The UUID of the attached server.
func (o CubeServerVolumePtrOutput) BootServer() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CubeServerVolume) *string {
		if v == nil {
			return nil
		}
		return v.BootServer
	}).(pulumi.StringPtrOutput)
}

func (o CubeServerVolumePtrOutput) Bus() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CubeServerVolume) *string {
		if v == nil {
			return nil
		}
		return v.Bus
	}).(pulumi.StringPtrOutput)
}

func (o CubeServerVolumePtrOutput) CpuHotPlug() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *CubeServerVolume) *bool {
		if v == nil {
			return nil
		}
		return v.CpuHotPlug
	}).(pulumi.BoolPtrOutput)
}

func (o CubeServerVolumePtrOutput) DeviceNumber() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *CubeServerVolume) *int {
		if v == nil {
			return nil
		}
		return v.DeviceNumber
	}).(pulumi.IntPtrOutput)
}

func (o CubeServerVolumePtrOutput) DiscVirtioHotPlug() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *CubeServerVolume) *bool {
		if v == nil {
			return nil
		}
		return v.DiscVirtioHotPlug
	}).(pulumi.BoolPtrOutput)
}

func (o CubeServerVolumePtrOutput) DiscVirtioHotUnplug() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *CubeServerVolume) *bool {
		if v == nil {
			return nil
		}
		return v.DiscVirtioHotUnplug
	}).(pulumi.BoolPtrOutput)
}

func (o CubeServerVolumePtrOutput) DiskType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CubeServerVolume) *string {
		if v == nil {
			return nil
		}
		return &v.DiskType
	}).(pulumi.StringPtrOutput)
}

// [string] Required if `sshKeyPath` is not provided.
//
// > **⚠ WARNING**
// >
// > Image_name under volume level is deprecated, please use imageName under server level
//
// > **⚠ WARNING**
// >
// > For creating a **CUBE** server, you can not set `volume.size` argument.
//
// Deprecated: Please use imagePassword under server level
func (o CubeServerVolumePtrOutput) ImagePassword() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CubeServerVolume) *string {
		if v == nil {
			return nil
		}
		return v.ImagePassword
	}).(pulumi.StringPtrOutput)
}

// [string] Sets the OS type of the server.
func (o CubeServerVolumePtrOutput) LicenceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CubeServerVolume) *string {
		if v == nil {
			return nil
		}
		return v.LicenceType
	}).(pulumi.StringPtrOutput)
}

// [string] The name of the server.
func (o CubeServerVolumePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CubeServerVolume) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

func (o CubeServerVolumePtrOutput) NicHotPlug() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *CubeServerVolume) *bool {
		if v == nil {
			return nil
		}
		return v.NicHotPlug
	}).(pulumi.BoolPtrOutput)
}

func (o CubeServerVolumePtrOutput) NicHotUnplug() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *CubeServerVolume) *bool {
		if v == nil {
			return nil
		}
		return v.NicHotUnplug
	}).(pulumi.BoolPtrOutput)
}

func (o CubeServerVolumePtrOutput) PciSlot() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *CubeServerVolume) *int {
		if v == nil {
			return nil
		}
		return v.PciSlot
	}).(pulumi.IntPtrOutput)
}

func (o CubeServerVolumePtrOutput) RamHotPlug() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *CubeServerVolume) *bool {
		if v == nil {
			return nil
		}
		return v.RamHotPlug
	}).(pulumi.BoolPtrOutput)
}

// [list] List of paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images. Required for IonosCloud Linux images. Required if `imagePassword` is not provided.
//
// Deprecated: Please use sshKeyPath under server level
func (o CubeServerVolumePtrOutput) SshKeyPaths() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CubeServerVolume) []string {
		if v == nil {
			return nil
		}
		return v.SshKeyPaths
	}).(pulumi.StringArrayOutput)
}

// The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
func (o CubeServerVolumePtrOutput) UserData() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CubeServerVolume) *string {
		if v == nil {
			return nil
		}
		return v.UserData
	}).(pulumi.StringPtrOutput)
}

type DatacenterCpuArchitecture struct {
	// A valid CPU family name
	CpuFamily *string `pulumi:"cpuFamily"`
	// The maximum number of cores available
	MaxCores *int `pulumi:"maxCores"`
	// The maximum number of RAM in MB
	MaxRam *int `pulumi:"maxRam"`
	// A valid CPU vendor name
	Vendor *string `pulumi:"vendor"`
}

// DatacenterCpuArchitectureInput is an input type that accepts DatacenterCpuArchitectureArgs and DatacenterCpuArchitectureOutput values.
// You can construct a concrete instance of `DatacenterCpuArchitectureInput` via:
//
//	DatacenterCpuArchitectureArgs{...}
type DatacenterCpuArchitectureInput interface {
	pulumi.Input

	ToDatacenterCpuArchitectureOutput() DatacenterCpuArchitectureOutput
	ToDatacenterCpuArchitectureOutputWithContext(context.Context) DatacenterCpuArchitectureOutput
}

type DatacenterCpuArchitectureArgs struct {
	// A valid CPU family name
	CpuFamily pulumi.StringPtrInput `pulumi:"cpuFamily"`
	// The maximum number of cores available
	MaxCores pulumi.IntPtrInput `pulumi:"maxCores"`
	// The maximum number of RAM in MB
	MaxRam pulumi.IntPtrInput `pulumi:"maxRam"`
	// A valid CPU vendor name
	Vendor pulumi.StringPtrInput `pulumi:"vendor"`
}

func (DatacenterCpuArchitectureArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DatacenterCpuArchitecture)(nil)).Elem()
}

func (i DatacenterCpuArchitectureArgs) ToDatacenterCpuArchitectureOutput() DatacenterCpuArchitectureOutput {
	return i.ToDatacenterCpuArchitectureOutputWithContext(context.Background())
}

func (i DatacenterCpuArchitectureArgs) ToDatacenterCpuArchitectureOutputWithContext(ctx context.Context) DatacenterCpuArchitectureOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DatacenterCpuArchitectureOutput)
}

// DatacenterCpuArchitectureArrayInput is an input type that accepts DatacenterCpuArchitectureArray and DatacenterCpuArchitectureArrayOutput values.
// You can construct a concrete instance of `DatacenterCpuArchitectureArrayInput` via:
//
//	DatacenterCpuArchitectureArray{ DatacenterCpuArchitectureArgs{...} }
type DatacenterCpuArchitectureArrayInput interface {
	pulumi.Input

	ToDatacenterCpuArchitectureArrayOutput() DatacenterCpuArchitectureArrayOutput
	ToDatacenterCpuArchitectureArrayOutputWithContext(context.Context) DatacenterCpuArchitectureArrayOutput
}

type DatacenterCpuArchitectureArray []DatacenterCpuArchitectureInput

func (DatacenterCpuArchitectureArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DatacenterCpuArchitecture)(nil)).Elem()
}

func (i DatacenterCpuArchitectureArray) ToDatacenterCpuArchitectureArrayOutput() DatacenterCpuArchitectureArrayOutput {
	return i.ToDatacenterCpuArchitectureArrayOutputWithContext(context.Background())
}

func (i DatacenterCpuArchitectureArray) ToDatacenterCpuArchitectureArrayOutputWithContext(ctx context.Context) DatacenterCpuArchitectureArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DatacenterCpuArchitectureArrayOutput)
}

type DatacenterCpuArchitectureOutput struct{ *pulumi.OutputState }

func (DatacenterCpuArchitectureOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DatacenterCpuArchitecture)(nil)).Elem()
}

func (o DatacenterCpuArchitectureOutput) ToDatacenterCpuArchitectureOutput() DatacenterCpuArchitectureOutput {
	return o
}

func (o DatacenterCpuArchitectureOutput) ToDatacenterCpuArchitectureOutputWithContext(ctx context.Context) DatacenterCpuArchitectureOutput {
	return o
}

// A valid CPU family name
func (o DatacenterCpuArchitectureOutput) CpuFamily() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DatacenterCpuArchitecture) *string { return v.CpuFamily }).(pulumi.StringPtrOutput)
}

// The maximum number of cores available
func (o DatacenterCpuArchitectureOutput) MaxCores() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DatacenterCpuArchitecture) *int { return v.MaxCores }).(pulumi.IntPtrOutput)
}

// The maximum number of RAM in MB
func (o DatacenterCpuArchitectureOutput) MaxRam() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DatacenterCpuArchitecture) *int { return v.MaxRam }).(pulumi.IntPtrOutput)
}

// A valid CPU vendor name
func (o DatacenterCpuArchitectureOutput) Vendor() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DatacenterCpuArchitecture) *string { return v.Vendor }).(pulumi.StringPtrOutput)
}

type DatacenterCpuArchitectureArrayOutput struct{ *pulumi.OutputState }

func (DatacenterCpuArchitectureArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DatacenterCpuArchitecture)(nil)).Elem()
}

func (o DatacenterCpuArchitectureArrayOutput) ToDatacenterCpuArchitectureArrayOutput() DatacenterCpuArchitectureArrayOutput {
	return o
}

func (o DatacenterCpuArchitectureArrayOutput) ToDatacenterCpuArchitectureArrayOutputWithContext(ctx context.Context) DatacenterCpuArchitectureArrayOutput {
	return o
}

func (o DatacenterCpuArchitectureArrayOutput) Index(i pulumi.IntInput) DatacenterCpuArchitectureOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DatacenterCpuArchitecture {
		return vs[0].([]DatacenterCpuArchitecture)[vs[1].(int)]
	}).(DatacenterCpuArchitectureOutput)
}

type GroupUser struct {
	Administrator *bool   `pulumi:"administrator"`
	Email         *string `pulumi:"email"`
	FirstName     *string `pulumi:"firstName"`
	ForceSecAuth  *bool   `pulumi:"forceSecAuth"`
	Id            *string `pulumi:"id"`
	LastName      *string `pulumi:"lastName"`
	Password      *string `pulumi:"password"`
}

// GroupUserInput is an input type that accepts GroupUserArgs and GroupUserOutput values.
// You can construct a concrete instance of `GroupUserInput` via:
//
//	GroupUserArgs{...}
type GroupUserInput interface {
	pulumi.Input

	ToGroupUserOutput() GroupUserOutput
	ToGroupUserOutputWithContext(context.Context) GroupUserOutput
}

type GroupUserArgs struct {
	Administrator pulumi.BoolPtrInput   `pulumi:"administrator"`
	Email         pulumi.StringPtrInput `pulumi:"email"`
	FirstName     pulumi.StringPtrInput `pulumi:"firstName"`
	ForceSecAuth  pulumi.BoolPtrInput   `pulumi:"forceSecAuth"`
	Id            pulumi.StringPtrInput `pulumi:"id"`
	LastName      pulumi.StringPtrInput `pulumi:"lastName"`
	Password      pulumi.StringPtrInput `pulumi:"password"`
}

func (GroupUserArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GroupUser)(nil)).Elem()
}

func (i GroupUserArgs) ToGroupUserOutput() GroupUserOutput {
	return i.ToGroupUserOutputWithContext(context.Background())
}

func (i GroupUserArgs) ToGroupUserOutputWithContext(ctx context.Context) GroupUserOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupUserOutput)
}

// GroupUserArrayInput is an input type that accepts GroupUserArray and GroupUserArrayOutput values.
// You can construct a concrete instance of `GroupUserArrayInput` via:
//
//	GroupUserArray{ GroupUserArgs{...} }
type GroupUserArrayInput interface {
	pulumi.Input

	ToGroupUserArrayOutput() GroupUserArrayOutput
	ToGroupUserArrayOutputWithContext(context.Context) GroupUserArrayOutput
}

type GroupUserArray []GroupUserInput

func (GroupUserArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GroupUser)(nil)).Elem()
}

func (i GroupUserArray) ToGroupUserArrayOutput() GroupUserArrayOutput {
	return i.ToGroupUserArrayOutputWithContext(context.Background())
}

func (i GroupUserArray) ToGroupUserArrayOutputWithContext(ctx context.Context) GroupUserArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupUserArrayOutput)
}

type GroupUserOutput struct{ *pulumi.OutputState }

func (GroupUserOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GroupUser)(nil)).Elem()
}

func (o GroupUserOutput) ToGroupUserOutput() GroupUserOutput {
	return o
}

func (o GroupUserOutput) ToGroupUserOutputWithContext(ctx context.Context) GroupUserOutput {
	return o
}

func (o GroupUserOutput) Administrator() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v GroupUser) *bool { return v.Administrator }).(pulumi.BoolPtrOutput)
}

func (o GroupUserOutput) Email() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GroupUser) *string { return v.Email }).(pulumi.StringPtrOutput)
}

func (o GroupUserOutput) FirstName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GroupUser) *string { return v.FirstName }).(pulumi.StringPtrOutput)
}

func (o GroupUserOutput) ForceSecAuth() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v GroupUser) *bool { return v.ForceSecAuth }).(pulumi.BoolPtrOutput)
}

func (o GroupUserOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GroupUser) *string { return v.Id }).(pulumi.StringPtrOutput)
}

func (o GroupUserOutput) LastName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GroupUser) *string { return v.LastName }).(pulumi.StringPtrOutput)
}

func (o GroupUserOutput) Password() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GroupUser) *string { return v.Password }).(pulumi.StringPtrOutput)
}

type GroupUserArrayOutput struct{ *pulumi.OutputState }

func (GroupUserArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GroupUser)(nil)).Elem()
}

func (o GroupUserArrayOutput) ToGroupUserArrayOutput() GroupUserArrayOutput {
	return o
}

func (o GroupUserArrayOutput) ToGroupUserArrayOutputWithContext(ctx context.Context) GroupUserArrayOutput {
	return o
}

func (o GroupUserArrayOutput) Index(i pulumi.IntInput) GroupUserOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GroupUser {
		return vs[0].([]GroupUser)[vs[1].(int)]
	}).(GroupUserOutput)
}

type IPBlockIpConsumer struct {
	DatacenterId    *string `pulumi:"datacenterId"`
	DatacenterName  *string `pulumi:"datacenterName"`
	Ip              *string `pulumi:"ip"`
	K8sClusterUuid  *string `pulumi:"k8sClusterUuid"`
	K8sNodepoolUuid *string `pulumi:"k8sNodepoolUuid"`
	Mac             *string `pulumi:"mac"`
	NicId           *string `pulumi:"nicId"`
	ServerId        *string `pulumi:"serverId"`
	ServerName      *string `pulumi:"serverName"`
}

// IPBlockIpConsumerInput is an input type that accepts IPBlockIpConsumerArgs and IPBlockIpConsumerOutput values.
// You can construct a concrete instance of `IPBlockIpConsumerInput` via:
//
//	IPBlockIpConsumerArgs{...}
type IPBlockIpConsumerInput interface {
	pulumi.Input

	ToIPBlockIpConsumerOutput() IPBlockIpConsumerOutput
	ToIPBlockIpConsumerOutputWithContext(context.Context) IPBlockIpConsumerOutput
}

type IPBlockIpConsumerArgs struct {
	DatacenterId    pulumi.StringPtrInput `pulumi:"datacenterId"`
	DatacenterName  pulumi.StringPtrInput `pulumi:"datacenterName"`
	Ip              pulumi.StringPtrInput `pulumi:"ip"`
	K8sClusterUuid  pulumi.StringPtrInput `pulumi:"k8sClusterUuid"`
	K8sNodepoolUuid pulumi.StringPtrInput `pulumi:"k8sNodepoolUuid"`
	Mac             pulumi.StringPtrInput `pulumi:"mac"`
	NicId           pulumi.StringPtrInput `pulumi:"nicId"`
	ServerId        pulumi.StringPtrInput `pulumi:"serverId"`
	ServerName      pulumi.StringPtrInput `pulumi:"serverName"`
}

func (IPBlockIpConsumerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IPBlockIpConsumer)(nil)).Elem()
}

func (i IPBlockIpConsumerArgs) ToIPBlockIpConsumerOutput() IPBlockIpConsumerOutput {
	return i.ToIPBlockIpConsumerOutputWithContext(context.Background())
}

func (i IPBlockIpConsumerArgs) ToIPBlockIpConsumerOutputWithContext(ctx context.Context) IPBlockIpConsumerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IPBlockIpConsumerOutput)
}

// IPBlockIpConsumerArrayInput is an input type that accepts IPBlockIpConsumerArray and IPBlockIpConsumerArrayOutput values.
// You can construct a concrete instance of `IPBlockIpConsumerArrayInput` via:
//
//	IPBlockIpConsumerArray{ IPBlockIpConsumerArgs{...} }
type IPBlockIpConsumerArrayInput interface {
	pulumi.Input

	ToIPBlockIpConsumerArrayOutput() IPBlockIpConsumerArrayOutput
	ToIPBlockIpConsumerArrayOutputWithContext(context.Context) IPBlockIpConsumerArrayOutput
}

type IPBlockIpConsumerArray []IPBlockIpConsumerInput

func (IPBlockIpConsumerArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IPBlockIpConsumer)(nil)).Elem()
}

func (i IPBlockIpConsumerArray) ToIPBlockIpConsumerArrayOutput() IPBlockIpConsumerArrayOutput {
	return i.ToIPBlockIpConsumerArrayOutputWithContext(context.Background())
}

func (i IPBlockIpConsumerArray) ToIPBlockIpConsumerArrayOutputWithContext(ctx context.Context) IPBlockIpConsumerArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IPBlockIpConsumerArrayOutput)
}

type IPBlockIpConsumerOutput struct{ *pulumi.OutputState }

func (IPBlockIpConsumerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IPBlockIpConsumer)(nil)).Elem()
}

func (o IPBlockIpConsumerOutput) ToIPBlockIpConsumerOutput() IPBlockIpConsumerOutput {
	return o
}

func (o IPBlockIpConsumerOutput) ToIPBlockIpConsumerOutputWithContext(ctx context.Context) IPBlockIpConsumerOutput {
	return o
}

func (o IPBlockIpConsumerOutput) DatacenterId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IPBlockIpConsumer) *string { return v.DatacenterId }).(pulumi.StringPtrOutput)
}

func (o IPBlockIpConsumerOutput) DatacenterName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IPBlockIpConsumer) *string { return v.DatacenterName }).(pulumi.StringPtrOutput)
}

func (o IPBlockIpConsumerOutput) Ip() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IPBlockIpConsumer) *string { return v.Ip }).(pulumi.StringPtrOutput)
}

func (o IPBlockIpConsumerOutput) K8sClusterUuid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IPBlockIpConsumer) *string { return v.K8sClusterUuid }).(pulumi.StringPtrOutput)
}

func (o IPBlockIpConsumerOutput) K8sNodepoolUuid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IPBlockIpConsumer) *string { return v.K8sNodepoolUuid }).(pulumi.StringPtrOutput)
}

func (o IPBlockIpConsumerOutput) Mac() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IPBlockIpConsumer) *string { return v.Mac }).(pulumi.StringPtrOutput)
}

func (o IPBlockIpConsumerOutput) NicId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IPBlockIpConsumer) *string { return v.NicId }).(pulumi.StringPtrOutput)
}

func (o IPBlockIpConsumerOutput) ServerId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IPBlockIpConsumer) *string { return v.ServerId }).(pulumi.StringPtrOutput)
}

func (o IPBlockIpConsumerOutput) ServerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IPBlockIpConsumer) *string { return v.ServerName }).(pulumi.StringPtrOutput)
}

type IPBlockIpConsumerArrayOutput struct{ *pulumi.OutputState }

func (IPBlockIpConsumerArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IPBlockIpConsumer)(nil)).Elem()
}

func (o IPBlockIpConsumerArrayOutput) ToIPBlockIpConsumerArrayOutput() IPBlockIpConsumerArrayOutput {
	return o
}

func (o IPBlockIpConsumerArrayOutput) ToIPBlockIpConsumerArrayOutputWithContext(ctx context.Context) IPBlockIpConsumerArrayOutput {
	return o
}

func (o IPBlockIpConsumerArrayOutput) Index(i pulumi.IntInput) IPBlockIpConsumerOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IPBlockIpConsumer {
		return vs[0].([]IPBlockIpConsumer)[vs[1].(int)]
	}).(IPBlockIpConsumerOutput)
}

type LanIpFailover struct {
	Ip      *string `pulumi:"ip"`
	NicUuid *string `pulumi:"nicUuid"`
}

// LanIpFailoverInput is an input type that accepts LanIpFailoverArgs and LanIpFailoverOutput values.
// You can construct a concrete instance of `LanIpFailoverInput` via:
//
//	LanIpFailoverArgs{...}
type LanIpFailoverInput interface {
	pulumi.Input

	ToLanIpFailoverOutput() LanIpFailoverOutput
	ToLanIpFailoverOutputWithContext(context.Context) LanIpFailoverOutput
}

type LanIpFailoverArgs struct {
	Ip      pulumi.StringPtrInput `pulumi:"ip"`
	NicUuid pulumi.StringPtrInput `pulumi:"nicUuid"`
}

func (LanIpFailoverArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LanIpFailover)(nil)).Elem()
}

func (i LanIpFailoverArgs) ToLanIpFailoverOutput() LanIpFailoverOutput {
	return i.ToLanIpFailoverOutputWithContext(context.Background())
}

func (i LanIpFailoverArgs) ToLanIpFailoverOutputWithContext(ctx context.Context) LanIpFailoverOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LanIpFailoverOutput)
}

// LanIpFailoverArrayInput is an input type that accepts LanIpFailoverArray and LanIpFailoverArrayOutput values.
// You can construct a concrete instance of `LanIpFailoverArrayInput` via:
//
//	LanIpFailoverArray{ LanIpFailoverArgs{...} }
type LanIpFailoverArrayInput interface {
	pulumi.Input

	ToLanIpFailoverArrayOutput() LanIpFailoverArrayOutput
	ToLanIpFailoverArrayOutputWithContext(context.Context) LanIpFailoverArrayOutput
}

type LanIpFailoverArray []LanIpFailoverInput

func (LanIpFailoverArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LanIpFailover)(nil)).Elem()
}

func (i LanIpFailoverArray) ToLanIpFailoverArrayOutput() LanIpFailoverArrayOutput {
	return i.ToLanIpFailoverArrayOutputWithContext(context.Background())
}

func (i LanIpFailoverArray) ToLanIpFailoverArrayOutputWithContext(ctx context.Context) LanIpFailoverArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LanIpFailoverArrayOutput)
}

type LanIpFailoverOutput struct{ *pulumi.OutputState }

func (LanIpFailoverOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LanIpFailover)(nil)).Elem()
}

func (o LanIpFailoverOutput) ToLanIpFailoverOutput() LanIpFailoverOutput {
	return o
}

func (o LanIpFailoverOutput) ToLanIpFailoverOutputWithContext(ctx context.Context) LanIpFailoverOutput {
	return o
}

func (o LanIpFailoverOutput) Ip() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LanIpFailover) *string { return v.Ip }).(pulumi.StringPtrOutput)
}

func (o LanIpFailoverOutput) NicUuid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LanIpFailover) *string { return v.NicUuid }).(pulumi.StringPtrOutput)
}

type LanIpFailoverArrayOutput struct{ *pulumi.OutputState }

func (LanIpFailoverArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LanIpFailover)(nil)).Elem()
}

func (o LanIpFailoverArrayOutput) ToLanIpFailoverArrayOutput() LanIpFailoverArrayOutput {
	return o
}

func (o LanIpFailoverArrayOutput) ToLanIpFailoverArrayOutputWithContext(ctx context.Context) LanIpFailoverArrayOutput {
	return o
}

func (o LanIpFailoverArrayOutput) Index(i pulumi.IntInput) LanIpFailoverOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LanIpFailover {
		return vs[0].([]LanIpFailover)[vs[1].(int)]
	}).(LanIpFailoverOutput)
}

type NatGatewayLan struct {
	// [list] Collection of gateway IP addresses of the NAT gateway. Will be auto-generated if not provided. Should ideally be an IP belonging to the same subnet as the LAN.
	GatewayIps []string `pulumi:"gatewayIps"`
	// [int] Id for the LAN connected to the NAT gateway.
	Id int `pulumi:"id"`
}

// NatGatewayLanInput is an input type that accepts NatGatewayLanArgs and NatGatewayLanOutput values.
// You can construct a concrete instance of `NatGatewayLanInput` via:
//
//	NatGatewayLanArgs{...}
type NatGatewayLanInput interface {
	pulumi.Input

	ToNatGatewayLanOutput() NatGatewayLanOutput
	ToNatGatewayLanOutputWithContext(context.Context) NatGatewayLanOutput
}

type NatGatewayLanArgs struct {
	// [list] Collection of gateway IP addresses of the NAT gateway. Will be auto-generated if not provided. Should ideally be an IP belonging to the same subnet as the LAN.
	GatewayIps pulumi.StringArrayInput `pulumi:"gatewayIps"`
	// [int] Id for the LAN connected to the NAT gateway.
	Id pulumi.IntInput `pulumi:"id"`
}

func (NatGatewayLanArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NatGatewayLan)(nil)).Elem()
}

func (i NatGatewayLanArgs) ToNatGatewayLanOutput() NatGatewayLanOutput {
	return i.ToNatGatewayLanOutputWithContext(context.Background())
}

func (i NatGatewayLanArgs) ToNatGatewayLanOutputWithContext(ctx context.Context) NatGatewayLanOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NatGatewayLanOutput)
}

// NatGatewayLanArrayInput is an input type that accepts NatGatewayLanArray and NatGatewayLanArrayOutput values.
// You can construct a concrete instance of `NatGatewayLanArrayInput` via:
//
//	NatGatewayLanArray{ NatGatewayLanArgs{...} }
type NatGatewayLanArrayInput interface {
	pulumi.Input

	ToNatGatewayLanArrayOutput() NatGatewayLanArrayOutput
	ToNatGatewayLanArrayOutputWithContext(context.Context) NatGatewayLanArrayOutput
}

type NatGatewayLanArray []NatGatewayLanInput

func (NatGatewayLanArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NatGatewayLan)(nil)).Elem()
}

func (i NatGatewayLanArray) ToNatGatewayLanArrayOutput() NatGatewayLanArrayOutput {
	return i.ToNatGatewayLanArrayOutputWithContext(context.Background())
}

func (i NatGatewayLanArray) ToNatGatewayLanArrayOutputWithContext(ctx context.Context) NatGatewayLanArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NatGatewayLanArrayOutput)
}

type NatGatewayLanOutput struct{ *pulumi.OutputState }

func (NatGatewayLanOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NatGatewayLan)(nil)).Elem()
}

func (o NatGatewayLanOutput) ToNatGatewayLanOutput() NatGatewayLanOutput {
	return o
}

func (o NatGatewayLanOutput) ToNatGatewayLanOutputWithContext(ctx context.Context) NatGatewayLanOutput {
	return o
}

// [list] Collection of gateway IP addresses of the NAT gateway. Will be auto-generated if not provided. Should ideally be an IP belonging to the same subnet as the LAN.
func (o NatGatewayLanOutput) GatewayIps() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NatGatewayLan) []string { return v.GatewayIps }).(pulumi.StringArrayOutput)
}

// [int] Id for the LAN connected to the NAT gateway.
func (o NatGatewayLanOutput) Id() pulumi.IntOutput {
	return o.ApplyT(func(v NatGatewayLan) int { return v.Id }).(pulumi.IntOutput)
}

type NatGatewayLanArrayOutput struct{ *pulumi.OutputState }

func (NatGatewayLanArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NatGatewayLan)(nil)).Elem()
}

func (o NatGatewayLanArrayOutput) ToNatGatewayLanArrayOutput() NatGatewayLanArrayOutput {
	return o
}

func (o NatGatewayLanArrayOutput) ToNatGatewayLanArrayOutputWithContext(ctx context.Context) NatGatewayLanArrayOutput {
	return o
}

func (o NatGatewayLanArrayOutput) Index(i pulumi.IntInput) NatGatewayLanOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) NatGatewayLan {
		return vs[0].([]NatGatewayLan)[vs[1].(int)]
	}).(NatGatewayLanOutput)
}

type NatGatewayRuleTargetPortRange struct {
	// [int] Target port range end associated with the NAT gateway rule.
	End *int `pulumi:"end"`
	// [int] Target port range start associated with the NAT gateway rule.
	Start *int `pulumi:"start"`
}

// NatGatewayRuleTargetPortRangeInput is an input type that accepts NatGatewayRuleTargetPortRangeArgs and NatGatewayRuleTargetPortRangeOutput values.
// You can construct a concrete instance of `NatGatewayRuleTargetPortRangeInput` via:
//
//	NatGatewayRuleTargetPortRangeArgs{...}
type NatGatewayRuleTargetPortRangeInput interface {
	pulumi.Input

	ToNatGatewayRuleTargetPortRangeOutput() NatGatewayRuleTargetPortRangeOutput
	ToNatGatewayRuleTargetPortRangeOutputWithContext(context.Context) NatGatewayRuleTargetPortRangeOutput
}

type NatGatewayRuleTargetPortRangeArgs struct {
	// [int] Target port range end associated with the NAT gateway rule.
	End pulumi.IntPtrInput `pulumi:"end"`
	// [int] Target port range start associated with the NAT gateway rule.
	Start pulumi.IntPtrInput `pulumi:"start"`
}

func (NatGatewayRuleTargetPortRangeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NatGatewayRuleTargetPortRange)(nil)).Elem()
}

func (i NatGatewayRuleTargetPortRangeArgs) ToNatGatewayRuleTargetPortRangeOutput() NatGatewayRuleTargetPortRangeOutput {
	return i.ToNatGatewayRuleTargetPortRangeOutputWithContext(context.Background())
}

func (i NatGatewayRuleTargetPortRangeArgs) ToNatGatewayRuleTargetPortRangeOutputWithContext(ctx context.Context) NatGatewayRuleTargetPortRangeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NatGatewayRuleTargetPortRangeOutput)
}

func (i NatGatewayRuleTargetPortRangeArgs) ToNatGatewayRuleTargetPortRangePtrOutput() NatGatewayRuleTargetPortRangePtrOutput {
	return i.ToNatGatewayRuleTargetPortRangePtrOutputWithContext(context.Background())
}

func (i NatGatewayRuleTargetPortRangeArgs) ToNatGatewayRuleTargetPortRangePtrOutputWithContext(ctx context.Context) NatGatewayRuleTargetPortRangePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NatGatewayRuleTargetPortRangeOutput).ToNatGatewayRuleTargetPortRangePtrOutputWithContext(ctx)
}

// NatGatewayRuleTargetPortRangePtrInput is an input type that accepts NatGatewayRuleTargetPortRangeArgs, NatGatewayRuleTargetPortRangePtr and NatGatewayRuleTargetPortRangePtrOutput values.
// You can construct a concrete instance of `NatGatewayRuleTargetPortRangePtrInput` via:
//
//	        NatGatewayRuleTargetPortRangeArgs{...}
//
//	or:
//
//	        nil
type NatGatewayRuleTargetPortRangePtrInput interface {
	pulumi.Input

	ToNatGatewayRuleTargetPortRangePtrOutput() NatGatewayRuleTargetPortRangePtrOutput
	ToNatGatewayRuleTargetPortRangePtrOutputWithContext(context.Context) NatGatewayRuleTargetPortRangePtrOutput
}

type natGatewayRuleTargetPortRangePtrType NatGatewayRuleTargetPortRangeArgs

func NatGatewayRuleTargetPortRangePtr(v *NatGatewayRuleTargetPortRangeArgs) NatGatewayRuleTargetPortRangePtrInput {
	return (*natGatewayRuleTargetPortRangePtrType)(v)
}

func (*natGatewayRuleTargetPortRangePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**NatGatewayRuleTargetPortRange)(nil)).Elem()
}

func (i *natGatewayRuleTargetPortRangePtrType) ToNatGatewayRuleTargetPortRangePtrOutput() NatGatewayRuleTargetPortRangePtrOutput {
	return i.ToNatGatewayRuleTargetPortRangePtrOutputWithContext(context.Background())
}

func (i *natGatewayRuleTargetPortRangePtrType) ToNatGatewayRuleTargetPortRangePtrOutputWithContext(ctx context.Context) NatGatewayRuleTargetPortRangePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NatGatewayRuleTargetPortRangePtrOutput)
}

type NatGatewayRuleTargetPortRangeOutput struct{ *pulumi.OutputState }

func (NatGatewayRuleTargetPortRangeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NatGatewayRuleTargetPortRange)(nil)).Elem()
}

func (o NatGatewayRuleTargetPortRangeOutput) ToNatGatewayRuleTargetPortRangeOutput() NatGatewayRuleTargetPortRangeOutput {
	return o
}

func (o NatGatewayRuleTargetPortRangeOutput) ToNatGatewayRuleTargetPortRangeOutputWithContext(ctx context.Context) NatGatewayRuleTargetPortRangeOutput {
	return o
}

func (o NatGatewayRuleTargetPortRangeOutput) ToNatGatewayRuleTargetPortRangePtrOutput() NatGatewayRuleTargetPortRangePtrOutput {
	return o.ToNatGatewayRuleTargetPortRangePtrOutputWithContext(context.Background())
}

func (o NatGatewayRuleTargetPortRangeOutput) ToNatGatewayRuleTargetPortRangePtrOutputWithContext(ctx context.Context) NatGatewayRuleTargetPortRangePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v NatGatewayRuleTargetPortRange) *NatGatewayRuleTargetPortRange {
		return &v
	}).(NatGatewayRuleTargetPortRangePtrOutput)
}

// [int] Target port range end associated with the NAT gateway rule.
func (o NatGatewayRuleTargetPortRangeOutput) End() pulumi.IntPtrOutput {
	return o.ApplyT(func(v NatGatewayRuleTargetPortRange) *int { return v.End }).(pulumi.IntPtrOutput)
}

// [int] Target port range start associated with the NAT gateway rule.
func (o NatGatewayRuleTargetPortRangeOutput) Start() pulumi.IntPtrOutput {
	return o.ApplyT(func(v NatGatewayRuleTargetPortRange) *int { return v.Start }).(pulumi.IntPtrOutput)
}

type NatGatewayRuleTargetPortRangePtrOutput struct{ *pulumi.OutputState }

func (NatGatewayRuleTargetPortRangePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NatGatewayRuleTargetPortRange)(nil)).Elem()
}

func (o NatGatewayRuleTargetPortRangePtrOutput) ToNatGatewayRuleTargetPortRangePtrOutput() NatGatewayRuleTargetPortRangePtrOutput {
	return o
}

func (o NatGatewayRuleTargetPortRangePtrOutput) ToNatGatewayRuleTargetPortRangePtrOutputWithContext(ctx context.Context) NatGatewayRuleTargetPortRangePtrOutput {
	return o
}

func (o NatGatewayRuleTargetPortRangePtrOutput) Elem() NatGatewayRuleTargetPortRangeOutput {
	return o.ApplyT(func(v *NatGatewayRuleTargetPortRange) NatGatewayRuleTargetPortRange {
		if v != nil {
			return *v
		}
		var ret NatGatewayRuleTargetPortRange
		return ret
	}).(NatGatewayRuleTargetPortRangeOutput)
}

// [int] Target port range end associated with the NAT gateway rule.
func (o NatGatewayRuleTargetPortRangePtrOutput) End() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *NatGatewayRuleTargetPortRange) *int {
		if v == nil {
			return nil
		}
		return v.End
	}).(pulumi.IntPtrOutput)
}

// [int] Target port range start associated with the NAT gateway rule.
func (o NatGatewayRuleTargetPortRangePtrOutput) Start() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *NatGatewayRuleTargetPortRange) *int {
		if v == nil {
			return nil
		}
		return v.Start
	}).(pulumi.IntPtrOutput)
}

type NicFlowlog struct {
	// Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL. Immutable, update forces re-creation.
	Action string `pulumi:"action"`
	// Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist. Immutable, update forces re-creation.
	Bucket string `pulumi:"bucket"`
	// Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, update forces re-creation.
	Direction string `pulumi:"direction"`
	// The ID of the NIC.
	Id *string `pulumi:"id"`
	// Specifies the name of the flow log.
	//
	// ⚠️ **Note:**: Removing the `flowlog` forces re-creation of the NIC resource.
	Name string `pulumi:"name"`
}

// NicFlowlogInput is an input type that accepts NicFlowlogArgs and NicFlowlogOutput values.
// You can construct a concrete instance of `NicFlowlogInput` via:
//
//	NicFlowlogArgs{...}
type NicFlowlogInput interface {
	pulumi.Input

	ToNicFlowlogOutput() NicFlowlogOutput
	ToNicFlowlogOutputWithContext(context.Context) NicFlowlogOutput
}

type NicFlowlogArgs struct {
	// Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL. Immutable, update forces re-creation.
	Action pulumi.StringInput `pulumi:"action"`
	// Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist. Immutable, update forces re-creation.
	Bucket pulumi.StringInput `pulumi:"bucket"`
	// Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, update forces re-creation.
	Direction pulumi.StringInput `pulumi:"direction"`
	// The ID of the NIC.
	Id pulumi.StringPtrInput `pulumi:"id"`
	// Specifies the name of the flow log.
	//
	// ⚠️ **Note:**: Removing the `flowlog` forces re-creation of the NIC resource.
	Name pulumi.StringInput `pulumi:"name"`
}

func (NicFlowlogArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NicFlowlog)(nil)).Elem()
}

func (i NicFlowlogArgs) ToNicFlowlogOutput() NicFlowlogOutput {
	return i.ToNicFlowlogOutputWithContext(context.Background())
}

func (i NicFlowlogArgs) ToNicFlowlogOutputWithContext(ctx context.Context) NicFlowlogOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NicFlowlogOutput)
}

func (i NicFlowlogArgs) ToNicFlowlogPtrOutput() NicFlowlogPtrOutput {
	return i.ToNicFlowlogPtrOutputWithContext(context.Background())
}

func (i NicFlowlogArgs) ToNicFlowlogPtrOutputWithContext(ctx context.Context) NicFlowlogPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NicFlowlogOutput).ToNicFlowlogPtrOutputWithContext(ctx)
}

// NicFlowlogPtrInput is an input type that accepts NicFlowlogArgs, NicFlowlogPtr and NicFlowlogPtrOutput values.
// You can construct a concrete instance of `NicFlowlogPtrInput` via:
//
//	        NicFlowlogArgs{...}
//
//	or:
//
//	        nil
type NicFlowlogPtrInput interface {
	pulumi.Input

	ToNicFlowlogPtrOutput() NicFlowlogPtrOutput
	ToNicFlowlogPtrOutputWithContext(context.Context) NicFlowlogPtrOutput
}

type nicFlowlogPtrType NicFlowlogArgs

func NicFlowlogPtr(v *NicFlowlogArgs) NicFlowlogPtrInput {
	return (*nicFlowlogPtrType)(v)
}

func (*nicFlowlogPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**NicFlowlog)(nil)).Elem()
}

func (i *nicFlowlogPtrType) ToNicFlowlogPtrOutput() NicFlowlogPtrOutput {
	return i.ToNicFlowlogPtrOutputWithContext(context.Background())
}

func (i *nicFlowlogPtrType) ToNicFlowlogPtrOutputWithContext(ctx context.Context) NicFlowlogPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NicFlowlogPtrOutput)
}

type NicFlowlogOutput struct{ *pulumi.OutputState }

func (NicFlowlogOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NicFlowlog)(nil)).Elem()
}

func (o NicFlowlogOutput) ToNicFlowlogOutput() NicFlowlogOutput {
	return o
}

func (o NicFlowlogOutput) ToNicFlowlogOutputWithContext(ctx context.Context) NicFlowlogOutput {
	return o
}

func (o NicFlowlogOutput) ToNicFlowlogPtrOutput() NicFlowlogPtrOutput {
	return o.ToNicFlowlogPtrOutputWithContext(context.Background())
}

func (o NicFlowlogOutput) ToNicFlowlogPtrOutputWithContext(ctx context.Context) NicFlowlogPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v NicFlowlog) *NicFlowlog {
		return &v
	}).(NicFlowlogPtrOutput)
}

// Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL. Immutable, update forces re-creation.
func (o NicFlowlogOutput) Action() pulumi.StringOutput {
	return o.ApplyT(func(v NicFlowlog) string { return v.Action }).(pulumi.StringOutput)
}

// Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist. Immutable, update forces re-creation.
func (o NicFlowlogOutput) Bucket() pulumi.StringOutput {
	return o.ApplyT(func(v NicFlowlog) string { return v.Bucket }).(pulumi.StringOutput)
}

// Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, update forces re-creation.
func (o NicFlowlogOutput) Direction() pulumi.StringOutput {
	return o.ApplyT(func(v NicFlowlog) string { return v.Direction }).(pulumi.StringOutput)
}

// The ID of the NIC.
func (o NicFlowlogOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NicFlowlog) *string { return v.Id }).(pulumi.StringPtrOutput)
}

// Specifies the name of the flow log.
//
// ⚠️ **Note:**: Removing the `flowlog` forces re-creation of the NIC resource.
func (o NicFlowlogOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v NicFlowlog) string { return v.Name }).(pulumi.StringOutput)
}

type NicFlowlogPtrOutput struct{ *pulumi.OutputState }

func (NicFlowlogPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NicFlowlog)(nil)).Elem()
}

func (o NicFlowlogPtrOutput) ToNicFlowlogPtrOutput() NicFlowlogPtrOutput {
	return o
}

func (o NicFlowlogPtrOutput) ToNicFlowlogPtrOutputWithContext(ctx context.Context) NicFlowlogPtrOutput {
	return o
}

func (o NicFlowlogPtrOutput) Elem() NicFlowlogOutput {
	return o.ApplyT(func(v *NicFlowlog) NicFlowlog {
		if v != nil {
			return *v
		}
		var ret NicFlowlog
		return ret
	}).(NicFlowlogOutput)
}

// Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL. Immutable, update forces re-creation.
func (o NicFlowlogPtrOutput) Action() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NicFlowlog) *string {
		if v == nil {
			return nil
		}
		return &v.Action
	}).(pulumi.StringPtrOutput)
}

// Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist. Immutable, update forces re-creation.
func (o NicFlowlogPtrOutput) Bucket() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NicFlowlog) *string {
		if v == nil {
			return nil
		}
		return &v.Bucket
	}).(pulumi.StringPtrOutput)
}

// Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, update forces re-creation.
func (o NicFlowlogPtrOutput) Direction() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NicFlowlog) *string {
		if v == nil {
			return nil
		}
		return &v.Direction
	}).(pulumi.StringPtrOutput)
}

// The ID of the NIC.
func (o NicFlowlogPtrOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NicFlowlog) *string {
		if v == nil {
			return nil
		}
		return v.Id
	}).(pulumi.StringPtrOutput)
}

// Specifies the name of the flow log.
//
// ⚠️ **Note:**: Removing the `flowlog` forces re-creation of the NIC resource.
func (o NicFlowlogPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NicFlowlog) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

type ServerLabel struct {
	// [string] The key of the label.
	Key string `pulumi:"key"`
	// [string] The value of the label.
	Value string `pulumi:"value"`
}

// ServerLabelInput is an input type that accepts ServerLabelArgs and ServerLabelOutput values.
// You can construct a concrete instance of `ServerLabelInput` via:
//
//	ServerLabelArgs{...}
type ServerLabelInput interface {
	pulumi.Input

	ToServerLabelOutput() ServerLabelOutput
	ToServerLabelOutputWithContext(context.Context) ServerLabelOutput
}

type ServerLabelArgs struct {
	// [string] The key of the label.
	Key pulumi.StringInput `pulumi:"key"`
	// [string] The value of the label.
	Value pulumi.StringInput `pulumi:"value"`
}

func (ServerLabelArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServerLabel)(nil)).Elem()
}

func (i ServerLabelArgs) ToServerLabelOutput() ServerLabelOutput {
	return i.ToServerLabelOutputWithContext(context.Background())
}

func (i ServerLabelArgs) ToServerLabelOutputWithContext(ctx context.Context) ServerLabelOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServerLabelOutput)
}

// ServerLabelArrayInput is an input type that accepts ServerLabelArray and ServerLabelArrayOutput values.
// You can construct a concrete instance of `ServerLabelArrayInput` via:
//
//	ServerLabelArray{ ServerLabelArgs{...} }
type ServerLabelArrayInput interface {
	pulumi.Input

	ToServerLabelArrayOutput() ServerLabelArrayOutput
	ToServerLabelArrayOutputWithContext(context.Context) ServerLabelArrayOutput
}

type ServerLabelArray []ServerLabelInput

func (ServerLabelArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ServerLabel)(nil)).Elem()
}

func (i ServerLabelArray) ToServerLabelArrayOutput() ServerLabelArrayOutput {
	return i.ToServerLabelArrayOutputWithContext(context.Background())
}

func (i ServerLabelArray) ToServerLabelArrayOutputWithContext(ctx context.Context) ServerLabelArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServerLabelArrayOutput)
}

type ServerLabelOutput struct{ *pulumi.OutputState }

func (ServerLabelOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServerLabel)(nil)).Elem()
}

func (o ServerLabelOutput) ToServerLabelOutput() ServerLabelOutput {
	return o
}

func (o ServerLabelOutput) ToServerLabelOutputWithContext(ctx context.Context) ServerLabelOutput {
	return o
}

// [string] The key of the label.
func (o ServerLabelOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ServerLabel) string { return v.Key }).(pulumi.StringOutput)
}

// [string] The value of the label.
func (o ServerLabelOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v ServerLabel) string { return v.Value }).(pulumi.StringOutput)
}

type ServerLabelArrayOutput struct{ *pulumi.OutputState }

func (ServerLabelArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ServerLabel)(nil)).Elem()
}

func (o ServerLabelArrayOutput) ToServerLabelArrayOutput() ServerLabelArrayOutput {
	return o
}

func (o ServerLabelArrayOutput) ToServerLabelArrayOutputWithContext(ctx context.Context) ServerLabelArrayOutput {
	return o
}

func (o ServerLabelArrayOutput) Index(i pulumi.IntInput) ServerLabelOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ServerLabel {
		return vs[0].([]ServerLabel)[vs[1].(int)]
	}).(ServerLabelOutput)
}

type ServerNic struct {
	DeviceNumber *int  `pulumi:"deviceNumber"`
	Dhcp         *bool `pulumi:"dhcp"`
	// Indicates whether this NIC receives an IPv6 address through DHCP.
	Dhcpv6         *bool   `pulumi:"dhcpv6"`
	FirewallActive *bool   `pulumi:"firewallActive"`
	FirewallType   *string `pulumi:"firewallType"`
	// Allows to define firewall rules inline in the server. See the Firewall section.
	Firewalls []ServerNicFirewall `pulumi:"firewalls"`
	Id        *string             `pulumi:"id"`
	// Collection of IP addresses assigned to a nic. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.
	Ips []string `pulumi:"ips"`
	// IPv6 CIDR block assigned to the NIC.
	Ipv6CidrBlock *string `pulumi:"ipv6CidrBlock"`
	// Collection for IPv6 addresses assigned to a nic. Explicitly assigned IPv6 addresses need to come from inside the IPv6 CIDR block assigned to the nic.
	Ipv6Ips []string `pulumi:"ipv6Ips"`
	Lan     int      `pulumi:"lan"`
	Mac     *string  `pulumi:"mac"`
	// [string] The name of the server.
	Name    *string `pulumi:"name"`
	PciSlot *int    `pulumi:"pciSlot"`
}

// ServerNicInput is an input type that accepts ServerNicArgs and ServerNicOutput values.
// You can construct a concrete instance of `ServerNicInput` via:
//
//	ServerNicArgs{...}
type ServerNicInput interface {
	pulumi.Input

	ToServerNicOutput() ServerNicOutput
	ToServerNicOutputWithContext(context.Context) ServerNicOutput
}

type ServerNicArgs struct {
	DeviceNumber pulumi.IntPtrInput  `pulumi:"deviceNumber"`
	Dhcp         pulumi.BoolPtrInput `pulumi:"dhcp"`
	// Indicates whether this NIC receives an IPv6 address through DHCP.
	Dhcpv6         pulumi.BoolPtrInput   `pulumi:"dhcpv6"`
	FirewallActive pulumi.BoolPtrInput   `pulumi:"firewallActive"`
	FirewallType   pulumi.StringPtrInput `pulumi:"firewallType"`
	// Allows to define firewall rules inline in the server. See the Firewall section.
	Firewalls ServerNicFirewallArrayInput `pulumi:"firewalls"`
	Id        pulumi.StringPtrInput       `pulumi:"id"`
	// Collection of IP addresses assigned to a nic. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.
	Ips pulumi.StringArrayInput `pulumi:"ips"`
	// IPv6 CIDR block assigned to the NIC.
	Ipv6CidrBlock pulumi.StringPtrInput `pulumi:"ipv6CidrBlock"`
	// Collection for IPv6 addresses assigned to a nic. Explicitly assigned IPv6 addresses need to come from inside the IPv6 CIDR block assigned to the nic.
	Ipv6Ips pulumi.StringArrayInput `pulumi:"ipv6Ips"`
	Lan     pulumi.IntInput         `pulumi:"lan"`
	Mac     pulumi.StringPtrInput   `pulumi:"mac"`
	// [string] The name of the server.
	Name    pulumi.StringPtrInput `pulumi:"name"`
	PciSlot pulumi.IntPtrInput    `pulumi:"pciSlot"`
}

func (ServerNicArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServerNic)(nil)).Elem()
}

func (i ServerNicArgs) ToServerNicOutput() ServerNicOutput {
	return i.ToServerNicOutputWithContext(context.Background())
}

func (i ServerNicArgs) ToServerNicOutputWithContext(ctx context.Context) ServerNicOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServerNicOutput)
}

func (i ServerNicArgs) ToServerNicPtrOutput() ServerNicPtrOutput {
	return i.ToServerNicPtrOutputWithContext(context.Background())
}

func (i ServerNicArgs) ToServerNicPtrOutputWithContext(ctx context.Context) ServerNicPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServerNicOutput).ToServerNicPtrOutputWithContext(ctx)
}

// ServerNicPtrInput is an input type that accepts ServerNicArgs, ServerNicPtr and ServerNicPtrOutput values.
// You can construct a concrete instance of `ServerNicPtrInput` via:
//
//	        ServerNicArgs{...}
//
//	or:
//
//	        nil
type ServerNicPtrInput interface {
	pulumi.Input

	ToServerNicPtrOutput() ServerNicPtrOutput
	ToServerNicPtrOutputWithContext(context.Context) ServerNicPtrOutput
}

type serverNicPtrType ServerNicArgs

func ServerNicPtr(v *ServerNicArgs) ServerNicPtrInput {
	return (*serverNicPtrType)(v)
}

func (*serverNicPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ServerNic)(nil)).Elem()
}

func (i *serverNicPtrType) ToServerNicPtrOutput() ServerNicPtrOutput {
	return i.ToServerNicPtrOutputWithContext(context.Background())
}

func (i *serverNicPtrType) ToServerNicPtrOutputWithContext(ctx context.Context) ServerNicPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServerNicPtrOutput)
}

type ServerNicOutput struct{ *pulumi.OutputState }

func (ServerNicOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServerNic)(nil)).Elem()
}

func (o ServerNicOutput) ToServerNicOutput() ServerNicOutput {
	return o
}

func (o ServerNicOutput) ToServerNicOutputWithContext(ctx context.Context) ServerNicOutput {
	return o
}

func (o ServerNicOutput) ToServerNicPtrOutput() ServerNicPtrOutput {
	return o.ToServerNicPtrOutputWithContext(context.Background())
}

func (o ServerNicOutput) ToServerNicPtrOutputWithContext(ctx context.Context) ServerNicPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ServerNic) *ServerNic {
		return &v
	}).(ServerNicPtrOutput)
}

func (o ServerNicOutput) DeviceNumber() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ServerNic) *int { return v.DeviceNumber }).(pulumi.IntPtrOutput)
}

func (o ServerNicOutput) Dhcp() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ServerNic) *bool { return v.Dhcp }).(pulumi.BoolPtrOutput)
}

// Indicates whether this NIC receives an IPv6 address through DHCP.
func (o ServerNicOutput) Dhcpv6() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ServerNic) *bool { return v.Dhcpv6 }).(pulumi.BoolPtrOutput)
}

func (o ServerNicOutput) FirewallActive() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ServerNic) *bool { return v.FirewallActive }).(pulumi.BoolPtrOutput)
}

func (o ServerNicOutput) FirewallType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServerNic) *string { return v.FirewallType }).(pulumi.StringPtrOutput)
}

// Allows to define firewall rules inline in the server. See the Firewall section.
func (o ServerNicOutput) Firewalls() ServerNicFirewallArrayOutput {
	return o.ApplyT(func(v ServerNic) []ServerNicFirewall { return v.Firewalls }).(ServerNicFirewallArrayOutput)
}

func (o ServerNicOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServerNic) *string { return v.Id }).(pulumi.StringPtrOutput)
}

// Collection of IP addresses assigned to a nic. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.
func (o ServerNicOutput) Ips() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ServerNic) []string { return v.Ips }).(pulumi.StringArrayOutput)
}

// IPv6 CIDR block assigned to the NIC.
func (o ServerNicOutput) Ipv6CidrBlock() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServerNic) *string { return v.Ipv6CidrBlock }).(pulumi.StringPtrOutput)
}

// Collection for IPv6 addresses assigned to a nic. Explicitly assigned IPv6 addresses need to come from inside the IPv6 CIDR block assigned to the nic.
func (o ServerNicOutput) Ipv6Ips() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ServerNic) []string { return v.Ipv6Ips }).(pulumi.StringArrayOutput)
}

func (o ServerNicOutput) Lan() pulumi.IntOutput {
	return o.ApplyT(func(v ServerNic) int { return v.Lan }).(pulumi.IntOutput)
}

func (o ServerNicOutput) Mac() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServerNic) *string { return v.Mac }).(pulumi.StringPtrOutput)
}

// [string] The name of the server.
func (o ServerNicOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServerNic) *string { return v.Name }).(pulumi.StringPtrOutput)
}

func (o ServerNicOutput) PciSlot() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ServerNic) *int { return v.PciSlot }).(pulumi.IntPtrOutput)
}

type ServerNicPtrOutput struct{ *pulumi.OutputState }

func (ServerNicPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ServerNic)(nil)).Elem()
}

func (o ServerNicPtrOutput) ToServerNicPtrOutput() ServerNicPtrOutput {
	return o
}

func (o ServerNicPtrOutput) ToServerNicPtrOutputWithContext(ctx context.Context) ServerNicPtrOutput {
	return o
}

func (o ServerNicPtrOutput) Elem() ServerNicOutput {
	return o.ApplyT(func(v *ServerNic) ServerNic {
		if v != nil {
			return *v
		}
		var ret ServerNic
		return ret
	}).(ServerNicOutput)
}

func (o ServerNicPtrOutput) DeviceNumber() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ServerNic) *int {
		if v == nil {
			return nil
		}
		return v.DeviceNumber
	}).(pulumi.IntPtrOutput)
}

func (o ServerNicPtrOutput) Dhcp() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ServerNic) *bool {
		if v == nil {
			return nil
		}
		return v.Dhcp
	}).(pulumi.BoolPtrOutput)
}

// Indicates whether this NIC receives an IPv6 address through DHCP.
func (o ServerNicPtrOutput) Dhcpv6() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ServerNic) *bool {
		if v == nil {
			return nil
		}
		return v.Dhcpv6
	}).(pulumi.BoolPtrOutput)
}

func (o ServerNicPtrOutput) FirewallActive() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ServerNic) *bool {
		if v == nil {
			return nil
		}
		return v.FirewallActive
	}).(pulumi.BoolPtrOutput)
}

func (o ServerNicPtrOutput) FirewallType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ServerNic) *string {
		if v == nil {
			return nil
		}
		return v.FirewallType
	}).(pulumi.StringPtrOutput)
}

// Allows to define firewall rules inline in the server. See the Firewall section.
func (o ServerNicPtrOutput) Firewalls() ServerNicFirewallArrayOutput {
	return o.ApplyT(func(v *ServerNic) []ServerNicFirewall {
		if v == nil {
			return nil
		}
		return v.Firewalls
	}).(ServerNicFirewallArrayOutput)
}

func (o ServerNicPtrOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ServerNic) *string {
		if v == nil {
			return nil
		}
		return v.Id
	}).(pulumi.StringPtrOutput)
}

// Collection of IP addresses assigned to a nic. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.
func (o ServerNicPtrOutput) Ips() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ServerNic) []string {
		if v == nil {
			return nil
		}
		return v.Ips
	}).(pulumi.StringArrayOutput)
}

// IPv6 CIDR block assigned to the NIC.
func (o ServerNicPtrOutput) Ipv6CidrBlock() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ServerNic) *string {
		if v == nil {
			return nil
		}
		return v.Ipv6CidrBlock
	}).(pulumi.StringPtrOutput)
}

// Collection for IPv6 addresses assigned to a nic. Explicitly assigned IPv6 addresses need to come from inside the IPv6 CIDR block assigned to the nic.
func (o ServerNicPtrOutput) Ipv6Ips() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ServerNic) []string {
		if v == nil {
			return nil
		}
		return v.Ipv6Ips
	}).(pulumi.StringArrayOutput)
}

func (o ServerNicPtrOutput) Lan() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ServerNic) *int {
		if v == nil {
			return nil
		}
		return &v.Lan
	}).(pulumi.IntPtrOutput)
}

func (o ServerNicPtrOutput) Mac() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ServerNic) *string {
		if v == nil {
			return nil
		}
		return v.Mac
	}).(pulumi.StringPtrOutput)
}

// [string] The name of the server.
func (o ServerNicPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ServerNic) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

func (o ServerNicPtrOutput) PciSlot() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ServerNic) *int {
		if v == nil {
			return nil
		}
		return v.PciSlot
	}).(pulumi.IntPtrOutput)
}

type ServerNicFirewall struct {
	IcmpCode *string `pulumi:"icmpCode"`
	IcmpType *string `pulumi:"icmpType"`
	Id       *string `pulumi:"id"`
	// [string] The name of the server.
	Name           *string `pulumi:"name"`
	PortRangeEnd   *int    `pulumi:"portRangeEnd"`
	PortRangeStart *int    `pulumi:"portRangeStart"`
	Protocol       string  `pulumi:"protocol"`
	SourceIp       *string `pulumi:"sourceIp"`
	SourceMac      *string `pulumi:"sourceMac"`
	TargetIp       *string `pulumi:"targetIp"`
	// (Computed)[string] Server usages: [ENTERPRISE](https://docs.ionos.com/cloud/compute-engine/virtual-servers/virtual-servers) or [CUBE](https://docs.ionos.com/cloud/compute-engine/virtual-servers/cloud-cubes). This property is immutable.
	Type *string `pulumi:"type"`
}

// ServerNicFirewallInput is an input type that accepts ServerNicFirewallArgs and ServerNicFirewallOutput values.
// You can construct a concrete instance of `ServerNicFirewallInput` via:
//
//	ServerNicFirewallArgs{...}
type ServerNicFirewallInput interface {
	pulumi.Input

	ToServerNicFirewallOutput() ServerNicFirewallOutput
	ToServerNicFirewallOutputWithContext(context.Context) ServerNicFirewallOutput
}

type ServerNicFirewallArgs struct {
	IcmpCode pulumi.StringPtrInput `pulumi:"icmpCode"`
	IcmpType pulumi.StringPtrInput `pulumi:"icmpType"`
	Id       pulumi.StringPtrInput `pulumi:"id"`
	// [string] The name of the server.
	Name           pulumi.StringPtrInput `pulumi:"name"`
	PortRangeEnd   pulumi.IntPtrInput    `pulumi:"portRangeEnd"`
	PortRangeStart pulumi.IntPtrInput    `pulumi:"portRangeStart"`
	Protocol       pulumi.StringInput    `pulumi:"protocol"`
	SourceIp       pulumi.StringPtrInput `pulumi:"sourceIp"`
	SourceMac      pulumi.StringPtrInput `pulumi:"sourceMac"`
	TargetIp       pulumi.StringPtrInput `pulumi:"targetIp"`
	// (Computed)[string] Server usages: [ENTERPRISE](https://docs.ionos.com/cloud/compute-engine/virtual-servers/virtual-servers) or [CUBE](https://docs.ionos.com/cloud/compute-engine/virtual-servers/cloud-cubes). This property is immutable.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (ServerNicFirewallArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServerNicFirewall)(nil)).Elem()
}

func (i ServerNicFirewallArgs) ToServerNicFirewallOutput() ServerNicFirewallOutput {
	return i.ToServerNicFirewallOutputWithContext(context.Background())
}

func (i ServerNicFirewallArgs) ToServerNicFirewallOutputWithContext(ctx context.Context) ServerNicFirewallOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServerNicFirewallOutput)
}

// ServerNicFirewallArrayInput is an input type that accepts ServerNicFirewallArray and ServerNicFirewallArrayOutput values.
// You can construct a concrete instance of `ServerNicFirewallArrayInput` via:
//
//	ServerNicFirewallArray{ ServerNicFirewallArgs{...} }
type ServerNicFirewallArrayInput interface {
	pulumi.Input

	ToServerNicFirewallArrayOutput() ServerNicFirewallArrayOutput
	ToServerNicFirewallArrayOutputWithContext(context.Context) ServerNicFirewallArrayOutput
}

type ServerNicFirewallArray []ServerNicFirewallInput

func (ServerNicFirewallArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ServerNicFirewall)(nil)).Elem()
}

func (i ServerNicFirewallArray) ToServerNicFirewallArrayOutput() ServerNicFirewallArrayOutput {
	return i.ToServerNicFirewallArrayOutputWithContext(context.Background())
}

func (i ServerNicFirewallArray) ToServerNicFirewallArrayOutputWithContext(ctx context.Context) ServerNicFirewallArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServerNicFirewallArrayOutput)
}

type ServerNicFirewallOutput struct{ *pulumi.OutputState }

func (ServerNicFirewallOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServerNicFirewall)(nil)).Elem()
}

func (o ServerNicFirewallOutput) ToServerNicFirewallOutput() ServerNicFirewallOutput {
	return o
}

func (o ServerNicFirewallOutput) ToServerNicFirewallOutputWithContext(ctx context.Context) ServerNicFirewallOutput {
	return o
}

func (o ServerNicFirewallOutput) IcmpCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServerNicFirewall) *string { return v.IcmpCode }).(pulumi.StringPtrOutput)
}

func (o ServerNicFirewallOutput) IcmpType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServerNicFirewall) *string { return v.IcmpType }).(pulumi.StringPtrOutput)
}

func (o ServerNicFirewallOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServerNicFirewall) *string { return v.Id }).(pulumi.StringPtrOutput)
}

// [string] The name of the server.
func (o ServerNicFirewallOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServerNicFirewall) *string { return v.Name }).(pulumi.StringPtrOutput)
}

func (o ServerNicFirewallOutput) PortRangeEnd() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ServerNicFirewall) *int { return v.PortRangeEnd }).(pulumi.IntPtrOutput)
}

func (o ServerNicFirewallOutput) PortRangeStart() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ServerNicFirewall) *int { return v.PortRangeStart }).(pulumi.IntPtrOutput)
}

func (o ServerNicFirewallOutput) Protocol() pulumi.StringOutput {
	return o.ApplyT(func(v ServerNicFirewall) string { return v.Protocol }).(pulumi.StringOutput)
}

func (o ServerNicFirewallOutput) SourceIp() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServerNicFirewall) *string { return v.SourceIp }).(pulumi.StringPtrOutput)
}

func (o ServerNicFirewallOutput) SourceMac() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServerNicFirewall) *string { return v.SourceMac }).(pulumi.StringPtrOutput)
}

func (o ServerNicFirewallOutput) TargetIp() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServerNicFirewall) *string { return v.TargetIp }).(pulumi.StringPtrOutput)
}

// (Computed)[string] Server usages: [ENTERPRISE](https://docs.ionos.com/cloud/compute-engine/virtual-servers/virtual-servers) or [CUBE](https://docs.ionos.com/cloud/compute-engine/virtual-servers/cloud-cubes). This property is immutable.
func (o ServerNicFirewallOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServerNicFirewall) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type ServerNicFirewallArrayOutput struct{ *pulumi.OutputState }

func (ServerNicFirewallArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ServerNicFirewall)(nil)).Elem()
}

func (o ServerNicFirewallArrayOutput) ToServerNicFirewallArrayOutput() ServerNicFirewallArrayOutput {
	return o
}

func (o ServerNicFirewallArrayOutput) ToServerNicFirewallArrayOutputWithContext(ctx context.Context) ServerNicFirewallArrayOutput {
	return o
}

func (o ServerNicFirewallArrayOutput) Index(i pulumi.IntInput) ServerNicFirewallOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ServerNicFirewall {
		return vs[0].([]ServerNicFirewall)[vs[1].(int)]
	}).(ServerNicFirewallOutput)
}

type ServerVolume struct {
	// [string] The availability zone in which the server should exist. E.g: `AUTO`, `ZONE_1`, `ZONE_2`. This property is immutable.
	AvailabilityZone *string `pulumi:"availabilityZone"`
	// The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
	BackupUnitId *string `pulumi:"backupUnitId"`
	// The UUID of the attached server.
	BootServer          *string `pulumi:"bootServer"`
	Bus                 *string `pulumi:"bus"`
	CpuHotPlug          *bool   `pulumi:"cpuHotPlug"`
	DeviceNumber        *int    `pulumi:"deviceNumber"`
	DiscVirtioHotPlug   *bool   `pulumi:"discVirtioHotPlug"`
	DiscVirtioHotUnplug *bool   `pulumi:"discVirtioHotUnplug"`
	DiskType            string  `pulumi:"diskType"`
	// [string] Required if `sshKeyPath` is not provided.
	//
	// Deprecated: Please use imagePassword under server level
	ImagePassword *string `pulumi:"imagePassword"`
	// [string] Sets the OS type of the server.
	LicenceType *string `pulumi:"licenceType"`
	// [string] The name of the server.
	Name         *string `pulumi:"name"`
	NicHotPlug   *bool   `pulumi:"nicHotPlug"`
	NicHotUnplug *bool   `pulumi:"nicHotUnplug"`
	PciSlot      *int    `pulumi:"pciSlot"`
	RamHotPlug   *bool   `pulumi:"ramHotPlug"`
	// The size of the volume in GB.
	Size *int `pulumi:"size"`
	// [list] List of absolute paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images.  Also accepts ssh keys directly. Required for IonosCloud Linux images. Required if `imagePassword` is not provided. Does not support `~` expansion to homedir in the given path. This property is immutable.
	//
	// Deprecated: Please use sshKeyPath under server level
	SshKeyPaths []string `pulumi:"sshKeyPaths"`
	// [list] Immutable List of absolute or relative paths to files containing public SSH key that will be injected into IonosCloud provided Linux images. Also accepts ssh keys directly. Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key. This field may only be set in creation requests. When reading, it always returns null. SSH keys are only supported if a public Linux image is used for the volume creation. Does not support `~` expansion to homedir in the given path.
	//
	// Deprecated: Please use sshKeys under server level
	SshKeys []string `pulumi:"sshKeys"`
	// The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
	UserData *string `pulumi:"userData"`
}

// ServerVolumeInput is an input type that accepts ServerVolumeArgs and ServerVolumeOutput values.
// You can construct a concrete instance of `ServerVolumeInput` via:
//
//	ServerVolumeArgs{...}
type ServerVolumeInput interface {
	pulumi.Input

	ToServerVolumeOutput() ServerVolumeOutput
	ToServerVolumeOutputWithContext(context.Context) ServerVolumeOutput
}

type ServerVolumeArgs struct {
	// [string] The availability zone in which the server should exist. E.g: `AUTO`, `ZONE_1`, `ZONE_2`. This property is immutable.
	AvailabilityZone pulumi.StringPtrInput `pulumi:"availabilityZone"`
	// The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
	BackupUnitId pulumi.StringPtrInput `pulumi:"backupUnitId"`
	// The UUID of the attached server.
	BootServer          pulumi.StringPtrInput `pulumi:"bootServer"`
	Bus                 pulumi.StringPtrInput `pulumi:"bus"`
	CpuHotPlug          pulumi.BoolPtrInput   `pulumi:"cpuHotPlug"`
	DeviceNumber        pulumi.IntPtrInput    `pulumi:"deviceNumber"`
	DiscVirtioHotPlug   pulumi.BoolPtrInput   `pulumi:"discVirtioHotPlug"`
	DiscVirtioHotUnplug pulumi.BoolPtrInput   `pulumi:"discVirtioHotUnplug"`
	DiskType            pulumi.StringInput    `pulumi:"diskType"`
	// [string] Required if `sshKeyPath` is not provided.
	//
	// Deprecated: Please use imagePassword under server level
	ImagePassword pulumi.StringPtrInput `pulumi:"imagePassword"`
	// [string] Sets the OS type of the server.
	LicenceType pulumi.StringPtrInput `pulumi:"licenceType"`
	// [string] The name of the server.
	Name         pulumi.StringPtrInput `pulumi:"name"`
	NicHotPlug   pulumi.BoolPtrInput   `pulumi:"nicHotPlug"`
	NicHotUnplug pulumi.BoolPtrInput   `pulumi:"nicHotUnplug"`
	PciSlot      pulumi.IntPtrInput    `pulumi:"pciSlot"`
	RamHotPlug   pulumi.BoolPtrInput   `pulumi:"ramHotPlug"`
	// The size of the volume in GB.
	Size pulumi.IntPtrInput `pulumi:"size"`
	// [list] List of absolute paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images.  Also accepts ssh keys directly. Required for IonosCloud Linux images. Required if `imagePassword` is not provided. Does not support `~` expansion to homedir in the given path. This property is immutable.
	//
	// Deprecated: Please use sshKeyPath under server level
	SshKeyPaths pulumi.StringArrayInput `pulumi:"sshKeyPaths"`
	// [list] Immutable List of absolute or relative paths to files containing public SSH key that will be injected into IonosCloud provided Linux images. Also accepts ssh keys directly. Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key. This field may only be set in creation requests. When reading, it always returns null. SSH keys are only supported if a public Linux image is used for the volume creation. Does not support `~` expansion to homedir in the given path.
	//
	// Deprecated: Please use sshKeys under server level
	SshKeys pulumi.StringArrayInput `pulumi:"sshKeys"`
	// The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
	UserData pulumi.StringPtrInput `pulumi:"userData"`
}

func (ServerVolumeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServerVolume)(nil)).Elem()
}

func (i ServerVolumeArgs) ToServerVolumeOutput() ServerVolumeOutput {
	return i.ToServerVolumeOutputWithContext(context.Background())
}

func (i ServerVolumeArgs) ToServerVolumeOutputWithContext(ctx context.Context) ServerVolumeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServerVolumeOutput)
}

func (i ServerVolumeArgs) ToServerVolumePtrOutput() ServerVolumePtrOutput {
	return i.ToServerVolumePtrOutputWithContext(context.Background())
}

func (i ServerVolumeArgs) ToServerVolumePtrOutputWithContext(ctx context.Context) ServerVolumePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServerVolumeOutput).ToServerVolumePtrOutputWithContext(ctx)
}

// ServerVolumePtrInput is an input type that accepts ServerVolumeArgs, ServerVolumePtr and ServerVolumePtrOutput values.
// You can construct a concrete instance of `ServerVolumePtrInput` via:
//
//	        ServerVolumeArgs{...}
//
//	or:
//
//	        nil
type ServerVolumePtrInput interface {
	pulumi.Input

	ToServerVolumePtrOutput() ServerVolumePtrOutput
	ToServerVolumePtrOutputWithContext(context.Context) ServerVolumePtrOutput
}

type serverVolumePtrType ServerVolumeArgs

func ServerVolumePtr(v *ServerVolumeArgs) ServerVolumePtrInput {
	return (*serverVolumePtrType)(v)
}

func (*serverVolumePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ServerVolume)(nil)).Elem()
}

func (i *serverVolumePtrType) ToServerVolumePtrOutput() ServerVolumePtrOutput {
	return i.ToServerVolumePtrOutputWithContext(context.Background())
}

func (i *serverVolumePtrType) ToServerVolumePtrOutputWithContext(ctx context.Context) ServerVolumePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServerVolumePtrOutput)
}

type ServerVolumeOutput struct{ *pulumi.OutputState }

func (ServerVolumeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServerVolume)(nil)).Elem()
}

func (o ServerVolumeOutput) ToServerVolumeOutput() ServerVolumeOutput {
	return o
}

func (o ServerVolumeOutput) ToServerVolumeOutputWithContext(ctx context.Context) ServerVolumeOutput {
	return o
}

func (o ServerVolumeOutput) ToServerVolumePtrOutput() ServerVolumePtrOutput {
	return o.ToServerVolumePtrOutputWithContext(context.Background())
}

func (o ServerVolumeOutput) ToServerVolumePtrOutputWithContext(ctx context.Context) ServerVolumePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ServerVolume) *ServerVolume {
		return &v
	}).(ServerVolumePtrOutput)
}

// [string] The availability zone in which the server should exist. E.g: `AUTO`, `ZONE_1`, `ZONE_2`. This property is immutable.
func (o ServerVolumeOutput) AvailabilityZone() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServerVolume) *string { return v.AvailabilityZone }).(pulumi.StringPtrOutput)
}

// The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
func (o ServerVolumeOutput) BackupUnitId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServerVolume) *string { return v.BackupUnitId }).(pulumi.StringPtrOutput)
}

// The UUID of the attached server.
func (o ServerVolumeOutput) BootServer() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServerVolume) *string { return v.BootServer }).(pulumi.StringPtrOutput)
}

func (o ServerVolumeOutput) Bus() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServerVolume) *string { return v.Bus }).(pulumi.StringPtrOutput)
}

func (o ServerVolumeOutput) CpuHotPlug() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ServerVolume) *bool { return v.CpuHotPlug }).(pulumi.BoolPtrOutput)
}

func (o ServerVolumeOutput) DeviceNumber() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ServerVolume) *int { return v.DeviceNumber }).(pulumi.IntPtrOutput)
}

func (o ServerVolumeOutput) DiscVirtioHotPlug() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ServerVolume) *bool { return v.DiscVirtioHotPlug }).(pulumi.BoolPtrOutput)
}

func (o ServerVolumeOutput) DiscVirtioHotUnplug() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ServerVolume) *bool { return v.DiscVirtioHotUnplug }).(pulumi.BoolPtrOutput)
}

func (o ServerVolumeOutput) DiskType() pulumi.StringOutput {
	return o.ApplyT(func(v ServerVolume) string { return v.DiskType }).(pulumi.StringOutput)
}

// [string] Required if `sshKeyPath` is not provided.
//
// Deprecated: Please use imagePassword under server level
func (o ServerVolumeOutput) ImagePassword() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServerVolume) *string { return v.ImagePassword }).(pulumi.StringPtrOutput)
}

// [string] Sets the OS type of the server.
func (o ServerVolumeOutput) LicenceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServerVolume) *string { return v.LicenceType }).(pulumi.StringPtrOutput)
}

// [string] The name of the server.
func (o ServerVolumeOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServerVolume) *string { return v.Name }).(pulumi.StringPtrOutput)
}

func (o ServerVolumeOutput) NicHotPlug() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ServerVolume) *bool { return v.NicHotPlug }).(pulumi.BoolPtrOutput)
}

func (o ServerVolumeOutput) NicHotUnplug() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ServerVolume) *bool { return v.NicHotUnplug }).(pulumi.BoolPtrOutput)
}

func (o ServerVolumeOutput) PciSlot() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ServerVolume) *int { return v.PciSlot }).(pulumi.IntPtrOutput)
}

func (o ServerVolumeOutput) RamHotPlug() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ServerVolume) *bool { return v.RamHotPlug }).(pulumi.BoolPtrOutput)
}

// The size of the volume in GB.
func (o ServerVolumeOutput) Size() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ServerVolume) *int { return v.Size }).(pulumi.IntPtrOutput)
}

// [list] List of absolute paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images.  Also accepts ssh keys directly. Required for IonosCloud Linux images. Required if `imagePassword` is not provided. Does not support `~` expansion to homedir in the given path. This property is immutable.
//
// Deprecated: Please use sshKeyPath under server level
func (o ServerVolumeOutput) SshKeyPaths() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ServerVolume) []string { return v.SshKeyPaths }).(pulumi.StringArrayOutput)
}

// [list] Immutable List of absolute or relative paths to files containing public SSH key that will be injected into IonosCloud provided Linux images. Also accepts ssh keys directly. Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key. This field may only be set in creation requests. When reading, it always returns null. SSH keys are only supported if a public Linux image is used for the volume creation. Does not support `~` expansion to homedir in the given path.
//
// Deprecated: Please use sshKeys under server level
func (o ServerVolumeOutput) SshKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ServerVolume) []string { return v.SshKeys }).(pulumi.StringArrayOutput)
}

// The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
func (o ServerVolumeOutput) UserData() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServerVolume) *string { return v.UserData }).(pulumi.StringPtrOutput)
}

type ServerVolumePtrOutput struct{ *pulumi.OutputState }

func (ServerVolumePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ServerVolume)(nil)).Elem()
}

func (o ServerVolumePtrOutput) ToServerVolumePtrOutput() ServerVolumePtrOutput {
	return o
}

func (o ServerVolumePtrOutput) ToServerVolumePtrOutputWithContext(ctx context.Context) ServerVolumePtrOutput {
	return o
}

func (o ServerVolumePtrOutput) Elem() ServerVolumeOutput {
	return o.ApplyT(func(v *ServerVolume) ServerVolume {
		if v != nil {
			return *v
		}
		var ret ServerVolume
		return ret
	}).(ServerVolumeOutput)
}

// [string] The availability zone in which the server should exist. E.g: `AUTO`, `ZONE_1`, `ZONE_2`. This property is immutable.
func (o ServerVolumePtrOutput) AvailabilityZone() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ServerVolume) *string {
		if v == nil {
			return nil
		}
		return v.AvailabilityZone
	}).(pulumi.StringPtrOutput)
}

// The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
func (o ServerVolumePtrOutput) BackupUnitId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ServerVolume) *string {
		if v == nil {
			return nil
		}
		return v.BackupUnitId
	}).(pulumi.StringPtrOutput)
}

// The UUID of the attached server.
func (o ServerVolumePtrOutput) BootServer() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ServerVolume) *string {
		if v == nil {
			return nil
		}
		return v.BootServer
	}).(pulumi.StringPtrOutput)
}

func (o ServerVolumePtrOutput) Bus() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ServerVolume) *string {
		if v == nil {
			return nil
		}
		return v.Bus
	}).(pulumi.StringPtrOutput)
}

func (o ServerVolumePtrOutput) CpuHotPlug() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ServerVolume) *bool {
		if v == nil {
			return nil
		}
		return v.CpuHotPlug
	}).(pulumi.BoolPtrOutput)
}

func (o ServerVolumePtrOutput) DeviceNumber() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ServerVolume) *int {
		if v == nil {
			return nil
		}
		return v.DeviceNumber
	}).(pulumi.IntPtrOutput)
}

func (o ServerVolumePtrOutput) DiscVirtioHotPlug() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ServerVolume) *bool {
		if v == nil {
			return nil
		}
		return v.DiscVirtioHotPlug
	}).(pulumi.BoolPtrOutput)
}

func (o ServerVolumePtrOutput) DiscVirtioHotUnplug() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ServerVolume) *bool {
		if v == nil {
			return nil
		}
		return v.DiscVirtioHotUnplug
	}).(pulumi.BoolPtrOutput)
}

func (o ServerVolumePtrOutput) DiskType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ServerVolume) *string {
		if v == nil {
			return nil
		}
		return &v.DiskType
	}).(pulumi.StringPtrOutput)
}

// [string] Required if `sshKeyPath` is not provided.
//
// Deprecated: Please use imagePassword under server level
func (o ServerVolumePtrOutput) ImagePassword() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ServerVolume) *string {
		if v == nil {
			return nil
		}
		return v.ImagePassword
	}).(pulumi.StringPtrOutput)
}

// [string] Sets the OS type of the server.
func (o ServerVolumePtrOutput) LicenceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ServerVolume) *string {
		if v == nil {
			return nil
		}
		return v.LicenceType
	}).(pulumi.StringPtrOutput)
}

// [string] The name of the server.
func (o ServerVolumePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ServerVolume) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

func (o ServerVolumePtrOutput) NicHotPlug() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ServerVolume) *bool {
		if v == nil {
			return nil
		}
		return v.NicHotPlug
	}).(pulumi.BoolPtrOutput)
}

func (o ServerVolumePtrOutput) NicHotUnplug() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ServerVolume) *bool {
		if v == nil {
			return nil
		}
		return v.NicHotUnplug
	}).(pulumi.BoolPtrOutput)
}

func (o ServerVolumePtrOutput) PciSlot() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ServerVolume) *int {
		if v == nil {
			return nil
		}
		return v.PciSlot
	}).(pulumi.IntPtrOutput)
}

func (o ServerVolumePtrOutput) RamHotPlug() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ServerVolume) *bool {
		if v == nil {
			return nil
		}
		return v.RamHotPlug
	}).(pulumi.BoolPtrOutput)
}

// The size of the volume in GB.
func (o ServerVolumePtrOutput) Size() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ServerVolume) *int {
		if v == nil {
			return nil
		}
		return v.Size
	}).(pulumi.IntPtrOutput)
}

// [list] List of absolute paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images.  Also accepts ssh keys directly. Required for IonosCloud Linux images. Required if `imagePassword` is not provided. Does not support `~` expansion to homedir in the given path. This property is immutable.
//
// Deprecated: Please use sshKeyPath under server level
func (o ServerVolumePtrOutput) SshKeyPaths() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ServerVolume) []string {
		if v == nil {
			return nil
		}
		return v.SshKeyPaths
	}).(pulumi.StringArrayOutput)
}

// [list] Immutable List of absolute or relative paths to files containing public SSH key that will be injected into IonosCloud provided Linux images. Also accepts ssh keys directly. Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key. This field may only be set in creation requests. When reading, it always returns null. SSH keys are only supported if a public Linux image is used for the volume creation. Does not support `~` expansion to homedir in the given path.
//
// Deprecated: Please use sshKeys under server level
func (o ServerVolumePtrOutput) SshKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ServerVolume) []string {
		if v == nil {
			return nil
		}
		return v.SshKeys
	}).(pulumi.StringArrayOutput)
}

// The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
func (o ServerVolumePtrOutput) UserData() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ServerVolume) *string {
		if v == nil {
			return nil
		}
		return v.UserData
	}).(pulumi.StringPtrOutput)
}

type VCPUServerLabel struct {
	Key   string `pulumi:"key"`
	Value string `pulumi:"value"`
}

// VCPUServerLabelInput is an input type that accepts VCPUServerLabelArgs and VCPUServerLabelOutput values.
// You can construct a concrete instance of `VCPUServerLabelInput` via:
//
//	VCPUServerLabelArgs{...}
type VCPUServerLabelInput interface {
	pulumi.Input

	ToVCPUServerLabelOutput() VCPUServerLabelOutput
	ToVCPUServerLabelOutputWithContext(context.Context) VCPUServerLabelOutput
}

type VCPUServerLabelArgs struct {
	Key   pulumi.StringInput `pulumi:"key"`
	Value pulumi.StringInput `pulumi:"value"`
}

func (VCPUServerLabelArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VCPUServerLabel)(nil)).Elem()
}

func (i VCPUServerLabelArgs) ToVCPUServerLabelOutput() VCPUServerLabelOutput {
	return i.ToVCPUServerLabelOutputWithContext(context.Background())
}

func (i VCPUServerLabelArgs) ToVCPUServerLabelOutputWithContext(ctx context.Context) VCPUServerLabelOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VCPUServerLabelOutput)
}

// VCPUServerLabelArrayInput is an input type that accepts VCPUServerLabelArray and VCPUServerLabelArrayOutput values.
// You can construct a concrete instance of `VCPUServerLabelArrayInput` via:
//
//	VCPUServerLabelArray{ VCPUServerLabelArgs{...} }
type VCPUServerLabelArrayInput interface {
	pulumi.Input

	ToVCPUServerLabelArrayOutput() VCPUServerLabelArrayOutput
	ToVCPUServerLabelArrayOutputWithContext(context.Context) VCPUServerLabelArrayOutput
}

type VCPUServerLabelArray []VCPUServerLabelInput

func (VCPUServerLabelArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VCPUServerLabel)(nil)).Elem()
}

func (i VCPUServerLabelArray) ToVCPUServerLabelArrayOutput() VCPUServerLabelArrayOutput {
	return i.ToVCPUServerLabelArrayOutputWithContext(context.Background())
}

func (i VCPUServerLabelArray) ToVCPUServerLabelArrayOutputWithContext(ctx context.Context) VCPUServerLabelArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VCPUServerLabelArrayOutput)
}

type VCPUServerLabelOutput struct{ *pulumi.OutputState }

func (VCPUServerLabelOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VCPUServerLabel)(nil)).Elem()
}

func (o VCPUServerLabelOutput) ToVCPUServerLabelOutput() VCPUServerLabelOutput {
	return o
}

func (o VCPUServerLabelOutput) ToVCPUServerLabelOutputWithContext(ctx context.Context) VCPUServerLabelOutput {
	return o
}

func (o VCPUServerLabelOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v VCPUServerLabel) string { return v.Key }).(pulumi.StringOutput)
}

func (o VCPUServerLabelOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v VCPUServerLabel) string { return v.Value }).(pulumi.StringOutput)
}

type VCPUServerLabelArrayOutput struct{ *pulumi.OutputState }

func (VCPUServerLabelArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VCPUServerLabel)(nil)).Elem()
}

func (o VCPUServerLabelArrayOutput) ToVCPUServerLabelArrayOutput() VCPUServerLabelArrayOutput {
	return o
}

func (o VCPUServerLabelArrayOutput) ToVCPUServerLabelArrayOutputWithContext(ctx context.Context) VCPUServerLabelArrayOutput {
	return o
}

func (o VCPUServerLabelArrayOutput) Index(i pulumi.IntInput) VCPUServerLabelOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VCPUServerLabel {
		return vs[0].([]VCPUServerLabel)[vs[1].(int)]
	}).(VCPUServerLabelOutput)
}

type VCPUServerNic struct {
	DeviceNumber   *int    `pulumi:"deviceNumber"`
	Dhcp           *bool   `pulumi:"dhcp"`
	Dhcpv6         *bool   `pulumi:"dhcpv6"`
	FirewallActive *bool   `pulumi:"firewallActive"`
	FirewallType   *string `pulumi:"firewallType"`
	// Allows to define firewall rules inline in the server. See the Firewall section.
	Firewalls []VCPUServerNicFirewall `pulumi:"firewalls"`
	Id        *string                 `pulumi:"id"`
	// Collection of IP addresses assigned to a nic. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.
	Ips           []string `pulumi:"ips"`
	Ipv6CidrBlock *string  `pulumi:"ipv6CidrBlock"`
	Ipv6Ips       []string `pulumi:"ipv6Ips"`
	Lan           int      `pulumi:"lan"`
	Mac           *string  `pulumi:"mac"`
	// [string] The name of the server.
	Name    *string `pulumi:"name"`
	PciSlot *int    `pulumi:"pciSlot"`
}

// VCPUServerNicInput is an input type that accepts VCPUServerNicArgs and VCPUServerNicOutput values.
// You can construct a concrete instance of `VCPUServerNicInput` via:
//
//	VCPUServerNicArgs{...}
type VCPUServerNicInput interface {
	pulumi.Input

	ToVCPUServerNicOutput() VCPUServerNicOutput
	ToVCPUServerNicOutputWithContext(context.Context) VCPUServerNicOutput
}

type VCPUServerNicArgs struct {
	DeviceNumber   pulumi.IntPtrInput    `pulumi:"deviceNumber"`
	Dhcp           pulumi.BoolPtrInput   `pulumi:"dhcp"`
	Dhcpv6         pulumi.BoolPtrInput   `pulumi:"dhcpv6"`
	FirewallActive pulumi.BoolPtrInput   `pulumi:"firewallActive"`
	FirewallType   pulumi.StringPtrInput `pulumi:"firewallType"`
	// Allows to define firewall rules inline in the server. See the Firewall section.
	Firewalls VCPUServerNicFirewallArrayInput `pulumi:"firewalls"`
	Id        pulumi.StringPtrInput           `pulumi:"id"`
	// Collection of IP addresses assigned to a nic. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.
	Ips           pulumi.StringArrayInput `pulumi:"ips"`
	Ipv6CidrBlock pulumi.StringPtrInput   `pulumi:"ipv6CidrBlock"`
	Ipv6Ips       pulumi.StringArrayInput `pulumi:"ipv6Ips"`
	Lan           pulumi.IntInput         `pulumi:"lan"`
	Mac           pulumi.StringPtrInput   `pulumi:"mac"`
	// [string] The name of the server.
	Name    pulumi.StringPtrInput `pulumi:"name"`
	PciSlot pulumi.IntPtrInput    `pulumi:"pciSlot"`
}

func (VCPUServerNicArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VCPUServerNic)(nil)).Elem()
}

func (i VCPUServerNicArgs) ToVCPUServerNicOutput() VCPUServerNicOutput {
	return i.ToVCPUServerNicOutputWithContext(context.Background())
}

func (i VCPUServerNicArgs) ToVCPUServerNicOutputWithContext(ctx context.Context) VCPUServerNicOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VCPUServerNicOutput)
}

func (i VCPUServerNicArgs) ToVCPUServerNicPtrOutput() VCPUServerNicPtrOutput {
	return i.ToVCPUServerNicPtrOutputWithContext(context.Background())
}

func (i VCPUServerNicArgs) ToVCPUServerNicPtrOutputWithContext(ctx context.Context) VCPUServerNicPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VCPUServerNicOutput).ToVCPUServerNicPtrOutputWithContext(ctx)
}

// VCPUServerNicPtrInput is an input type that accepts VCPUServerNicArgs, VCPUServerNicPtr and VCPUServerNicPtrOutput values.
// You can construct a concrete instance of `VCPUServerNicPtrInput` via:
//
//	        VCPUServerNicArgs{...}
//
//	or:
//
//	        nil
type VCPUServerNicPtrInput interface {
	pulumi.Input

	ToVCPUServerNicPtrOutput() VCPUServerNicPtrOutput
	ToVCPUServerNicPtrOutputWithContext(context.Context) VCPUServerNicPtrOutput
}

type vcpuserverNicPtrType VCPUServerNicArgs

func VCPUServerNicPtr(v *VCPUServerNicArgs) VCPUServerNicPtrInput {
	return (*vcpuserverNicPtrType)(v)
}

func (*vcpuserverNicPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**VCPUServerNic)(nil)).Elem()
}

func (i *vcpuserverNicPtrType) ToVCPUServerNicPtrOutput() VCPUServerNicPtrOutput {
	return i.ToVCPUServerNicPtrOutputWithContext(context.Background())
}

func (i *vcpuserverNicPtrType) ToVCPUServerNicPtrOutputWithContext(ctx context.Context) VCPUServerNicPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VCPUServerNicPtrOutput)
}

type VCPUServerNicOutput struct{ *pulumi.OutputState }

func (VCPUServerNicOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VCPUServerNic)(nil)).Elem()
}

func (o VCPUServerNicOutput) ToVCPUServerNicOutput() VCPUServerNicOutput {
	return o
}

func (o VCPUServerNicOutput) ToVCPUServerNicOutputWithContext(ctx context.Context) VCPUServerNicOutput {
	return o
}

func (o VCPUServerNicOutput) ToVCPUServerNicPtrOutput() VCPUServerNicPtrOutput {
	return o.ToVCPUServerNicPtrOutputWithContext(context.Background())
}

func (o VCPUServerNicOutput) ToVCPUServerNicPtrOutputWithContext(ctx context.Context) VCPUServerNicPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v VCPUServerNic) *VCPUServerNic {
		return &v
	}).(VCPUServerNicPtrOutput)
}

func (o VCPUServerNicOutput) DeviceNumber() pulumi.IntPtrOutput {
	return o.ApplyT(func(v VCPUServerNic) *int { return v.DeviceNumber }).(pulumi.IntPtrOutput)
}

func (o VCPUServerNicOutput) Dhcp() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VCPUServerNic) *bool { return v.Dhcp }).(pulumi.BoolPtrOutput)
}

func (o VCPUServerNicOutput) Dhcpv6() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VCPUServerNic) *bool { return v.Dhcpv6 }).(pulumi.BoolPtrOutput)
}

func (o VCPUServerNicOutput) FirewallActive() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VCPUServerNic) *bool { return v.FirewallActive }).(pulumi.BoolPtrOutput)
}

func (o VCPUServerNicOutput) FirewallType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VCPUServerNic) *string { return v.FirewallType }).(pulumi.StringPtrOutput)
}

// Allows to define firewall rules inline in the server. See the Firewall section.
func (o VCPUServerNicOutput) Firewalls() VCPUServerNicFirewallArrayOutput {
	return o.ApplyT(func(v VCPUServerNic) []VCPUServerNicFirewall { return v.Firewalls }).(VCPUServerNicFirewallArrayOutput)
}

func (o VCPUServerNicOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VCPUServerNic) *string { return v.Id }).(pulumi.StringPtrOutput)
}

// Collection of IP addresses assigned to a nic. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.
func (o VCPUServerNicOutput) Ips() pulumi.StringArrayOutput {
	return o.ApplyT(func(v VCPUServerNic) []string { return v.Ips }).(pulumi.StringArrayOutput)
}

func (o VCPUServerNicOutput) Ipv6CidrBlock() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VCPUServerNic) *string { return v.Ipv6CidrBlock }).(pulumi.StringPtrOutput)
}

func (o VCPUServerNicOutput) Ipv6Ips() pulumi.StringArrayOutput {
	return o.ApplyT(func(v VCPUServerNic) []string { return v.Ipv6Ips }).(pulumi.StringArrayOutput)
}

func (o VCPUServerNicOutput) Lan() pulumi.IntOutput {
	return o.ApplyT(func(v VCPUServerNic) int { return v.Lan }).(pulumi.IntOutput)
}

func (o VCPUServerNicOutput) Mac() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VCPUServerNic) *string { return v.Mac }).(pulumi.StringPtrOutput)
}

// [string] The name of the server.
func (o VCPUServerNicOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VCPUServerNic) *string { return v.Name }).(pulumi.StringPtrOutput)
}

func (o VCPUServerNicOutput) PciSlot() pulumi.IntPtrOutput {
	return o.ApplyT(func(v VCPUServerNic) *int { return v.PciSlot }).(pulumi.IntPtrOutput)
}

type VCPUServerNicPtrOutput struct{ *pulumi.OutputState }

func (VCPUServerNicPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VCPUServerNic)(nil)).Elem()
}

func (o VCPUServerNicPtrOutput) ToVCPUServerNicPtrOutput() VCPUServerNicPtrOutput {
	return o
}

func (o VCPUServerNicPtrOutput) ToVCPUServerNicPtrOutputWithContext(ctx context.Context) VCPUServerNicPtrOutput {
	return o
}

func (o VCPUServerNicPtrOutput) Elem() VCPUServerNicOutput {
	return o.ApplyT(func(v *VCPUServerNic) VCPUServerNic {
		if v != nil {
			return *v
		}
		var ret VCPUServerNic
		return ret
	}).(VCPUServerNicOutput)
}

func (o VCPUServerNicPtrOutput) DeviceNumber() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *VCPUServerNic) *int {
		if v == nil {
			return nil
		}
		return v.DeviceNumber
	}).(pulumi.IntPtrOutput)
}

func (o VCPUServerNicPtrOutput) Dhcp() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *VCPUServerNic) *bool {
		if v == nil {
			return nil
		}
		return v.Dhcp
	}).(pulumi.BoolPtrOutput)
}

func (o VCPUServerNicPtrOutput) Dhcpv6() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *VCPUServerNic) *bool {
		if v == nil {
			return nil
		}
		return v.Dhcpv6
	}).(pulumi.BoolPtrOutput)
}

func (o VCPUServerNicPtrOutput) FirewallActive() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *VCPUServerNic) *bool {
		if v == nil {
			return nil
		}
		return v.FirewallActive
	}).(pulumi.BoolPtrOutput)
}

func (o VCPUServerNicPtrOutput) FirewallType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VCPUServerNic) *string {
		if v == nil {
			return nil
		}
		return v.FirewallType
	}).(pulumi.StringPtrOutput)
}

// Allows to define firewall rules inline in the server. See the Firewall section.
func (o VCPUServerNicPtrOutput) Firewalls() VCPUServerNicFirewallArrayOutput {
	return o.ApplyT(func(v *VCPUServerNic) []VCPUServerNicFirewall {
		if v == nil {
			return nil
		}
		return v.Firewalls
	}).(VCPUServerNicFirewallArrayOutput)
}

func (o VCPUServerNicPtrOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VCPUServerNic) *string {
		if v == nil {
			return nil
		}
		return v.Id
	}).(pulumi.StringPtrOutput)
}

// Collection of IP addresses assigned to a nic. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.
func (o VCPUServerNicPtrOutput) Ips() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *VCPUServerNic) []string {
		if v == nil {
			return nil
		}
		return v.Ips
	}).(pulumi.StringArrayOutput)
}

func (o VCPUServerNicPtrOutput) Ipv6CidrBlock() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VCPUServerNic) *string {
		if v == nil {
			return nil
		}
		return v.Ipv6CidrBlock
	}).(pulumi.StringPtrOutput)
}

func (o VCPUServerNicPtrOutput) Ipv6Ips() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *VCPUServerNic) []string {
		if v == nil {
			return nil
		}
		return v.Ipv6Ips
	}).(pulumi.StringArrayOutput)
}

func (o VCPUServerNicPtrOutput) Lan() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *VCPUServerNic) *int {
		if v == nil {
			return nil
		}
		return &v.Lan
	}).(pulumi.IntPtrOutput)
}

func (o VCPUServerNicPtrOutput) Mac() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VCPUServerNic) *string {
		if v == nil {
			return nil
		}
		return v.Mac
	}).(pulumi.StringPtrOutput)
}

// [string] The name of the server.
func (o VCPUServerNicPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VCPUServerNic) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

func (o VCPUServerNicPtrOutput) PciSlot() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *VCPUServerNic) *int {
		if v == nil {
			return nil
		}
		return v.PciSlot
	}).(pulumi.IntPtrOutput)
}

type VCPUServerNicFirewall struct {
	IcmpCode *string `pulumi:"icmpCode"`
	IcmpType *string `pulumi:"icmpType"`
	Id       *string `pulumi:"id"`
	// [string] The name of the server.
	Name           *string `pulumi:"name"`
	PortRangeEnd   *int    `pulumi:"portRangeEnd"`
	PortRangeStart *int    `pulumi:"portRangeStart"`
	Protocol       string  `pulumi:"protocol"`
	SourceIp       *string `pulumi:"sourceIp"`
	SourceMac      *string `pulumi:"sourceMac"`
	TargetIp       *string `pulumi:"targetIp"`
	Type           *string `pulumi:"type"`
}

// VCPUServerNicFirewallInput is an input type that accepts VCPUServerNicFirewallArgs and VCPUServerNicFirewallOutput values.
// You can construct a concrete instance of `VCPUServerNicFirewallInput` via:
//
//	VCPUServerNicFirewallArgs{...}
type VCPUServerNicFirewallInput interface {
	pulumi.Input

	ToVCPUServerNicFirewallOutput() VCPUServerNicFirewallOutput
	ToVCPUServerNicFirewallOutputWithContext(context.Context) VCPUServerNicFirewallOutput
}

type VCPUServerNicFirewallArgs struct {
	IcmpCode pulumi.StringPtrInput `pulumi:"icmpCode"`
	IcmpType pulumi.StringPtrInput `pulumi:"icmpType"`
	Id       pulumi.StringPtrInput `pulumi:"id"`
	// [string] The name of the server.
	Name           pulumi.StringPtrInput `pulumi:"name"`
	PortRangeEnd   pulumi.IntPtrInput    `pulumi:"portRangeEnd"`
	PortRangeStart pulumi.IntPtrInput    `pulumi:"portRangeStart"`
	Protocol       pulumi.StringInput    `pulumi:"protocol"`
	SourceIp       pulumi.StringPtrInput `pulumi:"sourceIp"`
	SourceMac      pulumi.StringPtrInput `pulumi:"sourceMac"`
	TargetIp       pulumi.StringPtrInput `pulumi:"targetIp"`
	Type           pulumi.StringPtrInput `pulumi:"type"`
}

func (VCPUServerNicFirewallArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VCPUServerNicFirewall)(nil)).Elem()
}

func (i VCPUServerNicFirewallArgs) ToVCPUServerNicFirewallOutput() VCPUServerNicFirewallOutput {
	return i.ToVCPUServerNicFirewallOutputWithContext(context.Background())
}

func (i VCPUServerNicFirewallArgs) ToVCPUServerNicFirewallOutputWithContext(ctx context.Context) VCPUServerNicFirewallOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VCPUServerNicFirewallOutput)
}

// VCPUServerNicFirewallArrayInput is an input type that accepts VCPUServerNicFirewallArray and VCPUServerNicFirewallArrayOutput values.
// You can construct a concrete instance of `VCPUServerNicFirewallArrayInput` via:
//
//	VCPUServerNicFirewallArray{ VCPUServerNicFirewallArgs{...} }
type VCPUServerNicFirewallArrayInput interface {
	pulumi.Input

	ToVCPUServerNicFirewallArrayOutput() VCPUServerNicFirewallArrayOutput
	ToVCPUServerNicFirewallArrayOutputWithContext(context.Context) VCPUServerNicFirewallArrayOutput
}

type VCPUServerNicFirewallArray []VCPUServerNicFirewallInput

func (VCPUServerNicFirewallArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VCPUServerNicFirewall)(nil)).Elem()
}

func (i VCPUServerNicFirewallArray) ToVCPUServerNicFirewallArrayOutput() VCPUServerNicFirewallArrayOutput {
	return i.ToVCPUServerNicFirewallArrayOutputWithContext(context.Background())
}

func (i VCPUServerNicFirewallArray) ToVCPUServerNicFirewallArrayOutputWithContext(ctx context.Context) VCPUServerNicFirewallArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VCPUServerNicFirewallArrayOutput)
}

type VCPUServerNicFirewallOutput struct{ *pulumi.OutputState }

func (VCPUServerNicFirewallOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VCPUServerNicFirewall)(nil)).Elem()
}

func (o VCPUServerNicFirewallOutput) ToVCPUServerNicFirewallOutput() VCPUServerNicFirewallOutput {
	return o
}

func (o VCPUServerNicFirewallOutput) ToVCPUServerNicFirewallOutputWithContext(ctx context.Context) VCPUServerNicFirewallOutput {
	return o
}

func (o VCPUServerNicFirewallOutput) IcmpCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VCPUServerNicFirewall) *string { return v.IcmpCode }).(pulumi.StringPtrOutput)
}

func (o VCPUServerNicFirewallOutput) IcmpType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VCPUServerNicFirewall) *string { return v.IcmpType }).(pulumi.StringPtrOutput)
}

func (o VCPUServerNicFirewallOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VCPUServerNicFirewall) *string { return v.Id }).(pulumi.StringPtrOutput)
}

// [string] The name of the server.
func (o VCPUServerNicFirewallOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VCPUServerNicFirewall) *string { return v.Name }).(pulumi.StringPtrOutput)
}

func (o VCPUServerNicFirewallOutput) PortRangeEnd() pulumi.IntPtrOutput {
	return o.ApplyT(func(v VCPUServerNicFirewall) *int { return v.PortRangeEnd }).(pulumi.IntPtrOutput)
}

func (o VCPUServerNicFirewallOutput) PortRangeStart() pulumi.IntPtrOutput {
	return o.ApplyT(func(v VCPUServerNicFirewall) *int { return v.PortRangeStart }).(pulumi.IntPtrOutput)
}

func (o VCPUServerNicFirewallOutput) Protocol() pulumi.StringOutput {
	return o.ApplyT(func(v VCPUServerNicFirewall) string { return v.Protocol }).(pulumi.StringOutput)
}

func (o VCPUServerNicFirewallOutput) SourceIp() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VCPUServerNicFirewall) *string { return v.SourceIp }).(pulumi.StringPtrOutput)
}

func (o VCPUServerNicFirewallOutput) SourceMac() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VCPUServerNicFirewall) *string { return v.SourceMac }).(pulumi.StringPtrOutput)
}

func (o VCPUServerNicFirewallOutput) TargetIp() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VCPUServerNicFirewall) *string { return v.TargetIp }).(pulumi.StringPtrOutput)
}

func (o VCPUServerNicFirewallOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VCPUServerNicFirewall) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type VCPUServerNicFirewallArrayOutput struct{ *pulumi.OutputState }

func (VCPUServerNicFirewallArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VCPUServerNicFirewall)(nil)).Elem()
}

func (o VCPUServerNicFirewallArrayOutput) ToVCPUServerNicFirewallArrayOutput() VCPUServerNicFirewallArrayOutput {
	return o
}

func (o VCPUServerNicFirewallArrayOutput) ToVCPUServerNicFirewallArrayOutputWithContext(ctx context.Context) VCPUServerNicFirewallArrayOutput {
	return o
}

func (o VCPUServerNicFirewallArrayOutput) Index(i pulumi.IntInput) VCPUServerNicFirewallOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VCPUServerNicFirewall {
		return vs[0].([]VCPUServerNicFirewall)[vs[1].(int)]
	}).(VCPUServerNicFirewallOutput)
}

type VCPUServerVolume struct {
	// [string] The availability zone in which the server should exist. E.g: `AUTO`, `ZONE_1`, `ZONE_2`. This property is immutable.
	AvailabilityZone *string `pulumi:"availabilityZone"`
	// The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
	BackupUnitId *string `pulumi:"backupUnitId"`
	// The UUID of the attached server.
	BootServer          *string `pulumi:"bootServer"`
	Bus                 *string `pulumi:"bus"`
	CpuHotPlug          *bool   `pulumi:"cpuHotPlug"`
	DeviceNumber        *int    `pulumi:"deviceNumber"`
	DiscVirtioHotPlug   *bool   `pulumi:"discVirtioHotPlug"`
	DiscVirtioHotUnplug *bool   `pulumi:"discVirtioHotUnplug"`
	DiskType            string  `pulumi:"diskType"`
	// [string] Sets the OS type of the server.
	LicenceType *string `pulumi:"licenceType"`
	// [string] The name of the server.
	Name         *string `pulumi:"name"`
	NicHotPlug   *bool   `pulumi:"nicHotPlug"`
	NicHotUnplug *bool   `pulumi:"nicHotUnplug"`
	PciSlot      *int    `pulumi:"pciSlot"`
	RamHotPlug   *bool   `pulumi:"ramHotPlug"`
	// The size of the volume in GB.
	Size *int `pulumi:"size"`
	// The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
	UserData *string `pulumi:"userData"`
}

// VCPUServerVolumeInput is an input type that accepts VCPUServerVolumeArgs and VCPUServerVolumeOutput values.
// You can construct a concrete instance of `VCPUServerVolumeInput` via:
//
//	VCPUServerVolumeArgs{...}
type VCPUServerVolumeInput interface {
	pulumi.Input

	ToVCPUServerVolumeOutput() VCPUServerVolumeOutput
	ToVCPUServerVolumeOutputWithContext(context.Context) VCPUServerVolumeOutput
}

type VCPUServerVolumeArgs struct {
	// [string] The availability zone in which the server should exist. E.g: `AUTO`, `ZONE_1`, `ZONE_2`. This property is immutable.
	AvailabilityZone pulumi.StringPtrInput `pulumi:"availabilityZone"`
	// The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
	BackupUnitId pulumi.StringPtrInput `pulumi:"backupUnitId"`
	// The UUID of the attached server.
	BootServer          pulumi.StringPtrInput `pulumi:"bootServer"`
	Bus                 pulumi.StringPtrInput `pulumi:"bus"`
	CpuHotPlug          pulumi.BoolPtrInput   `pulumi:"cpuHotPlug"`
	DeviceNumber        pulumi.IntPtrInput    `pulumi:"deviceNumber"`
	DiscVirtioHotPlug   pulumi.BoolPtrInput   `pulumi:"discVirtioHotPlug"`
	DiscVirtioHotUnplug pulumi.BoolPtrInput   `pulumi:"discVirtioHotUnplug"`
	DiskType            pulumi.StringInput    `pulumi:"diskType"`
	// [string] Sets the OS type of the server.
	LicenceType pulumi.StringPtrInput `pulumi:"licenceType"`
	// [string] The name of the server.
	Name         pulumi.StringPtrInput `pulumi:"name"`
	NicHotPlug   pulumi.BoolPtrInput   `pulumi:"nicHotPlug"`
	NicHotUnplug pulumi.BoolPtrInput   `pulumi:"nicHotUnplug"`
	PciSlot      pulumi.IntPtrInput    `pulumi:"pciSlot"`
	RamHotPlug   pulumi.BoolPtrInput   `pulumi:"ramHotPlug"`
	// The size of the volume in GB.
	Size pulumi.IntPtrInput `pulumi:"size"`
	// The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
	UserData pulumi.StringPtrInput `pulumi:"userData"`
}

func (VCPUServerVolumeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VCPUServerVolume)(nil)).Elem()
}

func (i VCPUServerVolumeArgs) ToVCPUServerVolumeOutput() VCPUServerVolumeOutput {
	return i.ToVCPUServerVolumeOutputWithContext(context.Background())
}

func (i VCPUServerVolumeArgs) ToVCPUServerVolumeOutputWithContext(ctx context.Context) VCPUServerVolumeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VCPUServerVolumeOutput)
}

func (i VCPUServerVolumeArgs) ToVCPUServerVolumePtrOutput() VCPUServerVolumePtrOutput {
	return i.ToVCPUServerVolumePtrOutputWithContext(context.Background())
}

func (i VCPUServerVolumeArgs) ToVCPUServerVolumePtrOutputWithContext(ctx context.Context) VCPUServerVolumePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VCPUServerVolumeOutput).ToVCPUServerVolumePtrOutputWithContext(ctx)
}

// VCPUServerVolumePtrInput is an input type that accepts VCPUServerVolumeArgs, VCPUServerVolumePtr and VCPUServerVolumePtrOutput values.
// You can construct a concrete instance of `VCPUServerVolumePtrInput` via:
//
//	        VCPUServerVolumeArgs{...}
//
//	or:
//
//	        nil
type VCPUServerVolumePtrInput interface {
	pulumi.Input

	ToVCPUServerVolumePtrOutput() VCPUServerVolumePtrOutput
	ToVCPUServerVolumePtrOutputWithContext(context.Context) VCPUServerVolumePtrOutput
}

type vcpuserverVolumePtrType VCPUServerVolumeArgs

func VCPUServerVolumePtr(v *VCPUServerVolumeArgs) VCPUServerVolumePtrInput {
	return (*vcpuserverVolumePtrType)(v)
}

func (*vcpuserverVolumePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**VCPUServerVolume)(nil)).Elem()
}

func (i *vcpuserverVolumePtrType) ToVCPUServerVolumePtrOutput() VCPUServerVolumePtrOutput {
	return i.ToVCPUServerVolumePtrOutputWithContext(context.Background())
}

func (i *vcpuserverVolumePtrType) ToVCPUServerVolumePtrOutputWithContext(ctx context.Context) VCPUServerVolumePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VCPUServerVolumePtrOutput)
}

type VCPUServerVolumeOutput struct{ *pulumi.OutputState }

func (VCPUServerVolumeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VCPUServerVolume)(nil)).Elem()
}

func (o VCPUServerVolumeOutput) ToVCPUServerVolumeOutput() VCPUServerVolumeOutput {
	return o
}

func (o VCPUServerVolumeOutput) ToVCPUServerVolumeOutputWithContext(ctx context.Context) VCPUServerVolumeOutput {
	return o
}

func (o VCPUServerVolumeOutput) ToVCPUServerVolumePtrOutput() VCPUServerVolumePtrOutput {
	return o.ToVCPUServerVolumePtrOutputWithContext(context.Background())
}

func (o VCPUServerVolumeOutput) ToVCPUServerVolumePtrOutputWithContext(ctx context.Context) VCPUServerVolumePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v VCPUServerVolume) *VCPUServerVolume {
		return &v
	}).(VCPUServerVolumePtrOutput)
}

// [string] The availability zone in which the server should exist. E.g: `AUTO`, `ZONE_1`, `ZONE_2`. This property is immutable.
func (o VCPUServerVolumeOutput) AvailabilityZone() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VCPUServerVolume) *string { return v.AvailabilityZone }).(pulumi.StringPtrOutput)
}

// The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
func (o VCPUServerVolumeOutput) BackupUnitId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VCPUServerVolume) *string { return v.BackupUnitId }).(pulumi.StringPtrOutput)
}

// The UUID of the attached server.
func (o VCPUServerVolumeOutput) BootServer() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VCPUServerVolume) *string { return v.BootServer }).(pulumi.StringPtrOutput)
}

func (o VCPUServerVolumeOutput) Bus() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VCPUServerVolume) *string { return v.Bus }).(pulumi.StringPtrOutput)
}

func (o VCPUServerVolumeOutput) CpuHotPlug() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VCPUServerVolume) *bool { return v.CpuHotPlug }).(pulumi.BoolPtrOutput)
}

func (o VCPUServerVolumeOutput) DeviceNumber() pulumi.IntPtrOutput {
	return o.ApplyT(func(v VCPUServerVolume) *int { return v.DeviceNumber }).(pulumi.IntPtrOutput)
}

func (o VCPUServerVolumeOutput) DiscVirtioHotPlug() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VCPUServerVolume) *bool { return v.DiscVirtioHotPlug }).(pulumi.BoolPtrOutput)
}

func (o VCPUServerVolumeOutput) DiscVirtioHotUnplug() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VCPUServerVolume) *bool { return v.DiscVirtioHotUnplug }).(pulumi.BoolPtrOutput)
}

func (o VCPUServerVolumeOutput) DiskType() pulumi.StringOutput {
	return o.ApplyT(func(v VCPUServerVolume) string { return v.DiskType }).(pulumi.StringOutput)
}

// [string] Sets the OS type of the server.
func (o VCPUServerVolumeOutput) LicenceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VCPUServerVolume) *string { return v.LicenceType }).(pulumi.StringPtrOutput)
}

// [string] The name of the server.
func (o VCPUServerVolumeOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VCPUServerVolume) *string { return v.Name }).(pulumi.StringPtrOutput)
}

func (o VCPUServerVolumeOutput) NicHotPlug() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VCPUServerVolume) *bool { return v.NicHotPlug }).(pulumi.BoolPtrOutput)
}

func (o VCPUServerVolumeOutput) NicHotUnplug() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VCPUServerVolume) *bool { return v.NicHotUnplug }).(pulumi.BoolPtrOutput)
}

func (o VCPUServerVolumeOutput) PciSlot() pulumi.IntPtrOutput {
	return o.ApplyT(func(v VCPUServerVolume) *int { return v.PciSlot }).(pulumi.IntPtrOutput)
}

func (o VCPUServerVolumeOutput) RamHotPlug() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VCPUServerVolume) *bool { return v.RamHotPlug }).(pulumi.BoolPtrOutput)
}

// The size of the volume in GB.
func (o VCPUServerVolumeOutput) Size() pulumi.IntPtrOutput {
	return o.ApplyT(func(v VCPUServerVolume) *int { return v.Size }).(pulumi.IntPtrOutput)
}

// The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
func (o VCPUServerVolumeOutput) UserData() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VCPUServerVolume) *string { return v.UserData }).(pulumi.StringPtrOutput)
}

type VCPUServerVolumePtrOutput struct{ *pulumi.OutputState }

func (VCPUServerVolumePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VCPUServerVolume)(nil)).Elem()
}

func (o VCPUServerVolumePtrOutput) ToVCPUServerVolumePtrOutput() VCPUServerVolumePtrOutput {
	return o
}

func (o VCPUServerVolumePtrOutput) ToVCPUServerVolumePtrOutputWithContext(ctx context.Context) VCPUServerVolumePtrOutput {
	return o
}

func (o VCPUServerVolumePtrOutput) Elem() VCPUServerVolumeOutput {
	return o.ApplyT(func(v *VCPUServerVolume) VCPUServerVolume {
		if v != nil {
			return *v
		}
		var ret VCPUServerVolume
		return ret
	}).(VCPUServerVolumeOutput)
}

// [string] The availability zone in which the server should exist. E.g: `AUTO`, `ZONE_1`, `ZONE_2`. This property is immutable.
func (o VCPUServerVolumePtrOutput) AvailabilityZone() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VCPUServerVolume) *string {
		if v == nil {
			return nil
		}
		return v.AvailabilityZone
	}).(pulumi.StringPtrOutput)
}

// The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
func (o VCPUServerVolumePtrOutput) BackupUnitId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VCPUServerVolume) *string {
		if v == nil {
			return nil
		}
		return v.BackupUnitId
	}).(pulumi.StringPtrOutput)
}

// The UUID of the attached server.
func (o VCPUServerVolumePtrOutput) BootServer() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VCPUServerVolume) *string {
		if v == nil {
			return nil
		}
		return v.BootServer
	}).(pulumi.StringPtrOutput)
}

func (o VCPUServerVolumePtrOutput) Bus() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VCPUServerVolume) *string {
		if v == nil {
			return nil
		}
		return v.Bus
	}).(pulumi.StringPtrOutput)
}

func (o VCPUServerVolumePtrOutput) CpuHotPlug() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *VCPUServerVolume) *bool {
		if v == nil {
			return nil
		}
		return v.CpuHotPlug
	}).(pulumi.BoolPtrOutput)
}

func (o VCPUServerVolumePtrOutput) DeviceNumber() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *VCPUServerVolume) *int {
		if v == nil {
			return nil
		}
		return v.DeviceNumber
	}).(pulumi.IntPtrOutput)
}

func (o VCPUServerVolumePtrOutput) DiscVirtioHotPlug() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *VCPUServerVolume) *bool {
		if v == nil {
			return nil
		}
		return v.DiscVirtioHotPlug
	}).(pulumi.BoolPtrOutput)
}

func (o VCPUServerVolumePtrOutput) DiscVirtioHotUnplug() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *VCPUServerVolume) *bool {
		if v == nil {
			return nil
		}
		return v.DiscVirtioHotUnplug
	}).(pulumi.BoolPtrOutput)
}

func (o VCPUServerVolumePtrOutput) DiskType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VCPUServerVolume) *string {
		if v == nil {
			return nil
		}
		return &v.DiskType
	}).(pulumi.StringPtrOutput)
}

// [string] Sets the OS type of the server.
func (o VCPUServerVolumePtrOutput) LicenceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VCPUServerVolume) *string {
		if v == nil {
			return nil
		}
		return v.LicenceType
	}).(pulumi.StringPtrOutput)
}

// [string] The name of the server.
func (o VCPUServerVolumePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VCPUServerVolume) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

func (o VCPUServerVolumePtrOutput) NicHotPlug() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *VCPUServerVolume) *bool {
		if v == nil {
			return nil
		}
		return v.NicHotPlug
	}).(pulumi.BoolPtrOutput)
}

func (o VCPUServerVolumePtrOutput) NicHotUnplug() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *VCPUServerVolume) *bool {
		if v == nil {
			return nil
		}
		return v.NicHotUnplug
	}).(pulumi.BoolPtrOutput)
}

func (o VCPUServerVolumePtrOutput) PciSlot() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *VCPUServerVolume) *int {
		if v == nil {
			return nil
		}
		return v.PciSlot
	}).(pulumi.IntPtrOutput)
}

func (o VCPUServerVolumePtrOutput) RamHotPlug() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *VCPUServerVolume) *bool {
		if v == nil {
			return nil
		}
		return v.RamHotPlug
	}).(pulumi.BoolPtrOutput)
}

// The size of the volume in GB.
func (o VCPUServerVolumePtrOutput) Size() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *VCPUServerVolume) *int {
		if v == nil {
			return nil
		}
		return v.Size
	}).(pulumi.IntPtrOutput)
}

// The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
func (o VCPUServerVolumePtrOutput) UserData() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VCPUServerVolume) *string {
		if v == nil {
			return nil
		}
		return v.UserData
	}).(pulumi.StringPtrOutput)
}

type GetCrossconnectConnectableDatacenter struct {
	// ID of the cross connect you want to search for.
	//
	// Either `name` or `id` must be provided. If none, or both are provided, the datasource will return an error.
	Id string `pulumi:"id"`
	// The physical location of the connectable datacenter
	Location string `pulumi:"location"`
	// Name of an existing cross connect that you want to search for.
	Name string `pulumi:"name"`
}

// GetCrossconnectConnectableDatacenterInput is an input type that accepts GetCrossconnectConnectableDatacenterArgs and GetCrossconnectConnectableDatacenterOutput values.
// You can construct a concrete instance of `GetCrossconnectConnectableDatacenterInput` via:
//
//	GetCrossconnectConnectableDatacenterArgs{...}
type GetCrossconnectConnectableDatacenterInput interface {
	pulumi.Input

	ToGetCrossconnectConnectableDatacenterOutput() GetCrossconnectConnectableDatacenterOutput
	ToGetCrossconnectConnectableDatacenterOutputWithContext(context.Context) GetCrossconnectConnectableDatacenterOutput
}

type GetCrossconnectConnectableDatacenterArgs struct {
	// ID of the cross connect you want to search for.
	//
	// Either `name` or `id` must be provided. If none, or both are provided, the datasource will return an error.
	Id pulumi.StringInput `pulumi:"id"`
	// The physical location of the connectable datacenter
	Location pulumi.StringInput `pulumi:"location"`
	// Name of an existing cross connect that you want to search for.
	Name pulumi.StringInput `pulumi:"name"`
}

func (GetCrossconnectConnectableDatacenterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCrossconnectConnectableDatacenter)(nil)).Elem()
}

func (i GetCrossconnectConnectableDatacenterArgs) ToGetCrossconnectConnectableDatacenterOutput() GetCrossconnectConnectableDatacenterOutput {
	return i.ToGetCrossconnectConnectableDatacenterOutputWithContext(context.Background())
}

func (i GetCrossconnectConnectableDatacenterArgs) ToGetCrossconnectConnectableDatacenterOutputWithContext(ctx context.Context) GetCrossconnectConnectableDatacenterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCrossconnectConnectableDatacenterOutput)
}

// GetCrossconnectConnectableDatacenterArrayInput is an input type that accepts GetCrossconnectConnectableDatacenterArray and GetCrossconnectConnectableDatacenterArrayOutput values.
// You can construct a concrete instance of `GetCrossconnectConnectableDatacenterArrayInput` via:
//
//	GetCrossconnectConnectableDatacenterArray{ GetCrossconnectConnectableDatacenterArgs{...} }
type GetCrossconnectConnectableDatacenterArrayInput interface {
	pulumi.Input

	ToGetCrossconnectConnectableDatacenterArrayOutput() GetCrossconnectConnectableDatacenterArrayOutput
	ToGetCrossconnectConnectableDatacenterArrayOutputWithContext(context.Context) GetCrossconnectConnectableDatacenterArrayOutput
}

type GetCrossconnectConnectableDatacenterArray []GetCrossconnectConnectableDatacenterInput

func (GetCrossconnectConnectableDatacenterArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCrossconnectConnectableDatacenter)(nil)).Elem()
}

func (i GetCrossconnectConnectableDatacenterArray) ToGetCrossconnectConnectableDatacenterArrayOutput() GetCrossconnectConnectableDatacenterArrayOutput {
	return i.ToGetCrossconnectConnectableDatacenterArrayOutputWithContext(context.Background())
}

func (i GetCrossconnectConnectableDatacenterArray) ToGetCrossconnectConnectableDatacenterArrayOutputWithContext(ctx context.Context) GetCrossconnectConnectableDatacenterArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCrossconnectConnectableDatacenterArrayOutput)
}

type GetCrossconnectConnectableDatacenterOutput struct{ *pulumi.OutputState }

func (GetCrossconnectConnectableDatacenterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCrossconnectConnectableDatacenter)(nil)).Elem()
}

func (o GetCrossconnectConnectableDatacenterOutput) ToGetCrossconnectConnectableDatacenterOutput() GetCrossconnectConnectableDatacenterOutput {
	return o
}

func (o GetCrossconnectConnectableDatacenterOutput) ToGetCrossconnectConnectableDatacenterOutputWithContext(ctx context.Context) GetCrossconnectConnectableDatacenterOutput {
	return o
}

// ID of the cross connect you want to search for.
//
// Either `name` or `id` must be provided. If none, or both are provided, the datasource will return an error.
func (o GetCrossconnectConnectableDatacenterOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v GetCrossconnectConnectableDatacenter) string { return v.Id }).(pulumi.StringOutput)
}

// The physical location of the connectable datacenter
func (o GetCrossconnectConnectableDatacenterOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v GetCrossconnectConnectableDatacenter) string { return v.Location }).(pulumi.StringOutput)
}

// Name of an existing cross connect that you want to search for.
func (o GetCrossconnectConnectableDatacenterOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GetCrossconnectConnectableDatacenter) string { return v.Name }).(pulumi.StringOutput)
}

type GetCrossconnectConnectableDatacenterArrayOutput struct{ *pulumi.OutputState }

func (GetCrossconnectConnectableDatacenterArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCrossconnectConnectableDatacenter)(nil)).Elem()
}

func (o GetCrossconnectConnectableDatacenterArrayOutput) ToGetCrossconnectConnectableDatacenterArrayOutput() GetCrossconnectConnectableDatacenterArrayOutput {
	return o
}

func (o GetCrossconnectConnectableDatacenterArrayOutput) ToGetCrossconnectConnectableDatacenterArrayOutputWithContext(ctx context.Context) GetCrossconnectConnectableDatacenterArrayOutput {
	return o
}

func (o GetCrossconnectConnectableDatacenterArrayOutput) Index(i pulumi.IntInput) GetCrossconnectConnectableDatacenterOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetCrossconnectConnectableDatacenter {
		return vs[0].([]GetCrossconnectConnectableDatacenter)[vs[1].(int)]
	}).(GetCrossconnectConnectableDatacenterOutput)
}

type GetCrossconnectPeer struct {
	// The id of the cross-connected datacenter
	DatacenterId string `pulumi:"datacenterId"`
	// The name of the cross-connected datacenter
	DatacenterName string `pulumi:"datacenterName"`
	// The id of the cross-connected LAN
	LanId string `pulumi:"lanId"`
	// The name of the cross-connected LAN
	LanName string `pulumi:"lanName"`
	// The physical location of the connectable datacenter
	Location string `pulumi:"location"`
}

// GetCrossconnectPeerInput is an input type that accepts GetCrossconnectPeerArgs and GetCrossconnectPeerOutput values.
// You can construct a concrete instance of `GetCrossconnectPeerInput` via:
//
//	GetCrossconnectPeerArgs{...}
type GetCrossconnectPeerInput interface {
	pulumi.Input

	ToGetCrossconnectPeerOutput() GetCrossconnectPeerOutput
	ToGetCrossconnectPeerOutputWithContext(context.Context) GetCrossconnectPeerOutput
}

type GetCrossconnectPeerArgs struct {
	// The id of the cross-connected datacenter
	DatacenterId pulumi.StringInput `pulumi:"datacenterId"`
	// The name of the cross-connected datacenter
	DatacenterName pulumi.StringInput `pulumi:"datacenterName"`
	// The id of the cross-connected LAN
	LanId pulumi.StringInput `pulumi:"lanId"`
	// The name of the cross-connected LAN
	LanName pulumi.StringInput `pulumi:"lanName"`
	// The physical location of the connectable datacenter
	Location pulumi.StringInput `pulumi:"location"`
}

func (GetCrossconnectPeerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCrossconnectPeer)(nil)).Elem()
}

func (i GetCrossconnectPeerArgs) ToGetCrossconnectPeerOutput() GetCrossconnectPeerOutput {
	return i.ToGetCrossconnectPeerOutputWithContext(context.Background())
}

func (i GetCrossconnectPeerArgs) ToGetCrossconnectPeerOutputWithContext(ctx context.Context) GetCrossconnectPeerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCrossconnectPeerOutput)
}

// GetCrossconnectPeerArrayInput is an input type that accepts GetCrossconnectPeerArray and GetCrossconnectPeerArrayOutput values.
// You can construct a concrete instance of `GetCrossconnectPeerArrayInput` via:
//
//	GetCrossconnectPeerArray{ GetCrossconnectPeerArgs{...} }
type GetCrossconnectPeerArrayInput interface {
	pulumi.Input

	ToGetCrossconnectPeerArrayOutput() GetCrossconnectPeerArrayOutput
	ToGetCrossconnectPeerArrayOutputWithContext(context.Context) GetCrossconnectPeerArrayOutput
}

type GetCrossconnectPeerArray []GetCrossconnectPeerInput

func (GetCrossconnectPeerArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCrossconnectPeer)(nil)).Elem()
}

func (i GetCrossconnectPeerArray) ToGetCrossconnectPeerArrayOutput() GetCrossconnectPeerArrayOutput {
	return i.ToGetCrossconnectPeerArrayOutputWithContext(context.Background())
}

func (i GetCrossconnectPeerArray) ToGetCrossconnectPeerArrayOutputWithContext(ctx context.Context) GetCrossconnectPeerArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCrossconnectPeerArrayOutput)
}

type GetCrossconnectPeerOutput struct{ *pulumi.OutputState }

func (GetCrossconnectPeerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCrossconnectPeer)(nil)).Elem()
}

func (o GetCrossconnectPeerOutput) ToGetCrossconnectPeerOutput() GetCrossconnectPeerOutput {
	return o
}

func (o GetCrossconnectPeerOutput) ToGetCrossconnectPeerOutputWithContext(ctx context.Context) GetCrossconnectPeerOutput {
	return o
}

// The id of the cross-connected datacenter
func (o GetCrossconnectPeerOutput) DatacenterId() pulumi.StringOutput {
	return o.ApplyT(func(v GetCrossconnectPeer) string { return v.DatacenterId }).(pulumi.StringOutput)
}

// The name of the cross-connected datacenter
func (o GetCrossconnectPeerOutput) DatacenterName() pulumi.StringOutput {
	return o.ApplyT(func(v GetCrossconnectPeer) string { return v.DatacenterName }).(pulumi.StringOutput)
}

// The id of the cross-connected LAN
func (o GetCrossconnectPeerOutput) LanId() pulumi.StringOutput {
	return o.ApplyT(func(v GetCrossconnectPeer) string { return v.LanId }).(pulumi.StringOutput)
}

// The name of the cross-connected LAN
func (o GetCrossconnectPeerOutput) LanName() pulumi.StringOutput {
	return o.ApplyT(func(v GetCrossconnectPeer) string { return v.LanName }).(pulumi.StringOutput)
}

// The physical location of the connectable datacenter
func (o GetCrossconnectPeerOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v GetCrossconnectPeer) string { return v.Location }).(pulumi.StringOutput)
}

type GetCrossconnectPeerArrayOutput struct{ *pulumi.OutputState }

func (GetCrossconnectPeerArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCrossconnectPeer)(nil)).Elem()
}

func (o GetCrossconnectPeerArrayOutput) ToGetCrossconnectPeerArrayOutput() GetCrossconnectPeerArrayOutput {
	return o
}

func (o GetCrossconnectPeerArrayOutput) ToGetCrossconnectPeerArrayOutputWithContext(ctx context.Context) GetCrossconnectPeerArrayOutput {
	return o
}

func (o GetCrossconnectPeerArrayOutput) Index(i pulumi.IntInput) GetCrossconnectPeerOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetCrossconnectPeer {
		return vs[0].([]GetCrossconnectPeer)[vs[1].(int)]
	}).(GetCrossconnectPeerOutput)
}

type GetCubeServerCdrom struct {
	// Cloud init compatibility
	CloudInit string `pulumi:"cloudInit"`
	// Is capable of CPU hot plug (no reboot required)
	CpuHotPlug bool `pulumi:"cpuHotPlug"`
	// Is capable of CPU hot unplug (no reboot required)
	CpuHotUnplug bool `pulumi:"cpuHotUnplug"`
	// Description of cdrom
	Description string `pulumi:"description"`
	// Is capable of SCSI drive hot plug (no reboot required)
	DiscScsiHotPlug bool `pulumi:"discScsiHotPlug"`
	// Is capable of SCSI drive hot unplug (no reboot required)
	DiscScsiHotUnplug bool `pulumi:"discScsiHotUnplug"`
	// Is capable of Virt-IO drive hot plug (no reboot required)
	DiscVirtioHotPlug bool `pulumi:"discVirtioHotPlug"`
	// Is capable of Virt-IO drive hot unplug (no reboot required)
	DiscVirtioHotUnplug bool `pulumi:"discVirtioHotUnplug"`
	// ID of the server you want to search for.
	//
	// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
	Id string `pulumi:"id"`
	// List of image aliases mapped for this Image
	ImageAliases []string `pulumi:"imageAliases"`
	// Type of image
	ImageType string `pulumi:"imageType"`
	// OS type of this volume
	LicenceType string `pulumi:"licenceType"`
	// Location of that image/snapshot
	Location string `pulumi:"location"`
	// Name of an existing server that you want to search for.
	Name string `pulumi:"name"`
	// Is capable of nic hot plug (no reboot required)
	NicHotPlug bool `pulumi:"nicHotPlug"`
	// Is capable of nic hot unplug (no reboot required)
	NicHotUnplug bool `pulumi:"nicHotUnplug"`
	// Indicates if the image is part of the public repository or not
	Public bool `pulumi:"public"`
	// Is capable of memory hot plug (no reboot required)
	RamHotPlug bool `pulumi:"ramHotPlug"`
	// Is capable of memory hot unplug (no reboot required)
	RamHotUnplug bool `pulumi:"ramHotUnplug"`
	// The size of the image in GB
	Size float64 `pulumi:"size"`
}

// GetCubeServerCdromInput is an input type that accepts GetCubeServerCdromArgs and GetCubeServerCdromOutput values.
// You can construct a concrete instance of `GetCubeServerCdromInput` via:
//
//	GetCubeServerCdromArgs{...}
type GetCubeServerCdromInput interface {
	pulumi.Input

	ToGetCubeServerCdromOutput() GetCubeServerCdromOutput
	ToGetCubeServerCdromOutputWithContext(context.Context) GetCubeServerCdromOutput
}

type GetCubeServerCdromArgs struct {
	// Cloud init compatibility
	CloudInit pulumi.StringInput `pulumi:"cloudInit"`
	// Is capable of CPU hot plug (no reboot required)
	CpuHotPlug pulumi.BoolInput `pulumi:"cpuHotPlug"`
	// Is capable of CPU hot unplug (no reboot required)
	CpuHotUnplug pulumi.BoolInput `pulumi:"cpuHotUnplug"`
	// Description of cdrom
	Description pulumi.StringInput `pulumi:"description"`
	// Is capable of SCSI drive hot plug (no reboot required)
	DiscScsiHotPlug pulumi.BoolInput `pulumi:"discScsiHotPlug"`
	// Is capable of SCSI drive hot unplug (no reboot required)
	DiscScsiHotUnplug pulumi.BoolInput `pulumi:"discScsiHotUnplug"`
	// Is capable of Virt-IO drive hot plug (no reboot required)
	DiscVirtioHotPlug pulumi.BoolInput `pulumi:"discVirtioHotPlug"`
	// Is capable of Virt-IO drive hot unplug (no reboot required)
	DiscVirtioHotUnplug pulumi.BoolInput `pulumi:"discVirtioHotUnplug"`
	// ID of the server you want to search for.
	//
	// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
	Id pulumi.StringInput `pulumi:"id"`
	// List of image aliases mapped for this Image
	ImageAliases pulumi.StringArrayInput `pulumi:"imageAliases"`
	// Type of image
	ImageType pulumi.StringInput `pulumi:"imageType"`
	// OS type of this volume
	LicenceType pulumi.StringInput `pulumi:"licenceType"`
	// Location of that image/snapshot
	Location pulumi.StringInput `pulumi:"location"`
	// Name of an existing server that you want to search for.
	Name pulumi.StringInput `pulumi:"name"`
	// Is capable of nic hot plug (no reboot required)
	NicHotPlug pulumi.BoolInput `pulumi:"nicHotPlug"`
	// Is capable of nic hot unplug (no reboot required)
	NicHotUnplug pulumi.BoolInput `pulumi:"nicHotUnplug"`
	// Indicates if the image is part of the public repository or not
	Public pulumi.BoolInput `pulumi:"public"`
	// Is capable of memory hot plug (no reboot required)
	RamHotPlug pulumi.BoolInput `pulumi:"ramHotPlug"`
	// Is capable of memory hot unplug (no reboot required)
	RamHotUnplug pulumi.BoolInput `pulumi:"ramHotUnplug"`
	// The size of the image in GB
	Size pulumi.Float64Input `pulumi:"size"`
}

func (GetCubeServerCdromArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCubeServerCdrom)(nil)).Elem()
}

func (i GetCubeServerCdromArgs) ToGetCubeServerCdromOutput() GetCubeServerCdromOutput {
	return i.ToGetCubeServerCdromOutputWithContext(context.Background())
}

func (i GetCubeServerCdromArgs) ToGetCubeServerCdromOutputWithContext(ctx context.Context) GetCubeServerCdromOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCubeServerCdromOutput)
}

// GetCubeServerCdromArrayInput is an input type that accepts GetCubeServerCdromArray and GetCubeServerCdromArrayOutput values.
// You can construct a concrete instance of `GetCubeServerCdromArrayInput` via:
//
//	GetCubeServerCdromArray{ GetCubeServerCdromArgs{...} }
type GetCubeServerCdromArrayInput interface {
	pulumi.Input

	ToGetCubeServerCdromArrayOutput() GetCubeServerCdromArrayOutput
	ToGetCubeServerCdromArrayOutputWithContext(context.Context) GetCubeServerCdromArrayOutput
}

type GetCubeServerCdromArray []GetCubeServerCdromInput

func (GetCubeServerCdromArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCubeServerCdrom)(nil)).Elem()
}

func (i GetCubeServerCdromArray) ToGetCubeServerCdromArrayOutput() GetCubeServerCdromArrayOutput {
	return i.ToGetCubeServerCdromArrayOutputWithContext(context.Background())
}

func (i GetCubeServerCdromArray) ToGetCubeServerCdromArrayOutputWithContext(ctx context.Context) GetCubeServerCdromArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCubeServerCdromArrayOutput)
}

type GetCubeServerCdromOutput struct{ *pulumi.OutputState }

func (GetCubeServerCdromOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCubeServerCdrom)(nil)).Elem()
}

func (o GetCubeServerCdromOutput) ToGetCubeServerCdromOutput() GetCubeServerCdromOutput {
	return o
}

func (o GetCubeServerCdromOutput) ToGetCubeServerCdromOutputWithContext(ctx context.Context) GetCubeServerCdromOutput {
	return o
}

// Cloud init compatibility
func (o GetCubeServerCdromOutput) CloudInit() pulumi.StringOutput {
	return o.ApplyT(func(v GetCubeServerCdrom) string { return v.CloudInit }).(pulumi.StringOutput)
}

// Is capable of CPU hot plug (no reboot required)
func (o GetCubeServerCdromOutput) CpuHotPlug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetCubeServerCdrom) bool { return v.CpuHotPlug }).(pulumi.BoolOutput)
}

// Is capable of CPU hot unplug (no reboot required)
func (o GetCubeServerCdromOutput) CpuHotUnplug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetCubeServerCdrom) bool { return v.CpuHotUnplug }).(pulumi.BoolOutput)
}

// Description of cdrom
func (o GetCubeServerCdromOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v GetCubeServerCdrom) string { return v.Description }).(pulumi.StringOutput)
}

// Is capable of SCSI drive hot plug (no reboot required)
func (o GetCubeServerCdromOutput) DiscScsiHotPlug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetCubeServerCdrom) bool { return v.DiscScsiHotPlug }).(pulumi.BoolOutput)
}

// Is capable of SCSI drive hot unplug (no reboot required)
func (o GetCubeServerCdromOutput) DiscScsiHotUnplug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetCubeServerCdrom) bool { return v.DiscScsiHotUnplug }).(pulumi.BoolOutput)
}

// Is capable of Virt-IO drive hot plug (no reboot required)
func (o GetCubeServerCdromOutput) DiscVirtioHotPlug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetCubeServerCdrom) bool { return v.DiscVirtioHotPlug }).(pulumi.BoolOutput)
}

// Is capable of Virt-IO drive hot unplug (no reboot required)
func (o GetCubeServerCdromOutput) DiscVirtioHotUnplug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetCubeServerCdrom) bool { return v.DiscVirtioHotUnplug }).(pulumi.BoolOutput)
}

// ID of the server you want to search for.
//
// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
func (o GetCubeServerCdromOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v GetCubeServerCdrom) string { return v.Id }).(pulumi.StringOutput)
}

// List of image aliases mapped for this Image
func (o GetCubeServerCdromOutput) ImageAliases() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetCubeServerCdrom) []string { return v.ImageAliases }).(pulumi.StringArrayOutput)
}

// Type of image
func (o GetCubeServerCdromOutput) ImageType() pulumi.StringOutput {
	return o.ApplyT(func(v GetCubeServerCdrom) string { return v.ImageType }).(pulumi.StringOutput)
}

// OS type of this volume
func (o GetCubeServerCdromOutput) LicenceType() pulumi.StringOutput {
	return o.ApplyT(func(v GetCubeServerCdrom) string { return v.LicenceType }).(pulumi.StringOutput)
}

// Location of that image/snapshot
func (o GetCubeServerCdromOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v GetCubeServerCdrom) string { return v.Location }).(pulumi.StringOutput)
}

// Name of an existing server that you want to search for.
func (o GetCubeServerCdromOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GetCubeServerCdrom) string { return v.Name }).(pulumi.StringOutput)
}

// Is capable of nic hot plug (no reboot required)
func (o GetCubeServerCdromOutput) NicHotPlug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetCubeServerCdrom) bool { return v.NicHotPlug }).(pulumi.BoolOutput)
}

// Is capable of nic hot unplug (no reboot required)
func (o GetCubeServerCdromOutput) NicHotUnplug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetCubeServerCdrom) bool { return v.NicHotUnplug }).(pulumi.BoolOutput)
}

// Indicates if the image is part of the public repository or not
func (o GetCubeServerCdromOutput) Public() pulumi.BoolOutput {
	return o.ApplyT(func(v GetCubeServerCdrom) bool { return v.Public }).(pulumi.BoolOutput)
}

// Is capable of memory hot plug (no reboot required)
func (o GetCubeServerCdromOutput) RamHotPlug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetCubeServerCdrom) bool { return v.RamHotPlug }).(pulumi.BoolOutput)
}

// Is capable of memory hot unplug (no reboot required)
func (o GetCubeServerCdromOutput) RamHotUnplug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetCubeServerCdrom) bool { return v.RamHotUnplug }).(pulumi.BoolOutput)
}

// The size of the image in GB
func (o GetCubeServerCdromOutput) Size() pulumi.Float64Output {
	return o.ApplyT(func(v GetCubeServerCdrom) float64 { return v.Size }).(pulumi.Float64Output)
}

type GetCubeServerCdromArrayOutput struct{ *pulumi.OutputState }

func (GetCubeServerCdromArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCubeServerCdrom)(nil)).Elem()
}

func (o GetCubeServerCdromArrayOutput) ToGetCubeServerCdromArrayOutput() GetCubeServerCdromArrayOutput {
	return o
}

func (o GetCubeServerCdromArrayOutput) ToGetCubeServerCdromArrayOutputWithContext(ctx context.Context) GetCubeServerCdromArrayOutput {
	return o
}

func (o GetCubeServerCdromArrayOutput) Index(i pulumi.IntInput) GetCubeServerCdromOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetCubeServerCdrom {
		return vs[0].([]GetCubeServerCdrom)[vs[1].(int)]
	}).(GetCubeServerCdromOutput)
}

type GetCubeServerNic struct {
	// The Logical Unit Number (LUN) of the storage volume
	DeviceNumber int `pulumi:"deviceNumber"`
	// Indicates if the nic will reserve an IP using DHCP
	Dhcp   bool  `pulumi:"dhcp"`
	Dhcpv6 *bool `pulumi:"dhcpv6"`
	// Activate or deactivate the firewall
	FirewallActive bool `pulumi:"firewallActive"`
	// list of
	FirewallRules []GetCubeServerNicFirewallRule `pulumi:"firewallRules"`
	// The type of firewall rules that will be allowed on the NIC
	FirewallType string `pulumi:"firewallType"`
	// ID of the server you want to search for.
	//
	// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
	Id string `pulumi:"id"`
	// Collection of IP addresses assigned to a nic
	Ips           []string `pulumi:"ips"`
	Ipv6CidrBlock string   `pulumi:"ipv6CidrBlock"`
	Ipv6Ips       []string `pulumi:"ipv6Ips"`
	// The LAN ID the NIC will sit on
	Lan int `pulumi:"lan"`
	// The MAC address of the NIC
	Mac string `pulumi:"mac"`
	// Name of an existing server that you want to search for.
	Name string `pulumi:"name"`
	// The PCI slot number of the Nic
	PciSlot int `pulumi:"pciSlot"`
}

// GetCubeServerNicInput is an input type that accepts GetCubeServerNicArgs and GetCubeServerNicOutput values.
// You can construct a concrete instance of `GetCubeServerNicInput` via:
//
//	GetCubeServerNicArgs{...}
type GetCubeServerNicInput interface {
	pulumi.Input

	ToGetCubeServerNicOutput() GetCubeServerNicOutput
	ToGetCubeServerNicOutputWithContext(context.Context) GetCubeServerNicOutput
}

type GetCubeServerNicArgs struct {
	// The Logical Unit Number (LUN) of the storage volume
	DeviceNumber pulumi.IntInput `pulumi:"deviceNumber"`
	// Indicates if the nic will reserve an IP using DHCP
	Dhcp   pulumi.BoolInput    `pulumi:"dhcp"`
	Dhcpv6 pulumi.BoolPtrInput `pulumi:"dhcpv6"`
	// Activate or deactivate the firewall
	FirewallActive pulumi.BoolInput `pulumi:"firewallActive"`
	// list of
	FirewallRules GetCubeServerNicFirewallRuleArrayInput `pulumi:"firewallRules"`
	// The type of firewall rules that will be allowed on the NIC
	FirewallType pulumi.StringInput `pulumi:"firewallType"`
	// ID of the server you want to search for.
	//
	// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
	Id pulumi.StringInput `pulumi:"id"`
	// Collection of IP addresses assigned to a nic
	Ips           pulumi.StringArrayInput `pulumi:"ips"`
	Ipv6CidrBlock pulumi.StringInput      `pulumi:"ipv6CidrBlock"`
	Ipv6Ips       pulumi.StringArrayInput `pulumi:"ipv6Ips"`
	// The LAN ID the NIC will sit on
	Lan pulumi.IntInput `pulumi:"lan"`
	// The MAC address of the NIC
	Mac pulumi.StringInput `pulumi:"mac"`
	// Name of an existing server that you want to search for.
	Name pulumi.StringInput `pulumi:"name"`
	// The PCI slot number of the Nic
	PciSlot pulumi.IntInput `pulumi:"pciSlot"`
}

func (GetCubeServerNicArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCubeServerNic)(nil)).Elem()
}

func (i GetCubeServerNicArgs) ToGetCubeServerNicOutput() GetCubeServerNicOutput {
	return i.ToGetCubeServerNicOutputWithContext(context.Background())
}

func (i GetCubeServerNicArgs) ToGetCubeServerNicOutputWithContext(ctx context.Context) GetCubeServerNicOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCubeServerNicOutput)
}

// GetCubeServerNicArrayInput is an input type that accepts GetCubeServerNicArray and GetCubeServerNicArrayOutput values.
// You can construct a concrete instance of `GetCubeServerNicArrayInput` via:
//
//	GetCubeServerNicArray{ GetCubeServerNicArgs{...} }
type GetCubeServerNicArrayInput interface {
	pulumi.Input

	ToGetCubeServerNicArrayOutput() GetCubeServerNicArrayOutput
	ToGetCubeServerNicArrayOutputWithContext(context.Context) GetCubeServerNicArrayOutput
}

type GetCubeServerNicArray []GetCubeServerNicInput

func (GetCubeServerNicArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCubeServerNic)(nil)).Elem()
}

func (i GetCubeServerNicArray) ToGetCubeServerNicArrayOutput() GetCubeServerNicArrayOutput {
	return i.ToGetCubeServerNicArrayOutputWithContext(context.Background())
}

func (i GetCubeServerNicArray) ToGetCubeServerNicArrayOutputWithContext(ctx context.Context) GetCubeServerNicArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCubeServerNicArrayOutput)
}

type GetCubeServerNicOutput struct{ *pulumi.OutputState }

func (GetCubeServerNicOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCubeServerNic)(nil)).Elem()
}

func (o GetCubeServerNicOutput) ToGetCubeServerNicOutput() GetCubeServerNicOutput {
	return o
}

func (o GetCubeServerNicOutput) ToGetCubeServerNicOutputWithContext(ctx context.Context) GetCubeServerNicOutput {
	return o
}

// The Logical Unit Number (LUN) of the storage volume
func (o GetCubeServerNicOutput) DeviceNumber() pulumi.IntOutput {
	return o.ApplyT(func(v GetCubeServerNic) int { return v.DeviceNumber }).(pulumi.IntOutput)
}

// Indicates if the nic will reserve an IP using DHCP
func (o GetCubeServerNicOutput) Dhcp() pulumi.BoolOutput {
	return o.ApplyT(func(v GetCubeServerNic) bool { return v.Dhcp }).(pulumi.BoolOutput)
}

func (o GetCubeServerNicOutput) Dhcpv6() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v GetCubeServerNic) *bool { return v.Dhcpv6 }).(pulumi.BoolPtrOutput)
}

// Activate or deactivate the firewall
func (o GetCubeServerNicOutput) FirewallActive() pulumi.BoolOutput {
	return o.ApplyT(func(v GetCubeServerNic) bool { return v.FirewallActive }).(pulumi.BoolOutput)
}

// list of
func (o GetCubeServerNicOutput) FirewallRules() GetCubeServerNicFirewallRuleArrayOutput {
	return o.ApplyT(func(v GetCubeServerNic) []GetCubeServerNicFirewallRule { return v.FirewallRules }).(GetCubeServerNicFirewallRuleArrayOutput)
}

// The type of firewall rules that will be allowed on the NIC
func (o GetCubeServerNicOutput) FirewallType() pulumi.StringOutput {
	return o.ApplyT(func(v GetCubeServerNic) string { return v.FirewallType }).(pulumi.StringOutput)
}

// ID of the server you want to search for.
//
// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
func (o GetCubeServerNicOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v GetCubeServerNic) string { return v.Id }).(pulumi.StringOutput)
}

// Collection of IP addresses assigned to a nic
func (o GetCubeServerNicOutput) Ips() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetCubeServerNic) []string { return v.Ips }).(pulumi.StringArrayOutput)
}

func (o GetCubeServerNicOutput) Ipv6CidrBlock() pulumi.StringOutput {
	return o.ApplyT(func(v GetCubeServerNic) string { return v.Ipv6CidrBlock }).(pulumi.StringOutput)
}

func (o GetCubeServerNicOutput) Ipv6Ips() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetCubeServerNic) []string { return v.Ipv6Ips }).(pulumi.StringArrayOutput)
}

// The LAN ID the NIC will sit on
func (o GetCubeServerNicOutput) Lan() pulumi.IntOutput {
	return o.ApplyT(func(v GetCubeServerNic) int { return v.Lan }).(pulumi.IntOutput)
}

// The MAC address of the NIC
func (o GetCubeServerNicOutput) Mac() pulumi.StringOutput {
	return o.ApplyT(func(v GetCubeServerNic) string { return v.Mac }).(pulumi.StringOutput)
}

// Name of an existing server that you want to search for.
func (o GetCubeServerNicOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GetCubeServerNic) string { return v.Name }).(pulumi.StringOutput)
}

// The PCI slot number of the Nic
func (o GetCubeServerNicOutput) PciSlot() pulumi.IntOutput {
	return o.ApplyT(func(v GetCubeServerNic) int { return v.PciSlot }).(pulumi.IntOutput)
}

type GetCubeServerNicArrayOutput struct{ *pulumi.OutputState }

func (GetCubeServerNicArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCubeServerNic)(nil)).Elem()
}

func (o GetCubeServerNicArrayOutput) ToGetCubeServerNicArrayOutput() GetCubeServerNicArrayOutput {
	return o
}

func (o GetCubeServerNicArrayOutput) ToGetCubeServerNicArrayOutputWithContext(ctx context.Context) GetCubeServerNicArrayOutput {
	return o
}

func (o GetCubeServerNicArrayOutput) Index(i pulumi.IntInput) GetCubeServerNicOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetCubeServerNic {
		return vs[0].([]GetCubeServerNic)[vs[1].(int)]
	}).(GetCubeServerNicOutput)
}

type GetCubeServerNicFirewallRule struct {
	// Defines the allowed code (from 0 to 254) if protocol ICMP is chosen
	IcmpCode int `pulumi:"icmpCode"`
	// Defines the allowed type (from 0 to 254) if the protocol ICMP is chosen
	IcmpType int `pulumi:"icmpType"`
	// ID of the server you want to search for.
	//
	// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
	Id string `pulumi:"id"`
	// Name of an existing server that you want to search for.
	Name string `pulumi:"name"`
	// Defines the end range of the allowed port (from 1 to 65534) if the protocol TCP or UDP is chosen
	PortRangeEnd int `pulumi:"portRangeEnd"`
	// Defines the start range of the allowed port (from 1 to 65534) if protocol TCP or UDP is chosen
	PortRangeStart int `pulumi:"portRangeStart"`
	// he protocol for the rule
	Protocol string `pulumi:"protocol"`
	// Only traffic originating from the respective IPv4 address is allowed. Value null allows all source IPs
	SourceIp string `pulumi:"sourceIp"`
	// Only traffic originating from the respective MAC address is allowed
	SourceMac string `pulumi:"sourceMac"`
	// In case the target NIC has multiple IP addresses, only traffic directed to the respective IP address of the NIC is allowed
	TargetIp string `pulumi:"targetIp"`
	// The type of firewall rule
	Type string `pulumi:"type"`
}

// GetCubeServerNicFirewallRuleInput is an input type that accepts GetCubeServerNicFirewallRuleArgs and GetCubeServerNicFirewallRuleOutput values.
// You can construct a concrete instance of `GetCubeServerNicFirewallRuleInput` via:
//
//	GetCubeServerNicFirewallRuleArgs{...}
type GetCubeServerNicFirewallRuleInput interface {
	pulumi.Input

	ToGetCubeServerNicFirewallRuleOutput() GetCubeServerNicFirewallRuleOutput
	ToGetCubeServerNicFirewallRuleOutputWithContext(context.Context) GetCubeServerNicFirewallRuleOutput
}

type GetCubeServerNicFirewallRuleArgs struct {
	// Defines the allowed code (from 0 to 254) if protocol ICMP is chosen
	IcmpCode pulumi.IntInput `pulumi:"icmpCode"`
	// Defines the allowed type (from 0 to 254) if the protocol ICMP is chosen
	IcmpType pulumi.IntInput `pulumi:"icmpType"`
	// ID of the server you want to search for.
	//
	// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
	Id pulumi.StringInput `pulumi:"id"`
	// Name of an existing server that you want to search for.
	Name pulumi.StringInput `pulumi:"name"`
	// Defines the end range of the allowed port (from 1 to 65534) if the protocol TCP or UDP is chosen
	PortRangeEnd pulumi.IntInput `pulumi:"portRangeEnd"`
	// Defines the start range of the allowed port (from 1 to 65534) if protocol TCP or UDP is chosen
	PortRangeStart pulumi.IntInput `pulumi:"portRangeStart"`
	// he protocol for the rule
	Protocol pulumi.StringInput `pulumi:"protocol"`
	// Only traffic originating from the respective IPv4 address is allowed. Value null allows all source IPs
	SourceIp pulumi.StringInput `pulumi:"sourceIp"`
	// Only traffic originating from the respective MAC address is allowed
	SourceMac pulumi.StringInput `pulumi:"sourceMac"`
	// In case the target NIC has multiple IP addresses, only traffic directed to the respective IP address of the NIC is allowed
	TargetIp pulumi.StringInput `pulumi:"targetIp"`
	// The type of firewall rule
	Type pulumi.StringInput `pulumi:"type"`
}

func (GetCubeServerNicFirewallRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCubeServerNicFirewallRule)(nil)).Elem()
}

func (i GetCubeServerNicFirewallRuleArgs) ToGetCubeServerNicFirewallRuleOutput() GetCubeServerNicFirewallRuleOutput {
	return i.ToGetCubeServerNicFirewallRuleOutputWithContext(context.Background())
}

func (i GetCubeServerNicFirewallRuleArgs) ToGetCubeServerNicFirewallRuleOutputWithContext(ctx context.Context) GetCubeServerNicFirewallRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCubeServerNicFirewallRuleOutput)
}

// GetCubeServerNicFirewallRuleArrayInput is an input type that accepts GetCubeServerNicFirewallRuleArray and GetCubeServerNicFirewallRuleArrayOutput values.
// You can construct a concrete instance of `GetCubeServerNicFirewallRuleArrayInput` via:
//
//	GetCubeServerNicFirewallRuleArray{ GetCubeServerNicFirewallRuleArgs{...} }
type GetCubeServerNicFirewallRuleArrayInput interface {
	pulumi.Input

	ToGetCubeServerNicFirewallRuleArrayOutput() GetCubeServerNicFirewallRuleArrayOutput
	ToGetCubeServerNicFirewallRuleArrayOutputWithContext(context.Context) GetCubeServerNicFirewallRuleArrayOutput
}

type GetCubeServerNicFirewallRuleArray []GetCubeServerNicFirewallRuleInput

func (GetCubeServerNicFirewallRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCubeServerNicFirewallRule)(nil)).Elem()
}

func (i GetCubeServerNicFirewallRuleArray) ToGetCubeServerNicFirewallRuleArrayOutput() GetCubeServerNicFirewallRuleArrayOutput {
	return i.ToGetCubeServerNicFirewallRuleArrayOutputWithContext(context.Background())
}

func (i GetCubeServerNicFirewallRuleArray) ToGetCubeServerNicFirewallRuleArrayOutputWithContext(ctx context.Context) GetCubeServerNicFirewallRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCubeServerNicFirewallRuleArrayOutput)
}

type GetCubeServerNicFirewallRuleOutput struct{ *pulumi.OutputState }

func (GetCubeServerNicFirewallRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCubeServerNicFirewallRule)(nil)).Elem()
}

func (o GetCubeServerNicFirewallRuleOutput) ToGetCubeServerNicFirewallRuleOutput() GetCubeServerNicFirewallRuleOutput {
	return o
}

func (o GetCubeServerNicFirewallRuleOutput) ToGetCubeServerNicFirewallRuleOutputWithContext(ctx context.Context) GetCubeServerNicFirewallRuleOutput {
	return o
}

// Defines the allowed code (from 0 to 254) if protocol ICMP is chosen
func (o GetCubeServerNicFirewallRuleOutput) IcmpCode() pulumi.IntOutput {
	return o.ApplyT(func(v GetCubeServerNicFirewallRule) int { return v.IcmpCode }).(pulumi.IntOutput)
}

// Defines the allowed type (from 0 to 254) if the protocol ICMP is chosen
func (o GetCubeServerNicFirewallRuleOutput) IcmpType() pulumi.IntOutput {
	return o.ApplyT(func(v GetCubeServerNicFirewallRule) int { return v.IcmpType }).(pulumi.IntOutput)
}

// ID of the server you want to search for.
//
// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
func (o GetCubeServerNicFirewallRuleOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v GetCubeServerNicFirewallRule) string { return v.Id }).(pulumi.StringOutput)
}

// Name of an existing server that you want to search for.
func (o GetCubeServerNicFirewallRuleOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GetCubeServerNicFirewallRule) string { return v.Name }).(pulumi.StringOutput)
}

// Defines the end range of the allowed port (from 1 to 65534) if the protocol TCP or UDP is chosen
func (o GetCubeServerNicFirewallRuleOutput) PortRangeEnd() pulumi.IntOutput {
	return o.ApplyT(func(v GetCubeServerNicFirewallRule) int { return v.PortRangeEnd }).(pulumi.IntOutput)
}

// Defines the start range of the allowed port (from 1 to 65534) if protocol TCP or UDP is chosen
func (o GetCubeServerNicFirewallRuleOutput) PortRangeStart() pulumi.IntOutput {
	return o.ApplyT(func(v GetCubeServerNicFirewallRule) int { return v.PortRangeStart }).(pulumi.IntOutput)
}

// he protocol for the rule
func (o GetCubeServerNicFirewallRuleOutput) Protocol() pulumi.StringOutput {
	return o.ApplyT(func(v GetCubeServerNicFirewallRule) string { return v.Protocol }).(pulumi.StringOutput)
}

// Only traffic originating from the respective IPv4 address is allowed. Value null allows all source IPs
func (o GetCubeServerNicFirewallRuleOutput) SourceIp() pulumi.StringOutput {
	return o.ApplyT(func(v GetCubeServerNicFirewallRule) string { return v.SourceIp }).(pulumi.StringOutput)
}

// Only traffic originating from the respective MAC address is allowed
func (o GetCubeServerNicFirewallRuleOutput) SourceMac() pulumi.StringOutput {
	return o.ApplyT(func(v GetCubeServerNicFirewallRule) string { return v.SourceMac }).(pulumi.StringOutput)
}

// In case the target NIC has multiple IP addresses, only traffic directed to the respective IP address of the NIC is allowed
func (o GetCubeServerNicFirewallRuleOutput) TargetIp() pulumi.StringOutput {
	return o.ApplyT(func(v GetCubeServerNicFirewallRule) string { return v.TargetIp }).(pulumi.StringOutput)
}

// The type of firewall rule
func (o GetCubeServerNicFirewallRuleOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v GetCubeServerNicFirewallRule) string { return v.Type }).(pulumi.StringOutput)
}

type GetCubeServerNicFirewallRuleArrayOutput struct{ *pulumi.OutputState }

func (GetCubeServerNicFirewallRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCubeServerNicFirewallRule)(nil)).Elem()
}

func (o GetCubeServerNicFirewallRuleArrayOutput) ToGetCubeServerNicFirewallRuleArrayOutput() GetCubeServerNicFirewallRuleArrayOutput {
	return o
}

func (o GetCubeServerNicFirewallRuleArrayOutput) ToGetCubeServerNicFirewallRuleArrayOutputWithContext(ctx context.Context) GetCubeServerNicFirewallRuleArrayOutput {
	return o
}

func (o GetCubeServerNicFirewallRuleArrayOutput) Index(i pulumi.IntInput) GetCubeServerNicFirewallRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetCubeServerNicFirewallRule {
		return vs[0].([]GetCubeServerNicFirewallRule)[vs[1].(int)]
	}).(GetCubeServerNicFirewallRuleOutput)
}

type GetCubeServerVolume struct {
	// The availability zone in which the volume should exist
	AvailabilityZone string `pulumi:"availabilityZone"`
	// The uuid of the Backup Unit that user has access to
	BackupUnitId string `pulumi:"backupUnitId"`
	// The UUID of the attached server.
	BootServer string `pulumi:"bootServer"`
	// The bus type of the volume
	Bus string `pulumi:"bus"`
	// Is capable of CPU hot plug (no reboot required)
	CpuHotPlug bool `pulumi:"cpuHotPlug"`
	// The Logical Unit Number (LUN) of the storage volume
	DeviceNumber int `pulumi:"deviceNumber"`
	// Is capable of Virt-IO drive hot plug (no reboot required)
	DiscVirtioHotPlug bool `pulumi:"discVirtioHotPlug"`
	// Is capable of Virt-IO drive hot unplug (no reboot required)
	DiscVirtioHotUnplug bool `pulumi:"discVirtioHotUnplug"`
	// ID of the server you want to search for.
	//
	// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
	Id        string `pulumi:"id"`
	ImageName string `pulumi:"imageName"`
	// Initial password to be set for installed OS
	ImagePassword string `pulumi:"imagePassword"`
	// OS type of this volume
	LicenceType string `pulumi:"licenceType"`
	// Name of an existing server that you want to search for.
	Name string `pulumi:"name"`
	// Is capable of nic hot plug (no reboot required)
	NicHotPlug bool `pulumi:"nicHotPlug"`
	// Is capable of nic hot unplug (no reboot required)
	NicHotUnplug bool `pulumi:"nicHotUnplug"`
	// The PCI slot number of the Nic
	PciSlot int `pulumi:"pciSlot"`
	// Is capable of memory hot plug (no reboot required)
	RamHotPlug bool `pulumi:"ramHotPlug"`
	// Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key
	SshKeys []string `pulumi:"sshKeys"`
	// The type of firewall rule
	Type string `pulumi:"type"`
	// The cloud-init configuration for the volume as base64 encoded string
	UserData *string `pulumi:"userData"`
}

// GetCubeServerVolumeInput is an input type that accepts GetCubeServerVolumeArgs and GetCubeServerVolumeOutput values.
// You can construct a concrete instance of `GetCubeServerVolumeInput` via:
//
//	GetCubeServerVolumeArgs{...}
type GetCubeServerVolumeInput interface {
	pulumi.Input

	ToGetCubeServerVolumeOutput() GetCubeServerVolumeOutput
	ToGetCubeServerVolumeOutputWithContext(context.Context) GetCubeServerVolumeOutput
}

type GetCubeServerVolumeArgs struct {
	// The availability zone in which the volume should exist
	AvailabilityZone pulumi.StringInput `pulumi:"availabilityZone"`
	// The uuid of the Backup Unit that user has access to
	BackupUnitId pulumi.StringInput `pulumi:"backupUnitId"`
	// The UUID of the attached server.
	BootServer pulumi.StringInput `pulumi:"bootServer"`
	// The bus type of the volume
	Bus pulumi.StringInput `pulumi:"bus"`
	// Is capable of CPU hot plug (no reboot required)
	CpuHotPlug pulumi.BoolInput `pulumi:"cpuHotPlug"`
	// The Logical Unit Number (LUN) of the storage volume
	DeviceNumber pulumi.IntInput `pulumi:"deviceNumber"`
	// Is capable of Virt-IO drive hot plug (no reboot required)
	DiscVirtioHotPlug pulumi.BoolInput `pulumi:"discVirtioHotPlug"`
	// Is capable of Virt-IO drive hot unplug (no reboot required)
	DiscVirtioHotUnplug pulumi.BoolInput `pulumi:"discVirtioHotUnplug"`
	// ID of the server you want to search for.
	//
	// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
	Id        pulumi.StringInput `pulumi:"id"`
	ImageName pulumi.StringInput `pulumi:"imageName"`
	// Initial password to be set for installed OS
	ImagePassword pulumi.StringInput `pulumi:"imagePassword"`
	// OS type of this volume
	LicenceType pulumi.StringInput `pulumi:"licenceType"`
	// Name of an existing server that you want to search for.
	Name pulumi.StringInput `pulumi:"name"`
	// Is capable of nic hot plug (no reboot required)
	NicHotPlug pulumi.BoolInput `pulumi:"nicHotPlug"`
	// Is capable of nic hot unplug (no reboot required)
	NicHotUnplug pulumi.BoolInput `pulumi:"nicHotUnplug"`
	// The PCI slot number of the Nic
	PciSlot pulumi.IntInput `pulumi:"pciSlot"`
	// Is capable of memory hot plug (no reboot required)
	RamHotPlug pulumi.BoolInput `pulumi:"ramHotPlug"`
	// Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key
	SshKeys pulumi.StringArrayInput `pulumi:"sshKeys"`
	// The type of firewall rule
	Type pulumi.StringInput `pulumi:"type"`
	// The cloud-init configuration for the volume as base64 encoded string
	UserData pulumi.StringPtrInput `pulumi:"userData"`
}

func (GetCubeServerVolumeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCubeServerVolume)(nil)).Elem()
}

func (i GetCubeServerVolumeArgs) ToGetCubeServerVolumeOutput() GetCubeServerVolumeOutput {
	return i.ToGetCubeServerVolumeOutputWithContext(context.Background())
}

func (i GetCubeServerVolumeArgs) ToGetCubeServerVolumeOutputWithContext(ctx context.Context) GetCubeServerVolumeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCubeServerVolumeOutput)
}

// GetCubeServerVolumeArrayInput is an input type that accepts GetCubeServerVolumeArray and GetCubeServerVolumeArrayOutput values.
// You can construct a concrete instance of `GetCubeServerVolumeArrayInput` via:
//
//	GetCubeServerVolumeArray{ GetCubeServerVolumeArgs{...} }
type GetCubeServerVolumeArrayInput interface {
	pulumi.Input

	ToGetCubeServerVolumeArrayOutput() GetCubeServerVolumeArrayOutput
	ToGetCubeServerVolumeArrayOutputWithContext(context.Context) GetCubeServerVolumeArrayOutput
}

type GetCubeServerVolumeArray []GetCubeServerVolumeInput

func (GetCubeServerVolumeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCubeServerVolume)(nil)).Elem()
}

func (i GetCubeServerVolumeArray) ToGetCubeServerVolumeArrayOutput() GetCubeServerVolumeArrayOutput {
	return i.ToGetCubeServerVolumeArrayOutputWithContext(context.Background())
}

func (i GetCubeServerVolumeArray) ToGetCubeServerVolumeArrayOutputWithContext(ctx context.Context) GetCubeServerVolumeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetCubeServerVolumeArrayOutput)
}

type GetCubeServerVolumeOutput struct{ *pulumi.OutputState }

func (GetCubeServerVolumeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetCubeServerVolume)(nil)).Elem()
}

func (o GetCubeServerVolumeOutput) ToGetCubeServerVolumeOutput() GetCubeServerVolumeOutput {
	return o
}

func (o GetCubeServerVolumeOutput) ToGetCubeServerVolumeOutputWithContext(ctx context.Context) GetCubeServerVolumeOutput {
	return o
}

// The availability zone in which the volume should exist
func (o GetCubeServerVolumeOutput) AvailabilityZone() pulumi.StringOutput {
	return o.ApplyT(func(v GetCubeServerVolume) string { return v.AvailabilityZone }).(pulumi.StringOutput)
}

// The uuid of the Backup Unit that user has access to
func (o GetCubeServerVolumeOutput) BackupUnitId() pulumi.StringOutput {
	return o.ApplyT(func(v GetCubeServerVolume) string { return v.BackupUnitId }).(pulumi.StringOutput)
}

// The UUID of the attached server.
func (o GetCubeServerVolumeOutput) BootServer() pulumi.StringOutput {
	return o.ApplyT(func(v GetCubeServerVolume) string { return v.BootServer }).(pulumi.StringOutput)
}

// The bus type of the volume
func (o GetCubeServerVolumeOutput) Bus() pulumi.StringOutput {
	return o.ApplyT(func(v GetCubeServerVolume) string { return v.Bus }).(pulumi.StringOutput)
}

// Is capable of CPU hot plug (no reboot required)
func (o GetCubeServerVolumeOutput) CpuHotPlug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetCubeServerVolume) bool { return v.CpuHotPlug }).(pulumi.BoolOutput)
}

// The Logical Unit Number (LUN) of the storage volume
func (o GetCubeServerVolumeOutput) DeviceNumber() pulumi.IntOutput {
	return o.ApplyT(func(v GetCubeServerVolume) int { return v.DeviceNumber }).(pulumi.IntOutput)
}

// Is capable of Virt-IO drive hot plug (no reboot required)
func (o GetCubeServerVolumeOutput) DiscVirtioHotPlug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetCubeServerVolume) bool { return v.DiscVirtioHotPlug }).(pulumi.BoolOutput)
}

// Is capable of Virt-IO drive hot unplug (no reboot required)
func (o GetCubeServerVolumeOutput) DiscVirtioHotUnplug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetCubeServerVolume) bool { return v.DiscVirtioHotUnplug }).(pulumi.BoolOutput)
}

// ID of the server you want to search for.
//
// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
func (o GetCubeServerVolumeOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v GetCubeServerVolume) string { return v.Id }).(pulumi.StringOutput)
}

func (o GetCubeServerVolumeOutput) ImageName() pulumi.StringOutput {
	return o.ApplyT(func(v GetCubeServerVolume) string { return v.ImageName }).(pulumi.StringOutput)
}

// Initial password to be set for installed OS
func (o GetCubeServerVolumeOutput) ImagePassword() pulumi.StringOutput {
	return o.ApplyT(func(v GetCubeServerVolume) string { return v.ImagePassword }).(pulumi.StringOutput)
}

// OS type of this volume
func (o GetCubeServerVolumeOutput) LicenceType() pulumi.StringOutput {
	return o.ApplyT(func(v GetCubeServerVolume) string { return v.LicenceType }).(pulumi.StringOutput)
}

// Name of an existing server that you want to search for.
func (o GetCubeServerVolumeOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GetCubeServerVolume) string { return v.Name }).(pulumi.StringOutput)
}

// Is capable of nic hot plug (no reboot required)
func (o GetCubeServerVolumeOutput) NicHotPlug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetCubeServerVolume) bool { return v.NicHotPlug }).(pulumi.BoolOutput)
}

// Is capable of nic hot unplug (no reboot required)
func (o GetCubeServerVolumeOutput) NicHotUnplug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetCubeServerVolume) bool { return v.NicHotUnplug }).(pulumi.BoolOutput)
}

// The PCI slot number of the Nic
func (o GetCubeServerVolumeOutput) PciSlot() pulumi.IntOutput {
	return o.ApplyT(func(v GetCubeServerVolume) int { return v.PciSlot }).(pulumi.IntOutput)
}

// Is capable of memory hot plug (no reboot required)
func (o GetCubeServerVolumeOutput) RamHotPlug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetCubeServerVolume) bool { return v.RamHotPlug }).(pulumi.BoolOutput)
}

// Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key
func (o GetCubeServerVolumeOutput) SshKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetCubeServerVolume) []string { return v.SshKeys }).(pulumi.StringArrayOutput)
}

// The type of firewall rule
func (o GetCubeServerVolumeOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v GetCubeServerVolume) string { return v.Type }).(pulumi.StringOutput)
}

// The cloud-init configuration for the volume as base64 encoded string
func (o GetCubeServerVolumeOutput) UserData() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetCubeServerVolume) *string { return v.UserData }).(pulumi.StringPtrOutput)
}

type GetCubeServerVolumeArrayOutput struct{ *pulumi.OutputState }

func (GetCubeServerVolumeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetCubeServerVolume)(nil)).Elem()
}

func (o GetCubeServerVolumeArrayOutput) ToGetCubeServerVolumeArrayOutput() GetCubeServerVolumeArrayOutput {
	return o
}

func (o GetCubeServerVolumeArrayOutput) ToGetCubeServerVolumeArrayOutputWithContext(ctx context.Context) GetCubeServerVolumeArrayOutput {
	return o
}

func (o GetCubeServerVolumeArrayOutput) Index(i pulumi.IntInput) GetCubeServerVolumeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetCubeServerVolume {
		return vs[0].([]GetCubeServerVolume)[vs[1].(int)]
	}).(GetCubeServerVolumeOutput)
}

type GetDatacenterCpuArchitecture struct {
	// A valid CPU family name
	CpuFamily string `pulumi:"cpuFamily"`
	// The maximum number of cores available
	MaxCores int `pulumi:"maxCores"`
	// The maximum number of RAM in MB
	MaxRam int `pulumi:"maxRam"`
	// A valid CPU vendor name
	Vendor string `pulumi:"vendor"`
}

// GetDatacenterCpuArchitectureInput is an input type that accepts GetDatacenterCpuArchitectureArgs and GetDatacenterCpuArchitectureOutput values.
// You can construct a concrete instance of `GetDatacenterCpuArchitectureInput` via:
//
//	GetDatacenterCpuArchitectureArgs{...}
type GetDatacenterCpuArchitectureInput interface {
	pulumi.Input

	ToGetDatacenterCpuArchitectureOutput() GetDatacenterCpuArchitectureOutput
	ToGetDatacenterCpuArchitectureOutputWithContext(context.Context) GetDatacenterCpuArchitectureOutput
}

type GetDatacenterCpuArchitectureArgs struct {
	// A valid CPU family name
	CpuFamily pulumi.StringInput `pulumi:"cpuFamily"`
	// The maximum number of cores available
	MaxCores pulumi.IntInput `pulumi:"maxCores"`
	// The maximum number of RAM in MB
	MaxRam pulumi.IntInput `pulumi:"maxRam"`
	// A valid CPU vendor name
	Vendor pulumi.StringInput `pulumi:"vendor"`
}

func (GetDatacenterCpuArchitectureArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetDatacenterCpuArchitecture)(nil)).Elem()
}

func (i GetDatacenterCpuArchitectureArgs) ToGetDatacenterCpuArchitectureOutput() GetDatacenterCpuArchitectureOutput {
	return i.ToGetDatacenterCpuArchitectureOutputWithContext(context.Background())
}

func (i GetDatacenterCpuArchitectureArgs) ToGetDatacenterCpuArchitectureOutputWithContext(ctx context.Context) GetDatacenterCpuArchitectureOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetDatacenterCpuArchitectureOutput)
}

// GetDatacenterCpuArchitectureArrayInput is an input type that accepts GetDatacenterCpuArchitectureArray and GetDatacenterCpuArchitectureArrayOutput values.
// You can construct a concrete instance of `GetDatacenterCpuArchitectureArrayInput` via:
//
//	GetDatacenterCpuArchitectureArray{ GetDatacenterCpuArchitectureArgs{...} }
type GetDatacenterCpuArchitectureArrayInput interface {
	pulumi.Input

	ToGetDatacenterCpuArchitectureArrayOutput() GetDatacenterCpuArchitectureArrayOutput
	ToGetDatacenterCpuArchitectureArrayOutputWithContext(context.Context) GetDatacenterCpuArchitectureArrayOutput
}

type GetDatacenterCpuArchitectureArray []GetDatacenterCpuArchitectureInput

func (GetDatacenterCpuArchitectureArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetDatacenterCpuArchitecture)(nil)).Elem()
}

func (i GetDatacenterCpuArchitectureArray) ToGetDatacenterCpuArchitectureArrayOutput() GetDatacenterCpuArchitectureArrayOutput {
	return i.ToGetDatacenterCpuArchitectureArrayOutputWithContext(context.Background())
}

func (i GetDatacenterCpuArchitectureArray) ToGetDatacenterCpuArchitectureArrayOutputWithContext(ctx context.Context) GetDatacenterCpuArchitectureArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetDatacenterCpuArchitectureArrayOutput)
}

type GetDatacenterCpuArchitectureOutput struct{ *pulumi.OutputState }

func (GetDatacenterCpuArchitectureOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetDatacenterCpuArchitecture)(nil)).Elem()
}

func (o GetDatacenterCpuArchitectureOutput) ToGetDatacenterCpuArchitectureOutput() GetDatacenterCpuArchitectureOutput {
	return o
}

func (o GetDatacenterCpuArchitectureOutput) ToGetDatacenterCpuArchitectureOutputWithContext(ctx context.Context) GetDatacenterCpuArchitectureOutput {
	return o
}

// A valid CPU family name
func (o GetDatacenterCpuArchitectureOutput) CpuFamily() pulumi.StringOutput {
	return o.ApplyT(func(v GetDatacenterCpuArchitecture) string { return v.CpuFamily }).(pulumi.StringOutput)
}

// The maximum number of cores available
func (o GetDatacenterCpuArchitectureOutput) MaxCores() pulumi.IntOutput {
	return o.ApplyT(func(v GetDatacenterCpuArchitecture) int { return v.MaxCores }).(pulumi.IntOutput)
}

// The maximum number of RAM in MB
func (o GetDatacenterCpuArchitectureOutput) MaxRam() pulumi.IntOutput {
	return o.ApplyT(func(v GetDatacenterCpuArchitecture) int { return v.MaxRam }).(pulumi.IntOutput)
}

// A valid CPU vendor name
func (o GetDatacenterCpuArchitectureOutput) Vendor() pulumi.StringOutput {
	return o.ApplyT(func(v GetDatacenterCpuArchitecture) string { return v.Vendor }).(pulumi.StringOutput)
}

type GetDatacenterCpuArchitectureArrayOutput struct{ *pulumi.OutputState }

func (GetDatacenterCpuArchitectureArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetDatacenterCpuArchitecture)(nil)).Elem()
}

func (o GetDatacenterCpuArchitectureArrayOutput) ToGetDatacenterCpuArchitectureArrayOutput() GetDatacenterCpuArchitectureArrayOutput {
	return o
}

func (o GetDatacenterCpuArchitectureArrayOutput) ToGetDatacenterCpuArchitectureArrayOutputWithContext(ctx context.Context) GetDatacenterCpuArchitectureArrayOutput {
	return o
}

func (o GetDatacenterCpuArchitectureArrayOutput) Index(i pulumi.IntInput) GetDatacenterCpuArchitectureOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetDatacenterCpuArchitecture {
		return vs[0].([]GetDatacenterCpuArchitecture)[vs[1].(int)]
	}).(GetDatacenterCpuArchitectureOutput)
}

type GetGroupUser struct {
	Administrator bool   `pulumi:"administrator"`
	Email         string `pulumi:"email"`
	FirstName     string `pulumi:"firstName"`
	ForceSecAuth  bool   `pulumi:"forceSecAuth"`
	// ID of the group you want to search for.
	//
	// Either `name` or `id` must be provided. If none, or both are provided, the datasource will return an error.
	Id       string `pulumi:"id"`
	LastName string `pulumi:"lastName"`
}

// GetGroupUserInput is an input type that accepts GetGroupUserArgs and GetGroupUserOutput values.
// You can construct a concrete instance of `GetGroupUserInput` via:
//
//	GetGroupUserArgs{...}
type GetGroupUserInput interface {
	pulumi.Input

	ToGetGroupUserOutput() GetGroupUserOutput
	ToGetGroupUserOutputWithContext(context.Context) GetGroupUserOutput
}

type GetGroupUserArgs struct {
	Administrator pulumi.BoolInput   `pulumi:"administrator"`
	Email         pulumi.StringInput `pulumi:"email"`
	FirstName     pulumi.StringInput `pulumi:"firstName"`
	ForceSecAuth  pulumi.BoolInput   `pulumi:"forceSecAuth"`
	// ID of the group you want to search for.
	//
	// Either `name` or `id` must be provided. If none, or both are provided, the datasource will return an error.
	Id       pulumi.StringInput `pulumi:"id"`
	LastName pulumi.StringInput `pulumi:"lastName"`
}

func (GetGroupUserArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetGroupUser)(nil)).Elem()
}

func (i GetGroupUserArgs) ToGetGroupUserOutput() GetGroupUserOutput {
	return i.ToGetGroupUserOutputWithContext(context.Background())
}

func (i GetGroupUserArgs) ToGetGroupUserOutputWithContext(ctx context.Context) GetGroupUserOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetGroupUserOutput)
}

// GetGroupUserArrayInput is an input type that accepts GetGroupUserArray and GetGroupUserArrayOutput values.
// You can construct a concrete instance of `GetGroupUserArrayInput` via:
//
//	GetGroupUserArray{ GetGroupUserArgs{...} }
type GetGroupUserArrayInput interface {
	pulumi.Input

	ToGetGroupUserArrayOutput() GetGroupUserArrayOutput
	ToGetGroupUserArrayOutputWithContext(context.Context) GetGroupUserArrayOutput
}

type GetGroupUserArray []GetGroupUserInput

func (GetGroupUserArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetGroupUser)(nil)).Elem()
}

func (i GetGroupUserArray) ToGetGroupUserArrayOutput() GetGroupUserArrayOutput {
	return i.ToGetGroupUserArrayOutputWithContext(context.Background())
}

func (i GetGroupUserArray) ToGetGroupUserArrayOutputWithContext(ctx context.Context) GetGroupUserArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetGroupUserArrayOutput)
}

type GetGroupUserOutput struct{ *pulumi.OutputState }

func (GetGroupUserOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetGroupUser)(nil)).Elem()
}

func (o GetGroupUserOutput) ToGetGroupUserOutput() GetGroupUserOutput {
	return o
}

func (o GetGroupUserOutput) ToGetGroupUserOutputWithContext(ctx context.Context) GetGroupUserOutput {
	return o
}

func (o GetGroupUserOutput) Administrator() pulumi.BoolOutput {
	return o.ApplyT(func(v GetGroupUser) bool { return v.Administrator }).(pulumi.BoolOutput)
}

func (o GetGroupUserOutput) Email() pulumi.StringOutput {
	return o.ApplyT(func(v GetGroupUser) string { return v.Email }).(pulumi.StringOutput)
}

func (o GetGroupUserOutput) FirstName() pulumi.StringOutput {
	return o.ApplyT(func(v GetGroupUser) string { return v.FirstName }).(pulumi.StringOutput)
}

func (o GetGroupUserOutput) ForceSecAuth() pulumi.BoolOutput {
	return o.ApplyT(func(v GetGroupUser) bool { return v.ForceSecAuth }).(pulumi.BoolOutput)
}

// ID of the group you want to search for.
//
// Either `name` or `id` must be provided. If none, or both are provided, the datasource will return an error.
func (o GetGroupUserOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v GetGroupUser) string { return v.Id }).(pulumi.StringOutput)
}

func (o GetGroupUserOutput) LastName() pulumi.StringOutput {
	return o.ApplyT(func(v GetGroupUser) string { return v.LastName }).(pulumi.StringOutput)
}

type GetGroupUserArrayOutput struct{ *pulumi.OutputState }

func (GetGroupUserArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetGroupUser)(nil)).Elem()
}

func (o GetGroupUserArrayOutput) ToGetGroupUserArrayOutput() GetGroupUserArrayOutput {
	return o
}

func (o GetGroupUserArrayOutput) ToGetGroupUserArrayOutputWithContext(ctx context.Context) GetGroupUserArrayOutput {
	return o
}

func (o GetGroupUserArrayOutput) Index(i pulumi.IntInput) GetGroupUserOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetGroupUser {
		return vs[0].([]GetGroupUser)[vs[1].(int)]
	}).(GetGroupUserOutput)
}

type GetIPBlockIpConsumer struct {
	DatacenterId    string `pulumi:"datacenterId"`
	DatacenterName  string `pulumi:"datacenterName"`
	Ip              string `pulumi:"ip"`
	K8sClusterUuid  string `pulumi:"k8sClusterUuid"`
	K8sNodepoolUuid string `pulumi:"k8sNodepoolUuid"`
	Mac             string `pulumi:"mac"`
	NicId           string `pulumi:"nicId"`
	ServerId        string `pulumi:"serverId"`
	ServerName      string `pulumi:"serverName"`
}

// GetIPBlockIpConsumerInput is an input type that accepts GetIPBlockIpConsumerArgs and GetIPBlockIpConsumerOutput values.
// You can construct a concrete instance of `GetIPBlockIpConsumerInput` via:
//
//	GetIPBlockIpConsumerArgs{...}
type GetIPBlockIpConsumerInput interface {
	pulumi.Input

	ToGetIPBlockIpConsumerOutput() GetIPBlockIpConsumerOutput
	ToGetIPBlockIpConsumerOutputWithContext(context.Context) GetIPBlockIpConsumerOutput
}

type GetIPBlockIpConsumerArgs struct {
	DatacenterId    pulumi.StringInput `pulumi:"datacenterId"`
	DatacenterName  pulumi.StringInput `pulumi:"datacenterName"`
	Ip              pulumi.StringInput `pulumi:"ip"`
	K8sClusterUuid  pulumi.StringInput `pulumi:"k8sClusterUuid"`
	K8sNodepoolUuid pulumi.StringInput `pulumi:"k8sNodepoolUuid"`
	Mac             pulumi.StringInput `pulumi:"mac"`
	NicId           pulumi.StringInput `pulumi:"nicId"`
	ServerId        pulumi.StringInput `pulumi:"serverId"`
	ServerName      pulumi.StringInput `pulumi:"serverName"`
}

func (GetIPBlockIpConsumerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetIPBlockIpConsumer)(nil)).Elem()
}

func (i GetIPBlockIpConsumerArgs) ToGetIPBlockIpConsumerOutput() GetIPBlockIpConsumerOutput {
	return i.ToGetIPBlockIpConsumerOutputWithContext(context.Background())
}

func (i GetIPBlockIpConsumerArgs) ToGetIPBlockIpConsumerOutputWithContext(ctx context.Context) GetIPBlockIpConsumerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetIPBlockIpConsumerOutput)
}

// GetIPBlockIpConsumerArrayInput is an input type that accepts GetIPBlockIpConsumerArray and GetIPBlockIpConsumerArrayOutput values.
// You can construct a concrete instance of `GetIPBlockIpConsumerArrayInput` via:
//
//	GetIPBlockIpConsumerArray{ GetIPBlockIpConsumerArgs{...} }
type GetIPBlockIpConsumerArrayInput interface {
	pulumi.Input

	ToGetIPBlockIpConsumerArrayOutput() GetIPBlockIpConsumerArrayOutput
	ToGetIPBlockIpConsumerArrayOutputWithContext(context.Context) GetIPBlockIpConsumerArrayOutput
}

type GetIPBlockIpConsumerArray []GetIPBlockIpConsumerInput

func (GetIPBlockIpConsumerArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetIPBlockIpConsumer)(nil)).Elem()
}

func (i GetIPBlockIpConsumerArray) ToGetIPBlockIpConsumerArrayOutput() GetIPBlockIpConsumerArrayOutput {
	return i.ToGetIPBlockIpConsumerArrayOutputWithContext(context.Background())
}

func (i GetIPBlockIpConsumerArray) ToGetIPBlockIpConsumerArrayOutputWithContext(ctx context.Context) GetIPBlockIpConsumerArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetIPBlockIpConsumerArrayOutput)
}

type GetIPBlockIpConsumerOutput struct{ *pulumi.OutputState }

func (GetIPBlockIpConsumerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetIPBlockIpConsumer)(nil)).Elem()
}

func (o GetIPBlockIpConsumerOutput) ToGetIPBlockIpConsumerOutput() GetIPBlockIpConsumerOutput {
	return o
}

func (o GetIPBlockIpConsumerOutput) ToGetIPBlockIpConsumerOutputWithContext(ctx context.Context) GetIPBlockIpConsumerOutput {
	return o
}

func (o GetIPBlockIpConsumerOutput) DatacenterId() pulumi.StringOutput {
	return o.ApplyT(func(v GetIPBlockIpConsumer) string { return v.DatacenterId }).(pulumi.StringOutput)
}

func (o GetIPBlockIpConsumerOutput) DatacenterName() pulumi.StringOutput {
	return o.ApplyT(func(v GetIPBlockIpConsumer) string { return v.DatacenterName }).(pulumi.StringOutput)
}

func (o GetIPBlockIpConsumerOutput) Ip() pulumi.StringOutput {
	return o.ApplyT(func(v GetIPBlockIpConsumer) string { return v.Ip }).(pulumi.StringOutput)
}

func (o GetIPBlockIpConsumerOutput) K8sClusterUuid() pulumi.StringOutput {
	return o.ApplyT(func(v GetIPBlockIpConsumer) string { return v.K8sClusterUuid }).(pulumi.StringOutput)
}

func (o GetIPBlockIpConsumerOutput) K8sNodepoolUuid() pulumi.StringOutput {
	return o.ApplyT(func(v GetIPBlockIpConsumer) string { return v.K8sNodepoolUuid }).(pulumi.StringOutput)
}

func (o GetIPBlockIpConsumerOutput) Mac() pulumi.StringOutput {
	return o.ApplyT(func(v GetIPBlockIpConsumer) string { return v.Mac }).(pulumi.StringOutput)
}

func (o GetIPBlockIpConsumerOutput) NicId() pulumi.StringOutput {
	return o.ApplyT(func(v GetIPBlockIpConsumer) string { return v.NicId }).(pulumi.StringOutput)
}

func (o GetIPBlockIpConsumerOutput) ServerId() pulumi.StringOutput {
	return o.ApplyT(func(v GetIPBlockIpConsumer) string { return v.ServerId }).(pulumi.StringOutput)
}

func (o GetIPBlockIpConsumerOutput) ServerName() pulumi.StringOutput {
	return o.ApplyT(func(v GetIPBlockIpConsumer) string { return v.ServerName }).(pulumi.StringOutput)
}

type GetIPBlockIpConsumerArrayOutput struct{ *pulumi.OutputState }

func (GetIPBlockIpConsumerArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetIPBlockIpConsumer)(nil)).Elem()
}

func (o GetIPBlockIpConsumerArrayOutput) ToGetIPBlockIpConsumerArrayOutput() GetIPBlockIpConsumerArrayOutput {
	return o
}

func (o GetIPBlockIpConsumerArrayOutput) ToGetIPBlockIpConsumerArrayOutputWithContext(ctx context.Context) GetIPBlockIpConsumerArrayOutput {
	return o
}

func (o GetIPBlockIpConsumerArrayOutput) Index(i pulumi.IntInput) GetIPBlockIpConsumerOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetIPBlockIpConsumer {
		return vs[0].([]GetIPBlockIpConsumer)[vs[1].(int)]
	}).(GetIPBlockIpConsumerOutput)
}

type GetLanIpFailover struct {
	Ip      string `pulumi:"ip"`
	NicUuid string `pulumi:"nicUuid"`
}

// GetLanIpFailoverInput is an input type that accepts GetLanIpFailoverArgs and GetLanIpFailoverOutput values.
// You can construct a concrete instance of `GetLanIpFailoverInput` via:
//
//	GetLanIpFailoverArgs{...}
type GetLanIpFailoverInput interface {
	pulumi.Input

	ToGetLanIpFailoverOutput() GetLanIpFailoverOutput
	ToGetLanIpFailoverOutputWithContext(context.Context) GetLanIpFailoverOutput
}

type GetLanIpFailoverArgs struct {
	Ip      pulumi.StringInput `pulumi:"ip"`
	NicUuid pulumi.StringInput `pulumi:"nicUuid"`
}

func (GetLanIpFailoverArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetLanIpFailover)(nil)).Elem()
}

func (i GetLanIpFailoverArgs) ToGetLanIpFailoverOutput() GetLanIpFailoverOutput {
	return i.ToGetLanIpFailoverOutputWithContext(context.Background())
}

func (i GetLanIpFailoverArgs) ToGetLanIpFailoverOutputWithContext(ctx context.Context) GetLanIpFailoverOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetLanIpFailoverOutput)
}

// GetLanIpFailoverArrayInput is an input type that accepts GetLanIpFailoverArray and GetLanIpFailoverArrayOutput values.
// You can construct a concrete instance of `GetLanIpFailoverArrayInput` via:
//
//	GetLanIpFailoverArray{ GetLanIpFailoverArgs{...} }
type GetLanIpFailoverArrayInput interface {
	pulumi.Input

	ToGetLanIpFailoverArrayOutput() GetLanIpFailoverArrayOutput
	ToGetLanIpFailoverArrayOutputWithContext(context.Context) GetLanIpFailoverArrayOutput
}

type GetLanIpFailoverArray []GetLanIpFailoverInput

func (GetLanIpFailoverArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetLanIpFailover)(nil)).Elem()
}

func (i GetLanIpFailoverArray) ToGetLanIpFailoverArrayOutput() GetLanIpFailoverArrayOutput {
	return i.ToGetLanIpFailoverArrayOutputWithContext(context.Background())
}

func (i GetLanIpFailoverArray) ToGetLanIpFailoverArrayOutputWithContext(ctx context.Context) GetLanIpFailoverArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetLanIpFailoverArrayOutput)
}

type GetLanIpFailoverOutput struct{ *pulumi.OutputState }

func (GetLanIpFailoverOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetLanIpFailover)(nil)).Elem()
}

func (o GetLanIpFailoverOutput) ToGetLanIpFailoverOutput() GetLanIpFailoverOutput {
	return o
}

func (o GetLanIpFailoverOutput) ToGetLanIpFailoverOutputWithContext(ctx context.Context) GetLanIpFailoverOutput {
	return o
}

func (o GetLanIpFailoverOutput) Ip() pulumi.StringOutput {
	return o.ApplyT(func(v GetLanIpFailover) string { return v.Ip }).(pulumi.StringOutput)
}

func (o GetLanIpFailoverOutput) NicUuid() pulumi.StringOutput {
	return o.ApplyT(func(v GetLanIpFailover) string { return v.NicUuid }).(pulumi.StringOutput)
}

type GetLanIpFailoverArrayOutput struct{ *pulumi.OutputState }

func (GetLanIpFailoverArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetLanIpFailover)(nil)).Elem()
}

func (o GetLanIpFailoverArrayOutput) ToGetLanIpFailoverArrayOutput() GetLanIpFailoverArrayOutput {
	return o
}

func (o GetLanIpFailoverArrayOutput) ToGetLanIpFailoverArrayOutputWithContext(ctx context.Context) GetLanIpFailoverArrayOutput {
	return o
}

func (o GetLanIpFailoverArrayOutput) Index(i pulumi.IntInput) GetLanIpFailoverOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetLanIpFailover {
		return vs[0].([]GetLanIpFailover)[vs[1].(int)]
	}).(GetLanIpFailoverOutput)
}

type GetNatGatewayLan struct {
	// Collection of gateway IP addresses of the NAT gateway. Will be auto-generated if not provided. Should ideally be an IP belonging to the same subnet as the LAN
	GatewayIps []string `pulumi:"gatewayIps"`
	// ID of the network load balancer forwarding rule you want to search for.
	//
	// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
	Id int `pulumi:"id"`
}

// GetNatGatewayLanInput is an input type that accepts GetNatGatewayLanArgs and GetNatGatewayLanOutput values.
// You can construct a concrete instance of `GetNatGatewayLanInput` via:
//
//	GetNatGatewayLanArgs{...}
type GetNatGatewayLanInput interface {
	pulumi.Input

	ToGetNatGatewayLanOutput() GetNatGatewayLanOutput
	ToGetNatGatewayLanOutputWithContext(context.Context) GetNatGatewayLanOutput
}

type GetNatGatewayLanArgs struct {
	// Collection of gateway IP addresses of the NAT gateway. Will be auto-generated if not provided. Should ideally be an IP belonging to the same subnet as the LAN
	GatewayIps pulumi.StringArrayInput `pulumi:"gatewayIps"`
	// ID of the network load balancer forwarding rule you want to search for.
	//
	// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
	Id pulumi.IntInput `pulumi:"id"`
}

func (GetNatGatewayLanArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetNatGatewayLan)(nil)).Elem()
}

func (i GetNatGatewayLanArgs) ToGetNatGatewayLanOutput() GetNatGatewayLanOutput {
	return i.ToGetNatGatewayLanOutputWithContext(context.Background())
}

func (i GetNatGatewayLanArgs) ToGetNatGatewayLanOutputWithContext(ctx context.Context) GetNatGatewayLanOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetNatGatewayLanOutput)
}

// GetNatGatewayLanArrayInput is an input type that accepts GetNatGatewayLanArray and GetNatGatewayLanArrayOutput values.
// You can construct a concrete instance of `GetNatGatewayLanArrayInput` via:
//
//	GetNatGatewayLanArray{ GetNatGatewayLanArgs{...} }
type GetNatGatewayLanArrayInput interface {
	pulumi.Input

	ToGetNatGatewayLanArrayOutput() GetNatGatewayLanArrayOutput
	ToGetNatGatewayLanArrayOutputWithContext(context.Context) GetNatGatewayLanArrayOutput
}

type GetNatGatewayLanArray []GetNatGatewayLanInput

func (GetNatGatewayLanArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetNatGatewayLan)(nil)).Elem()
}

func (i GetNatGatewayLanArray) ToGetNatGatewayLanArrayOutput() GetNatGatewayLanArrayOutput {
	return i.ToGetNatGatewayLanArrayOutputWithContext(context.Background())
}

func (i GetNatGatewayLanArray) ToGetNatGatewayLanArrayOutputWithContext(ctx context.Context) GetNatGatewayLanArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetNatGatewayLanArrayOutput)
}

type GetNatGatewayLanOutput struct{ *pulumi.OutputState }

func (GetNatGatewayLanOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetNatGatewayLan)(nil)).Elem()
}

func (o GetNatGatewayLanOutput) ToGetNatGatewayLanOutput() GetNatGatewayLanOutput {
	return o
}

func (o GetNatGatewayLanOutput) ToGetNatGatewayLanOutputWithContext(ctx context.Context) GetNatGatewayLanOutput {
	return o
}

// Collection of gateway IP addresses of the NAT gateway. Will be auto-generated if not provided. Should ideally be an IP belonging to the same subnet as the LAN
func (o GetNatGatewayLanOutput) GatewayIps() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetNatGatewayLan) []string { return v.GatewayIps }).(pulumi.StringArrayOutput)
}

// ID of the network load balancer forwarding rule you want to search for.
//
// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
func (o GetNatGatewayLanOutput) Id() pulumi.IntOutput {
	return o.ApplyT(func(v GetNatGatewayLan) int { return v.Id }).(pulumi.IntOutput)
}

type GetNatGatewayLanArrayOutput struct{ *pulumi.OutputState }

func (GetNatGatewayLanArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetNatGatewayLan)(nil)).Elem()
}

func (o GetNatGatewayLanArrayOutput) ToGetNatGatewayLanArrayOutput() GetNatGatewayLanArrayOutput {
	return o
}

func (o GetNatGatewayLanArrayOutput) ToGetNatGatewayLanArrayOutputWithContext(ctx context.Context) GetNatGatewayLanArrayOutput {
	return o
}

func (o GetNatGatewayLanArrayOutput) Index(i pulumi.IntInput) GetNatGatewayLanOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetNatGatewayLan {
		return vs[0].([]GetNatGatewayLan)[vs[1].(int)]
	}).(GetNatGatewayLanOutput)
}

type GetNatGatewayRuleTargetPortRange struct {
	// Target port range end associated with the NAT gateway rule.
	End int `pulumi:"end"`
	// Target port range start associated with the NAT gateway rule.
	Start int `pulumi:"start"`
}

// GetNatGatewayRuleTargetPortRangeInput is an input type that accepts GetNatGatewayRuleTargetPortRangeArgs and GetNatGatewayRuleTargetPortRangeOutput values.
// You can construct a concrete instance of `GetNatGatewayRuleTargetPortRangeInput` via:
//
//	GetNatGatewayRuleTargetPortRangeArgs{...}
type GetNatGatewayRuleTargetPortRangeInput interface {
	pulumi.Input

	ToGetNatGatewayRuleTargetPortRangeOutput() GetNatGatewayRuleTargetPortRangeOutput
	ToGetNatGatewayRuleTargetPortRangeOutputWithContext(context.Context) GetNatGatewayRuleTargetPortRangeOutput
}

type GetNatGatewayRuleTargetPortRangeArgs struct {
	// Target port range end associated with the NAT gateway rule.
	End pulumi.IntInput `pulumi:"end"`
	// Target port range start associated with the NAT gateway rule.
	Start pulumi.IntInput `pulumi:"start"`
}

func (GetNatGatewayRuleTargetPortRangeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetNatGatewayRuleTargetPortRange)(nil)).Elem()
}

func (i GetNatGatewayRuleTargetPortRangeArgs) ToGetNatGatewayRuleTargetPortRangeOutput() GetNatGatewayRuleTargetPortRangeOutput {
	return i.ToGetNatGatewayRuleTargetPortRangeOutputWithContext(context.Background())
}

func (i GetNatGatewayRuleTargetPortRangeArgs) ToGetNatGatewayRuleTargetPortRangeOutputWithContext(ctx context.Context) GetNatGatewayRuleTargetPortRangeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetNatGatewayRuleTargetPortRangeOutput)
}

// GetNatGatewayRuleTargetPortRangeArrayInput is an input type that accepts GetNatGatewayRuleTargetPortRangeArray and GetNatGatewayRuleTargetPortRangeArrayOutput values.
// You can construct a concrete instance of `GetNatGatewayRuleTargetPortRangeArrayInput` via:
//
//	GetNatGatewayRuleTargetPortRangeArray{ GetNatGatewayRuleTargetPortRangeArgs{...} }
type GetNatGatewayRuleTargetPortRangeArrayInput interface {
	pulumi.Input

	ToGetNatGatewayRuleTargetPortRangeArrayOutput() GetNatGatewayRuleTargetPortRangeArrayOutput
	ToGetNatGatewayRuleTargetPortRangeArrayOutputWithContext(context.Context) GetNatGatewayRuleTargetPortRangeArrayOutput
}

type GetNatGatewayRuleTargetPortRangeArray []GetNatGatewayRuleTargetPortRangeInput

func (GetNatGatewayRuleTargetPortRangeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetNatGatewayRuleTargetPortRange)(nil)).Elem()
}

func (i GetNatGatewayRuleTargetPortRangeArray) ToGetNatGatewayRuleTargetPortRangeArrayOutput() GetNatGatewayRuleTargetPortRangeArrayOutput {
	return i.ToGetNatGatewayRuleTargetPortRangeArrayOutputWithContext(context.Background())
}

func (i GetNatGatewayRuleTargetPortRangeArray) ToGetNatGatewayRuleTargetPortRangeArrayOutputWithContext(ctx context.Context) GetNatGatewayRuleTargetPortRangeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetNatGatewayRuleTargetPortRangeArrayOutput)
}

type GetNatGatewayRuleTargetPortRangeOutput struct{ *pulumi.OutputState }

func (GetNatGatewayRuleTargetPortRangeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetNatGatewayRuleTargetPortRange)(nil)).Elem()
}

func (o GetNatGatewayRuleTargetPortRangeOutput) ToGetNatGatewayRuleTargetPortRangeOutput() GetNatGatewayRuleTargetPortRangeOutput {
	return o
}

func (o GetNatGatewayRuleTargetPortRangeOutput) ToGetNatGatewayRuleTargetPortRangeOutputWithContext(ctx context.Context) GetNatGatewayRuleTargetPortRangeOutput {
	return o
}

// Target port range end associated with the NAT gateway rule.
func (o GetNatGatewayRuleTargetPortRangeOutput) End() pulumi.IntOutput {
	return o.ApplyT(func(v GetNatGatewayRuleTargetPortRange) int { return v.End }).(pulumi.IntOutput)
}

// Target port range start associated with the NAT gateway rule.
func (o GetNatGatewayRuleTargetPortRangeOutput) Start() pulumi.IntOutput {
	return o.ApplyT(func(v GetNatGatewayRuleTargetPortRange) int { return v.Start }).(pulumi.IntOutput)
}

type GetNatGatewayRuleTargetPortRangeArrayOutput struct{ *pulumi.OutputState }

func (GetNatGatewayRuleTargetPortRangeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetNatGatewayRuleTargetPortRange)(nil)).Elem()
}

func (o GetNatGatewayRuleTargetPortRangeArrayOutput) ToGetNatGatewayRuleTargetPortRangeArrayOutput() GetNatGatewayRuleTargetPortRangeArrayOutput {
	return o
}

func (o GetNatGatewayRuleTargetPortRangeArrayOutput) ToGetNatGatewayRuleTargetPortRangeArrayOutputWithContext(ctx context.Context) GetNatGatewayRuleTargetPortRangeArrayOutput {
	return o
}

func (o GetNatGatewayRuleTargetPortRangeArrayOutput) Index(i pulumi.IntInput) GetNatGatewayRuleTargetPortRangeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetNatGatewayRuleTargetPortRange {
		return vs[0].([]GetNatGatewayRuleTargetPortRange)[vs[1].(int)]
	}).(GetNatGatewayRuleTargetPortRangeOutput)
}

type GetNicFlowlog struct {
	// Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL.
	Action string `pulumi:"action"`
	// Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist.
	Bucket string `pulumi:"bucket"`
	// Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL.
	Direction string `pulumi:"direction"`
	// ID of the nic you want to search for.
	//
	// `datacenterId` and either `name` or `id` must be provided.
	// If none, are provided, the datasource will return an error.
	Id string `pulumi:"id"`
	// [string] The name of the LAN.
	Name string `pulumi:"name"`
}

// GetNicFlowlogInput is an input type that accepts GetNicFlowlogArgs and GetNicFlowlogOutput values.
// You can construct a concrete instance of `GetNicFlowlogInput` via:
//
//	GetNicFlowlogArgs{...}
type GetNicFlowlogInput interface {
	pulumi.Input

	ToGetNicFlowlogOutput() GetNicFlowlogOutput
	ToGetNicFlowlogOutputWithContext(context.Context) GetNicFlowlogOutput
}

type GetNicFlowlogArgs struct {
	// Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL.
	Action pulumi.StringInput `pulumi:"action"`
	// Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist.
	Bucket pulumi.StringInput `pulumi:"bucket"`
	// Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL.
	Direction pulumi.StringInput `pulumi:"direction"`
	// ID of the nic you want to search for.
	//
	// `datacenterId` and either `name` or `id` must be provided.
	// If none, are provided, the datasource will return an error.
	Id pulumi.StringInput `pulumi:"id"`
	// [string] The name of the LAN.
	Name pulumi.StringInput `pulumi:"name"`
}

func (GetNicFlowlogArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetNicFlowlog)(nil)).Elem()
}

func (i GetNicFlowlogArgs) ToGetNicFlowlogOutput() GetNicFlowlogOutput {
	return i.ToGetNicFlowlogOutputWithContext(context.Background())
}

func (i GetNicFlowlogArgs) ToGetNicFlowlogOutputWithContext(ctx context.Context) GetNicFlowlogOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetNicFlowlogOutput)
}

// GetNicFlowlogArrayInput is an input type that accepts GetNicFlowlogArray and GetNicFlowlogArrayOutput values.
// You can construct a concrete instance of `GetNicFlowlogArrayInput` via:
//
//	GetNicFlowlogArray{ GetNicFlowlogArgs{...} }
type GetNicFlowlogArrayInput interface {
	pulumi.Input

	ToGetNicFlowlogArrayOutput() GetNicFlowlogArrayOutput
	ToGetNicFlowlogArrayOutputWithContext(context.Context) GetNicFlowlogArrayOutput
}

type GetNicFlowlogArray []GetNicFlowlogInput

func (GetNicFlowlogArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetNicFlowlog)(nil)).Elem()
}

func (i GetNicFlowlogArray) ToGetNicFlowlogArrayOutput() GetNicFlowlogArrayOutput {
	return i.ToGetNicFlowlogArrayOutputWithContext(context.Background())
}

func (i GetNicFlowlogArray) ToGetNicFlowlogArrayOutputWithContext(ctx context.Context) GetNicFlowlogArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetNicFlowlogArrayOutput)
}

type GetNicFlowlogOutput struct{ *pulumi.OutputState }

func (GetNicFlowlogOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetNicFlowlog)(nil)).Elem()
}

func (o GetNicFlowlogOutput) ToGetNicFlowlogOutput() GetNicFlowlogOutput {
	return o
}

func (o GetNicFlowlogOutput) ToGetNicFlowlogOutputWithContext(ctx context.Context) GetNicFlowlogOutput {
	return o
}

// Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL.
func (o GetNicFlowlogOutput) Action() pulumi.StringOutput {
	return o.ApplyT(func(v GetNicFlowlog) string { return v.Action }).(pulumi.StringOutput)
}

// Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist.
func (o GetNicFlowlogOutput) Bucket() pulumi.StringOutput {
	return o.ApplyT(func(v GetNicFlowlog) string { return v.Bucket }).(pulumi.StringOutput)
}

// Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL.
func (o GetNicFlowlogOutput) Direction() pulumi.StringOutput {
	return o.ApplyT(func(v GetNicFlowlog) string { return v.Direction }).(pulumi.StringOutput)
}

// ID of the nic you want to search for.
//
// `datacenterId` and either `name` or `id` must be provided.
// If none, are provided, the datasource will return an error.
func (o GetNicFlowlogOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v GetNicFlowlog) string { return v.Id }).(pulumi.StringOutput)
}

// [string] The name of the LAN.
func (o GetNicFlowlogOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GetNicFlowlog) string { return v.Name }).(pulumi.StringOutput)
}

type GetNicFlowlogArrayOutput struct{ *pulumi.OutputState }

func (GetNicFlowlogArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetNicFlowlog)(nil)).Elem()
}

func (o GetNicFlowlogArrayOutput) ToGetNicFlowlogArrayOutput() GetNicFlowlogArrayOutput {
	return o
}

func (o GetNicFlowlogArrayOutput) ToGetNicFlowlogArrayOutputWithContext(ctx context.Context) GetNicFlowlogArrayOutput {
	return o
}

func (o GetNicFlowlogArrayOutput) Index(i pulumi.IntInput) GetNicFlowlogOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetNicFlowlog {
		return vs[0].([]GetNicFlowlog)[vs[1].(int)]
	}).(GetNicFlowlogOutput)
}

type GetServerCdrom struct {
	// Cloud init compatibility
	CloudInit string `pulumi:"cloudInit"`
	// Is capable of CPU hot plug (no reboot required)
	CpuHotPlug bool `pulumi:"cpuHotPlug"`
	// Is capable of CPU hot unplug (no reboot required)
	CpuHotUnplug bool `pulumi:"cpuHotUnplug"`
	// Description of cdrom
	Description string `pulumi:"description"`
	// Is capable of SCSI drive hot plug (no reboot required)
	DiscScsiHotPlug bool `pulumi:"discScsiHotPlug"`
	// Is capable of SCSI drive hot unplug (no reboot required)
	DiscScsiHotUnplug bool `pulumi:"discScsiHotUnplug"`
	// Is capable of Virt-IO drive hot plug (no reboot required)
	DiscVirtioHotPlug bool `pulumi:"discVirtioHotPlug"`
	// Is capable of Virt-IO drive hot unplug (no reboot required)
	DiscVirtioHotUnplug bool `pulumi:"discVirtioHotUnplug"`
	// ID of the server you want to search for.
	//
	// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
	Id string `pulumi:"id"`
	// List of image aliases mapped for this Image
	ImageAliases []string `pulumi:"imageAliases"`
	// Type of image
	ImageType string `pulumi:"imageType"`
	// OS type of this volume
	LicenceType string `pulumi:"licenceType"`
	// Location of that image/snapshot
	Location string `pulumi:"location"`
	// Name of an existing server that you want to search for.
	Name string `pulumi:"name"`
	// Is capable of nic hot plug (no reboot required)
	NicHotPlug bool `pulumi:"nicHotPlug"`
	// Is capable of nic hot unplug (no reboot required)
	NicHotUnplug bool `pulumi:"nicHotUnplug"`
	// Indicates if the image is part of the public repository or not
	Public bool `pulumi:"public"`
	// Is capable of memory hot plug (no reboot required)
	RamHotPlug bool `pulumi:"ramHotPlug"`
	// Is capable of memory hot unplug (no reboot required)
	RamHotUnplug bool `pulumi:"ramHotUnplug"`
	// The size of the volume in GB
	Size float64 `pulumi:"size"`
}

// GetServerCdromInput is an input type that accepts GetServerCdromArgs and GetServerCdromOutput values.
// You can construct a concrete instance of `GetServerCdromInput` via:
//
//	GetServerCdromArgs{...}
type GetServerCdromInput interface {
	pulumi.Input

	ToGetServerCdromOutput() GetServerCdromOutput
	ToGetServerCdromOutputWithContext(context.Context) GetServerCdromOutput
}

type GetServerCdromArgs struct {
	// Cloud init compatibility
	CloudInit pulumi.StringInput `pulumi:"cloudInit"`
	// Is capable of CPU hot plug (no reboot required)
	CpuHotPlug pulumi.BoolInput `pulumi:"cpuHotPlug"`
	// Is capable of CPU hot unplug (no reboot required)
	CpuHotUnplug pulumi.BoolInput `pulumi:"cpuHotUnplug"`
	// Description of cdrom
	Description pulumi.StringInput `pulumi:"description"`
	// Is capable of SCSI drive hot plug (no reboot required)
	DiscScsiHotPlug pulumi.BoolInput `pulumi:"discScsiHotPlug"`
	// Is capable of SCSI drive hot unplug (no reboot required)
	DiscScsiHotUnplug pulumi.BoolInput `pulumi:"discScsiHotUnplug"`
	// Is capable of Virt-IO drive hot plug (no reboot required)
	DiscVirtioHotPlug pulumi.BoolInput `pulumi:"discVirtioHotPlug"`
	// Is capable of Virt-IO drive hot unplug (no reboot required)
	DiscVirtioHotUnplug pulumi.BoolInput `pulumi:"discVirtioHotUnplug"`
	// ID of the server you want to search for.
	//
	// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
	Id pulumi.StringInput `pulumi:"id"`
	// List of image aliases mapped for this Image
	ImageAliases pulumi.StringArrayInput `pulumi:"imageAliases"`
	// Type of image
	ImageType pulumi.StringInput `pulumi:"imageType"`
	// OS type of this volume
	LicenceType pulumi.StringInput `pulumi:"licenceType"`
	// Location of that image/snapshot
	Location pulumi.StringInput `pulumi:"location"`
	// Name of an existing server that you want to search for.
	Name pulumi.StringInput `pulumi:"name"`
	// Is capable of nic hot plug (no reboot required)
	NicHotPlug pulumi.BoolInput `pulumi:"nicHotPlug"`
	// Is capable of nic hot unplug (no reboot required)
	NicHotUnplug pulumi.BoolInput `pulumi:"nicHotUnplug"`
	// Indicates if the image is part of the public repository or not
	Public pulumi.BoolInput `pulumi:"public"`
	// Is capable of memory hot plug (no reboot required)
	RamHotPlug pulumi.BoolInput `pulumi:"ramHotPlug"`
	// Is capable of memory hot unplug (no reboot required)
	RamHotUnplug pulumi.BoolInput `pulumi:"ramHotUnplug"`
	// The size of the volume in GB
	Size pulumi.Float64Input `pulumi:"size"`
}

func (GetServerCdromArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetServerCdrom)(nil)).Elem()
}

func (i GetServerCdromArgs) ToGetServerCdromOutput() GetServerCdromOutput {
	return i.ToGetServerCdromOutputWithContext(context.Background())
}

func (i GetServerCdromArgs) ToGetServerCdromOutputWithContext(ctx context.Context) GetServerCdromOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetServerCdromOutput)
}

// GetServerCdromArrayInput is an input type that accepts GetServerCdromArray and GetServerCdromArrayOutput values.
// You can construct a concrete instance of `GetServerCdromArrayInput` via:
//
//	GetServerCdromArray{ GetServerCdromArgs{...} }
type GetServerCdromArrayInput interface {
	pulumi.Input

	ToGetServerCdromArrayOutput() GetServerCdromArrayOutput
	ToGetServerCdromArrayOutputWithContext(context.Context) GetServerCdromArrayOutput
}

type GetServerCdromArray []GetServerCdromInput

func (GetServerCdromArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetServerCdrom)(nil)).Elem()
}

func (i GetServerCdromArray) ToGetServerCdromArrayOutput() GetServerCdromArrayOutput {
	return i.ToGetServerCdromArrayOutputWithContext(context.Background())
}

func (i GetServerCdromArray) ToGetServerCdromArrayOutputWithContext(ctx context.Context) GetServerCdromArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetServerCdromArrayOutput)
}

type GetServerCdromOutput struct{ *pulumi.OutputState }

func (GetServerCdromOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetServerCdrom)(nil)).Elem()
}

func (o GetServerCdromOutput) ToGetServerCdromOutput() GetServerCdromOutput {
	return o
}

func (o GetServerCdromOutput) ToGetServerCdromOutputWithContext(ctx context.Context) GetServerCdromOutput {
	return o
}

// Cloud init compatibility
func (o GetServerCdromOutput) CloudInit() pulumi.StringOutput {
	return o.ApplyT(func(v GetServerCdrom) string { return v.CloudInit }).(pulumi.StringOutput)
}

// Is capable of CPU hot plug (no reboot required)
func (o GetServerCdromOutput) CpuHotPlug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetServerCdrom) bool { return v.CpuHotPlug }).(pulumi.BoolOutput)
}

// Is capable of CPU hot unplug (no reboot required)
func (o GetServerCdromOutput) CpuHotUnplug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetServerCdrom) bool { return v.CpuHotUnplug }).(pulumi.BoolOutput)
}

// Description of cdrom
func (o GetServerCdromOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v GetServerCdrom) string { return v.Description }).(pulumi.StringOutput)
}

// Is capable of SCSI drive hot plug (no reboot required)
func (o GetServerCdromOutput) DiscScsiHotPlug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetServerCdrom) bool { return v.DiscScsiHotPlug }).(pulumi.BoolOutput)
}

// Is capable of SCSI drive hot unplug (no reboot required)
func (o GetServerCdromOutput) DiscScsiHotUnplug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetServerCdrom) bool { return v.DiscScsiHotUnplug }).(pulumi.BoolOutput)
}

// Is capable of Virt-IO drive hot plug (no reboot required)
func (o GetServerCdromOutput) DiscVirtioHotPlug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetServerCdrom) bool { return v.DiscVirtioHotPlug }).(pulumi.BoolOutput)
}

// Is capable of Virt-IO drive hot unplug (no reboot required)
func (o GetServerCdromOutput) DiscVirtioHotUnplug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetServerCdrom) bool { return v.DiscVirtioHotUnplug }).(pulumi.BoolOutput)
}

// ID of the server you want to search for.
//
// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
func (o GetServerCdromOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v GetServerCdrom) string { return v.Id }).(pulumi.StringOutput)
}

// List of image aliases mapped for this Image
func (o GetServerCdromOutput) ImageAliases() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetServerCdrom) []string { return v.ImageAliases }).(pulumi.StringArrayOutput)
}

// Type of image
func (o GetServerCdromOutput) ImageType() pulumi.StringOutput {
	return o.ApplyT(func(v GetServerCdrom) string { return v.ImageType }).(pulumi.StringOutput)
}

// OS type of this volume
func (o GetServerCdromOutput) LicenceType() pulumi.StringOutput {
	return o.ApplyT(func(v GetServerCdrom) string { return v.LicenceType }).(pulumi.StringOutput)
}

// Location of that image/snapshot
func (o GetServerCdromOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v GetServerCdrom) string { return v.Location }).(pulumi.StringOutput)
}

// Name of an existing server that you want to search for.
func (o GetServerCdromOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GetServerCdrom) string { return v.Name }).(pulumi.StringOutput)
}

// Is capable of nic hot plug (no reboot required)
func (o GetServerCdromOutput) NicHotPlug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetServerCdrom) bool { return v.NicHotPlug }).(pulumi.BoolOutput)
}

// Is capable of nic hot unplug (no reboot required)
func (o GetServerCdromOutput) NicHotUnplug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetServerCdrom) bool { return v.NicHotUnplug }).(pulumi.BoolOutput)
}

// Indicates if the image is part of the public repository or not
func (o GetServerCdromOutput) Public() pulumi.BoolOutput {
	return o.ApplyT(func(v GetServerCdrom) bool { return v.Public }).(pulumi.BoolOutput)
}

// Is capable of memory hot plug (no reboot required)
func (o GetServerCdromOutput) RamHotPlug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetServerCdrom) bool { return v.RamHotPlug }).(pulumi.BoolOutput)
}

// Is capable of memory hot unplug (no reboot required)
func (o GetServerCdromOutput) RamHotUnplug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetServerCdrom) bool { return v.RamHotUnplug }).(pulumi.BoolOutput)
}

// The size of the volume in GB
func (o GetServerCdromOutput) Size() pulumi.Float64Output {
	return o.ApplyT(func(v GetServerCdrom) float64 { return v.Size }).(pulumi.Float64Output)
}

type GetServerCdromArrayOutput struct{ *pulumi.OutputState }

func (GetServerCdromArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetServerCdrom)(nil)).Elem()
}

func (o GetServerCdromArrayOutput) ToGetServerCdromArrayOutput() GetServerCdromArrayOutput {
	return o
}

func (o GetServerCdromArrayOutput) ToGetServerCdromArrayOutputWithContext(ctx context.Context) GetServerCdromArrayOutput {
	return o
}

func (o GetServerCdromArrayOutput) Index(i pulumi.IntInput) GetServerCdromOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetServerCdrom {
		return vs[0].([]GetServerCdrom)[vs[1].(int)]
	}).(GetServerCdromOutput)
}

type GetServerLabel struct {
	// ID of the server you want to search for.
	//
	// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
	Id string `pulumi:"id"`
	// The key of the label
	Key string `pulumi:"key"`
	// The value of the label
	Value string `pulumi:"value"`
}

// GetServerLabelInput is an input type that accepts GetServerLabelArgs and GetServerLabelOutput values.
// You can construct a concrete instance of `GetServerLabelInput` via:
//
//	GetServerLabelArgs{...}
type GetServerLabelInput interface {
	pulumi.Input

	ToGetServerLabelOutput() GetServerLabelOutput
	ToGetServerLabelOutputWithContext(context.Context) GetServerLabelOutput
}

type GetServerLabelArgs struct {
	// ID of the server you want to search for.
	//
	// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
	Id pulumi.StringInput `pulumi:"id"`
	// The key of the label
	Key pulumi.StringInput `pulumi:"key"`
	// The value of the label
	Value pulumi.StringInput `pulumi:"value"`
}

func (GetServerLabelArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetServerLabel)(nil)).Elem()
}

func (i GetServerLabelArgs) ToGetServerLabelOutput() GetServerLabelOutput {
	return i.ToGetServerLabelOutputWithContext(context.Background())
}

func (i GetServerLabelArgs) ToGetServerLabelOutputWithContext(ctx context.Context) GetServerLabelOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetServerLabelOutput)
}

// GetServerLabelArrayInput is an input type that accepts GetServerLabelArray and GetServerLabelArrayOutput values.
// You can construct a concrete instance of `GetServerLabelArrayInput` via:
//
//	GetServerLabelArray{ GetServerLabelArgs{...} }
type GetServerLabelArrayInput interface {
	pulumi.Input

	ToGetServerLabelArrayOutput() GetServerLabelArrayOutput
	ToGetServerLabelArrayOutputWithContext(context.Context) GetServerLabelArrayOutput
}

type GetServerLabelArray []GetServerLabelInput

func (GetServerLabelArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetServerLabel)(nil)).Elem()
}

func (i GetServerLabelArray) ToGetServerLabelArrayOutput() GetServerLabelArrayOutput {
	return i.ToGetServerLabelArrayOutputWithContext(context.Background())
}

func (i GetServerLabelArray) ToGetServerLabelArrayOutputWithContext(ctx context.Context) GetServerLabelArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetServerLabelArrayOutput)
}

type GetServerLabelOutput struct{ *pulumi.OutputState }

func (GetServerLabelOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetServerLabel)(nil)).Elem()
}

func (o GetServerLabelOutput) ToGetServerLabelOutput() GetServerLabelOutput {
	return o
}

func (o GetServerLabelOutput) ToGetServerLabelOutputWithContext(ctx context.Context) GetServerLabelOutput {
	return o
}

// ID of the server you want to search for.
//
// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
func (o GetServerLabelOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v GetServerLabel) string { return v.Id }).(pulumi.StringOutput)
}

// The key of the label
func (o GetServerLabelOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v GetServerLabel) string { return v.Key }).(pulumi.StringOutput)
}

// The value of the label
func (o GetServerLabelOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v GetServerLabel) string { return v.Value }).(pulumi.StringOutput)
}

type GetServerLabelArrayOutput struct{ *pulumi.OutputState }

func (GetServerLabelArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetServerLabel)(nil)).Elem()
}

func (o GetServerLabelArrayOutput) ToGetServerLabelArrayOutput() GetServerLabelArrayOutput {
	return o
}

func (o GetServerLabelArrayOutput) ToGetServerLabelArrayOutputWithContext(ctx context.Context) GetServerLabelArrayOutput {
	return o
}

func (o GetServerLabelArrayOutput) Index(i pulumi.IntInput) GetServerLabelOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetServerLabel {
		return vs[0].([]GetServerLabel)[vs[1].(int)]
	}).(GetServerLabelOutput)
}

type GetServerNic struct {
	// The Logical Unit Number (LUN) of the storage volume
	DeviceNumber int `pulumi:"deviceNumber"`
	// Indicates if the nic will reserve an IP using DHCP
	Dhcp   bool  `pulumi:"dhcp"`
	Dhcpv6 *bool `pulumi:"dhcpv6"`
	// Activate or deactivate the firewall
	FirewallActive bool `pulumi:"firewallActive"`
	// list of
	FirewallRules []GetServerNicFirewallRule `pulumi:"firewallRules"`
	// The type of firewall rules that will be allowed on the NIC
	FirewallType string `pulumi:"firewallType"`
	// ID of the server you want to search for.
	//
	// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
	Id string `pulumi:"id"`
	// Collection of IP addresses assigned to a nic
	Ips           []string `pulumi:"ips"`
	Ipv6CidrBlock string   `pulumi:"ipv6CidrBlock"`
	Ipv6Ips       []string `pulumi:"ipv6Ips"`
	// The LAN ID the NIC will sit on
	Lan int `pulumi:"lan"`
	// The MAC address of the NIC
	Mac string `pulumi:"mac"`
	// Name of an existing server that you want to search for.
	Name string `pulumi:"name"`
	// The PCI slot number of the Nic
	PciSlot int `pulumi:"pciSlot"`
}

// GetServerNicInput is an input type that accepts GetServerNicArgs and GetServerNicOutput values.
// You can construct a concrete instance of `GetServerNicInput` via:
//
//	GetServerNicArgs{...}
type GetServerNicInput interface {
	pulumi.Input

	ToGetServerNicOutput() GetServerNicOutput
	ToGetServerNicOutputWithContext(context.Context) GetServerNicOutput
}

type GetServerNicArgs struct {
	// The Logical Unit Number (LUN) of the storage volume
	DeviceNumber pulumi.IntInput `pulumi:"deviceNumber"`
	// Indicates if the nic will reserve an IP using DHCP
	Dhcp   pulumi.BoolInput    `pulumi:"dhcp"`
	Dhcpv6 pulumi.BoolPtrInput `pulumi:"dhcpv6"`
	// Activate or deactivate the firewall
	FirewallActive pulumi.BoolInput `pulumi:"firewallActive"`
	// list of
	FirewallRules GetServerNicFirewallRuleArrayInput `pulumi:"firewallRules"`
	// The type of firewall rules that will be allowed on the NIC
	FirewallType pulumi.StringInput `pulumi:"firewallType"`
	// ID of the server you want to search for.
	//
	// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
	Id pulumi.StringInput `pulumi:"id"`
	// Collection of IP addresses assigned to a nic
	Ips           pulumi.StringArrayInput `pulumi:"ips"`
	Ipv6CidrBlock pulumi.StringInput      `pulumi:"ipv6CidrBlock"`
	Ipv6Ips       pulumi.StringArrayInput `pulumi:"ipv6Ips"`
	// The LAN ID the NIC will sit on
	Lan pulumi.IntInput `pulumi:"lan"`
	// The MAC address of the NIC
	Mac pulumi.StringInput `pulumi:"mac"`
	// Name of an existing server that you want to search for.
	Name pulumi.StringInput `pulumi:"name"`
	// The PCI slot number of the Nic
	PciSlot pulumi.IntInput `pulumi:"pciSlot"`
}

func (GetServerNicArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetServerNic)(nil)).Elem()
}

func (i GetServerNicArgs) ToGetServerNicOutput() GetServerNicOutput {
	return i.ToGetServerNicOutputWithContext(context.Background())
}

func (i GetServerNicArgs) ToGetServerNicOutputWithContext(ctx context.Context) GetServerNicOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetServerNicOutput)
}

// GetServerNicArrayInput is an input type that accepts GetServerNicArray and GetServerNicArrayOutput values.
// You can construct a concrete instance of `GetServerNicArrayInput` via:
//
//	GetServerNicArray{ GetServerNicArgs{...} }
type GetServerNicArrayInput interface {
	pulumi.Input

	ToGetServerNicArrayOutput() GetServerNicArrayOutput
	ToGetServerNicArrayOutputWithContext(context.Context) GetServerNicArrayOutput
}

type GetServerNicArray []GetServerNicInput

func (GetServerNicArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetServerNic)(nil)).Elem()
}

func (i GetServerNicArray) ToGetServerNicArrayOutput() GetServerNicArrayOutput {
	return i.ToGetServerNicArrayOutputWithContext(context.Background())
}

func (i GetServerNicArray) ToGetServerNicArrayOutputWithContext(ctx context.Context) GetServerNicArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetServerNicArrayOutput)
}

type GetServerNicOutput struct{ *pulumi.OutputState }

func (GetServerNicOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetServerNic)(nil)).Elem()
}

func (o GetServerNicOutput) ToGetServerNicOutput() GetServerNicOutput {
	return o
}

func (o GetServerNicOutput) ToGetServerNicOutputWithContext(ctx context.Context) GetServerNicOutput {
	return o
}

// The Logical Unit Number (LUN) of the storage volume
func (o GetServerNicOutput) DeviceNumber() pulumi.IntOutput {
	return o.ApplyT(func(v GetServerNic) int { return v.DeviceNumber }).(pulumi.IntOutput)
}

// Indicates if the nic will reserve an IP using DHCP
func (o GetServerNicOutput) Dhcp() pulumi.BoolOutput {
	return o.ApplyT(func(v GetServerNic) bool { return v.Dhcp }).(pulumi.BoolOutput)
}

func (o GetServerNicOutput) Dhcpv6() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v GetServerNic) *bool { return v.Dhcpv6 }).(pulumi.BoolPtrOutput)
}

// Activate or deactivate the firewall
func (o GetServerNicOutput) FirewallActive() pulumi.BoolOutput {
	return o.ApplyT(func(v GetServerNic) bool { return v.FirewallActive }).(pulumi.BoolOutput)
}

// list of
func (o GetServerNicOutput) FirewallRules() GetServerNicFirewallRuleArrayOutput {
	return o.ApplyT(func(v GetServerNic) []GetServerNicFirewallRule { return v.FirewallRules }).(GetServerNicFirewallRuleArrayOutput)
}

// The type of firewall rules that will be allowed on the NIC
func (o GetServerNicOutput) FirewallType() pulumi.StringOutput {
	return o.ApplyT(func(v GetServerNic) string { return v.FirewallType }).(pulumi.StringOutput)
}

// ID of the server you want to search for.
//
// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
func (o GetServerNicOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v GetServerNic) string { return v.Id }).(pulumi.StringOutput)
}

// Collection of IP addresses assigned to a nic
func (o GetServerNicOutput) Ips() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetServerNic) []string { return v.Ips }).(pulumi.StringArrayOutput)
}

func (o GetServerNicOutput) Ipv6CidrBlock() pulumi.StringOutput {
	return o.ApplyT(func(v GetServerNic) string { return v.Ipv6CidrBlock }).(pulumi.StringOutput)
}

func (o GetServerNicOutput) Ipv6Ips() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetServerNic) []string { return v.Ipv6Ips }).(pulumi.StringArrayOutput)
}

// The LAN ID the NIC will sit on
func (o GetServerNicOutput) Lan() pulumi.IntOutput {
	return o.ApplyT(func(v GetServerNic) int { return v.Lan }).(pulumi.IntOutput)
}

// The MAC address of the NIC
func (o GetServerNicOutput) Mac() pulumi.StringOutput {
	return o.ApplyT(func(v GetServerNic) string { return v.Mac }).(pulumi.StringOutput)
}

// Name of an existing server that you want to search for.
func (o GetServerNicOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GetServerNic) string { return v.Name }).(pulumi.StringOutput)
}

// The PCI slot number of the Nic
func (o GetServerNicOutput) PciSlot() pulumi.IntOutput {
	return o.ApplyT(func(v GetServerNic) int { return v.PciSlot }).(pulumi.IntOutput)
}

type GetServerNicArrayOutput struct{ *pulumi.OutputState }

func (GetServerNicArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetServerNic)(nil)).Elem()
}

func (o GetServerNicArrayOutput) ToGetServerNicArrayOutput() GetServerNicArrayOutput {
	return o
}

func (o GetServerNicArrayOutput) ToGetServerNicArrayOutputWithContext(ctx context.Context) GetServerNicArrayOutput {
	return o
}

func (o GetServerNicArrayOutput) Index(i pulumi.IntInput) GetServerNicOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetServerNic {
		return vs[0].([]GetServerNic)[vs[1].(int)]
	}).(GetServerNicOutput)
}

type GetServerNicFirewallRule struct {
	// Defines the allowed code (from 0 to 254) if protocol ICMP is chosen
	IcmpCode int `pulumi:"icmpCode"`
	// Defines the allowed type (from 0 to 254) if the protocol ICMP is chosen
	IcmpType int `pulumi:"icmpType"`
	// ID of the server you want to search for.
	//
	// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
	Id string `pulumi:"id"`
	// Name of an existing server that you want to search for.
	Name string `pulumi:"name"`
	// Defines the end range of the allowed port (from 1 to 65534) if the protocol TCP or UDP is chosen
	PortRangeEnd int `pulumi:"portRangeEnd"`
	// Defines the start range of the allowed port (from 1 to 65534) if protocol TCP or UDP is chosen
	PortRangeStart int `pulumi:"portRangeStart"`
	// he protocol for the rule
	Protocol string `pulumi:"protocol"`
	// Only traffic originating from the respective IPv4 address is allowed. Value null allows all source IPs
	SourceIp string `pulumi:"sourceIp"`
	// Only traffic originating from the respective MAC address is allowed
	SourceMac string `pulumi:"sourceMac"`
	// In case the target NIC has multiple IP addresses, only traffic directed to the respective IP address of the NIC is allowed
	TargetIp string `pulumi:"targetIp"`
	// The type of firewall rule
	Type string `pulumi:"type"`
}

// GetServerNicFirewallRuleInput is an input type that accepts GetServerNicFirewallRuleArgs and GetServerNicFirewallRuleOutput values.
// You can construct a concrete instance of `GetServerNicFirewallRuleInput` via:
//
//	GetServerNicFirewallRuleArgs{...}
type GetServerNicFirewallRuleInput interface {
	pulumi.Input

	ToGetServerNicFirewallRuleOutput() GetServerNicFirewallRuleOutput
	ToGetServerNicFirewallRuleOutputWithContext(context.Context) GetServerNicFirewallRuleOutput
}

type GetServerNicFirewallRuleArgs struct {
	// Defines the allowed code (from 0 to 254) if protocol ICMP is chosen
	IcmpCode pulumi.IntInput `pulumi:"icmpCode"`
	// Defines the allowed type (from 0 to 254) if the protocol ICMP is chosen
	IcmpType pulumi.IntInput `pulumi:"icmpType"`
	// ID of the server you want to search for.
	//
	// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
	Id pulumi.StringInput `pulumi:"id"`
	// Name of an existing server that you want to search for.
	Name pulumi.StringInput `pulumi:"name"`
	// Defines the end range of the allowed port (from 1 to 65534) if the protocol TCP or UDP is chosen
	PortRangeEnd pulumi.IntInput `pulumi:"portRangeEnd"`
	// Defines the start range of the allowed port (from 1 to 65534) if protocol TCP or UDP is chosen
	PortRangeStart pulumi.IntInput `pulumi:"portRangeStart"`
	// he protocol for the rule
	Protocol pulumi.StringInput `pulumi:"protocol"`
	// Only traffic originating from the respective IPv4 address is allowed. Value null allows all source IPs
	SourceIp pulumi.StringInput `pulumi:"sourceIp"`
	// Only traffic originating from the respective MAC address is allowed
	SourceMac pulumi.StringInput `pulumi:"sourceMac"`
	// In case the target NIC has multiple IP addresses, only traffic directed to the respective IP address of the NIC is allowed
	TargetIp pulumi.StringInput `pulumi:"targetIp"`
	// The type of firewall rule
	Type pulumi.StringInput `pulumi:"type"`
}

func (GetServerNicFirewallRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetServerNicFirewallRule)(nil)).Elem()
}

func (i GetServerNicFirewallRuleArgs) ToGetServerNicFirewallRuleOutput() GetServerNicFirewallRuleOutput {
	return i.ToGetServerNicFirewallRuleOutputWithContext(context.Background())
}

func (i GetServerNicFirewallRuleArgs) ToGetServerNicFirewallRuleOutputWithContext(ctx context.Context) GetServerNicFirewallRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetServerNicFirewallRuleOutput)
}

// GetServerNicFirewallRuleArrayInput is an input type that accepts GetServerNicFirewallRuleArray and GetServerNicFirewallRuleArrayOutput values.
// You can construct a concrete instance of `GetServerNicFirewallRuleArrayInput` via:
//
//	GetServerNicFirewallRuleArray{ GetServerNicFirewallRuleArgs{...} }
type GetServerNicFirewallRuleArrayInput interface {
	pulumi.Input

	ToGetServerNicFirewallRuleArrayOutput() GetServerNicFirewallRuleArrayOutput
	ToGetServerNicFirewallRuleArrayOutputWithContext(context.Context) GetServerNicFirewallRuleArrayOutput
}

type GetServerNicFirewallRuleArray []GetServerNicFirewallRuleInput

func (GetServerNicFirewallRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetServerNicFirewallRule)(nil)).Elem()
}

func (i GetServerNicFirewallRuleArray) ToGetServerNicFirewallRuleArrayOutput() GetServerNicFirewallRuleArrayOutput {
	return i.ToGetServerNicFirewallRuleArrayOutputWithContext(context.Background())
}

func (i GetServerNicFirewallRuleArray) ToGetServerNicFirewallRuleArrayOutputWithContext(ctx context.Context) GetServerNicFirewallRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetServerNicFirewallRuleArrayOutput)
}

type GetServerNicFirewallRuleOutput struct{ *pulumi.OutputState }

func (GetServerNicFirewallRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetServerNicFirewallRule)(nil)).Elem()
}

func (o GetServerNicFirewallRuleOutput) ToGetServerNicFirewallRuleOutput() GetServerNicFirewallRuleOutput {
	return o
}

func (o GetServerNicFirewallRuleOutput) ToGetServerNicFirewallRuleOutputWithContext(ctx context.Context) GetServerNicFirewallRuleOutput {
	return o
}

// Defines the allowed code (from 0 to 254) if protocol ICMP is chosen
func (o GetServerNicFirewallRuleOutput) IcmpCode() pulumi.IntOutput {
	return o.ApplyT(func(v GetServerNicFirewallRule) int { return v.IcmpCode }).(pulumi.IntOutput)
}

// Defines the allowed type (from 0 to 254) if the protocol ICMP is chosen
func (o GetServerNicFirewallRuleOutput) IcmpType() pulumi.IntOutput {
	return o.ApplyT(func(v GetServerNicFirewallRule) int { return v.IcmpType }).(pulumi.IntOutput)
}

// ID of the server you want to search for.
//
// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
func (o GetServerNicFirewallRuleOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v GetServerNicFirewallRule) string { return v.Id }).(pulumi.StringOutput)
}

// Name of an existing server that you want to search for.
func (o GetServerNicFirewallRuleOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GetServerNicFirewallRule) string { return v.Name }).(pulumi.StringOutput)
}

// Defines the end range of the allowed port (from 1 to 65534) if the protocol TCP or UDP is chosen
func (o GetServerNicFirewallRuleOutput) PortRangeEnd() pulumi.IntOutput {
	return o.ApplyT(func(v GetServerNicFirewallRule) int { return v.PortRangeEnd }).(pulumi.IntOutput)
}

// Defines the start range of the allowed port (from 1 to 65534) if protocol TCP or UDP is chosen
func (o GetServerNicFirewallRuleOutput) PortRangeStart() pulumi.IntOutput {
	return o.ApplyT(func(v GetServerNicFirewallRule) int { return v.PortRangeStart }).(pulumi.IntOutput)
}

// he protocol for the rule
func (o GetServerNicFirewallRuleOutput) Protocol() pulumi.StringOutput {
	return o.ApplyT(func(v GetServerNicFirewallRule) string { return v.Protocol }).(pulumi.StringOutput)
}

// Only traffic originating from the respective IPv4 address is allowed. Value null allows all source IPs
func (o GetServerNicFirewallRuleOutput) SourceIp() pulumi.StringOutput {
	return o.ApplyT(func(v GetServerNicFirewallRule) string { return v.SourceIp }).(pulumi.StringOutput)
}

// Only traffic originating from the respective MAC address is allowed
func (o GetServerNicFirewallRuleOutput) SourceMac() pulumi.StringOutput {
	return o.ApplyT(func(v GetServerNicFirewallRule) string { return v.SourceMac }).(pulumi.StringOutput)
}

// In case the target NIC has multiple IP addresses, only traffic directed to the respective IP address of the NIC is allowed
func (o GetServerNicFirewallRuleOutput) TargetIp() pulumi.StringOutput {
	return o.ApplyT(func(v GetServerNicFirewallRule) string { return v.TargetIp }).(pulumi.StringOutput)
}

// The type of firewall rule
func (o GetServerNicFirewallRuleOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v GetServerNicFirewallRule) string { return v.Type }).(pulumi.StringOutput)
}

type GetServerNicFirewallRuleArrayOutput struct{ *pulumi.OutputState }

func (GetServerNicFirewallRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetServerNicFirewallRule)(nil)).Elem()
}

func (o GetServerNicFirewallRuleArrayOutput) ToGetServerNicFirewallRuleArrayOutput() GetServerNicFirewallRuleArrayOutput {
	return o
}

func (o GetServerNicFirewallRuleArrayOutput) ToGetServerNicFirewallRuleArrayOutputWithContext(ctx context.Context) GetServerNicFirewallRuleArrayOutput {
	return o
}

func (o GetServerNicFirewallRuleArrayOutput) Index(i pulumi.IntInput) GetServerNicFirewallRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetServerNicFirewallRule {
		return vs[0].([]GetServerNicFirewallRule)[vs[1].(int)]
	}).(GetServerNicFirewallRuleOutput)
}

type GetServerVolume struct {
	// The availability zone in which the volume should exist
	AvailabilityZone string `pulumi:"availabilityZone"`
	// The uuid of the Backup Unit that user has access to
	BackupUnitId string `pulumi:"backupUnitId"`
	// The UUID of the attached server.
	BootServer string `pulumi:"bootServer"`
	// The bus type of the volume
	Bus string `pulumi:"bus"`
	// Is capable of CPU hot plug (no reboot required)
	CpuHotPlug bool `pulumi:"cpuHotPlug"`
	// The Logical Unit Number (LUN) of the storage volume
	DeviceNumber int `pulumi:"deviceNumber"`
	// Is capable of Virt-IO drive hot plug (no reboot required)
	DiscVirtioHotPlug bool `pulumi:"discVirtioHotPlug"`
	// Is capable of Virt-IO drive hot unplug (no reboot required)
	DiscVirtioHotUnplug bool `pulumi:"discVirtioHotUnplug"`
	// ID of the server you want to search for.
	//
	// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
	Id        string `pulumi:"id"`
	ImageName string `pulumi:"imageName"`
	// Initial password to be set for installed OS
	ImagePassword string `pulumi:"imagePassword"`
	// OS type of this volume
	LicenceType string `pulumi:"licenceType"`
	// Name of an existing server that you want to search for.
	Name string `pulumi:"name"`
	// Is capable of nic hot plug (no reboot required)
	NicHotPlug bool `pulumi:"nicHotPlug"`
	// Is capable of nic hot unplug (no reboot required)
	NicHotUnplug bool `pulumi:"nicHotUnplug"`
	// The PCI slot number of the Nic
	PciSlot int `pulumi:"pciSlot"`
	// Is capable of memory hot plug (no reboot required)
	RamHotPlug bool `pulumi:"ramHotPlug"`
	// The size of the volume in GB
	Size int `pulumi:"size"`
	// Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key
	SshKeys []string `pulumi:"sshKeys"`
	// The type of firewall rule
	Type string `pulumi:"type"`
	// The cloud-init configuration for the volume as base64 encoded string
	UserData *string `pulumi:"userData"`
}

// GetServerVolumeInput is an input type that accepts GetServerVolumeArgs and GetServerVolumeOutput values.
// You can construct a concrete instance of `GetServerVolumeInput` via:
//
//	GetServerVolumeArgs{...}
type GetServerVolumeInput interface {
	pulumi.Input

	ToGetServerVolumeOutput() GetServerVolumeOutput
	ToGetServerVolumeOutputWithContext(context.Context) GetServerVolumeOutput
}

type GetServerVolumeArgs struct {
	// The availability zone in which the volume should exist
	AvailabilityZone pulumi.StringInput `pulumi:"availabilityZone"`
	// The uuid of the Backup Unit that user has access to
	BackupUnitId pulumi.StringInput `pulumi:"backupUnitId"`
	// The UUID of the attached server.
	BootServer pulumi.StringInput `pulumi:"bootServer"`
	// The bus type of the volume
	Bus pulumi.StringInput `pulumi:"bus"`
	// Is capable of CPU hot plug (no reboot required)
	CpuHotPlug pulumi.BoolInput `pulumi:"cpuHotPlug"`
	// The Logical Unit Number (LUN) of the storage volume
	DeviceNumber pulumi.IntInput `pulumi:"deviceNumber"`
	// Is capable of Virt-IO drive hot plug (no reboot required)
	DiscVirtioHotPlug pulumi.BoolInput `pulumi:"discVirtioHotPlug"`
	// Is capable of Virt-IO drive hot unplug (no reboot required)
	DiscVirtioHotUnplug pulumi.BoolInput `pulumi:"discVirtioHotUnplug"`
	// ID of the server you want to search for.
	//
	// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
	Id        pulumi.StringInput `pulumi:"id"`
	ImageName pulumi.StringInput `pulumi:"imageName"`
	// Initial password to be set for installed OS
	ImagePassword pulumi.StringInput `pulumi:"imagePassword"`
	// OS type of this volume
	LicenceType pulumi.StringInput `pulumi:"licenceType"`
	// Name of an existing server that you want to search for.
	Name pulumi.StringInput `pulumi:"name"`
	// Is capable of nic hot plug (no reboot required)
	NicHotPlug pulumi.BoolInput `pulumi:"nicHotPlug"`
	// Is capable of nic hot unplug (no reboot required)
	NicHotUnplug pulumi.BoolInput `pulumi:"nicHotUnplug"`
	// The PCI slot number of the Nic
	PciSlot pulumi.IntInput `pulumi:"pciSlot"`
	// Is capable of memory hot plug (no reboot required)
	RamHotPlug pulumi.BoolInput `pulumi:"ramHotPlug"`
	// The size of the volume in GB
	Size pulumi.IntInput `pulumi:"size"`
	// Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key
	SshKeys pulumi.StringArrayInput `pulumi:"sshKeys"`
	// The type of firewall rule
	Type pulumi.StringInput `pulumi:"type"`
	// The cloud-init configuration for the volume as base64 encoded string
	UserData pulumi.StringPtrInput `pulumi:"userData"`
}

func (GetServerVolumeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetServerVolume)(nil)).Elem()
}

func (i GetServerVolumeArgs) ToGetServerVolumeOutput() GetServerVolumeOutput {
	return i.ToGetServerVolumeOutputWithContext(context.Background())
}

func (i GetServerVolumeArgs) ToGetServerVolumeOutputWithContext(ctx context.Context) GetServerVolumeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetServerVolumeOutput)
}

// GetServerVolumeArrayInput is an input type that accepts GetServerVolumeArray and GetServerVolumeArrayOutput values.
// You can construct a concrete instance of `GetServerVolumeArrayInput` via:
//
//	GetServerVolumeArray{ GetServerVolumeArgs{...} }
type GetServerVolumeArrayInput interface {
	pulumi.Input

	ToGetServerVolumeArrayOutput() GetServerVolumeArrayOutput
	ToGetServerVolumeArrayOutputWithContext(context.Context) GetServerVolumeArrayOutput
}

type GetServerVolumeArray []GetServerVolumeInput

func (GetServerVolumeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetServerVolume)(nil)).Elem()
}

func (i GetServerVolumeArray) ToGetServerVolumeArrayOutput() GetServerVolumeArrayOutput {
	return i.ToGetServerVolumeArrayOutputWithContext(context.Background())
}

func (i GetServerVolumeArray) ToGetServerVolumeArrayOutputWithContext(ctx context.Context) GetServerVolumeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetServerVolumeArrayOutput)
}

type GetServerVolumeOutput struct{ *pulumi.OutputState }

func (GetServerVolumeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetServerVolume)(nil)).Elem()
}

func (o GetServerVolumeOutput) ToGetServerVolumeOutput() GetServerVolumeOutput {
	return o
}

func (o GetServerVolumeOutput) ToGetServerVolumeOutputWithContext(ctx context.Context) GetServerVolumeOutput {
	return o
}

// The availability zone in which the volume should exist
func (o GetServerVolumeOutput) AvailabilityZone() pulumi.StringOutput {
	return o.ApplyT(func(v GetServerVolume) string { return v.AvailabilityZone }).(pulumi.StringOutput)
}

// The uuid of the Backup Unit that user has access to
func (o GetServerVolumeOutput) BackupUnitId() pulumi.StringOutput {
	return o.ApplyT(func(v GetServerVolume) string { return v.BackupUnitId }).(pulumi.StringOutput)
}

// The UUID of the attached server.
func (o GetServerVolumeOutput) BootServer() pulumi.StringOutput {
	return o.ApplyT(func(v GetServerVolume) string { return v.BootServer }).(pulumi.StringOutput)
}

// The bus type of the volume
func (o GetServerVolumeOutput) Bus() pulumi.StringOutput {
	return o.ApplyT(func(v GetServerVolume) string { return v.Bus }).(pulumi.StringOutput)
}

// Is capable of CPU hot plug (no reboot required)
func (o GetServerVolumeOutput) CpuHotPlug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetServerVolume) bool { return v.CpuHotPlug }).(pulumi.BoolOutput)
}

// The Logical Unit Number (LUN) of the storage volume
func (o GetServerVolumeOutput) DeviceNumber() pulumi.IntOutput {
	return o.ApplyT(func(v GetServerVolume) int { return v.DeviceNumber }).(pulumi.IntOutput)
}

// Is capable of Virt-IO drive hot plug (no reboot required)
func (o GetServerVolumeOutput) DiscVirtioHotPlug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetServerVolume) bool { return v.DiscVirtioHotPlug }).(pulumi.BoolOutput)
}

// Is capable of Virt-IO drive hot unplug (no reboot required)
func (o GetServerVolumeOutput) DiscVirtioHotUnplug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetServerVolume) bool { return v.DiscVirtioHotUnplug }).(pulumi.BoolOutput)
}

// ID of the server you want to search for.
//
// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
func (o GetServerVolumeOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v GetServerVolume) string { return v.Id }).(pulumi.StringOutput)
}

func (o GetServerVolumeOutput) ImageName() pulumi.StringOutput {
	return o.ApplyT(func(v GetServerVolume) string { return v.ImageName }).(pulumi.StringOutput)
}

// Initial password to be set for installed OS
func (o GetServerVolumeOutput) ImagePassword() pulumi.StringOutput {
	return o.ApplyT(func(v GetServerVolume) string { return v.ImagePassword }).(pulumi.StringOutput)
}

// OS type of this volume
func (o GetServerVolumeOutput) LicenceType() pulumi.StringOutput {
	return o.ApplyT(func(v GetServerVolume) string { return v.LicenceType }).(pulumi.StringOutput)
}

// Name of an existing server that you want to search for.
func (o GetServerVolumeOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GetServerVolume) string { return v.Name }).(pulumi.StringOutput)
}

// Is capable of nic hot plug (no reboot required)
func (o GetServerVolumeOutput) NicHotPlug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetServerVolume) bool { return v.NicHotPlug }).(pulumi.BoolOutput)
}

// Is capable of nic hot unplug (no reboot required)
func (o GetServerVolumeOutput) NicHotUnplug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetServerVolume) bool { return v.NicHotUnplug }).(pulumi.BoolOutput)
}

// The PCI slot number of the Nic
func (o GetServerVolumeOutput) PciSlot() pulumi.IntOutput {
	return o.ApplyT(func(v GetServerVolume) int { return v.PciSlot }).(pulumi.IntOutput)
}

// Is capable of memory hot plug (no reboot required)
func (o GetServerVolumeOutput) RamHotPlug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetServerVolume) bool { return v.RamHotPlug }).(pulumi.BoolOutput)
}

// The size of the volume in GB
func (o GetServerVolumeOutput) Size() pulumi.IntOutput {
	return o.ApplyT(func(v GetServerVolume) int { return v.Size }).(pulumi.IntOutput)
}

// Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key
func (o GetServerVolumeOutput) SshKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetServerVolume) []string { return v.SshKeys }).(pulumi.StringArrayOutput)
}

// The type of firewall rule
func (o GetServerVolumeOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v GetServerVolume) string { return v.Type }).(pulumi.StringOutput)
}

// The cloud-init configuration for the volume as base64 encoded string
func (o GetServerVolumeOutput) UserData() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetServerVolume) *string { return v.UserData }).(pulumi.StringPtrOutput)
}

type GetServerVolumeArrayOutput struct{ *pulumi.OutputState }

func (GetServerVolumeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetServerVolume)(nil)).Elem()
}

func (o GetServerVolumeArrayOutput) ToGetServerVolumeArrayOutput() GetServerVolumeArrayOutput {
	return o
}

func (o GetServerVolumeArrayOutput) ToGetServerVolumeArrayOutputWithContext(ctx context.Context) GetServerVolumeArrayOutput {
	return o
}

func (o GetServerVolumeArrayOutput) Index(i pulumi.IntInput) GetServerVolumeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetServerVolume {
		return vs[0].([]GetServerVolume)[vs[1].(int)]
	}).(GetServerVolumeOutput)
}

type GetUserGroup struct {
	// ID of the user you want to search for.
	//
	// Either `email` or `id` can be provided. If no argument is set, the provider will search for the **email that was provided for the configuration**. If none is found, the provider will return an error.
	Id   string `pulumi:"id"`
	Name string `pulumi:"name"`
}

// GetUserGroupInput is an input type that accepts GetUserGroupArgs and GetUserGroupOutput values.
// You can construct a concrete instance of `GetUserGroupInput` via:
//
//	GetUserGroupArgs{...}
type GetUserGroupInput interface {
	pulumi.Input

	ToGetUserGroupOutput() GetUserGroupOutput
	ToGetUserGroupOutputWithContext(context.Context) GetUserGroupOutput
}

type GetUserGroupArgs struct {
	// ID of the user you want to search for.
	//
	// Either `email` or `id` can be provided. If no argument is set, the provider will search for the **email that was provided for the configuration**. If none is found, the provider will return an error.
	Id   pulumi.StringInput `pulumi:"id"`
	Name pulumi.StringInput `pulumi:"name"`
}

func (GetUserGroupArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetUserGroup)(nil)).Elem()
}

func (i GetUserGroupArgs) ToGetUserGroupOutput() GetUserGroupOutput {
	return i.ToGetUserGroupOutputWithContext(context.Background())
}

func (i GetUserGroupArgs) ToGetUserGroupOutputWithContext(ctx context.Context) GetUserGroupOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetUserGroupOutput)
}

// GetUserGroupArrayInput is an input type that accepts GetUserGroupArray and GetUserGroupArrayOutput values.
// You can construct a concrete instance of `GetUserGroupArrayInput` via:
//
//	GetUserGroupArray{ GetUserGroupArgs{...} }
type GetUserGroupArrayInput interface {
	pulumi.Input

	ToGetUserGroupArrayOutput() GetUserGroupArrayOutput
	ToGetUserGroupArrayOutputWithContext(context.Context) GetUserGroupArrayOutput
}

type GetUserGroupArray []GetUserGroupInput

func (GetUserGroupArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetUserGroup)(nil)).Elem()
}

func (i GetUserGroupArray) ToGetUserGroupArrayOutput() GetUserGroupArrayOutput {
	return i.ToGetUserGroupArrayOutputWithContext(context.Background())
}

func (i GetUserGroupArray) ToGetUserGroupArrayOutputWithContext(ctx context.Context) GetUserGroupArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetUserGroupArrayOutput)
}

type GetUserGroupOutput struct{ *pulumi.OutputState }

func (GetUserGroupOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetUserGroup)(nil)).Elem()
}

func (o GetUserGroupOutput) ToGetUserGroupOutput() GetUserGroupOutput {
	return o
}

func (o GetUserGroupOutput) ToGetUserGroupOutputWithContext(ctx context.Context) GetUserGroupOutput {
	return o
}

// ID of the user you want to search for.
//
// Either `email` or `id` can be provided. If no argument is set, the provider will search for the **email that was provided for the configuration**. If none is found, the provider will return an error.
func (o GetUserGroupOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v GetUserGroup) string { return v.Id }).(pulumi.StringOutput)
}

func (o GetUserGroupOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GetUserGroup) string { return v.Name }).(pulumi.StringOutput)
}

type GetUserGroupArrayOutput struct{ *pulumi.OutputState }

func (GetUserGroupArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetUserGroup)(nil)).Elem()
}

func (o GetUserGroupArrayOutput) ToGetUserGroupArrayOutput() GetUserGroupArrayOutput {
	return o
}

func (o GetUserGroupArrayOutput) ToGetUserGroupArrayOutputWithContext(ctx context.Context) GetUserGroupArrayOutput {
	return o
}

func (o GetUserGroupArrayOutput) Index(i pulumi.IntInput) GetUserGroupOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetUserGroup {
		return vs[0].([]GetUserGroup)[vs[1].(int)]
	}).(GetUserGroupOutput)
}

type GetVCPUServerCdrom struct {
	// Cloud init compatibility
	CloudInit string `pulumi:"cloudInit"`
	// Is capable of CPU hot plug (no reboot required)
	CpuHotPlug bool `pulumi:"cpuHotPlug"`
	// Is capable of CPU hot unplug (no reboot required)
	CpuHotUnplug bool `pulumi:"cpuHotUnplug"`
	// Description of cdrom
	Description string `pulumi:"description"`
	// Is capable of SCSI drive hot plug (no reboot required)
	DiscScsiHotPlug bool `pulumi:"discScsiHotPlug"`
	// Is capable of SCSI drive hot unplug (no reboot required)
	DiscScsiHotUnplug bool `pulumi:"discScsiHotUnplug"`
	// Is capable of Virt-IO drive hot plug (no reboot required)
	DiscVirtioHotPlug bool `pulumi:"discVirtioHotPlug"`
	// Is capable of Virt-IO drive hot unplug (no reboot required)
	DiscVirtioHotUnplug bool `pulumi:"discVirtioHotUnplug"`
	// ID of the server you want to search for.
	//
	// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
	Id string `pulumi:"id"`
	// List of image aliases mapped for this Image
	ImageAliases []string `pulumi:"imageAliases"`
	// Type of image
	ImageType string `pulumi:"imageType"`
	// OS type of this volume
	LicenceType string `pulumi:"licenceType"`
	// Location of that image/snapshot
	Location string `pulumi:"location"`
	// Name of an existing server that you want to search for.
	Name string `pulumi:"name"`
	// Is capable of nic hot plug (no reboot required)
	NicHotPlug bool `pulumi:"nicHotPlug"`
	// Is capable of nic hot unplug (no reboot required)
	NicHotUnplug bool `pulumi:"nicHotUnplug"`
	// Indicates if the image is part of the public repository or not
	Public bool `pulumi:"public"`
	// Is capable of memory hot plug (no reboot required)
	RamHotPlug bool `pulumi:"ramHotPlug"`
	// Is capable of memory hot unplug (no reboot required)
	RamHotUnplug bool `pulumi:"ramHotUnplug"`
	// The size of the volume in GB
	Size float64 `pulumi:"size"`
}

// GetVCPUServerCdromInput is an input type that accepts GetVCPUServerCdromArgs and GetVCPUServerCdromOutput values.
// You can construct a concrete instance of `GetVCPUServerCdromInput` via:
//
//	GetVCPUServerCdromArgs{...}
type GetVCPUServerCdromInput interface {
	pulumi.Input

	ToGetVCPUServerCdromOutput() GetVCPUServerCdromOutput
	ToGetVCPUServerCdromOutputWithContext(context.Context) GetVCPUServerCdromOutput
}

type GetVCPUServerCdromArgs struct {
	// Cloud init compatibility
	CloudInit pulumi.StringInput `pulumi:"cloudInit"`
	// Is capable of CPU hot plug (no reboot required)
	CpuHotPlug pulumi.BoolInput `pulumi:"cpuHotPlug"`
	// Is capable of CPU hot unplug (no reboot required)
	CpuHotUnplug pulumi.BoolInput `pulumi:"cpuHotUnplug"`
	// Description of cdrom
	Description pulumi.StringInput `pulumi:"description"`
	// Is capable of SCSI drive hot plug (no reboot required)
	DiscScsiHotPlug pulumi.BoolInput `pulumi:"discScsiHotPlug"`
	// Is capable of SCSI drive hot unplug (no reboot required)
	DiscScsiHotUnplug pulumi.BoolInput `pulumi:"discScsiHotUnplug"`
	// Is capable of Virt-IO drive hot plug (no reboot required)
	DiscVirtioHotPlug pulumi.BoolInput `pulumi:"discVirtioHotPlug"`
	// Is capable of Virt-IO drive hot unplug (no reboot required)
	DiscVirtioHotUnplug pulumi.BoolInput `pulumi:"discVirtioHotUnplug"`
	// ID of the server you want to search for.
	//
	// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
	Id pulumi.StringInput `pulumi:"id"`
	// List of image aliases mapped for this Image
	ImageAliases pulumi.StringArrayInput `pulumi:"imageAliases"`
	// Type of image
	ImageType pulumi.StringInput `pulumi:"imageType"`
	// OS type of this volume
	LicenceType pulumi.StringInput `pulumi:"licenceType"`
	// Location of that image/snapshot
	Location pulumi.StringInput `pulumi:"location"`
	// Name of an existing server that you want to search for.
	Name pulumi.StringInput `pulumi:"name"`
	// Is capable of nic hot plug (no reboot required)
	NicHotPlug pulumi.BoolInput `pulumi:"nicHotPlug"`
	// Is capable of nic hot unplug (no reboot required)
	NicHotUnplug pulumi.BoolInput `pulumi:"nicHotUnplug"`
	// Indicates if the image is part of the public repository or not
	Public pulumi.BoolInput `pulumi:"public"`
	// Is capable of memory hot plug (no reboot required)
	RamHotPlug pulumi.BoolInput `pulumi:"ramHotPlug"`
	// Is capable of memory hot unplug (no reboot required)
	RamHotUnplug pulumi.BoolInput `pulumi:"ramHotUnplug"`
	// The size of the volume in GB
	Size pulumi.Float64Input `pulumi:"size"`
}

func (GetVCPUServerCdromArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetVCPUServerCdrom)(nil)).Elem()
}

func (i GetVCPUServerCdromArgs) ToGetVCPUServerCdromOutput() GetVCPUServerCdromOutput {
	return i.ToGetVCPUServerCdromOutputWithContext(context.Background())
}

func (i GetVCPUServerCdromArgs) ToGetVCPUServerCdromOutputWithContext(ctx context.Context) GetVCPUServerCdromOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetVCPUServerCdromOutput)
}

// GetVCPUServerCdromArrayInput is an input type that accepts GetVCPUServerCdromArray and GetVCPUServerCdromArrayOutput values.
// You can construct a concrete instance of `GetVCPUServerCdromArrayInput` via:
//
//	GetVCPUServerCdromArray{ GetVCPUServerCdromArgs{...} }
type GetVCPUServerCdromArrayInput interface {
	pulumi.Input

	ToGetVCPUServerCdromArrayOutput() GetVCPUServerCdromArrayOutput
	ToGetVCPUServerCdromArrayOutputWithContext(context.Context) GetVCPUServerCdromArrayOutput
}

type GetVCPUServerCdromArray []GetVCPUServerCdromInput

func (GetVCPUServerCdromArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetVCPUServerCdrom)(nil)).Elem()
}

func (i GetVCPUServerCdromArray) ToGetVCPUServerCdromArrayOutput() GetVCPUServerCdromArrayOutput {
	return i.ToGetVCPUServerCdromArrayOutputWithContext(context.Background())
}

func (i GetVCPUServerCdromArray) ToGetVCPUServerCdromArrayOutputWithContext(ctx context.Context) GetVCPUServerCdromArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetVCPUServerCdromArrayOutput)
}

type GetVCPUServerCdromOutput struct{ *pulumi.OutputState }

func (GetVCPUServerCdromOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetVCPUServerCdrom)(nil)).Elem()
}

func (o GetVCPUServerCdromOutput) ToGetVCPUServerCdromOutput() GetVCPUServerCdromOutput {
	return o
}

func (o GetVCPUServerCdromOutput) ToGetVCPUServerCdromOutputWithContext(ctx context.Context) GetVCPUServerCdromOutput {
	return o
}

// Cloud init compatibility
func (o GetVCPUServerCdromOutput) CloudInit() pulumi.StringOutput {
	return o.ApplyT(func(v GetVCPUServerCdrom) string { return v.CloudInit }).(pulumi.StringOutput)
}

// Is capable of CPU hot plug (no reboot required)
func (o GetVCPUServerCdromOutput) CpuHotPlug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetVCPUServerCdrom) bool { return v.CpuHotPlug }).(pulumi.BoolOutput)
}

// Is capable of CPU hot unplug (no reboot required)
func (o GetVCPUServerCdromOutput) CpuHotUnplug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetVCPUServerCdrom) bool { return v.CpuHotUnplug }).(pulumi.BoolOutput)
}

// Description of cdrom
func (o GetVCPUServerCdromOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v GetVCPUServerCdrom) string { return v.Description }).(pulumi.StringOutput)
}

// Is capable of SCSI drive hot plug (no reboot required)
func (o GetVCPUServerCdromOutput) DiscScsiHotPlug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetVCPUServerCdrom) bool { return v.DiscScsiHotPlug }).(pulumi.BoolOutput)
}

// Is capable of SCSI drive hot unplug (no reboot required)
func (o GetVCPUServerCdromOutput) DiscScsiHotUnplug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetVCPUServerCdrom) bool { return v.DiscScsiHotUnplug }).(pulumi.BoolOutput)
}

// Is capable of Virt-IO drive hot plug (no reboot required)
func (o GetVCPUServerCdromOutput) DiscVirtioHotPlug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetVCPUServerCdrom) bool { return v.DiscVirtioHotPlug }).(pulumi.BoolOutput)
}

// Is capable of Virt-IO drive hot unplug (no reboot required)
func (o GetVCPUServerCdromOutput) DiscVirtioHotUnplug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetVCPUServerCdrom) bool { return v.DiscVirtioHotUnplug }).(pulumi.BoolOutput)
}

// ID of the server you want to search for.
//
// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
func (o GetVCPUServerCdromOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v GetVCPUServerCdrom) string { return v.Id }).(pulumi.StringOutput)
}

// List of image aliases mapped for this Image
func (o GetVCPUServerCdromOutput) ImageAliases() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetVCPUServerCdrom) []string { return v.ImageAliases }).(pulumi.StringArrayOutput)
}

// Type of image
func (o GetVCPUServerCdromOutput) ImageType() pulumi.StringOutput {
	return o.ApplyT(func(v GetVCPUServerCdrom) string { return v.ImageType }).(pulumi.StringOutput)
}

// OS type of this volume
func (o GetVCPUServerCdromOutput) LicenceType() pulumi.StringOutput {
	return o.ApplyT(func(v GetVCPUServerCdrom) string { return v.LicenceType }).(pulumi.StringOutput)
}

// Location of that image/snapshot
func (o GetVCPUServerCdromOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v GetVCPUServerCdrom) string { return v.Location }).(pulumi.StringOutput)
}

// Name of an existing server that you want to search for.
func (o GetVCPUServerCdromOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GetVCPUServerCdrom) string { return v.Name }).(pulumi.StringOutput)
}

// Is capable of nic hot plug (no reboot required)
func (o GetVCPUServerCdromOutput) NicHotPlug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetVCPUServerCdrom) bool { return v.NicHotPlug }).(pulumi.BoolOutput)
}

// Is capable of nic hot unplug (no reboot required)
func (o GetVCPUServerCdromOutput) NicHotUnplug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetVCPUServerCdrom) bool { return v.NicHotUnplug }).(pulumi.BoolOutput)
}

// Indicates if the image is part of the public repository or not
func (o GetVCPUServerCdromOutput) Public() pulumi.BoolOutput {
	return o.ApplyT(func(v GetVCPUServerCdrom) bool { return v.Public }).(pulumi.BoolOutput)
}

// Is capable of memory hot plug (no reboot required)
func (o GetVCPUServerCdromOutput) RamHotPlug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetVCPUServerCdrom) bool { return v.RamHotPlug }).(pulumi.BoolOutput)
}

// Is capable of memory hot unplug (no reboot required)
func (o GetVCPUServerCdromOutput) RamHotUnplug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetVCPUServerCdrom) bool { return v.RamHotUnplug }).(pulumi.BoolOutput)
}

// The size of the volume in GB
func (o GetVCPUServerCdromOutput) Size() pulumi.Float64Output {
	return o.ApplyT(func(v GetVCPUServerCdrom) float64 { return v.Size }).(pulumi.Float64Output)
}

type GetVCPUServerCdromArrayOutput struct{ *pulumi.OutputState }

func (GetVCPUServerCdromArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetVCPUServerCdrom)(nil)).Elem()
}

func (o GetVCPUServerCdromArrayOutput) ToGetVCPUServerCdromArrayOutput() GetVCPUServerCdromArrayOutput {
	return o
}

func (o GetVCPUServerCdromArrayOutput) ToGetVCPUServerCdromArrayOutputWithContext(ctx context.Context) GetVCPUServerCdromArrayOutput {
	return o
}

func (o GetVCPUServerCdromArrayOutput) Index(i pulumi.IntInput) GetVCPUServerCdromOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetVCPUServerCdrom {
		return vs[0].([]GetVCPUServerCdrom)[vs[1].(int)]
	}).(GetVCPUServerCdromOutput)
}

type GetVCPUServerLabel struct {
	// ID of the server you want to search for.
	//
	// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
	Id string `pulumi:"id"`
	// The key of the label
	Key string `pulumi:"key"`
	// The value of the label
	Value string `pulumi:"value"`
}

// GetVCPUServerLabelInput is an input type that accepts GetVCPUServerLabelArgs and GetVCPUServerLabelOutput values.
// You can construct a concrete instance of `GetVCPUServerLabelInput` via:
//
//	GetVCPUServerLabelArgs{...}
type GetVCPUServerLabelInput interface {
	pulumi.Input

	ToGetVCPUServerLabelOutput() GetVCPUServerLabelOutput
	ToGetVCPUServerLabelOutputWithContext(context.Context) GetVCPUServerLabelOutput
}

type GetVCPUServerLabelArgs struct {
	// ID of the server you want to search for.
	//
	// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
	Id pulumi.StringInput `pulumi:"id"`
	// The key of the label
	Key pulumi.StringInput `pulumi:"key"`
	// The value of the label
	Value pulumi.StringInput `pulumi:"value"`
}

func (GetVCPUServerLabelArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetVCPUServerLabel)(nil)).Elem()
}

func (i GetVCPUServerLabelArgs) ToGetVCPUServerLabelOutput() GetVCPUServerLabelOutput {
	return i.ToGetVCPUServerLabelOutputWithContext(context.Background())
}

func (i GetVCPUServerLabelArgs) ToGetVCPUServerLabelOutputWithContext(ctx context.Context) GetVCPUServerLabelOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetVCPUServerLabelOutput)
}

// GetVCPUServerLabelArrayInput is an input type that accepts GetVCPUServerLabelArray and GetVCPUServerLabelArrayOutput values.
// You can construct a concrete instance of `GetVCPUServerLabelArrayInput` via:
//
//	GetVCPUServerLabelArray{ GetVCPUServerLabelArgs{...} }
type GetVCPUServerLabelArrayInput interface {
	pulumi.Input

	ToGetVCPUServerLabelArrayOutput() GetVCPUServerLabelArrayOutput
	ToGetVCPUServerLabelArrayOutputWithContext(context.Context) GetVCPUServerLabelArrayOutput
}

type GetVCPUServerLabelArray []GetVCPUServerLabelInput

func (GetVCPUServerLabelArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetVCPUServerLabel)(nil)).Elem()
}

func (i GetVCPUServerLabelArray) ToGetVCPUServerLabelArrayOutput() GetVCPUServerLabelArrayOutput {
	return i.ToGetVCPUServerLabelArrayOutputWithContext(context.Background())
}

func (i GetVCPUServerLabelArray) ToGetVCPUServerLabelArrayOutputWithContext(ctx context.Context) GetVCPUServerLabelArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetVCPUServerLabelArrayOutput)
}

type GetVCPUServerLabelOutput struct{ *pulumi.OutputState }

func (GetVCPUServerLabelOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetVCPUServerLabel)(nil)).Elem()
}

func (o GetVCPUServerLabelOutput) ToGetVCPUServerLabelOutput() GetVCPUServerLabelOutput {
	return o
}

func (o GetVCPUServerLabelOutput) ToGetVCPUServerLabelOutputWithContext(ctx context.Context) GetVCPUServerLabelOutput {
	return o
}

// ID of the server you want to search for.
//
// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
func (o GetVCPUServerLabelOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v GetVCPUServerLabel) string { return v.Id }).(pulumi.StringOutput)
}

// The key of the label
func (o GetVCPUServerLabelOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v GetVCPUServerLabel) string { return v.Key }).(pulumi.StringOutput)
}

// The value of the label
func (o GetVCPUServerLabelOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v GetVCPUServerLabel) string { return v.Value }).(pulumi.StringOutput)
}

type GetVCPUServerLabelArrayOutput struct{ *pulumi.OutputState }

func (GetVCPUServerLabelArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetVCPUServerLabel)(nil)).Elem()
}

func (o GetVCPUServerLabelArrayOutput) ToGetVCPUServerLabelArrayOutput() GetVCPUServerLabelArrayOutput {
	return o
}

func (o GetVCPUServerLabelArrayOutput) ToGetVCPUServerLabelArrayOutputWithContext(ctx context.Context) GetVCPUServerLabelArrayOutput {
	return o
}

func (o GetVCPUServerLabelArrayOutput) Index(i pulumi.IntInput) GetVCPUServerLabelOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetVCPUServerLabel {
		return vs[0].([]GetVCPUServerLabel)[vs[1].(int)]
	}).(GetVCPUServerLabelOutput)
}

type GetVCPUServerNic struct {
	// The Logical Unit Number (LUN) of the storage volume
	DeviceNumber int `pulumi:"deviceNumber"`
	// Indicates if the nic will reserve an IP using DHCP
	Dhcp   bool  `pulumi:"dhcp"`
	Dhcpv6 *bool `pulumi:"dhcpv6"`
	// Activate or deactivate the firewall
	FirewallActive bool `pulumi:"firewallActive"`
	// list of
	FirewallRules []GetVCPUServerNicFirewallRule `pulumi:"firewallRules"`
	// The type of firewall rules that will be allowed on the NIC
	FirewallType string `pulumi:"firewallType"`
	// ID of the server you want to search for.
	//
	// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
	Id string `pulumi:"id"`
	// Collection of IP addresses assigned to a nic
	Ips           []string `pulumi:"ips"`
	Ipv6CidrBlock string   `pulumi:"ipv6CidrBlock"`
	Ipv6Ips       []string `pulumi:"ipv6Ips"`
	// The LAN ID the NIC will sit on
	Lan int `pulumi:"lan"`
	// The MAC address of the NIC
	Mac string `pulumi:"mac"`
	// Name of an existing server that you want to search for.
	Name string `pulumi:"name"`
	// The PCI slot number of the Nic
	PciSlot int `pulumi:"pciSlot"`
}

// GetVCPUServerNicInput is an input type that accepts GetVCPUServerNicArgs and GetVCPUServerNicOutput values.
// You can construct a concrete instance of `GetVCPUServerNicInput` via:
//
//	GetVCPUServerNicArgs{...}
type GetVCPUServerNicInput interface {
	pulumi.Input

	ToGetVCPUServerNicOutput() GetVCPUServerNicOutput
	ToGetVCPUServerNicOutputWithContext(context.Context) GetVCPUServerNicOutput
}

type GetVCPUServerNicArgs struct {
	// The Logical Unit Number (LUN) of the storage volume
	DeviceNumber pulumi.IntInput `pulumi:"deviceNumber"`
	// Indicates if the nic will reserve an IP using DHCP
	Dhcp   pulumi.BoolInput    `pulumi:"dhcp"`
	Dhcpv6 pulumi.BoolPtrInput `pulumi:"dhcpv6"`
	// Activate or deactivate the firewall
	FirewallActive pulumi.BoolInput `pulumi:"firewallActive"`
	// list of
	FirewallRules GetVCPUServerNicFirewallRuleArrayInput `pulumi:"firewallRules"`
	// The type of firewall rules that will be allowed on the NIC
	FirewallType pulumi.StringInput `pulumi:"firewallType"`
	// ID of the server you want to search for.
	//
	// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
	Id pulumi.StringInput `pulumi:"id"`
	// Collection of IP addresses assigned to a nic
	Ips           pulumi.StringArrayInput `pulumi:"ips"`
	Ipv6CidrBlock pulumi.StringInput      `pulumi:"ipv6CidrBlock"`
	Ipv6Ips       pulumi.StringArrayInput `pulumi:"ipv6Ips"`
	// The LAN ID the NIC will sit on
	Lan pulumi.IntInput `pulumi:"lan"`
	// The MAC address of the NIC
	Mac pulumi.StringInput `pulumi:"mac"`
	// Name of an existing server that you want to search for.
	Name pulumi.StringInput `pulumi:"name"`
	// The PCI slot number of the Nic
	PciSlot pulumi.IntInput `pulumi:"pciSlot"`
}

func (GetVCPUServerNicArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetVCPUServerNic)(nil)).Elem()
}

func (i GetVCPUServerNicArgs) ToGetVCPUServerNicOutput() GetVCPUServerNicOutput {
	return i.ToGetVCPUServerNicOutputWithContext(context.Background())
}

func (i GetVCPUServerNicArgs) ToGetVCPUServerNicOutputWithContext(ctx context.Context) GetVCPUServerNicOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetVCPUServerNicOutput)
}

// GetVCPUServerNicArrayInput is an input type that accepts GetVCPUServerNicArray and GetVCPUServerNicArrayOutput values.
// You can construct a concrete instance of `GetVCPUServerNicArrayInput` via:
//
//	GetVCPUServerNicArray{ GetVCPUServerNicArgs{...} }
type GetVCPUServerNicArrayInput interface {
	pulumi.Input

	ToGetVCPUServerNicArrayOutput() GetVCPUServerNicArrayOutput
	ToGetVCPUServerNicArrayOutputWithContext(context.Context) GetVCPUServerNicArrayOutput
}

type GetVCPUServerNicArray []GetVCPUServerNicInput

func (GetVCPUServerNicArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetVCPUServerNic)(nil)).Elem()
}

func (i GetVCPUServerNicArray) ToGetVCPUServerNicArrayOutput() GetVCPUServerNicArrayOutput {
	return i.ToGetVCPUServerNicArrayOutputWithContext(context.Background())
}

func (i GetVCPUServerNicArray) ToGetVCPUServerNicArrayOutputWithContext(ctx context.Context) GetVCPUServerNicArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetVCPUServerNicArrayOutput)
}

type GetVCPUServerNicOutput struct{ *pulumi.OutputState }

func (GetVCPUServerNicOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetVCPUServerNic)(nil)).Elem()
}

func (o GetVCPUServerNicOutput) ToGetVCPUServerNicOutput() GetVCPUServerNicOutput {
	return o
}

func (o GetVCPUServerNicOutput) ToGetVCPUServerNicOutputWithContext(ctx context.Context) GetVCPUServerNicOutput {
	return o
}

// The Logical Unit Number (LUN) of the storage volume
func (o GetVCPUServerNicOutput) DeviceNumber() pulumi.IntOutput {
	return o.ApplyT(func(v GetVCPUServerNic) int { return v.DeviceNumber }).(pulumi.IntOutput)
}

// Indicates if the nic will reserve an IP using DHCP
func (o GetVCPUServerNicOutput) Dhcp() pulumi.BoolOutput {
	return o.ApplyT(func(v GetVCPUServerNic) bool { return v.Dhcp }).(pulumi.BoolOutput)
}

func (o GetVCPUServerNicOutput) Dhcpv6() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v GetVCPUServerNic) *bool { return v.Dhcpv6 }).(pulumi.BoolPtrOutput)
}

// Activate or deactivate the firewall
func (o GetVCPUServerNicOutput) FirewallActive() pulumi.BoolOutput {
	return o.ApplyT(func(v GetVCPUServerNic) bool { return v.FirewallActive }).(pulumi.BoolOutput)
}

// list of
func (o GetVCPUServerNicOutput) FirewallRules() GetVCPUServerNicFirewallRuleArrayOutput {
	return o.ApplyT(func(v GetVCPUServerNic) []GetVCPUServerNicFirewallRule { return v.FirewallRules }).(GetVCPUServerNicFirewallRuleArrayOutput)
}

// The type of firewall rules that will be allowed on the NIC
func (o GetVCPUServerNicOutput) FirewallType() pulumi.StringOutput {
	return o.ApplyT(func(v GetVCPUServerNic) string { return v.FirewallType }).(pulumi.StringOutput)
}

// ID of the server you want to search for.
//
// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
func (o GetVCPUServerNicOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v GetVCPUServerNic) string { return v.Id }).(pulumi.StringOutput)
}

// Collection of IP addresses assigned to a nic
func (o GetVCPUServerNicOutput) Ips() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetVCPUServerNic) []string { return v.Ips }).(pulumi.StringArrayOutput)
}

func (o GetVCPUServerNicOutput) Ipv6CidrBlock() pulumi.StringOutput {
	return o.ApplyT(func(v GetVCPUServerNic) string { return v.Ipv6CidrBlock }).(pulumi.StringOutput)
}

func (o GetVCPUServerNicOutput) Ipv6Ips() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetVCPUServerNic) []string { return v.Ipv6Ips }).(pulumi.StringArrayOutput)
}

// The LAN ID the NIC will sit on
func (o GetVCPUServerNicOutput) Lan() pulumi.IntOutput {
	return o.ApplyT(func(v GetVCPUServerNic) int { return v.Lan }).(pulumi.IntOutput)
}

// The MAC address of the NIC
func (o GetVCPUServerNicOutput) Mac() pulumi.StringOutput {
	return o.ApplyT(func(v GetVCPUServerNic) string { return v.Mac }).(pulumi.StringOutput)
}

// Name of an existing server that you want to search for.
func (o GetVCPUServerNicOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GetVCPUServerNic) string { return v.Name }).(pulumi.StringOutput)
}

// The PCI slot number of the Nic
func (o GetVCPUServerNicOutput) PciSlot() pulumi.IntOutput {
	return o.ApplyT(func(v GetVCPUServerNic) int { return v.PciSlot }).(pulumi.IntOutput)
}

type GetVCPUServerNicArrayOutput struct{ *pulumi.OutputState }

func (GetVCPUServerNicArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetVCPUServerNic)(nil)).Elem()
}

func (o GetVCPUServerNicArrayOutput) ToGetVCPUServerNicArrayOutput() GetVCPUServerNicArrayOutput {
	return o
}

func (o GetVCPUServerNicArrayOutput) ToGetVCPUServerNicArrayOutputWithContext(ctx context.Context) GetVCPUServerNicArrayOutput {
	return o
}

func (o GetVCPUServerNicArrayOutput) Index(i pulumi.IntInput) GetVCPUServerNicOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetVCPUServerNic {
		return vs[0].([]GetVCPUServerNic)[vs[1].(int)]
	}).(GetVCPUServerNicOutput)
}

type GetVCPUServerNicFirewallRule struct {
	// Defines the allowed code (from 0 to 254) if protocol ICMP is chosen
	IcmpCode int `pulumi:"icmpCode"`
	// Defines the allowed type (from 0 to 254) if the protocol ICMP is chosen
	IcmpType int `pulumi:"icmpType"`
	// ID of the server you want to search for.
	//
	// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
	Id string `pulumi:"id"`
	// Name of an existing server that you want to search for.
	Name string `pulumi:"name"`
	// Defines the end range of the allowed port (from 1 to 65534) if the protocol TCP or UDP is chosen
	PortRangeEnd int `pulumi:"portRangeEnd"`
	// Defines the start range of the allowed port (from 1 to 65534) if protocol TCP or UDP is chosen
	PortRangeStart int `pulumi:"portRangeStart"`
	// he protocol for the rule
	Protocol string `pulumi:"protocol"`
	// Only traffic originating from the respective IPv4 address is allowed. Value null allows all source IPs
	SourceIp string `pulumi:"sourceIp"`
	// Only traffic originating from the respective MAC address is allowed
	SourceMac string `pulumi:"sourceMac"`
	// In case the target NIC has multiple IP addresses, only traffic directed to the respective IP address of the NIC is allowed
	TargetIp string `pulumi:"targetIp"`
	// The type of firewall rule
	Type string `pulumi:"type"`
}

// GetVCPUServerNicFirewallRuleInput is an input type that accepts GetVCPUServerNicFirewallRuleArgs and GetVCPUServerNicFirewallRuleOutput values.
// You can construct a concrete instance of `GetVCPUServerNicFirewallRuleInput` via:
//
//	GetVCPUServerNicFirewallRuleArgs{...}
type GetVCPUServerNicFirewallRuleInput interface {
	pulumi.Input

	ToGetVCPUServerNicFirewallRuleOutput() GetVCPUServerNicFirewallRuleOutput
	ToGetVCPUServerNicFirewallRuleOutputWithContext(context.Context) GetVCPUServerNicFirewallRuleOutput
}

type GetVCPUServerNicFirewallRuleArgs struct {
	// Defines the allowed code (from 0 to 254) if protocol ICMP is chosen
	IcmpCode pulumi.IntInput `pulumi:"icmpCode"`
	// Defines the allowed type (from 0 to 254) if the protocol ICMP is chosen
	IcmpType pulumi.IntInput `pulumi:"icmpType"`
	// ID of the server you want to search for.
	//
	// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
	Id pulumi.StringInput `pulumi:"id"`
	// Name of an existing server that you want to search for.
	Name pulumi.StringInput `pulumi:"name"`
	// Defines the end range of the allowed port (from 1 to 65534) if the protocol TCP or UDP is chosen
	PortRangeEnd pulumi.IntInput `pulumi:"portRangeEnd"`
	// Defines the start range of the allowed port (from 1 to 65534) if protocol TCP or UDP is chosen
	PortRangeStart pulumi.IntInput `pulumi:"portRangeStart"`
	// he protocol for the rule
	Protocol pulumi.StringInput `pulumi:"protocol"`
	// Only traffic originating from the respective IPv4 address is allowed. Value null allows all source IPs
	SourceIp pulumi.StringInput `pulumi:"sourceIp"`
	// Only traffic originating from the respective MAC address is allowed
	SourceMac pulumi.StringInput `pulumi:"sourceMac"`
	// In case the target NIC has multiple IP addresses, only traffic directed to the respective IP address of the NIC is allowed
	TargetIp pulumi.StringInput `pulumi:"targetIp"`
	// The type of firewall rule
	Type pulumi.StringInput `pulumi:"type"`
}

func (GetVCPUServerNicFirewallRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetVCPUServerNicFirewallRule)(nil)).Elem()
}

func (i GetVCPUServerNicFirewallRuleArgs) ToGetVCPUServerNicFirewallRuleOutput() GetVCPUServerNicFirewallRuleOutput {
	return i.ToGetVCPUServerNicFirewallRuleOutputWithContext(context.Background())
}

func (i GetVCPUServerNicFirewallRuleArgs) ToGetVCPUServerNicFirewallRuleOutputWithContext(ctx context.Context) GetVCPUServerNicFirewallRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetVCPUServerNicFirewallRuleOutput)
}

// GetVCPUServerNicFirewallRuleArrayInput is an input type that accepts GetVCPUServerNicFirewallRuleArray and GetVCPUServerNicFirewallRuleArrayOutput values.
// You can construct a concrete instance of `GetVCPUServerNicFirewallRuleArrayInput` via:
//
//	GetVCPUServerNicFirewallRuleArray{ GetVCPUServerNicFirewallRuleArgs{...} }
type GetVCPUServerNicFirewallRuleArrayInput interface {
	pulumi.Input

	ToGetVCPUServerNicFirewallRuleArrayOutput() GetVCPUServerNicFirewallRuleArrayOutput
	ToGetVCPUServerNicFirewallRuleArrayOutputWithContext(context.Context) GetVCPUServerNicFirewallRuleArrayOutput
}

type GetVCPUServerNicFirewallRuleArray []GetVCPUServerNicFirewallRuleInput

func (GetVCPUServerNicFirewallRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetVCPUServerNicFirewallRule)(nil)).Elem()
}

func (i GetVCPUServerNicFirewallRuleArray) ToGetVCPUServerNicFirewallRuleArrayOutput() GetVCPUServerNicFirewallRuleArrayOutput {
	return i.ToGetVCPUServerNicFirewallRuleArrayOutputWithContext(context.Background())
}

func (i GetVCPUServerNicFirewallRuleArray) ToGetVCPUServerNicFirewallRuleArrayOutputWithContext(ctx context.Context) GetVCPUServerNicFirewallRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetVCPUServerNicFirewallRuleArrayOutput)
}

type GetVCPUServerNicFirewallRuleOutput struct{ *pulumi.OutputState }

func (GetVCPUServerNicFirewallRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetVCPUServerNicFirewallRule)(nil)).Elem()
}

func (o GetVCPUServerNicFirewallRuleOutput) ToGetVCPUServerNicFirewallRuleOutput() GetVCPUServerNicFirewallRuleOutput {
	return o
}

func (o GetVCPUServerNicFirewallRuleOutput) ToGetVCPUServerNicFirewallRuleOutputWithContext(ctx context.Context) GetVCPUServerNicFirewallRuleOutput {
	return o
}

// Defines the allowed code (from 0 to 254) if protocol ICMP is chosen
func (o GetVCPUServerNicFirewallRuleOutput) IcmpCode() pulumi.IntOutput {
	return o.ApplyT(func(v GetVCPUServerNicFirewallRule) int { return v.IcmpCode }).(pulumi.IntOutput)
}

// Defines the allowed type (from 0 to 254) if the protocol ICMP is chosen
func (o GetVCPUServerNicFirewallRuleOutput) IcmpType() pulumi.IntOutput {
	return o.ApplyT(func(v GetVCPUServerNicFirewallRule) int { return v.IcmpType }).(pulumi.IntOutput)
}

// ID of the server you want to search for.
//
// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
func (o GetVCPUServerNicFirewallRuleOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v GetVCPUServerNicFirewallRule) string { return v.Id }).(pulumi.StringOutput)
}

// Name of an existing server that you want to search for.
func (o GetVCPUServerNicFirewallRuleOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GetVCPUServerNicFirewallRule) string { return v.Name }).(pulumi.StringOutput)
}

// Defines the end range of the allowed port (from 1 to 65534) if the protocol TCP or UDP is chosen
func (o GetVCPUServerNicFirewallRuleOutput) PortRangeEnd() pulumi.IntOutput {
	return o.ApplyT(func(v GetVCPUServerNicFirewallRule) int { return v.PortRangeEnd }).(pulumi.IntOutput)
}

// Defines the start range of the allowed port (from 1 to 65534) if protocol TCP or UDP is chosen
func (o GetVCPUServerNicFirewallRuleOutput) PortRangeStart() pulumi.IntOutput {
	return o.ApplyT(func(v GetVCPUServerNicFirewallRule) int { return v.PortRangeStart }).(pulumi.IntOutput)
}

// he protocol for the rule
func (o GetVCPUServerNicFirewallRuleOutput) Protocol() pulumi.StringOutput {
	return o.ApplyT(func(v GetVCPUServerNicFirewallRule) string { return v.Protocol }).(pulumi.StringOutput)
}

// Only traffic originating from the respective IPv4 address is allowed. Value null allows all source IPs
func (o GetVCPUServerNicFirewallRuleOutput) SourceIp() pulumi.StringOutput {
	return o.ApplyT(func(v GetVCPUServerNicFirewallRule) string { return v.SourceIp }).(pulumi.StringOutput)
}

// Only traffic originating from the respective MAC address is allowed
func (o GetVCPUServerNicFirewallRuleOutput) SourceMac() pulumi.StringOutput {
	return o.ApplyT(func(v GetVCPUServerNicFirewallRule) string { return v.SourceMac }).(pulumi.StringOutput)
}

// In case the target NIC has multiple IP addresses, only traffic directed to the respective IP address of the NIC is allowed
func (o GetVCPUServerNicFirewallRuleOutput) TargetIp() pulumi.StringOutput {
	return o.ApplyT(func(v GetVCPUServerNicFirewallRule) string { return v.TargetIp }).(pulumi.StringOutput)
}

// The type of firewall rule
func (o GetVCPUServerNicFirewallRuleOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v GetVCPUServerNicFirewallRule) string { return v.Type }).(pulumi.StringOutput)
}

type GetVCPUServerNicFirewallRuleArrayOutput struct{ *pulumi.OutputState }

func (GetVCPUServerNicFirewallRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetVCPUServerNicFirewallRule)(nil)).Elem()
}

func (o GetVCPUServerNicFirewallRuleArrayOutput) ToGetVCPUServerNicFirewallRuleArrayOutput() GetVCPUServerNicFirewallRuleArrayOutput {
	return o
}

func (o GetVCPUServerNicFirewallRuleArrayOutput) ToGetVCPUServerNicFirewallRuleArrayOutputWithContext(ctx context.Context) GetVCPUServerNicFirewallRuleArrayOutput {
	return o
}

func (o GetVCPUServerNicFirewallRuleArrayOutput) Index(i pulumi.IntInput) GetVCPUServerNicFirewallRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetVCPUServerNicFirewallRule {
		return vs[0].([]GetVCPUServerNicFirewallRule)[vs[1].(int)]
	}).(GetVCPUServerNicFirewallRuleOutput)
}

type GetVCPUServerVolume struct {
	// The availability zone in which the volume should exist
	AvailabilityZone string `pulumi:"availabilityZone"`
	// The uuid of the Backup Unit that user has access to
	BackupUnitId string `pulumi:"backupUnitId"`
	// The UUID of the attached server.
	BootServer string `pulumi:"bootServer"`
	// The bus type of the volume
	Bus string `pulumi:"bus"`
	// Is capable of CPU hot plug (no reboot required)
	CpuHotPlug bool `pulumi:"cpuHotPlug"`
	// The Logical Unit Number (LUN) of the storage volume
	DeviceNumber int `pulumi:"deviceNumber"`
	// Is capable of Virt-IO drive hot plug (no reboot required)
	DiscVirtioHotPlug bool `pulumi:"discVirtioHotPlug"`
	// Is capable of Virt-IO drive hot unplug (no reboot required)
	DiscVirtioHotUnplug bool `pulumi:"discVirtioHotUnplug"`
	// ID of the server you want to search for.
	//
	// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
	Id        string `pulumi:"id"`
	ImageName string `pulumi:"imageName"`
	// Initial password to be set for installed OS
	ImagePassword string `pulumi:"imagePassword"`
	// OS type of this volume
	LicenceType string `pulumi:"licenceType"`
	// Name of an existing server that you want to search for.
	Name string `pulumi:"name"`
	// Is capable of nic hot plug (no reboot required)
	NicHotPlug bool `pulumi:"nicHotPlug"`
	// Is capable of nic hot unplug (no reboot required)
	NicHotUnplug bool `pulumi:"nicHotUnplug"`
	// The PCI slot number of the Nic
	PciSlot int `pulumi:"pciSlot"`
	// Is capable of memory hot plug (no reboot required)
	RamHotPlug bool `pulumi:"ramHotPlug"`
	// The size of the volume in GB
	Size int `pulumi:"size"`
	// Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key
	SshKeys []string `pulumi:"sshKeys"`
	// The type of firewall rule
	Type string `pulumi:"type"`
	// The cloud-init configuration for the volume as base64 encoded string
	UserData *string `pulumi:"userData"`
}

// GetVCPUServerVolumeInput is an input type that accepts GetVCPUServerVolumeArgs and GetVCPUServerVolumeOutput values.
// You can construct a concrete instance of `GetVCPUServerVolumeInput` via:
//
//	GetVCPUServerVolumeArgs{...}
type GetVCPUServerVolumeInput interface {
	pulumi.Input

	ToGetVCPUServerVolumeOutput() GetVCPUServerVolumeOutput
	ToGetVCPUServerVolumeOutputWithContext(context.Context) GetVCPUServerVolumeOutput
}

type GetVCPUServerVolumeArgs struct {
	// The availability zone in which the volume should exist
	AvailabilityZone pulumi.StringInput `pulumi:"availabilityZone"`
	// The uuid of the Backup Unit that user has access to
	BackupUnitId pulumi.StringInput `pulumi:"backupUnitId"`
	// The UUID of the attached server.
	BootServer pulumi.StringInput `pulumi:"bootServer"`
	// The bus type of the volume
	Bus pulumi.StringInput `pulumi:"bus"`
	// Is capable of CPU hot plug (no reboot required)
	CpuHotPlug pulumi.BoolInput `pulumi:"cpuHotPlug"`
	// The Logical Unit Number (LUN) of the storage volume
	DeviceNumber pulumi.IntInput `pulumi:"deviceNumber"`
	// Is capable of Virt-IO drive hot plug (no reboot required)
	DiscVirtioHotPlug pulumi.BoolInput `pulumi:"discVirtioHotPlug"`
	// Is capable of Virt-IO drive hot unplug (no reboot required)
	DiscVirtioHotUnplug pulumi.BoolInput `pulumi:"discVirtioHotUnplug"`
	// ID of the server you want to search for.
	//
	// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
	Id        pulumi.StringInput `pulumi:"id"`
	ImageName pulumi.StringInput `pulumi:"imageName"`
	// Initial password to be set for installed OS
	ImagePassword pulumi.StringInput `pulumi:"imagePassword"`
	// OS type of this volume
	LicenceType pulumi.StringInput `pulumi:"licenceType"`
	// Name of an existing server that you want to search for.
	Name pulumi.StringInput `pulumi:"name"`
	// Is capable of nic hot plug (no reboot required)
	NicHotPlug pulumi.BoolInput `pulumi:"nicHotPlug"`
	// Is capable of nic hot unplug (no reboot required)
	NicHotUnplug pulumi.BoolInput `pulumi:"nicHotUnplug"`
	// The PCI slot number of the Nic
	PciSlot pulumi.IntInput `pulumi:"pciSlot"`
	// Is capable of memory hot plug (no reboot required)
	RamHotPlug pulumi.BoolInput `pulumi:"ramHotPlug"`
	// The size of the volume in GB
	Size pulumi.IntInput `pulumi:"size"`
	// Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key
	SshKeys pulumi.StringArrayInput `pulumi:"sshKeys"`
	// The type of firewall rule
	Type pulumi.StringInput `pulumi:"type"`
	// The cloud-init configuration for the volume as base64 encoded string
	UserData pulumi.StringPtrInput `pulumi:"userData"`
}

func (GetVCPUServerVolumeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetVCPUServerVolume)(nil)).Elem()
}

func (i GetVCPUServerVolumeArgs) ToGetVCPUServerVolumeOutput() GetVCPUServerVolumeOutput {
	return i.ToGetVCPUServerVolumeOutputWithContext(context.Background())
}

func (i GetVCPUServerVolumeArgs) ToGetVCPUServerVolumeOutputWithContext(ctx context.Context) GetVCPUServerVolumeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetVCPUServerVolumeOutput)
}

// GetVCPUServerVolumeArrayInput is an input type that accepts GetVCPUServerVolumeArray and GetVCPUServerVolumeArrayOutput values.
// You can construct a concrete instance of `GetVCPUServerVolumeArrayInput` via:
//
//	GetVCPUServerVolumeArray{ GetVCPUServerVolumeArgs{...} }
type GetVCPUServerVolumeArrayInput interface {
	pulumi.Input

	ToGetVCPUServerVolumeArrayOutput() GetVCPUServerVolumeArrayOutput
	ToGetVCPUServerVolumeArrayOutputWithContext(context.Context) GetVCPUServerVolumeArrayOutput
}

type GetVCPUServerVolumeArray []GetVCPUServerVolumeInput

func (GetVCPUServerVolumeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetVCPUServerVolume)(nil)).Elem()
}

func (i GetVCPUServerVolumeArray) ToGetVCPUServerVolumeArrayOutput() GetVCPUServerVolumeArrayOutput {
	return i.ToGetVCPUServerVolumeArrayOutputWithContext(context.Background())
}

func (i GetVCPUServerVolumeArray) ToGetVCPUServerVolumeArrayOutputWithContext(ctx context.Context) GetVCPUServerVolumeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetVCPUServerVolumeArrayOutput)
}

type GetVCPUServerVolumeOutput struct{ *pulumi.OutputState }

func (GetVCPUServerVolumeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetVCPUServerVolume)(nil)).Elem()
}

func (o GetVCPUServerVolumeOutput) ToGetVCPUServerVolumeOutput() GetVCPUServerVolumeOutput {
	return o
}

func (o GetVCPUServerVolumeOutput) ToGetVCPUServerVolumeOutputWithContext(ctx context.Context) GetVCPUServerVolumeOutput {
	return o
}

// The availability zone in which the volume should exist
func (o GetVCPUServerVolumeOutput) AvailabilityZone() pulumi.StringOutput {
	return o.ApplyT(func(v GetVCPUServerVolume) string { return v.AvailabilityZone }).(pulumi.StringOutput)
}

// The uuid of the Backup Unit that user has access to
func (o GetVCPUServerVolumeOutput) BackupUnitId() pulumi.StringOutput {
	return o.ApplyT(func(v GetVCPUServerVolume) string { return v.BackupUnitId }).(pulumi.StringOutput)
}

// The UUID of the attached server.
func (o GetVCPUServerVolumeOutput) BootServer() pulumi.StringOutput {
	return o.ApplyT(func(v GetVCPUServerVolume) string { return v.BootServer }).(pulumi.StringOutput)
}

// The bus type of the volume
func (o GetVCPUServerVolumeOutput) Bus() pulumi.StringOutput {
	return o.ApplyT(func(v GetVCPUServerVolume) string { return v.Bus }).(pulumi.StringOutput)
}

// Is capable of CPU hot plug (no reboot required)
func (o GetVCPUServerVolumeOutput) CpuHotPlug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetVCPUServerVolume) bool { return v.CpuHotPlug }).(pulumi.BoolOutput)
}

// The Logical Unit Number (LUN) of the storage volume
func (o GetVCPUServerVolumeOutput) DeviceNumber() pulumi.IntOutput {
	return o.ApplyT(func(v GetVCPUServerVolume) int { return v.DeviceNumber }).(pulumi.IntOutput)
}

// Is capable of Virt-IO drive hot plug (no reboot required)
func (o GetVCPUServerVolumeOutput) DiscVirtioHotPlug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetVCPUServerVolume) bool { return v.DiscVirtioHotPlug }).(pulumi.BoolOutput)
}

// Is capable of Virt-IO drive hot unplug (no reboot required)
func (o GetVCPUServerVolumeOutput) DiscVirtioHotUnplug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetVCPUServerVolume) bool { return v.DiscVirtioHotUnplug }).(pulumi.BoolOutput)
}

// ID of the server you want to search for.
//
// `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
func (o GetVCPUServerVolumeOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v GetVCPUServerVolume) string { return v.Id }).(pulumi.StringOutput)
}

func (o GetVCPUServerVolumeOutput) ImageName() pulumi.StringOutput {
	return o.ApplyT(func(v GetVCPUServerVolume) string { return v.ImageName }).(pulumi.StringOutput)
}

// Initial password to be set for installed OS
func (o GetVCPUServerVolumeOutput) ImagePassword() pulumi.StringOutput {
	return o.ApplyT(func(v GetVCPUServerVolume) string { return v.ImagePassword }).(pulumi.StringOutput)
}

// OS type of this volume
func (o GetVCPUServerVolumeOutput) LicenceType() pulumi.StringOutput {
	return o.ApplyT(func(v GetVCPUServerVolume) string { return v.LicenceType }).(pulumi.StringOutput)
}

// Name of an existing server that you want to search for.
func (o GetVCPUServerVolumeOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GetVCPUServerVolume) string { return v.Name }).(pulumi.StringOutput)
}

// Is capable of nic hot plug (no reboot required)
func (o GetVCPUServerVolumeOutput) NicHotPlug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetVCPUServerVolume) bool { return v.NicHotPlug }).(pulumi.BoolOutput)
}

// Is capable of nic hot unplug (no reboot required)
func (o GetVCPUServerVolumeOutput) NicHotUnplug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetVCPUServerVolume) bool { return v.NicHotUnplug }).(pulumi.BoolOutput)
}

// The PCI slot number of the Nic
func (o GetVCPUServerVolumeOutput) PciSlot() pulumi.IntOutput {
	return o.ApplyT(func(v GetVCPUServerVolume) int { return v.PciSlot }).(pulumi.IntOutput)
}

// Is capable of memory hot plug (no reboot required)
func (o GetVCPUServerVolumeOutput) RamHotPlug() pulumi.BoolOutput {
	return o.ApplyT(func(v GetVCPUServerVolume) bool { return v.RamHotPlug }).(pulumi.BoolOutput)
}

// The size of the volume in GB
func (o GetVCPUServerVolumeOutput) Size() pulumi.IntOutput {
	return o.ApplyT(func(v GetVCPUServerVolume) int { return v.Size }).(pulumi.IntOutput)
}

// Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key
func (o GetVCPUServerVolumeOutput) SshKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetVCPUServerVolume) []string { return v.SshKeys }).(pulumi.StringArrayOutput)
}

// The type of firewall rule
func (o GetVCPUServerVolumeOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v GetVCPUServerVolume) string { return v.Type }).(pulumi.StringOutput)
}

// The cloud-init configuration for the volume as base64 encoded string
func (o GetVCPUServerVolumeOutput) UserData() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetVCPUServerVolume) *string { return v.UserData }).(pulumi.StringPtrOutput)
}

type GetVCPUServerVolumeArrayOutput struct{ *pulumi.OutputState }

func (GetVCPUServerVolumeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetVCPUServerVolume)(nil)).Elem()
}

func (o GetVCPUServerVolumeArrayOutput) ToGetVCPUServerVolumeArrayOutput() GetVCPUServerVolumeArrayOutput {
	return o
}

func (o GetVCPUServerVolumeArrayOutput) ToGetVCPUServerVolumeArrayOutputWithContext(ctx context.Context) GetVCPUServerVolumeArrayOutput {
	return o
}

func (o GetVCPUServerVolumeArrayOutput) Index(i pulumi.IntInput) GetVCPUServerVolumeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetVCPUServerVolume {
		return vs[0].([]GetVCPUServerVolume)[vs[1].(int)]
	}).(GetVCPUServerVolumeOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*CrossconnectConnectableDatacenterInput)(nil)).Elem(), CrossconnectConnectableDatacenterArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CrossconnectConnectableDatacenterArrayInput)(nil)).Elem(), CrossconnectConnectableDatacenterArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*CrossconnectPeerInput)(nil)).Elem(), CrossconnectPeerArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CrossconnectPeerArrayInput)(nil)).Elem(), CrossconnectPeerArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*CubeServerNicInput)(nil)).Elem(), CubeServerNicArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CubeServerNicPtrInput)(nil)).Elem(), CubeServerNicArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CubeServerNicFirewallInput)(nil)).Elem(), CubeServerNicFirewallArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CubeServerNicFirewallPtrInput)(nil)).Elem(), CubeServerNicFirewallArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CubeServerVolumeInput)(nil)).Elem(), CubeServerVolumeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CubeServerVolumePtrInput)(nil)).Elem(), CubeServerVolumeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DatacenterCpuArchitectureInput)(nil)).Elem(), DatacenterCpuArchitectureArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DatacenterCpuArchitectureArrayInput)(nil)).Elem(), DatacenterCpuArchitectureArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GroupUserInput)(nil)).Elem(), GroupUserArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GroupUserArrayInput)(nil)).Elem(), GroupUserArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*IPBlockIpConsumerInput)(nil)).Elem(), IPBlockIpConsumerArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*IPBlockIpConsumerArrayInput)(nil)).Elem(), IPBlockIpConsumerArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LanIpFailoverInput)(nil)).Elem(), LanIpFailoverArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LanIpFailoverArrayInput)(nil)).Elem(), LanIpFailoverArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*NatGatewayLanInput)(nil)).Elem(), NatGatewayLanArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NatGatewayLanArrayInput)(nil)).Elem(), NatGatewayLanArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*NatGatewayRuleTargetPortRangeInput)(nil)).Elem(), NatGatewayRuleTargetPortRangeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NatGatewayRuleTargetPortRangePtrInput)(nil)).Elem(), NatGatewayRuleTargetPortRangeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NicFlowlogInput)(nil)).Elem(), NicFlowlogArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NicFlowlogPtrInput)(nil)).Elem(), NicFlowlogArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ServerLabelInput)(nil)).Elem(), ServerLabelArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ServerLabelArrayInput)(nil)).Elem(), ServerLabelArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ServerNicInput)(nil)).Elem(), ServerNicArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ServerNicPtrInput)(nil)).Elem(), ServerNicArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ServerNicFirewallInput)(nil)).Elem(), ServerNicFirewallArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ServerNicFirewallArrayInput)(nil)).Elem(), ServerNicFirewallArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ServerVolumeInput)(nil)).Elem(), ServerVolumeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ServerVolumePtrInput)(nil)).Elem(), ServerVolumeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*VCPUServerLabelInput)(nil)).Elem(), VCPUServerLabelArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*VCPUServerLabelArrayInput)(nil)).Elem(), VCPUServerLabelArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*VCPUServerNicInput)(nil)).Elem(), VCPUServerNicArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*VCPUServerNicPtrInput)(nil)).Elem(), VCPUServerNicArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*VCPUServerNicFirewallInput)(nil)).Elem(), VCPUServerNicFirewallArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*VCPUServerNicFirewallArrayInput)(nil)).Elem(), VCPUServerNicFirewallArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*VCPUServerVolumeInput)(nil)).Elem(), VCPUServerVolumeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*VCPUServerVolumePtrInput)(nil)).Elem(), VCPUServerVolumeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCrossconnectConnectableDatacenterInput)(nil)).Elem(), GetCrossconnectConnectableDatacenterArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCrossconnectConnectableDatacenterArrayInput)(nil)).Elem(), GetCrossconnectConnectableDatacenterArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCrossconnectPeerInput)(nil)).Elem(), GetCrossconnectPeerArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCrossconnectPeerArrayInput)(nil)).Elem(), GetCrossconnectPeerArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCubeServerCdromInput)(nil)).Elem(), GetCubeServerCdromArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCubeServerCdromArrayInput)(nil)).Elem(), GetCubeServerCdromArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCubeServerNicInput)(nil)).Elem(), GetCubeServerNicArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCubeServerNicArrayInput)(nil)).Elem(), GetCubeServerNicArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCubeServerNicFirewallRuleInput)(nil)).Elem(), GetCubeServerNicFirewallRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCubeServerNicFirewallRuleArrayInput)(nil)).Elem(), GetCubeServerNicFirewallRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCubeServerVolumeInput)(nil)).Elem(), GetCubeServerVolumeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetCubeServerVolumeArrayInput)(nil)).Elem(), GetCubeServerVolumeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetDatacenterCpuArchitectureInput)(nil)).Elem(), GetDatacenterCpuArchitectureArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetDatacenterCpuArchitectureArrayInput)(nil)).Elem(), GetDatacenterCpuArchitectureArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetGroupUserInput)(nil)).Elem(), GetGroupUserArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetGroupUserArrayInput)(nil)).Elem(), GetGroupUserArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetIPBlockIpConsumerInput)(nil)).Elem(), GetIPBlockIpConsumerArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetIPBlockIpConsumerArrayInput)(nil)).Elem(), GetIPBlockIpConsumerArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetLanIpFailoverInput)(nil)).Elem(), GetLanIpFailoverArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetLanIpFailoverArrayInput)(nil)).Elem(), GetLanIpFailoverArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetNatGatewayLanInput)(nil)).Elem(), GetNatGatewayLanArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetNatGatewayLanArrayInput)(nil)).Elem(), GetNatGatewayLanArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetNatGatewayRuleTargetPortRangeInput)(nil)).Elem(), GetNatGatewayRuleTargetPortRangeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetNatGatewayRuleTargetPortRangeArrayInput)(nil)).Elem(), GetNatGatewayRuleTargetPortRangeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetNicFlowlogInput)(nil)).Elem(), GetNicFlowlogArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetNicFlowlogArrayInput)(nil)).Elem(), GetNicFlowlogArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetServerCdromInput)(nil)).Elem(), GetServerCdromArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetServerCdromArrayInput)(nil)).Elem(), GetServerCdromArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetServerLabelInput)(nil)).Elem(), GetServerLabelArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetServerLabelArrayInput)(nil)).Elem(), GetServerLabelArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetServerNicInput)(nil)).Elem(), GetServerNicArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetServerNicArrayInput)(nil)).Elem(), GetServerNicArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetServerNicFirewallRuleInput)(nil)).Elem(), GetServerNicFirewallRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetServerNicFirewallRuleArrayInput)(nil)).Elem(), GetServerNicFirewallRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetServerVolumeInput)(nil)).Elem(), GetServerVolumeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetServerVolumeArrayInput)(nil)).Elem(), GetServerVolumeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetUserGroupInput)(nil)).Elem(), GetUserGroupArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetUserGroupArrayInput)(nil)).Elem(), GetUserGroupArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetVCPUServerCdromInput)(nil)).Elem(), GetVCPUServerCdromArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetVCPUServerCdromArrayInput)(nil)).Elem(), GetVCPUServerCdromArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetVCPUServerLabelInput)(nil)).Elem(), GetVCPUServerLabelArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetVCPUServerLabelArrayInput)(nil)).Elem(), GetVCPUServerLabelArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetVCPUServerNicInput)(nil)).Elem(), GetVCPUServerNicArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetVCPUServerNicArrayInput)(nil)).Elem(), GetVCPUServerNicArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetVCPUServerNicFirewallRuleInput)(nil)).Elem(), GetVCPUServerNicFirewallRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetVCPUServerNicFirewallRuleArrayInput)(nil)).Elem(), GetVCPUServerNicFirewallRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetVCPUServerVolumeInput)(nil)).Elem(), GetVCPUServerVolumeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetVCPUServerVolumeArrayInput)(nil)).Elem(), GetVCPUServerVolumeArray{})
	pulumi.RegisterOutputType(CrossconnectConnectableDatacenterOutput{})
	pulumi.RegisterOutputType(CrossconnectConnectableDatacenterArrayOutput{})
	pulumi.RegisterOutputType(CrossconnectPeerOutput{})
	pulumi.RegisterOutputType(CrossconnectPeerArrayOutput{})
	pulumi.RegisterOutputType(CubeServerNicOutput{})
	pulumi.RegisterOutputType(CubeServerNicPtrOutput{})
	pulumi.RegisterOutputType(CubeServerNicFirewallOutput{})
	pulumi.RegisterOutputType(CubeServerNicFirewallPtrOutput{})
	pulumi.RegisterOutputType(CubeServerVolumeOutput{})
	pulumi.RegisterOutputType(CubeServerVolumePtrOutput{})
	pulumi.RegisterOutputType(DatacenterCpuArchitectureOutput{})
	pulumi.RegisterOutputType(DatacenterCpuArchitectureArrayOutput{})
	pulumi.RegisterOutputType(GroupUserOutput{})
	pulumi.RegisterOutputType(GroupUserArrayOutput{})
	pulumi.RegisterOutputType(IPBlockIpConsumerOutput{})
	pulumi.RegisterOutputType(IPBlockIpConsumerArrayOutput{})
	pulumi.RegisterOutputType(LanIpFailoverOutput{})
	pulumi.RegisterOutputType(LanIpFailoverArrayOutput{})
	pulumi.RegisterOutputType(NatGatewayLanOutput{})
	pulumi.RegisterOutputType(NatGatewayLanArrayOutput{})
	pulumi.RegisterOutputType(NatGatewayRuleTargetPortRangeOutput{})
	pulumi.RegisterOutputType(NatGatewayRuleTargetPortRangePtrOutput{})
	pulumi.RegisterOutputType(NicFlowlogOutput{})
	pulumi.RegisterOutputType(NicFlowlogPtrOutput{})
	pulumi.RegisterOutputType(ServerLabelOutput{})
	pulumi.RegisterOutputType(ServerLabelArrayOutput{})
	pulumi.RegisterOutputType(ServerNicOutput{})
	pulumi.RegisterOutputType(ServerNicPtrOutput{})
	pulumi.RegisterOutputType(ServerNicFirewallOutput{})
	pulumi.RegisterOutputType(ServerNicFirewallArrayOutput{})
	pulumi.RegisterOutputType(ServerVolumeOutput{})
	pulumi.RegisterOutputType(ServerVolumePtrOutput{})
	pulumi.RegisterOutputType(VCPUServerLabelOutput{})
	pulumi.RegisterOutputType(VCPUServerLabelArrayOutput{})
	pulumi.RegisterOutputType(VCPUServerNicOutput{})
	pulumi.RegisterOutputType(VCPUServerNicPtrOutput{})
	pulumi.RegisterOutputType(VCPUServerNicFirewallOutput{})
	pulumi.RegisterOutputType(VCPUServerNicFirewallArrayOutput{})
	pulumi.RegisterOutputType(VCPUServerVolumeOutput{})
	pulumi.RegisterOutputType(VCPUServerVolumePtrOutput{})
	pulumi.RegisterOutputType(GetCrossconnectConnectableDatacenterOutput{})
	pulumi.RegisterOutputType(GetCrossconnectConnectableDatacenterArrayOutput{})
	pulumi.RegisterOutputType(GetCrossconnectPeerOutput{})
	pulumi.RegisterOutputType(GetCrossconnectPeerArrayOutput{})
	pulumi.RegisterOutputType(GetCubeServerCdromOutput{})
	pulumi.RegisterOutputType(GetCubeServerCdromArrayOutput{})
	pulumi.RegisterOutputType(GetCubeServerNicOutput{})
	pulumi.RegisterOutputType(GetCubeServerNicArrayOutput{})
	pulumi.RegisterOutputType(GetCubeServerNicFirewallRuleOutput{})
	pulumi.RegisterOutputType(GetCubeServerNicFirewallRuleArrayOutput{})
	pulumi.RegisterOutputType(GetCubeServerVolumeOutput{})
	pulumi.RegisterOutputType(GetCubeServerVolumeArrayOutput{})
	pulumi.RegisterOutputType(GetDatacenterCpuArchitectureOutput{})
	pulumi.RegisterOutputType(GetDatacenterCpuArchitectureArrayOutput{})
	pulumi.RegisterOutputType(GetGroupUserOutput{})
	pulumi.RegisterOutputType(GetGroupUserArrayOutput{})
	pulumi.RegisterOutputType(GetIPBlockIpConsumerOutput{})
	pulumi.RegisterOutputType(GetIPBlockIpConsumerArrayOutput{})
	pulumi.RegisterOutputType(GetLanIpFailoverOutput{})
	pulumi.RegisterOutputType(GetLanIpFailoverArrayOutput{})
	pulumi.RegisterOutputType(GetNatGatewayLanOutput{})
	pulumi.RegisterOutputType(GetNatGatewayLanArrayOutput{})
	pulumi.RegisterOutputType(GetNatGatewayRuleTargetPortRangeOutput{})
	pulumi.RegisterOutputType(GetNatGatewayRuleTargetPortRangeArrayOutput{})
	pulumi.RegisterOutputType(GetNicFlowlogOutput{})
	pulumi.RegisterOutputType(GetNicFlowlogArrayOutput{})
	pulumi.RegisterOutputType(GetServerCdromOutput{})
	pulumi.RegisterOutputType(GetServerCdromArrayOutput{})
	pulumi.RegisterOutputType(GetServerLabelOutput{})
	pulumi.RegisterOutputType(GetServerLabelArrayOutput{})
	pulumi.RegisterOutputType(GetServerNicOutput{})
	pulumi.RegisterOutputType(GetServerNicArrayOutput{})
	pulumi.RegisterOutputType(GetServerNicFirewallRuleOutput{})
	pulumi.RegisterOutputType(GetServerNicFirewallRuleArrayOutput{})
	pulumi.RegisterOutputType(GetServerVolumeOutput{})
	pulumi.RegisterOutputType(GetServerVolumeArrayOutput{})
	pulumi.RegisterOutputType(GetUserGroupOutput{})
	pulumi.RegisterOutputType(GetUserGroupArrayOutput{})
	pulumi.RegisterOutputType(GetVCPUServerCdromOutput{})
	pulumi.RegisterOutputType(GetVCPUServerCdromArrayOutput{})
	pulumi.RegisterOutputType(GetVCPUServerLabelOutput{})
	pulumi.RegisterOutputType(GetVCPUServerLabelArrayOutput{})
	pulumi.RegisterOutputType(GetVCPUServerNicOutput{})
	pulumi.RegisterOutputType(GetVCPUServerNicArrayOutput{})
	pulumi.RegisterOutputType(GetVCPUServerNicFirewallRuleOutput{})
	pulumi.RegisterOutputType(GetVCPUServerNicFirewallRuleArrayOutput{})
	pulumi.RegisterOutputType(GetVCPUServerVolumeOutput{})
	pulumi.RegisterOutputType(GetVCPUServerVolumeArrayOutput{})
}
