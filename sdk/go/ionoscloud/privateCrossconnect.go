// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package ionoscloud

import (
	"context"
	"reflect"

	"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages a **Cross Connect** on IonosCloud.
// Cross Connect allows you to connect virtual data centers (VDC) with each other using a private LAN.
// The VDCs to be connected need to belong to the same IONOS Cloud contract and location.
// You can only use private LANs for a Cross Connect connection. A LAN can only be a part of one Cross Connect.
//
// The IP addresses of the NICs used for the Cross Connect connection may not be used in more than one NIC and they need to belong to the same IP range.
//
// ## Example Usage
//
// To connect two datacenters we need 2 lans defined, one in each datacenter. After, we reference the cross-connect through which we want the connection to be established.
//
// ```go
// package main
//
// import (
//
//	"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud"
//	"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			crossConnectTestResource, err := ionoscloud.NewPrivateCrossconnect(ctx, "crossConnectTestResource", &ionoscloud.PrivateCrossconnectArgs{
//				Description: pulumi.String("CrossConnectTestResource"),
//			})
//			if err != nil {
//				return err
//			}
//			dc1, err := compute.NewDatacenter(ctx, "dc1", &compute.DatacenterArgs{
//				Location: pulumi.String("de/txl"),
//			})
//			if err != nil {
//				return err
//			}
//			dc2, err := compute.NewDatacenter(ctx, "dc2", &compute.DatacenterArgs{
//				Location: pulumi.String("de/txl"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewLan(ctx, "dc1lan", &compute.LanArgs{
//				DatacenterId: dc1.ID(),
//				Public:       pulumi.Bool(false),
//				Pcc:          crossConnectTestResource.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewLan(ctx, "dc2lan", &compute.LanArgs{
//				DatacenterId: dc2.ID(),
//				Public:       pulumi.Bool(false),
//				Pcc:          crossConnectTestResource.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// A Cross Connect resource can be imported using its `resource id`, e.g.
//
// ```sh
// $ pulumi import ionoscloud:index/privateCrossconnect:PrivateCrossconnect demo {ionoscloud_private_crossconnect_uuid}
// ```
//
// This can be helpful when you want to import cross-connects which you have already created manually or using other means, outside of terraform.
type PrivateCrossconnect struct {
	pulumi.CustomResourceState

	// A list containing all the connectable datacenters
	ConnectableDatacenters PrivateCrossconnectConnectableDatacenterArrayOutput `pulumi:"connectableDatacenters"`
	// [string] A short description for the cross-connection.
	// - `connectable datacenters` - (Computed) A list containing all the connectable datacenters
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// [string] The name of the cross-connection.
	Name pulumi.StringOutput `pulumi:"name"`
	// Lists LAN's joined to this cross connect
	Peers PrivateCrossconnectPeerArrayOutput `pulumi:"peers"`
}

// NewPrivateCrossconnect registers a new resource with the given unique name, arguments, and options.
func NewPrivateCrossconnect(ctx *pulumi.Context,
	name string, args *PrivateCrossconnectArgs, opts ...pulumi.ResourceOption) (*PrivateCrossconnect, error) {
	if args == nil {
		args = &PrivateCrossconnectArgs{}
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource PrivateCrossconnect
	err := ctx.RegisterResource("ionoscloud:index/privateCrossconnect:PrivateCrossconnect", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetPrivateCrossconnect gets an existing PrivateCrossconnect resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetPrivateCrossconnect(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *PrivateCrossconnectState, opts ...pulumi.ResourceOption) (*PrivateCrossconnect, error) {
	var resource PrivateCrossconnect
	err := ctx.ReadResource("ionoscloud:index/privateCrossconnect:PrivateCrossconnect", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering PrivateCrossconnect resources.
type privateCrossconnectState struct {
	// A list containing all the connectable datacenters
	ConnectableDatacenters []PrivateCrossconnectConnectableDatacenter `pulumi:"connectableDatacenters"`
	// [string] A short description for the cross-connection.
	// - `connectable datacenters` - (Computed) A list containing all the connectable datacenters
	Description *string `pulumi:"description"`
	// [string] The name of the cross-connection.
	Name *string `pulumi:"name"`
	// Lists LAN's joined to this cross connect
	Peers []PrivateCrossconnectPeer `pulumi:"peers"`
}

type PrivateCrossconnectState struct {
	// A list containing all the connectable datacenters
	ConnectableDatacenters PrivateCrossconnectConnectableDatacenterArrayInput
	// [string] A short description for the cross-connection.
	// - `connectable datacenters` - (Computed) A list containing all the connectable datacenters
	Description pulumi.StringPtrInput
	// [string] The name of the cross-connection.
	Name pulumi.StringPtrInput
	// Lists LAN's joined to this cross connect
	Peers PrivateCrossconnectPeerArrayInput
}

func (PrivateCrossconnectState) ElementType() reflect.Type {
	return reflect.TypeOf((*privateCrossconnectState)(nil)).Elem()
}

type privateCrossconnectArgs struct {
	// A list containing all the connectable datacenters
	ConnectableDatacenters []PrivateCrossconnectConnectableDatacenter `pulumi:"connectableDatacenters"`
	// [string] A short description for the cross-connection.
	// - `connectable datacenters` - (Computed) A list containing all the connectable datacenters
	Description *string `pulumi:"description"`
	// [string] The name of the cross-connection.
	Name *string `pulumi:"name"`
	// Lists LAN's joined to this cross connect
	Peers []PrivateCrossconnectPeer `pulumi:"peers"`
}

// The set of arguments for constructing a PrivateCrossconnect resource.
type PrivateCrossconnectArgs struct {
	// A list containing all the connectable datacenters
	ConnectableDatacenters PrivateCrossconnectConnectableDatacenterArrayInput
	// [string] A short description for the cross-connection.
	// - `connectable datacenters` - (Computed) A list containing all the connectable datacenters
	Description pulumi.StringPtrInput
	// [string] The name of the cross-connection.
	Name pulumi.StringPtrInput
	// Lists LAN's joined to this cross connect
	Peers PrivateCrossconnectPeerArrayInput
}

func (PrivateCrossconnectArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*privateCrossconnectArgs)(nil)).Elem()
}

type PrivateCrossconnectInput interface {
	pulumi.Input

	ToPrivateCrossconnectOutput() PrivateCrossconnectOutput
	ToPrivateCrossconnectOutputWithContext(ctx context.Context) PrivateCrossconnectOutput
}

func (*PrivateCrossconnect) ElementType() reflect.Type {
	return reflect.TypeOf((**PrivateCrossconnect)(nil)).Elem()
}

func (i *PrivateCrossconnect) ToPrivateCrossconnectOutput() PrivateCrossconnectOutput {
	return i.ToPrivateCrossconnectOutputWithContext(context.Background())
}

func (i *PrivateCrossconnect) ToPrivateCrossconnectOutputWithContext(ctx context.Context) PrivateCrossconnectOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PrivateCrossconnectOutput)
}

// PrivateCrossconnectArrayInput is an input type that accepts PrivateCrossconnectArray and PrivateCrossconnectArrayOutput values.
// You can construct a concrete instance of `PrivateCrossconnectArrayInput` via:
//
//	PrivateCrossconnectArray{ PrivateCrossconnectArgs{...} }
type PrivateCrossconnectArrayInput interface {
	pulumi.Input

	ToPrivateCrossconnectArrayOutput() PrivateCrossconnectArrayOutput
	ToPrivateCrossconnectArrayOutputWithContext(context.Context) PrivateCrossconnectArrayOutput
}

type PrivateCrossconnectArray []PrivateCrossconnectInput

func (PrivateCrossconnectArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*PrivateCrossconnect)(nil)).Elem()
}

func (i PrivateCrossconnectArray) ToPrivateCrossconnectArrayOutput() PrivateCrossconnectArrayOutput {
	return i.ToPrivateCrossconnectArrayOutputWithContext(context.Background())
}

func (i PrivateCrossconnectArray) ToPrivateCrossconnectArrayOutputWithContext(ctx context.Context) PrivateCrossconnectArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PrivateCrossconnectArrayOutput)
}

// PrivateCrossconnectMapInput is an input type that accepts PrivateCrossconnectMap and PrivateCrossconnectMapOutput values.
// You can construct a concrete instance of `PrivateCrossconnectMapInput` via:
//
//	PrivateCrossconnectMap{ "key": PrivateCrossconnectArgs{...} }
type PrivateCrossconnectMapInput interface {
	pulumi.Input

	ToPrivateCrossconnectMapOutput() PrivateCrossconnectMapOutput
	ToPrivateCrossconnectMapOutputWithContext(context.Context) PrivateCrossconnectMapOutput
}

type PrivateCrossconnectMap map[string]PrivateCrossconnectInput

func (PrivateCrossconnectMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*PrivateCrossconnect)(nil)).Elem()
}

func (i PrivateCrossconnectMap) ToPrivateCrossconnectMapOutput() PrivateCrossconnectMapOutput {
	return i.ToPrivateCrossconnectMapOutputWithContext(context.Background())
}

func (i PrivateCrossconnectMap) ToPrivateCrossconnectMapOutputWithContext(ctx context.Context) PrivateCrossconnectMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PrivateCrossconnectMapOutput)
}

type PrivateCrossconnectOutput struct{ *pulumi.OutputState }

func (PrivateCrossconnectOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PrivateCrossconnect)(nil)).Elem()
}

func (o PrivateCrossconnectOutput) ToPrivateCrossconnectOutput() PrivateCrossconnectOutput {
	return o
}

func (o PrivateCrossconnectOutput) ToPrivateCrossconnectOutputWithContext(ctx context.Context) PrivateCrossconnectOutput {
	return o
}

// A list containing all the connectable datacenters
func (o PrivateCrossconnectOutput) ConnectableDatacenters() PrivateCrossconnectConnectableDatacenterArrayOutput {
	return o.ApplyT(func(v *PrivateCrossconnect) PrivateCrossconnectConnectableDatacenterArrayOutput {
		return v.ConnectableDatacenters
	}).(PrivateCrossconnectConnectableDatacenterArrayOutput)
}

// [string] A short description for the cross-connection.
// - `connectable datacenters` - (Computed) A list containing all the connectable datacenters
func (o PrivateCrossconnectOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PrivateCrossconnect) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// [string] The name of the cross-connection.
func (o PrivateCrossconnectOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *PrivateCrossconnect) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Lists LAN's joined to this cross connect
func (o PrivateCrossconnectOutput) Peers() PrivateCrossconnectPeerArrayOutput {
	return o.ApplyT(func(v *PrivateCrossconnect) PrivateCrossconnectPeerArrayOutput { return v.Peers }).(PrivateCrossconnectPeerArrayOutput)
}

type PrivateCrossconnectArrayOutput struct{ *pulumi.OutputState }

func (PrivateCrossconnectArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*PrivateCrossconnect)(nil)).Elem()
}

func (o PrivateCrossconnectArrayOutput) ToPrivateCrossconnectArrayOutput() PrivateCrossconnectArrayOutput {
	return o
}

func (o PrivateCrossconnectArrayOutput) ToPrivateCrossconnectArrayOutputWithContext(ctx context.Context) PrivateCrossconnectArrayOutput {
	return o
}

func (o PrivateCrossconnectArrayOutput) Index(i pulumi.IntInput) PrivateCrossconnectOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *PrivateCrossconnect {
		return vs[0].([]*PrivateCrossconnect)[vs[1].(int)]
	}).(PrivateCrossconnectOutput)
}

type PrivateCrossconnectMapOutput struct{ *pulumi.OutputState }

func (PrivateCrossconnectMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*PrivateCrossconnect)(nil)).Elem()
}

func (o PrivateCrossconnectMapOutput) ToPrivateCrossconnectMapOutput() PrivateCrossconnectMapOutput {
	return o
}

func (o PrivateCrossconnectMapOutput) ToPrivateCrossconnectMapOutputWithContext(ctx context.Context) PrivateCrossconnectMapOutput {
	return o
}

func (o PrivateCrossconnectMapOutput) MapIndex(k pulumi.StringInput) PrivateCrossconnectOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *PrivateCrossconnect {
		return vs[0].(map[string]*PrivateCrossconnect)[vs[1].(string)]
	}).(PrivateCrossconnectOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*PrivateCrossconnectInput)(nil)).Elem(), &PrivateCrossconnect{})
	pulumi.RegisterInputType(reflect.TypeOf((*PrivateCrossconnectArrayInput)(nil)).Elem(), PrivateCrossconnectArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*PrivateCrossconnectMapInput)(nil)).Elem(), PrivateCrossconnectMap{})
	pulumi.RegisterOutputType(PrivateCrossconnectOutput{})
	pulumi.RegisterOutputType(PrivateCrossconnectArrayOutput{})
	pulumi.RegisterOutputType(PrivateCrossconnectMapOutput{})
}
