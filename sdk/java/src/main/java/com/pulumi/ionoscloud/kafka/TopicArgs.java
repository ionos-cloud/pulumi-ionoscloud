// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.ionoscloud.kafka;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Integer;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class TopicArgs extends com.pulumi.resources.ResourceArgs {

    public static final TopicArgs Empty = new TopicArgs();

    /**
     * [string] ID of the Kafka Cluster that the topic belongs to.
     * 
     */
    @Import(name="clusterId", required=true)
    private Output<String> clusterId;

    /**
     * @return [string] ID of the Kafka Cluster that the topic belongs to.
     * 
     */
    public Output<String> clusterId() {
        return this.clusterId;
    }

    /**
     * [string] The location of the Kafka Cluster Topic. Possible values: `de/fra`, `de/txl`. If this is not set and if no value is provided for the `IONOS_API_URL` env var, the default `location` will be: `de/fra`.
     * 
     */
    @Import(name="location")
    private @Nullable Output<String> location;

    /**
     * @return [string] The location of the Kafka Cluster Topic. Possible values: `de/fra`, `de/txl`. If this is not set and if no value is provided for the `IONOS_API_URL` env var, the default `location` will be: `de/fra`.
     * 
     */
    public Optional<Output<String>> location() {
        return Optional.ofNullable(this.location);
    }

    /**
     * [string] Name of the Kafka Cluster.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return [string] Name of the Kafka Cluster.
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * [int] The number of partitions of the topic. Partitions allow for parallel
     * processing of messages. The partition count must be greater than or equal to the replication factor. Minimum value: 1.
     * Default value: 3.
     * 
     */
    @Import(name="numberOfPartitions")
    private @Nullable Output<Integer> numberOfPartitions;

    /**
     * @return [int] The number of partitions of the topic. Partitions allow for parallel
     * processing of messages. The partition count must be greater than or equal to the replication factor. Minimum value: 1.
     * Default value: 3.
     * 
     */
    public Optional<Output<Integer>> numberOfPartitions() {
        return Optional.ofNullable(this.numberOfPartitions);
    }

    /**
     * [int] The number of replicas of the topic. The replication factor determines how many
     * copies of the topic are stored on different brokers. The replication factor must be less than or equal to the number
     * of brokers in the Kafka Cluster. Minimum value: 1. Default value: 3.
     * 
     */
    @Import(name="replicationFactor")
    private @Nullable Output<Integer> replicationFactor;

    /**
     * @return [int] The number of replicas of the topic. The replication factor determines how many
     * copies of the topic are stored on different brokers. The replication factor must be less than or equal to the number
     * of brokers in the Kafka Cluster. Minimum value: 1. Default value: 3.
     * 
     */
    public Optional<Output<Integer>> replicationFactor() {
        return Optional.ofNullable(this.replicationFactor);
    }

    /**
     * [int] This configuration controls the maximum time we will retain a log before we will
     * discard old log segments to free up space. This represents an SLA on how soon consumers must read their data. If set
     * to -1, no time limit is applied. Default value: 604800000.
     * 
     */
    @Import(name="retentionTime")
    private @Nullable Output<Integer> retentionTime;

    /**
     * @return [int] This configuration controls the maximum time we will retain a log before we will
     * discard old log segments to free up space. This represents an SLA on how soon consumers must read their data. If set
     * to -1, no time limit is applied. Default value: 604800000.
     * 
     */
    public Optional<Output<Integer>> retentionTime() {
        return Optional.ofNullable(this.retentionTime);
    }

    /**
     * [int] This configuration controls the segment file size for the log. Retention and
     * cleaning is always done a file at a time so a larger segment size means fewer files but less granular control over
     * retention. Default value: 1073741824.
     * 
     */
    @Import(name="segmentBytes")
    private @Nullable Output<Integer> segmentBytes;

    /**
     * @return [int] This configuration controls the segment file size for the log. Retention and
     * cleaning is always done a file at a time so a larger segment size means fewer files but less granular control over
     * retention. Default value: 1073741824.
     * 
     */
    public Optional<Output<Integer>> segmentBytes() {
        return Optional.ofNullable(this.segmentBytes);
    }

    private TopicArgs() {}

    private TopicArgs(TopicArgs $) {
        this.clusterId = $.clusterId;
        this.location = $.location;
        this.name = $.name;
        this.numberOfPartitions = $.numberOfPartitions;
        this.replicationFactor = $.replicationFactor;
        this.retentionTime = $.retentionTime;
        this.segmentBytes = $.segmentBytes;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(TopicArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private TopicArgs $;

        public Builder() {
            $ = new TopicArgs();
        }

        public Builder(TopicArgs defaults) {
            $ = new TopicArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param clusterId [string] ID of the Kafka Cluster that the topic belongs to.
         * 
         * @return builder
         * 
         */
        public Builder clusterId(Output<String> clusterId) {
            $.clusterId = clusterId;
            return this;
        }

        /**
         * @param clusterId [string] ID of the Kafka Cluster that the topic belongs to.
         * 
         * @return builder
         * 
         */
        public Builder clusterId(String clusterId) {
            return clusterId(Output.of(clusterId));
        }

        /**
         * @param location [string] The location of the Kafka Cluster Topic. Possible values: `de/fra`, `de/txl`. If this is not set and if no value is provided for the `IONOS_API_URL` env var, the default `location` will be: `de/fra`.
         * 
         * @return builder
         * 
         */
        public Builder location(@Nullable Output<String> location) {
            $.location = location;
            return this;
        }

        /**
         * @param location [string] The location of the Kafka Cluster Topic. Possible values: `de/fra`, `de/txl`. If this is not set and if no value is provided for the `IONOS_API_URL` env var, the default `location` will be: `de/fra`.
         * 
         * @return builder
         * 
         */
        public Builder location(String location) {
            return location(Output.of(location));
        }

        /**
         * @param name [string] Name of the Kafka Cluster.
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name [string] Name of the Kafka Cluster.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param numberOfPartitions [int] The number of partitions of the topic. Partitions allow for parallel
         * processing of messages. The partition count must be greater than or equal to the replication factor. Minimum value: 1.
         * Default value: 3.
         * 
         * @return builder
         * 
         */
        public Builder numberOfPartitions(@Nullable Output<Integer> numberOfPartitions) {
            $.numberOfPartitions = numberOfPartitions;
            return this;
        }

        /**
         * @param numberOfPartitions [int] The number of partitions of the topic. Partitions allow for parallel
         * processing of messages. The partition count must be greater than or equal to the replication factor. Minimum value: 1.
         * Default value: 3.
         * 
         * @return builder
         * 
         */
        public Builder numberOfPartitions(Integer numberOfPartitions) {
            return numberOfPartitions(Output.of(numberOfPartitions));
        }

        /**
         * @param replicationFactor [int] The number of replicas of the topic. The replication factor determines how many
         * copies of the topic are stored on different brokers. The replication factor must be less than or equal to the number
         * of brokers in the Kafka Cluster. Minimum value: 1. Default value: 3.
         * 
         * @return builder
         * 
         */
        public Builder replicationFactor(@Nullable Output<Integer> replicationFactor) {
            $.replicationFactor = replicationFactor;
            return this;
        }

        /**
         * @param replicationFactor [int] The number of replicas of the topic. The replication factor determines how many
         * copies of the topic are stored on different brokers. The replication factor must be less than or equal to the number
         * of brokers in the Kafka Cluster. Minimum value: 1. Default value: 3.
         * 
         * @return builder
         * 
         */
        public Builder replicationFactor(Integer replicationFactor) {
            return replicationFactor(Output.of(replicationFactor));
        }

        /**
         * @param retentionTime [int] This configuration controls the maximum time we will retain a log before we will
         * discard old log segments to free up space. This represents an SLA on how soon consumers must read their data. If set
         * to -1, no time limit is applied. Default value: 604800000.
         * 
         * @return builder
         * 
         */
        public Builder retentionTime(@Nullable Output<Integer> retentionTime) {
            $.retentionTime = retentionTime;
            return this;
        }

        /**
         * @param retentionTime [int] This configuration controls the maximum time we will retain a log before we will
         * discard old log segments to free up space. This represents an SLA on how soon consumers must read their data. If set
         * to -1, no time limit is applied. Default value: 604800000.
         * 
         * @return builder
         * 
         */
        public Builder retentionTime(Integer retentionTime) {
            return retentionTime(Output.of(retentionTime));
        }

        /**
         * @param segmentBytes [int] This configuration controls the segment file size for the log. Retention and
         * cleaning is always done a file at a time so a larger segment size means fewer files but less granular control over
         * retention. Default value: 1073741824.
         * 
         * @return builder
         * 
         */
        public Builder segmentBytes(@Nullable Output<Integer> segmentBytes) {
            $.segmentBytes = segmentBytes;
            return this;
        }

        /**
         * @param segmentBytes [int] This configuration controls the segment file size for the log. Retention and
         * cleaning is always done a file at a time so a larger segment size means fewer files but less granular control over
         * retention. Default value: 1073741824.
         * 
         * @return builder
         * 
         */
        public Builder segmentBytes(Integer segmentBytes) {
            return segmentBytes(Output.of(segmentBytes));
        }

        public TopicArgs build() {
            if ($.clusterId == null) {
                throw new MissingRequiredPropertyException("TopicArgs", "clusterId");
            }
            return $;
        }
    }

}
