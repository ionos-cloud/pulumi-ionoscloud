// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.ionoscloud.k8s;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.ionoscloud.Utilities;
import com.pulumi.ionoscloud.k8s.ClusterArgs;
import com.pulumi.ionoscloud.k8s.inputs.ClusterState;
import com.pulumi.ionoscloud.k8s.outputs.ClusterMaintenanceWindow;
import com.pulumi.ionoscloud.k8s.outputs.ClusterS3Bucket;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * Manages a **Managed Kubernetes Cluster** on IonosCloud.
 * 
 * ## Example Usage
 * 
 * ### Public cluster
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.ionoscloud.k8s.Cluster;
 * import com.pulumi.ionoscloud.k8s.ClusterArgs;
 * import com.pulumi.ionoscloud.k8s.inputs.ClusterMaintenanceWindowArgs;
 * import com.pulumi.ionoscloud.k8s.inputs.ClusterS3BucketArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var example = new Cluster("example", ClusterArgs.builder()
 *             .name("k8sClusterExample")
 *             .k8sVersion("1.31.2")
 *             .maintenanceWindow(ClusterMaintenanceWindowArgs.builder()
 *                 .dayOfTheWeek("Sunday")
 *                 .time("09:00:00Z")
 *                 .build())
 *             .apiSubnetAllowLists("1.2.3.4/32")
 *             .s3Buckets(ClusterS3BucketArgs.builder()
 *                 .name("globally_unique_bucket_name")
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * 
 * ### Private Cluster
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.ionoscloud.compute.Datacenter;
 * import com.pulumi.ionoscloud.compute.DatacenterArgs;
 * import com.pulumi.ionoscloud.compute.IPBlock;
 * import com.pulumi.ionoscloud.compute.IPBlockArgs;
 * import com.pulumi.ionoscloud.k8s.Cluster;
 * import com.pulumi.ionoscloud.k8s.ClusterArgs;
 * import com.pulumi.ionoscloud.k8s.inputs.ClusterMaintenanceWindowArgs;
 * import com.pulumi.ionoscloud.k8s.inputs.ClusterS3BucketArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var testdatacenter = new Datacenter("testdatacenter", DatacenterArgs.builder()
 *             .name("example")
 *             .location("de/fra")
 *             .description("Test datacenter")
 *             .build());
 * 
 *         var k8sip = new IPBlock("k8sip", IPBlockArgs.builder()
 *             .location("de/fra")
 *             .size(1)
 *             .name("IP Block Private K8s")
 *             .build());
 * 
 *         var example = new Cluster("example", ClusterArgs.builder()
 *             .name("k8sClusterExample")
 *             .k8sVersion("1.31.2")
 *             .maintenanceWindow(ClusterMaintenanceWindowArgs.builder()
 *                 .dayOfTheWeek("Sunday")
 *                 .time("09:00:00Z")
 *                 .build())
 *             .apiSubnetAllowLists("1.2.3.4/32")
 *             .s3Buckets(ClusterS3BucketArgs.builder()
 *                 .name("globally_unique_bucket_name")
 *                 .build())
 *             .location("de/fra")
 *             .natGatewayIp(k8sip.ips().applyValue(ips -> ips[0]))
 *             .nodeSubnet("192.168.0.0/16")
 *             .public_(false)
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * 
 * ## Import
 * 
 * A Kubernetes Cluster resource can be imported using its `resource id`, e.g.
 * 
 * ```sh
 * $ pulumi import ionoscloud:k8s/cluster:Cluster demo k8s_cluster uuid
 * ```
 * 
 * This can be helpful when you want to import kubernetes clusters which you have already created manually or using other means, outside of terraform.
 * 
 * ⚠️ **_Warning: **During a maintenance window, k8s can update your `k8s_version` if the old one reaches end of life. This upgrade will not be shown in the plan, as we prevent
 * 
 * terraform from doing a downgrade, as downgrading `k8s_version` is not supported._**
 * 
 */
@ResourceType(type="ionoscloud:k8s/cluster:Cluster")
public class Cluster extends com.pulumi.resources.CustomResource {
    /**
     * [bool] When set to true, allows the update of immutable fields by first destroying and then re-creating the cluster.
     * 
     * ⚠️ **_Warning: `allow_replace` - lets you update immutable fields, but it first destroys and then re-creates the cluster in order to do it. Set the field to true only if you know what you are doing._**
     * 
     */
    @Export(name="allowReplace", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> allowReplace;

    /**
     * @return [bool] When set to true, allows the update of immutable fields by first destroying and then re-creating the cluster.
     * 
     * ⚠️ **_Warning: `allow_replace` - lets you update immutable fields, but it first destroys and then re-creates the cluster in order to do it. Set the field to true only if you know what you are doing._**
     * 
     */
    public Output<Optional<Boolean>> allowReplace() {
        return Codegen.optional(this.allowReplace);
    }
    /**
     * [list] Access to the K8s API server is restricted to these CIDRs. Cluster-internal traffic is not affected by this restriction. If no allowlist is specified, access is not restricted. If an IP without subnet mask is provided, the default value will be used: 32 for IPv4 and 128 for IPv6.
     * 
     */
    @Export(name="apiSubnetAllowLists", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> apiSubnetAllowLists;

    /**
     * @return [list] Access to the K8s API server is restricted to these CIDRs. Cluster-internal traffic is not affected by this restriction. If no allowlist is specified, access is not restricted. If an IP without subnet mask is provided, the default value will be used: 32 for IPv4 and 128 for IPv6.
     * 
     */
    public Output<Optional<List<String>>> apiSubnetAllowLists() {
        return Codegen.optional(this.apiSubnetAllowLists);
    }
    /**
     * [string] The desired Kubernetes Version. For supported values, please check the API documentation. Downgrades are not supported. The provider will ignore downgrades of patch level.
     * 
     */
    @Export(name="k8sVersion", refs={String.class}, tree="[0]")
    private Output<String> k8sVersion;

    /**
     * @return [string] The desired Kubernetes Version. For supported values, please check the API documentation. Downgrades are not supported. The provider will ignore downgrades of patch level.
     * 
     */
    public Output<String> k8sVersion() {
        return this.k8sVersion;
    }
    /**
     * [string] This attribute is mandatory if the cluster is private. The location must be enabled for your contract, or you must have a data center at that location. This property is not adjustable.
     * 
     */
    @Export(name="location", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> location;

    /**
     * @return [string] This attribute is mandatory if the cluster is private. The location must be enabled for your contract, or you must have a data center at that location. This property is not adjustable.
     * 
     */
    public Output<Optional<String>> location() {
        return Codegen.optional(this.location);
    }
    /**
     * A maintenance window comprise of a day of the week and a time for maintenance to be allowed
     * 
     */
    @Export(name="maintenanceWindow", refs={ClusterMaintenanceWindow.class}, tree="[0]")
    private Output<ClusterMaintenanceWindow> maintenanceWindow;

    /**
     * @return A maintenance window comprise of a day of the week and a time for maintenance to be allowed
     * 
     */
    public Output<ClusterMaintenanceWindow> maintenanceWindow() {
        return this.maintenanceWindow;
    }
    /**
     * [string] The name of the Kubernetes Cluster.
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return [string] The name of the Kubernetes Cluster.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * [string] The NAT gateway IP of the cluster if the cluster is private. This attribute is immutable. Must be a reserved IP in the same location as the cluster&#39;s location. This attribute is mandatory if the cluster is private.
     * 
     */
    @Export(name="natGatewayIp", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> natGatewayIp;

    /**
     * @return [string] The NAT gateway IP of the cluster if the cluster is private. This attribute is immutable. Must be a reserved IP in the same location as the cluster&#39;s location. This attribute is mandatory if the cluster is private.
     * 
     */
    public Output<Optional<String>> natGatewayIp() {
        return Codegen.optional(this.natGatewayIp);
    }
    /**
     * [string] The node subnet of the cluster, if the cluster is private. This attribute is optional and immutable. Must be a valid CIDR notation for an IPv4 network prefix of 16 bits length.
     * 
     */
    @Export(name="nodeSubnet", refs={String.class}, tree="[0]")
    private Output<String> nodeSubnet;

    /**
     * @return [string] The node subnet of the cluster, if the cluster is private. This attribute is optional and immutable. Must be a valid CIDR notation for an IPv4 network prefix of 16 bits length.
     * 
     */
    public Output<String> nodeSubnet() {
        return this.nodeSubnet;
    }
    /**
     * [boolean] Indicates if the cluster is public or private. This attribute is immutable.
     * 
     */
    @Export(name="public", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> public_;

    /**
     * @return [boolean] Indicates if the cluster is public or private. This attribute is immutable.
     * 
     */
    public Output<Optional<Boolean>> public_() {
        return Codegen.optional(this.public_);
    }
    /**
     * [list] List of IONOS Object Storage buckets configured for K8s usage. For now it contains only an IONOS Object Storage bucket used to store K8s API audit logs.
     * 
     */
    @Export(name="s3Buckets", refs={List.class,ClusterS3Bucket.class}, tree="[0,1]")
    private Output</* @Nullable */ List<ClusterS3Bucket>> s3Buckets;

    /**
     * @return [list] List of IONOS Object Storage buckets configured for K8s usage. For now it contains only an IONOS Object Storage bucket used to store K8s API audit logs.
     * 
     */
    public Output<Optional<List<ClusterS3Bucket>>> s3Buckets() {
        return Codegen.optional(this.s3Buckets);
    }
    /**
     * [list] List of versions that may be used for node pools under this cluster
     * 
     */
    @Export(name="viableNodePoolVersions", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> viableNodePoolVersions;

    /**
     * @return [list] List of versions that may be used for node pools under this cluster
     * 
     */
    public Output<List<String>> viableNodePoolVersions() {
        return this.viableNodePoolVersions;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public Cluster(java.lang.String name) {
        this(name, ClusterArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public Cluster(java.lang.String name, @Nullable ClusterArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public Cluster(java.lang.String name, @Nullable ClusterArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("ionoscloud:k8s/cluster:Cluster", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private Cluster(java.lang.String name, Output<java.lang.String> id, @Nullable ClusterState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("ionoscloud:k8s/cluster:Cluster", name, state, makeResourceOptions(options, id), false);
    }

    private static ClusterArgs makeArgs(@Nullable ClusterArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? ClusterArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static Cluster get(java.lang.String name, Output<java.lang.String> id, @Nullable ClusterState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new Cluster(name, id, state, options);
    }
}
