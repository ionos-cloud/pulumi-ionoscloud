// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.ionoscloud.pulumi.ionoscloud.compute;

import com.ionoscloud.pulumi.ionoscloud.Utilities;
import com.ionoscloud.pulumi.ionoscloud.compute.NicArgs;
import com.ionoscloud.pulumi.ionoscloud.compute.inputs.NicState;
import com.ionoscloud.pulumi.ionoscloud.compute.outputs.NicFlowlog;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * Manages a **NIC** on IonosCloud.
 * ## Example Usage
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.ionoscloud.compute.Datacenter;
 * import com.pulumi.ionoscloud.compute.DatacenterArgs;
 * import com.pulumi.ionoscloud.compute.IPBlock;
 * import com.pulumi.ionoscloud.compute.IPBlockArgs;
 * import com.pulumi.ionoscloud.compute.Lan;
 * import com.pulumi.ionoscloud.compute.LanArgs;
 * import com.pulumi.random.password;
 * import com.pulumi.random.PasswordArgs;
 * import com.pulumi.ionoscloud.compute.Server;
 * import com.pulumi.ionoscloud.compute.ServerArgs;
 * import com.pulumi.ionoscloud.compute.inputs.ServerVolumeArgs;
 * import com.pulumi.ionoscloud.compute.inputs.ServerNicArgs;
 * import com.pulumi.ionoscloud.compute.Nic;
 * import com.pulumi.ionoscloud.compute.NicArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var example = new Datacenter("example", DatacenterArgs.builder()
 *             .name("Datacenter Example")
 *             .location("us/las")
 *             .description("Datacenter Description")
 *             .secAuthProtection(false)
 *             .build());
 * 
 *         var exampleIPBlock = new IPBlock("exampleIPBlock", IPBlockArgs.builder()
 *             .location(example.location())
 *             .size(2)
 *             .name("IP Block Example")
 *             .build());
 * 
 *         var exampleLan = new Lan("exampleLan", LanArgs.builder()
 *             .datacenterId(example.id())
 *             .public_(true)
 *             .name("Lan")
 *             .build());
 * 
 *         var serverImagePassword = new Password("serverImagePassword", PasswordArgs.builder()
 *             .length(16)
 *             .special(false)
 *             .build());
 * 
 *         var exampleServer = new Server("exampleServer", ServerArgs.builder()
 *             .name("Server Example")
 *             .datacenterId(example.id())
 *             .cores(1)
 *             .ram(1024)
 *             .availabilityZone("ZONE_1")
 *             .cpuFamily("INTEL_XEON")
 *             .imageName("Ubuntu-20.04")
 *             .imagePassword(serverImagePassword.result())
 *             .volume(ServerVolumeArgs.builder()
 *                 .name("system")
 *                 .size(14)
 *                 .diskType("SSD")
 *                 .build())
 *             .nic(ServerNicArgs.builder()
 *                 .lan("1")
 *                 .dhcp(true)
 *                 .firewallActive(true)
 *                 .build())
 *             .build());
 * 
 *         var exampleNic = new Nic("exampleNic", NicArgs.builder()
 *             .datacenterId(example.id())
 *             .serverId(exampleServer.id())
 *             .lan(exampleLan.id())
 *             .name("NIC")
 *             .dhcp(true)
 *             .firewallActive(true)
 *             .firewallType("INGRESS")
 *             .ips(            
 *                 exampleIPBlock.ips().applyValue(ips -> ips[0]),
 *                 exampleIPBlock.ips().applyValue(ips -> ips[1]))
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * 
 * ### With IPv6
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.ionoscloud.compute.Datacenter;
 * import com.pulumi.ionoscloud.compute.DatacenterArgs;
 * import com.pulumi.ionoscloud.compute.Lan;
 * import com.pulumi.ionoscloud.compute.LanArgs;
 * import com.pulumi.random.password;
 * import com.pulumi.random.PasswordArgs;
 * import com.pulumi.ionoscloud.compute.Server;
 * import com.pulumi.ionoscloud.compute.ServerArgs;
 * import com.pulumi.ionoscloud.compute.inputs.ServerVolumeArgs;
 * import com.pulumi.ionoscloud.compute.inputs.ServerNicArgs;
 * import com.pulumi.ionoscloud.compute.Nic;
 * import com.pulumi.ionoscloud.compute.NicArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var example = new Datacenter("example", DatacenterArgs.builder()
 *             .name("Datacenter Example")
 *             .location("us/las")
 *             .description("Datacenter Description")
 *             .secAuthProtection(false)
 *             .build());
 * 
 *         var exampleLan = new Lan("exampleLan", LanArgs.builder()
 *             .datacenterId(example.id())
 *             .public_(true)
 *             .name("IPv6 Enabled LAN")
 *             .ipv6CidrBlock("ipv6_cidr_block_from_dc")
 *             .build());
 * 
 *         var serverImagePassword = new Password("serverImagePassword", PasswordArgs.builder()
 *             .length(16)
 *             .special(false)
 *             .build());
 * 
 *         var exampleServer = new Server("exampleServer", ServerArgs.builder()
 *             .name("Server Example")
 *             .datacenterId(example.id())
 *             .cores(1)
 *             .ram(1024)
 *             .availabilityZone("ZONE_1")
 *             .cpuFamily("INTEL_XEON")
 *             .imageName("Ubuntu-20.04")
 *             .imagePassword(serverImagePassword.result())
 *             .volume(ServerVolumeArgs.builder()
 *                 .name("system")
 *                 .size(14)
 *                 .diskType("SSD")
 *                 .build())
 *             .nic(ServerNicArgs.builder()
 *                 .lan("1")
 *                 .dhcp(true)
 *                 .firewallActive(true)
 *                 .build())
 *             .build());
 * 
 *         var exampleNic = new Nic("exampleNic", NicArgs.builder()
 *             .datacenterId(example.id())
 *             .serverId(exampleServer.id())
 *             .lan(exampleLan.id())
 *             .name("IPv6 Enabled NIC")
 *             .dhcp(true)
 *             .firewallActive(true)
 *             .firewallType("INGRESS")
 *             .dhcpv6(false)
 *             .ipv6CidrBlock("ipv6_cidr_block_from_lan")
 *             .ipv6Ips(            
 *                 "ipv6_ip1",
 *                 "ipv6_ip2",
 *                 "ipv6_ip3")
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * ## Example configuring Flowlog
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.ionoscloud.compute.Datacenter;
 * import com.pulumi.ionoscloud.compute.DatacenterArgs;
 * import com.pulumi.ionoscloud.compute.Lan;
 * import com.pulumi.ionoscloud.compute.LanArgs;
 * import com.pulumi.random.password;
 * import com.pulumi.random.PasswordArgs;
 * import com.pulumi.ionoscloud.compute.Server;
 * import com.pulumi.ionoscloud.compute.ServerArgs;
 * import com.pulumi.ionoscloud.compute.inputs.ServerVolumeArgs;
 * import com.pulumi.ionoscloud.compute.inputs.ServerNicArgs;
 * import com.pulumi.ionoscloud.compute.Nic;
 * import com.pulumi.ionoscloud.compute.NicArgs;
 * import com.pulumi.ionoscloud.compute.inputs.NicFlowlogArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var example = new Datacenter("example", DatacenterArgs.builder()
 *             .name("Datacenter Example")
 *             .location("us/las")
 *             .description("Datacenter Description")
 *             .secAuthProtection(false)
 *             .build());
 * 
 *         var exampleLan = new Lan("exampleLan", LanArgs.builder()
 *             .datacenterId(example.id())
 *             .public_(true)
 *             .name("IPv6 Enabled LAN")
 *             .ipv6CidrBlock("ipv6_cidr_block_from_dc")
 *             .build());
 * 
 *         var serverImagePassword = new Password("serverImagePassword", PasswordArgs.builder()
 *             .length(16)
 *             .special(false)
 *             .build());
 * 
 *         var exampleServer = new Server("exampleServer", ServerArgs.builder()
 *             .name("Server Example")
 *             .datacenterId(example.id())
 *             .cores(1)
 *             .ram(1024)
 *             .availabilityZone("ZONE_1")
 *             .cpuFamily("INTEL_XEON")
 *             .imageName("Ubuntu-20.04")
 *             .imagePassword(serverImagePassword.result())
 *             .volume(ServerVolumeArgs.builder()
 *                 .name("system")
 *                 .size(14)
 *                 .diskType("SSD")
 *                 .build())
 *             .nic(ServerNicArgs.builder()
 *                 .lan("1")
 *                 .dhcp(true)
 *                 .firewallActive(true)
 *                 .build())
 *             .build());
 * 
 *         var exampleNic = new Nic("exampleNic", NicArgs.builder()
 *             .datacenterId(example.id())
 *             .serverId(exampleServer.id())
 *             .lan(exampleLan.id())
 *             .name("IPV6 and Flowlog Enabled NIC")
 *             .dhcp(true)
 *             .firewallActive(true)
 *             .firewallType("INGRESS")
 *             .dhcpv6(false)
 *             .ipv6CidrBlock("ipv6_cidr_block_from_lan")
 *             .ipv6Ips(            
 *                 "ipv6_ip1",
 *                 "ipv6_ip2",
 *                 "ipv6_ip3")
 *             .flowlog(NicFlowlogArgs.builder()
 *                 .action("ACCEPTED")
 *                 .bucket("flowlog-bucket")
 *                 .direction("INGRESS")
 *                 .name("flowlog")
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * 
 * This will configure flowlog for accepted ingress traffic and will log it into an existing IONOS Object Storage bucket named `flowlog-bucket`. Any s3 compatible client can be used to create it. Adding a flowlog does not force re-creation of the NIC, but changing any other field than
 * `name` will. Deleting a flowlog will also force NIC re-creation.
 * 
 * ## Working with load balancers
 * 
 * Please be aware that when using a NIC in a load balancer, the load balancer will
 * change the NIC&#39;s ID behind the scenes, therefore the plan will always report this change
 * trying to revert the state to the one specified by your file.
 * In order to prevent this, use the &#34;lifecycle meta-argument&#34; when declaring your NIC,
 * in order to ignore changes to the `lan` attribute:
 * 
 * Here&#39;s an example:
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.ionoscloud.compute.Nic;
 * import com.pulumi.ionoscloud.compute.NicArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var example = new Nic("example", NicArgs.builder()
 *             .datacenterId(foobar.id())
 *             .serverId(exampleIonoscloudServer.id())
 *             .lan("2")
 *             .dhcp(true)
 *             .firewallActive(true)
 *             .name("updated")
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * 
 * ## Import
 * 
 * Resource **Nic** can be imported using the `resource id`, e.g.
 * 
 * ```sh
 * $ pulumi import ionoscloud:compute/nic:Nic mynic datacenter uuid/server uuid/nic uuid
 * ```
 * 
 */
@ResourceType(type="ionoscloud:compute/nic:Nic")
public class Nic extends com.pulumi.resources.CustomResource {
    /**
     * [string] The ID of a Virtual Data Center.
     * 
     */
    @Export(name="datacenterId", refs={String.class}, tree="[0]")
    private Output<String> datacenterId;

    /**
     * @return [string] The ID of a Virtual Data Center.
     * 
     */
    public Output<String> datacenterId() {
        return this.datacenterId;
    }
    /**
     * The Logical Unit Number (LUN) of the storage volume. Null if this NIC was created from CloudAPI and no DCD changes were done on the Datacenter.
     * 
     */
    @Export(name="deviceNumber", refs={Integer.class}, tree="[0]")
    private Output<Integer> deviceNumber;

    /**
     * @return The Logical Unit Number (LUN) of the storage volume. Null if this NIC was created from CloudAPI and no DCD changes were done on the Datacenter.
     * 
     */
    public Output<Integer> deviceNumber() {
        return this.deviceNumber;
    }
    /**
     * [Boolean] Indicates if the NIC should get an IP address using DHCP (true) or not (false).
     * 
     */
    @Export(name="dhcp", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> dhcp;

    /**
     * @return [Boolean] Indicates if the NIC should get an IP address using DHCP (true) or not (false).
     * 
     */
    public Output<Optional<Boolean>> dhcp() {
        return Codegen.optional(this.dhcp);
    }
    /**
     * [Boolean] Indicates if the NIC should get an IPv6 address using DHCP (true) or not (false).
     * 
     */
    @Export(name="dhcpv6", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> dhcpv6;

    /**
     * @return [Boolean] Indicates if the NIC should get an IPv6 address using DHCP (true) or not (false).
     * 
     */
    public Output<Optional<Boolean>> dhcpv6() {
        return Codegen.optional(this.dhcpv6);
    }
    /**
     * [Boolean] If this resource is set to true and is nested under a server resource firewall, with open SSH port, resource must be nested under the NIC.
     * 
     */
    @Export(name="firewallActive", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> firewallActive;

    /**
     * @return [Boolean] If this resource is set to true and is nested under a server resource firewall, with open SSH port, resource must be nested under the NIC.
     * 
     */
    public Output<Optional<Boolean>> firewallActive() {
        return Codegen.optional(this.firewallActive);
    }
    /**
     * [String] The type of firewall rules that will be allowed on the NIC. If it is not specified it will take the default value INGRESS
     * 
     */
    @Export(name="firewallType", refs={String.class}, tree="[0]")
    private Output<String> firewallType;

    /**
     * @return [String] The type of firewall rules that will be allowed on the NIC. If it is not specified it will take the default value INGRESS
     * 
     */
    public Output<String> firewallType() {
        return this.firewallType;
    }
    /**
     * Only 1 flow log can be configured. Only the name field can change as part of an update. Flow logs holistically capture network information such as source and destination IP addresses, source and destination ports, number of packets, amount of bytes, the start and end time of the recording, and the type of protocol – and log the extent to which your instances are being accessed.
     * 
     */
    @Export(name="flowlog", refs={NicFlowlog.class}, tree="[0]")
    private Output</* @Nullable */ NicFlowlog> flowlog;

    /**
     * @return Only 1 flow log can be configured. Only the name field can change as part of an update. Flow logs holistically capture network information such as source and destination IP addresses, source and destination ports, number of packets, amount of bytes, the start and end time of the recording, and the type of protocol – and log the extent to which your instances are being accessed.
     * 
     */
    public Output<Optional<NicFlowlog>> flowlog() {
        return Codegen.optional(this.flowlog);
    }
    /**
     * [list] Collection of IP addresses assigned to a NIC. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.
     * 
     */
    @Export(name="ips", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> ips;

    /**
     * @return [list] Collection of IP addresses assigned to a NIC. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.
     * 
     */
    public Output<List<String>> ips() {
        return this.ips;
    }
    /**
     * Automatically assigned /80 IPv6 CIDR block if the NIC is connected to an IPv6 enabled LAN. You can also specify an /80 IPv6 CIDR block for the NIC on your own, which must be inside the /64 IPv6 CIDR block of the LAN and unique.
     * 
     */
    @Export(name="ipv6CidrBlock", refs={String.class}, tree="[0]")
    private Output<String> ipv6CidrBlock;

    /**
     * @return Automatically assigned /80 IPv6 CIDR block if the NIC is connected to an IPv6 enabled LAN. You can also specify an /80 IPv6 CIDR block for the NIC on your own, which must be inside the /64 IPv6 CIDR block of the LAN and unique.
     * 
     */
    public Output<String> ipv6CidrBlock() {
        return this.ipv6CidrBlock;
    }
    /**
     * [list] Collection of IPv6 addresses assigned to a NIC. Explicitly assigned public IPs need to come from the NIC&#39;s Ipv6 CIDR block, Passing value null or empty array will assign an IPv6 address automatically from the NIC&#39;s CIDR block.
     * 
     */
    @Export(name="ipv6Ips", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> ipv6Ips;

    /**
     * @return [list] Collection of IPv6 addresses assigned to a NIC. Explicitly assigned public IPs need to come from the NIC&#39;s Ipv6 CIDR block, Passing value null or empty array will assign an IPv6 address automatically from the NIC&#39;s CIDR block.
     * 
     */
    public Output<List<String>> ipv6Ips() {
        return this.ipv6Ips;
    }
    /**
     * [integer] The LAN ID the NIC will sit on.
     * 
     */
    @Export(name="lan", refs={Integer.class}, tree="[0]")
    private Output<Integer> lan;

    /**
     * @return [integer] The LAN ID the NIC will sit on.
     * 
     */
    public Output<Integer> lan() {
        return this.lan;
    }
    /**
     * The MAC address of the NIC. Can be set on creation only. If not set, one will be assigned automatically by the API. Immutable, update forces re-creation.
     * 
     */
    @Export(name="mac", refs={String.class}, tree="[0]")
    private Output<String> mac;

    /**
     * @return The MAC address of the NIC. Can be set on creation only. If not set, one will be assigned automatically by the API. Immutable, update forces re-creation.
     * 
     */
    public Output<String> mac() {
        return this.mac;
    }
    /**
     * [string] The name of the LAN.
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return [string] The name of the LAN.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * The PCI slot number of the Nic.
     * 
     */
    @Export(name="pciSlot", refs={Integer.class}, tree="[0]")
    private Output<Integer> pciSlot;

    /**
     * @return The PCI slot number of the Nic.
     * 
     */
    public Output<Integer> pciSlot() {
        return this.pciSlot;
    }
    /**
     * The list of Security Group IDs for the resource.
     * 
     * ⚠️ **Note:**: Removing the `flowlog` forces re-creation of the NIC resource.
     * 
     */
    @Export(name="securityGroupsIds", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> securityGroupsIds;

    /**
     * @return The list of Security Group IDs for the resource.
     * 
     * ⚠️ **Note:**: Removing the `flowlog` forces re-creation of the NIC resource.
     * 
     */
    public Output<Optional<List<String>>> securityGroupsIds() {
        return Codegen.optional(this.securityGroupsIds);
    }
    /**
     * [string] The ID of a server.
     * 
     */
    @Export(name="serverId", refs={String.class}, tree="[0]")
    private Output<String> serverId;

    /**
     * @return [string] The ID of a server.
     * 
     */
    public Output<String> serverId() {
        return this.serverId;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public Nic(java.lang.String name) {
        this(name, NicArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public Nic(java.lang.String name, NicArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public Nic(java.lang.String name, NicArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("ionoscloud:compute/nic:Nic", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private Nic(java.lang.String name, Output<java.lang.String> id, @Nullable NicState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("ionoscloud:compute/nic:Nic", name, state, makeResourceOptions(options, id), false);
    }

    private static NicArgs makeArgs(NicArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? NicArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static Nic get(java.lang.String name, Output<java.lang.String> id, @Nullable NicState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new Nic(name, id, state, options);
    }
}
