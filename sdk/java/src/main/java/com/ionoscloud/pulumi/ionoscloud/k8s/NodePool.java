// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.ionoscloud.pulumi.ionoscloud.k8s;

import com.ionoscloud.pulumi.ionoscloud.Utilities;
import com.ionoscloud.pulumi.ionoscloud.k8s.NodePoolArgs;
import com.ionoscloud.pulumi.ionoscloud.k8s.inputs.NodePoolState;
import com.ionoscloud.pulumi.ionoscloud.k8s.outputs.NodePoolAutoScaling;
import com.ionoscloud.pulumi.ionoscloud.k8s.outputs.NodePoolLan;
import com.ionoscloud.pulumi.ionoscloud.k8s.outputs.NodePoolMaintenanceWindow;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * Manages a **Managed Kubernetes Node Pool**, part of a managed Kubernetes cluster on IonosCloud.
 * 
 * ## Example Usage
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.ionoscloud.compute.Datacenter;
 * import com.pulumi.ionoscloud.compute.DatacenterArgs;
 * import com.pulumi.ionoscloud.compute.Lan;
 * import com.pulumi.ionoscloud.compute.LanArgs;
 * import com.pulumi.ionoscloud.compute.IPBlock;
 * import com.pulumi.ionoscloud.compute.IPBlockArgs;
 * import com.pulumi.ionoscloud.k8s.Cluster;
 * import com.pulumi.ionoscloud.k8s.ClusterArgs;
 * import com.pulumi.ionoscloud.k8s.inputs.ClusterMaintenanceWindowArgs;
 * import com.pulumi.ionoscloud.k8s.inputs.ClusterS3BucketArgs;
 * import com.pulumi.ionoscloud.k8s.NodePool;
 * import com.pulumi.ionoscloud.k8s.NodePoolArgs;
 * import com.pulumi.ionoscloud.k8s.inputs.NodePoolMaintenanceWindowArgs;
 * import com.pulumi.ionoscloud.k8s.inputs.NodePoolAutoScalingArgs;
 * import com.pulumi.ionoscloud.k8s.inputs.NodePoolLanArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var example = new Datacenter("example", DatacenterArgs.builder()
 *             .name("Datacenter Example")
 *             .location("us/las")
 *             .description("datacenter description")
 *             .secAuthProtection(false)
 *             .build());
 * 
 *         var exampleLan = new Lan("exampleLan", LanArgs.builder()
 *             .datacenterId(example.id())
 *             .public_(false)
 *             .name("Lan Example")
 *             .build());
 * 
 *         var exampleIPBlock = new IPBlock("exampleIPBlock", IPBlockArgs.builder()
 *             .location("us/las")
 *             .size(3)
 *             .name("IP Block Example")
 *             .build());
 * 
 *         var exampleCluster = new Cluster("exampleCluster", ClusterArgs.builder()
 *             .name("k8sClusterExample")
 *             .k8sVersion("1.31.2")
 *             .maintenanceWindow(ClusterMaintenanceWindowArgs.builder()
 *                 .dayOfTheWeek("Sunday")
 *                 .time("09:00:00Z")
 *                 .build())
 *             .apiSubnetAllowLists("1.2.3.4/32")
 *             .s3Buckets(ClusterS3BucketArgs.builder()
 *                 .name("globally_unique_s3_bucket_name")
 *                 .build())
 *             .build());
 * 
 *         var exampleNodePool = new NodePool("exampleNodePool", NodePoolArgs.builder()
 *             .datacenterId(example.id())
 *             .k8sClusterId(exampleCluster.id())
 *             .name("k8sNodePoolExample")
 *             .k8sVersion(exampleCluster.k8sVersion())
 *             .maintenanceWindow(NodePoolMaintenanceWindowArgs.builder()
 *                 .dayOfTheWeek("Monday")
 *                 .time("09:00:00Z")
 *                 .build())
 *             .autoScaling(NodePoolAutoScalingArgs.builder()
 *                 .minNodeCount(1)
 *                 .maxNodeCount(2)
 *                 .build())
 *             .cpuFamily("INTEL_XEON")
 *             .availabilityZone("AUTO")
 *             .storageType("SSD")
 *             .nodeCount(1)
 *             .coresCount(2)
 *             .ramSize(2048)
 *             .storageSize(40)
 *             .publicIps(            
 *                 exampleIPBlock.ips().applyValue(ips -> ips[0]),
 *                 exampleIPBlock.ips().applyValue(ips -> ips[1]),
 *                 exampleIPBlock.ips().applyValue(ips -> ips[2]))
 *             .lans(NodePoolLanArgs.builder()
 *                 .id(exampleLan.id())
 *                 .dhcp(true)
 *                 .routes(NodePoolLanRouteArgs.builder()
 *                     .network("1.2.3.5/24")
 *                     .gatewayIp("10.1.5.17")
 *                     .build())
 *                 .build())
 *             .labels(Map.ofEntries(
 *                 Map.entry("lab1", "value1"),
 *                 Map.entry("lab2", "value2")
 *             ))
 *             .annotations(Map.ofEntries(
 *                 Map.entry("ann1", "value1"),
 *                 Map.entry("ann2", "value2")
 *             ))
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * **Note:** Set `create_before_destroy` on the lan resource if you want to remove it from the nodepool during an update. This is to ensure that the nodepool is updated before the lan is destroyed.
 * 
 * ## Import
 * 
 * A Kubernetes Node Pool resource can be imported using its Kubernetes cluster&#39;s uuid as well as its own UUID, both of which you can retrieve from the cloud API: `resource id`, e.g.:
 * 
 * ```sh
 * $ pulumi import ionoscloud:k8s/nodePool:NodePool demo k8s_cluster_uuid/k8s_nodepool_id
 * ```
 * 
 * This can be helpful when you want to import kubernetes node pools which you have already created manually or using other means, outside of pulumi, towards the goal of managing them via Pulumi
 * 
 * ⚠️ **_Warning: **During a maintenance window, k8s can update your `k8s_version` if the old one reaches end of life. This upgrade will not be shown in the plan, as we prevent
 * 
 * pulumi from doing a downgrade, as downgrading `k8s_version` is not supported._**
 * 
 * ⚠️ **_Warning: **If you are upgrading from v5.x.x to v6.x.x**: You have to modify you plan for lans to match the new structure, by putting the ids from the old slice in lans.id fields. This is not backwards compatible._**
 * 
 */
@ResourceType(type="ionoscloud:k8s/nodePool:NodePool")
public class NodePool extends com.pulumi.resources.CustomResource {
    /**
     * [bool] When set to true, allows the update of immutable fields by first destroying and then re-creating the node pool.
     * 
     * ⚠️ **_Warning: `allow_replace` - lets you update immutable fields, but it first destroys and then re-creates the node pool in order to do it. Set the field to true only if you know what you are doing.
     * This will cause a downtime for all pods on that nodepool. Consider adding multiple nodepools and update one after the other for downtime free nodepool upgrade._**
     * 
     * Immutable fields list: name, cpu_family, availability_zone, cores_count, ram_size, storage_size, storage_type.
     * 
     * ⚠️ **Note**:
     * 
     * Be careful when using `auto_scaling` since the number of nodes can change. Because of that, when running
     * `pulumi preview`, An update will be considered required (since `node_count` from the `tf` plan will be different
     * from the number of nodes set by the scheduler). To avoid that, you can use `ignore_changes`.
     * This will also ignore the manual changes for `node_count` made in the `tf` plan.
     * You can read more details about the `ignore_changes` attribute here.
     * 
     */
    @Export(name="allowReplace", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> allowReplace;

    /**
     * @return [bool] When set to true, allows the update of immutable fields by first destroying and then re-creating the node pool.
     * 
     * ⚠️ **_Warning: `allow_replace` - lets you update immutable fields, but it first destroys and then re-creates the node pool in order to do it. Set the field to true only if you know what you are doing.
     * This will cause a downtime for all pods on that nodepool. Consider adding multiple nodepools and update one after the other for downtime free nodepool upgrade._**
     * 
     * Immutable fields list: name, cpu_family, availability_zone, cores_count, ram_size, storage_size, storage_type.
     * 
     * ⚠️ **Note**:
     * 
     * Be careful when using `auto_scaling` since the number of nodes can change. Because of that, when running
     * `pulumi preview`, An update will be considered required (since `node_count` from the `tf` plan will be different
     * from the number of nodes set by the scheduler). To avoid that, you can use `ignore_changes`.
     * This will also ignore the manual changes for `node_count` made in the `tf` plan.
     * You can read more details about the `ignore_changes` attribute here.
     * 
     */
    public Output<Optional<Boolean>> allowReplace() {
        return Codegen.optional(this.allowReplace);
    }
    /**
     * [map] A key/value map of annotations
     * 
     */
    @Export(name="annotations", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> annotations;

    /**
     * @return [map] A key/value map of annotations
     * 
     */
    public Output<Optional<Map<String,String>>> annotations() {
        return Codegen.optional(this.annotations);
    }
    /**
     * [string] Whether the Node Pool should autoscale. For more details, please check the API documentation
     * 
     */
    @Export(name="autoScaling", refs={NodePoolAutoScaling.class}, tree="[0]")
    private Output</* @Nullable */ NodePoolAutoScaling> autoScaling;

    /**
     * @return [string] Whether the Node Pool should autoscale. For more details, please check the API documentation
     * 
     */
    public Output<Optional<NodePoolAutoScaling>> autoScaling() {
        return Codegen.optional(this.autoScaling);
    }
    /**
     * [string] - The desired Compute availability zone - See the API documentation for more information. *This attribute is immutable*.
     * 
     */
    @Export(name="availabilityZone", refs={String.class}, tree="[0]")
    private Output<String> availabilityZone;

    /**
     * @return [string] - The desired Compute availability zone - See the API documentation for more information. *This attribute is immutable*.
     * 
     */
    public Output<String> availabilityZone() {
        return this.availabilityZone;
    }
    /**
     * [int] - The CPU cores count for each node of the node pool. *This attribute is immutable*.
     * 
     */
    @Export(name="coresCount", refs={Integer.class}, tree="[0]")
    private Output<Integer> coresCount;

    /**
     * @return [int] - The CPU cores count for each node of the node pool. *This attribute is immutable*.
     * 
     */
    public Output<Integer> coresCount() {
        return this.coresCount;
    }
    /**
     * [string] The desired CPU Family - See the API documentation for more information. *This attribute is immutable*.
     * 
     */
    @Export(name="cpuFamily", refs={String.class}, tree="[0]")
    private Output<String> cpuFamily;

    /**
     * @return [string] The desired CPU Family - See the API documentation for more information. *This attribute is immutable*.
     * 
     */
    public Output<String> cpuFamily() {
        return this.cpuFamily;
    }
    /**
     * [string] A Datacenter&#39;s UUID
     * 
     */
    @Export(name="datacenterId", refs={String.class}, tree="[0]")
    private Output<String> datacenterId;

    /**
     * @return [string] A Datacenter&#39;s UUID
     * 
     */
    public Output<String> datacenterId() {
        return this.datacenterId;
    }
    /**
     * [string] A k8s cluster&#39;s UUID
     * 
     */
    @Export(name="k8sClusterId", refs={String.class}, tree="[0]")
    private Output<String> k8sClusterId;

    /**
     * @return [string] A k8s cluster&#39;s UUID
     * 
     */
    public Output<String> k8sClusterId() {
        return this.k8sClusterId;
    }
    /**
     * [string] The desired Kubernetes Version. For supported values, please check the API documentation. Downgrades are not supported. The provider will ignore downgrades of patch level.
     * 
     */
    @Export(name="k8sVersion", refs={String.class}, tree="[0]")
    private Output<String> k8sVersion;

    /**
     * @return [string] The desired Kubernetes Version. For supported values, please check the API documentation. Downgrades are not supported. The provider will ignore downgrades of patch level.
     * 
     */
    public Output<String> k8sVersion() {
        return this.k8sVersion;
    }
    /**
     * [map] A key/value map of labels
     * 
     */
    @Export(name="labels", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> labels;

    /**
     * @return [map] A key/value map of labels
     * 
     */
    public Output<Optional<Map<String,String>>> labels() {
        return Codegen.optional(this.labels);
    }
    /**
     * [list] A list of numeric LAN id&#39;s you want this node pool to be part of. For more details, please check the API documentation, as well as the example above
     * 
     */
    @Export(name="lans", refs={List.class,NodePoolLan.class}, tree="[0,1]")
    private Output</* @Nullable */ List<NodePoolLan>> lans;

    /**
     * @return [list] A list of numeric LAN id&#39;s you want this node pool to be part of. For more details, please check the API documentation, as well as the example above
     * 
     */
    public Output<Optional<List<NodePoolLan>>> lans() {
        return Codegen.optional(this.lans);
    }
    /**
     * See the **maintenance_window** section in the example above
     * 
     */
    @Export(name="maintenanceWindow", refs={NodePoolMaintenanceWindow.class}, tree="[0]")
    private Output<NodePoolMaintenanceWindow> maintenanceWindow;

    /**
     * @return See the **maintenance_window** section in the example above
     * 
     */
    public Output<NodePoolMaintenanceWindow> maintenanceWindow() {
        return this.maintenanceWindow;
    }
    /**
     * [string] The name of the Kubernetes Cluster. *This attribute is immutable*.
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return [string] The name of the Kubernetes Cluster. *This attribute is immutable*.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * [int] - The desired number of nodes in the node pool
     * 
     */
    @Export(name="nodeCount", refs={Integer.class}, tree="[0]")
    private Output<Integer> nodeCount;

    /**
     * @return [int] - The desired number of nodes in the node pool
     * 
     */
    public Output<Integer> nodeCount() {
        return this.nodeCount;
    }
    /**
     * [list] A list of public IPs associated with the node pool; must have at least `node_count + 1` elements
     * 
     */
    @Export(name="publicIps", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> publicIps;

    /**
     * @return [list] A list of public IPs associated with the node pool; must have at least `node_count + 1` elements
     * 
     */
    public Output<Optional<List<String>>> publicIps() {
        return Codegen.optional(this.publicIps);
    }
    /**
     * [int] - The desired amount of RAM, in MB. *This attribute is immutable*.
     * 
     */
    @Export(name="ramSize", refs={Integer.class}, tree="[0]")
    private Output<Integer> ramSize;

    /**
     * @return [int] - The desired amount of RAM, in MB. *This attribute is immutable*.
     * 
     */
    public Output<Integer> ramSize() {
        return this.ramSize;
    }
    /**
     * [int] - The size of the volume in GB. The size should be greater than 10GB. *This attribute is immutable*.
     * 
     */
    @Export(name="storageSize", refs={Integer.class}, tree="[0]")
    private Output<Integer> storageSize;

    /**
     * @return [int] - The size of the volume in GB. The size should be greater than 10GB. *This attribute is immutable*.
     * 
     */
    public Output<Integer> storageSize() {
        return this.storageSize;
    }
    /**
     * [string] - The desired storage type - SSD/HDD. *This attribute is immutable*.
     * 
     */
    @Export(name="storageType", refs={String.class}, tree="[0]")
    private Output<String> storageType;

    /**
     * @return [string] - The desired storage type - SSD/HDD. *This attribute is immutable*.
     * 
     */
    public Output<String> storageType() {
        return this.storageType;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public NodePool(java.lang.String name) {
        this(name, NodePoolArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public NodePool(java.lang.String name, NodePoolArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public NodePool(java.lang.String name, NodePoolArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("ionoscloud:k8s/nodePool:NodePool", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private NodePool(java.lang.String name, Output<java.lang.String> id, @Nullable NodePoolState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("ionoscloud:k8s/nodePool:NodePool", name, state, makeResourceOptions(options, id), false);
    }

    private static NodePoolArgs makeArgs(NodePoolArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? NodePoolArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static NodePool get(java.lang.String name, Output<java.lang.String> id, @Nullable NodePoolState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new NodePool(name, id, state, options);
    }
}
