// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.ionoscloud.pulumi.ionoscloud.k8s.outputs;

import com.ionoscloud.pulumi.ionoscloud.k8s.outputs.GetClusterConfig;
import com.ionoscloud.pulumi.ionoscloud.k8s.outputs.GetClusterMaintenanceWindow;
import com.ionoscloud.pulumi.ionoscloud.k8s.outputs.GetClusterS3Bucket;
import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;

@CustomType
public final class GetClusterResult {
    /**
     * @return access to the K8s API server is restricted to these CIDRs
     * 
     */
    private List<String> apiSubnetAllowLists;
    /**
     * @return A list of available versions for upgrading the cluster
     * 
     */
    private List<String> availableUpgradeVersions;
    /**
     * @return base64 decoded cluster certificate authority data (provided as an attribute for direct use)
     * 
     */
    private String caCrt;
    /**
     * @return structured kubernetes config consisting of a list with 1 item with the following fields:
     * * api_version - Kubernetes API Version
     * * kind - &#34;Config&#34;
     * * current-context - string
     * * clusters - list of
     * * name - name of cluster
     * * cluster - map of
     * * certificate-authority-data - **base64 decoded** cluster CA data
     * * server -  server address in the form `https://host:port`
     * * contexts - list of
     * * name - context name
     * * context - map of
     * * cluster - cluster name
     * * user - cluster user
     * * users - list of
     * * name - user name
     * * user - map of
     * * token - user token used for authentication
     * 
     */
    private List<GetClusterConfig> configs;
    /**
     * @return id of the cluster
     * 
     */
    private String id;
    /**
     * @return Kubernetes version
     * 
     */
    private String k8sVersion;
    /**
     * @return Kubernetes configuration
     * 
     */
    private String kubeConfig;
    /**
     * @return this attribute is mandatory if the cluster is private.
     * 
     */
    private String location;
    /**
     * @return A maintenance window comprise of a day of the week and a time for maintenance to be allowed
     * 
     */
    private List<GetClusterMaintenanceWindow> maintenanceWindows;
    /**
     * @return name of the cluster
     * 
     */
    private String name;
    /**
     * @return the NAT gateway IP of the cluster if the cluster is private.
     * 
     */
    private String natGatewayIp;
    /**
     * @return list of the IDs of the node pools in this cluster
     * 
     */
    private List<String> nodePools;
    /**
     * @return the node subnet of the cluster, if the cluster is private.
     * 
     */
    private String nodeSubnet;
    /**
     * @return indicates if the cluster is public or private.
     * 
     */
    private Boolean public_;
    /**
     * @return list of IONOS Object Storage bucket configured for K8s usage
     * 
     */
    private List<GetClusterS3Bucket> s3Buckets;
    /**
     * @return cluster server (same as `config[0].clusters[0].cluster.server` but provided as an attribute for ease of use)
     * 
     */
    private String server;
    /**
     * @return one of &#34;AVAILABLE&#34;,
     * &#34;INACTIVE&#34;,
     * &#34;BUSY&#34;,
     * &#34;DEPLOYING&#34;,
     * &#34;ACTIVE&#34;,
     * &#34;FAILED&#34;,
     * &#34;SUSPENDED&#34;,
     * &#34;FAILED_SUSPENDED&#34;,
     * &#34;UPDATING&#34;,
     * &#34;FAILED_UPDATING&#34;,
     * &#34;DESTROYING&#34;,
     * &#34;FAILED_DESTROYING&#34;,
     * &#34;TERMINATED&#34;
     * 
     */
    private String state;
    /**
     * @return a convenience map to be search the token of a specific user
     * - key - is the user name
     * - value - is the token
     * 
     */
    private Map<String,String> userTokens;
    /**
     * @return A list of versions that may be used for node pools under this cluster
     * 
     */
    private List<String> viableNodePoolVersions;

    private GetClusterResult() {}
    /**
     * @return access to the K8s API server is restricted to these CIDRs
     * 
     */
    public List<String> apiSubnetAllowLists() {
        return this.apiSubnetAllowLists;
    }
    /**
     * @return A list of available versions for upgrading the cluster
     * 
     */
    public List<String> availableUpgradeVersions() {
        return this.availableUpgradeVersions;
    }
    /**
     * @return base64 decoded cluster certificate authority data (provided as an attribute for direct use)
     * 
     */
    public String caCrt() {
        return this.caCrt;
    }
    /**
     * @return structured kubernetes config consisting of a list with 1 item with the following fields:
     * * api_version - Kubernetes API Version
     * * kind - &#34;Config&#34;
     * * current-context - string
     * * clusters - list of
     * * name - name of cluster
     * * cluster - map of
     * * certificate-authority-data - **base64 decoded** cluster CA data
     * * server -  server address in the form `https://host:port`
     * * contexts - list of
     * * name - context name
     * * context - map of
     * * cluster - cluster name
     * * user - cluster user
     * * users - list of
     * * name - user name
     * * user - map of
     * * token - user token used for authentication
     * 
     */
    public List<GetClusterConfig> configs() {
        return this.configs;
    }
    /**
     * @return id of the cluster
     * 
     */
    public String id() {
        return this.id;
    }
    /**
     * @return Kubernetes version
     * 
     */
    public String k8sVersion() {
        return this.k8sVersion;
    }
    /**
     * @return Kubernetes configuration
     * 
     */
    public String kubeConfig() {
        return this.kubeConfig;
    }
    /**
     * @return this attribute is mandatory if the cluster is private.
     * 
     */
    public String location() {
        return this.location;
    }
    /**
     * @return A maintenance window comprise of a day of the week and a time for maintenance to be allowed
     * 
     */
    public List<GetClusterMaintenanceWindow> maintenanceWindows() {
        return this.maintenanceWindows;
    }
    /**
     * @return name of the cluster
     * 
     */
    public String name() {
        return this.name;
    }
    /**
     * @return the NAT gateway IP of the cluster if the cluster is private.
     * 
     */
    public String natGatewayIp() {
        return this.natGatewayIp;
    }
    /**
     * @return list of the IDs of the node pools in this cluster
     * 
     */
    public List<String> nodePools() {
        return this.nodePools;
    }
    /**
     * @return the node subnet of the cluster, if the cluster is private.
     * 
     */
    public String nodeSubnet() {
        return this.nodeSubnet;
    }
    /**
     * @return indicates if the cluster is public or private.
     * 
     */
    public Boolean public_() {
        return this.public_;
    }
    /**
     * @return list of IONOS Object Storage bucket configured for K8s usage
     * 
     */
    public List<GetClusterS3Bucket> s3Buckets() {
        return this.s3Buckets;
    }
    /**
     * @return cluster server (same as `config[0].clusters[0].cluster.server` but provided as an attribute for ease of use)
     * 
     */
    public String server() {
        return this.server;
    }
    /**
     * @return one of &#34;AVAILABLE&#34;,
     * &#34;INACTIVE&#34;,
     * &#34;BUSY&#34;,
     * &#34;DEPLOYING&#34;,
     * &#34;ACTIVE&#34;,
     * &#34;FAILED&#34;,
     * &#34;SUSPENDED&#34;,
     * &#34;FAILED_SUSPENDED&#34;,
     * &#34;UPDATING&#34;,
     * &#34;FAILED_UPDATING&#34;,
     * &#34;DESTROYING&#34;,
     * &#34;FAILED_DESTROYING&#34;,
     * &#34;TERMINATED&#34;
     * 
     */
    public String state() {
        return this.state;
    }
    /**
     * @return a convenience map to be search the token of a specific user
     * - key - is the user name
     * - value - is the token
     * 
     */
    public Map<String,String> userTokens() {
        return this.userTokens;
    }
    /**
     * @return A list of versions that may be used for node pools under this cluster
     * 
     */
    public List<String> viableNodePoolVersions() {
        return this.viableNodePoolVersions;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetClusterResult defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private List<String> apiSubnetAllowLists;
        private List<String> availableUpgradeVersions;
        private String caCrt;
        private List<GetClusterConfig> configs;
        private String id;
        private String k8sVersion;
        private String kubeConfig;
        private String location;
        private List<GetClusterMaintenanceWindow> maintenanceWindows;
        private String name;
        private String natGatewayIp;
        private List<String> nodePools;
        private String nodeSubnet;
        private Boolean public_;
        private List<GetClusterS3Bucket> s3Buckets;
        private String server;
        private String state;
        private Map<String,String> userTokens;
        private List<String> viableNodePoolVersions;
        public Builder() {}
        public Builder(GetClusterResult defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.apiSubnetAllowLists = defaults.apiSubnetAllowLists;
    	      this.availableUpgradeVersions = defaults.availableUpgradeVersions;
    	      this.caCrt = defaults.caCrt;
    	      this.configs = defaults.configs;
    	      this.id = defaults.id;
    	      this.k8sVersion = defaults.k8sVersion;
    	      this.kubeConfig = defaults.kubeConfig;
    	      this.location = defaults.location;
    	      this.maintenanceWindows = defaults.maintenanceWindows;
    	      this.name = defaults.name;
    	      this.natGatewayIp = defaults.natGatewayIp;
    	      this.nodePools = defaults.nodePools;
    	      this.nodeSubnet = defaults.nodeSubnet;
    	      this.public_ = defaults.public_;
    	      this.s3Buckets = defaults.s3Buckets;
    	      this.server = defaults.server;
    	      this.state = defaults.state;
    	      this.userTokens = defaults.userTokens;
    	      this.viableNodePoolVersions = defaults.viableNodePoolVersions;
        }

        @CustomType.Setter
        public Builder apiSubnetAllowLists(List<String> apiSubnetAllowLists) {
            if (apiSubnetAllowLists == null) {
              throw new MissingRequiredPropertyException("GetClusterResult", "apiSubnetAllowLists");
            }
            this.apiSubnetAllowLists = apiSubnetAllowLists;
            return this;
        }
        public Builder apiSubnetAllowLists(String... apiSubnetAllowLists) {
            return apiSubnetAllowLists(List.of(apiSubnetAllowLists));
        }
        @CustomType.Setter
        public Builder availableUpgradeVersions(List<String> availableUpgradeVersions) {
            if (availableUpgradeVersions == null) {
              throw new MissingRequiredPropertyException("GetClusterResult", "availableUpgradeVersions");
            }
            this.availableUpgradeVersions = availableUpgradeVersions;
            return this;
        }
        public Builder availableUpgradeVersions(String... availableUpgradeVersions) {
            return availableUpgradeVersions(List.of(availableUpgradeVersions));
        }
        @CustomType.Setter
        public Builder caCrt(String caCrt) {
            if (caCrt == null) {
              throw new MissingRequiredPropertyException("GetClusterResult", "caCrt");
            }
            this.caCrt = caCrt;
            return this;
        }
        @CustomType.Setter
        public Builder configs(List<GetClusterConfig> configs) {
            if (configs == null) {
              throw new MissingRequiredPropertyException("GetClusterResult", "configs");
            }
            this.configs = configs;
            return this;
        }
        public Builder configs(GetClusterConfig... configs) {
            return configs(List.of(configs));
        }
        @CustomType.Setter
        public Builder id(String id) {
            if (id == null) {
              throw new MissingRequiredPropertyException("GetClusterResult", "id");
            }
            this.id = id;
            return this;
        }
        @CustomType.Setter
        public Builder k8sVersion(String k8sVersion) {
            if (k8sVersion == null) {
              throw new MissingRequiredPropertyException("GetClusterResult", "k8sVersion");
            }
            this.k8sVersion = k8sVersion;
            return this;
        }
        @CustomType.Setter
        public Builder kubeConfig(String kubeConfig) {
            if (kubeConfig == null) {
              throw new MissingRequiredPropertyException("GetClusterResult", "kubeConfig");
            }
            this.kubeConfig = kubeConfig;
            return this;
        }
        @CustomType.Setter
        public Builder location(String location) {
            if (location == null) {
              throw new MissingRequiredPropertyException("GetClusterResult", "location");
            }
            this.location = location;
            return this;
        }
        @CustomType.Setter
        public Builder maintenanceWindows(List<GetClusterMaintenanceWindow> maintenanceWindows) {
            if (maintenanceWindows == null) {
              throw new MissingRequiredPropertyException("GetClusterResult", "maintenanceWindows");
            }
            this.maintenanceWindows = maintenanceWindows;
            return this;
        }
        public Builder maintenanceWindows(GetClusterMaintenanceWindow... maintenanceWindows) {
            return maintenanceWindows(List.of(maintenanceWindows));
        }
        @CustomType.Setter
        public Builder name(String name) {
            if (name == null) {
              throw new MissingRequiredPropertyException("GetClusterResult", "name");
            }
            this.name = name;
            return this;
        }
        @CustomType.Setter
        public Builder natGatewayIp(String natGatewayIp) {
            if (natGatewayIp == null) {
              throw new MissingRequiredPropertyException("GetClusterResult", "natGatewayIp");
            }
            this.natGatewayIp = natGatewayIp;
            return this;
        }
        @CustomType.Setter
        public Builder nodePools(List<String> nodePools) {
            if (nodePools == null) {
              throw new MissingRequiredPropertyException("GetClusterResult", "nodePools");
            }
            this.nodePools = nodePools;
            return this;
        }
        public Builder nodePools(String... nodePools) {
            return nodePools(List.of(nodePools));
        }
        @CustomType.Setter
        public Builder nodeSubnet(String nodeSubnet) {
            if (nodeSubnet == null) {
              throw new MissingRequiredPropertyException("GetClusterResult", "nodeSubnet");
            }
            this.nodeSubnet = nodeSubnet;
            return this;
        }
        @CustomType.Setter("public")
        public Builder public_(Boolean public_) {
            if (public_ == null) {
              throw new MissingRequiredPropertyException("GetClusterResult", "public_");
            }
            this.public_ = public_;
            return this;
        }
        @CustomType.Setter
        public Builder s3Buckets(List<GetClusterS3Bucket> s3Buckets) {
            if (s3Buckets == null) {
              throw new MissingRequiredPropertyException("GetClusterResult", "s3Buckets");
            }
            this.s3Buckets = s3Buckets;
            return this;
        }
        public Builder s3Buckets(GetClusterS3Bucket... s3Buckets) {
            return s3Buckets(List.of(s3Buckets));
        }
        @CustomType.Setter
        public Builder server(String server) {
            if (server == null) {
              throw new MissingRequiredPropertyException("GetClusterResult", "server");
            }
            this.server = server;
            return this;
        }
        @CustomType.Setter
        public Builder state(String state) {
            if (state == null) {
              throw new MissingRequiredPropertyException("GetClusterResult", "state");
            }
            this.state = state;
            return this;
        }
        @CustomType.Setter
        public Builder userTokens(Map<String,String> userTokens) {
            if (userTokens == null) {
              throw new MissingRequiredPropertyException("GetClusterResult", "userTokens");
            }
            this.userTokens = userTokens;
            return this;
        }
        @CustomType.Setter
        public Builder viableNodePoolVersions(List<String> viableNodePoolVersions) {
            if (viableNodePoolVersions == null) {
              throw new MissingRequiredPropertyException("GetClusterResult", "viableNodePoolVersions");
            }
            this.viableNodePoolVersions = viableNodePoolVersions;
            return this;
        }
        public Builder viableNodePoolVersions(String... viableNodePoolVersions) {
            return viableNodePoolVersions(List.of(viableNodePoolVersions));
        }
        public GetClusterResult build() {
            final var _resultValue = new GetClusterResult();
            _resultValue.apiSubnetAllowLists = apiSubnetAllowLists;
            _resultValue.availableUpgradeVersions = availableUpgradeVersions;
            _resultValue.caCrt = caCrt;
            _resultValue.configs = configs;
            _resultValue.id = id;
            _resultValue.k8sVersion = k8sVersion;
            _resultValue.kubeConfig = kubeConfig;
            _resultValue.location = location;
            _resultValue.maintenanceWindows = maintenanceWindows;
            _resultValue.name = name;
            _resultValue.natGatewayIp = natGatewayIp;
            _resultValue.nodePools = nodePools;
            _resultValue.nodeSubnet = nodeSubnet;
            _resultValue.public_ = public_;
            _resultValue.s3Buckets = s3Buckets;
            _resultValue.server = server;
            _resultValue.state = state;
            _resultValue.userTokens = userTokens;
            _resultValue.viableNodePoolVersions = viableNodePoolVersions;
            return _resultValue;
        }
    }
}
