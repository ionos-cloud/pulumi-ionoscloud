// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ApigatewayCustomDomain {
    /**
     * [string] The certificate ID for the domain. Must be a valid certificate in UUID form.
     */
    certificateId?: pulumi.Input<string>;
    /**
     * [string] The domain name. Externally reachable.
     */
    name: pulumi.Input<string>;
}

export interface ApigatewayRouteUpstream {
    /**
     * [string] The host of the upstream.
     */
    host: pulumi.Input<string>;
    /**
     * [string] The load balancer algorithm. Default value: `roundrobin`.
     */
    loadbalancer?: pulumi.Input<string>;
    /**
     * [int] The port of the upstream. Default value: `80`.
     */
    port?: pulumi.Input<number>;
    /**
     * [string] The target URL of the upstream. Default value: `http`.
     */
    scheme?: pulumi.Input<string>;
    /**
     * [int] Weight with which to split traffic to the upstream. Default value: `100`.
     */
    weight?: pulumi.Input<number>;
}

export interface ApplicationLoadbalancerFlowlog {
    /**
     * [string] Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL. Immutable, forces re-creation.
     */
    action: pulumi.Input<string>;
    /**
     * [string] Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist. Immutable, forces re-creation.
     */
    bucket: pulumi.Input<string>;
    /**
     * [string] Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, forces re-creation.
     */
    direction: pulumi.Input<string>;
    /**
     * The resource's unique identifier.
     */
    id?: pulumi.Input<string>;
    /**
     * [string] Specifies the name of the flow log.
     *
     * ⚠️ **Note:**: Removing the `flowlog` forces re-creation of the application load balancer resource.
     */
    name: pulumi.Input<string>;
}

export interface ApplicationLoadbalancerForwardingruleHttpRule {
    /**
     * [list] - An array of items in the collection.The action is only performed if each and every condition is met; if no conditions are set, the rule will always be performed.
     */
    conditions?: pulumi.Input<pulumi.Input<inputs.ApplicationLoadbalancerForwardingruleHttpRuleCondition>[]>;
    /**
     * [string] Valid only for STATIC actions.
     */
    contentType?: pulumi.Input<string>;
    /**
     * [bool] Default is false; valid only for REDIRECT actions.
     */
    dropQuery?: pulumi.Input<boolean>;
    /**
     * [string] The location for redirecting; mandatory and valid only for REDIRECT actions.
     */
    location?: pulumi.Input<string>;
    /**
     * [string] The unique name of the Application Load Balancer HTTP rule.
     */
    name: pulumi.Input<string>;
    /**
     * [string] The response message of the request; mandatory for STATIC action.
     */
    responseMessage?: pulumi.Input<string>;
    /**
     * [int] Valid only for REDIRECT and STATIC actions. For REDIRECT actions, default is 301 and possible values are 301, 302, 303, 307, and 308. For STATIC actions, default is 503 and valid range is 200 to 599.
     */
    statusCode?: pulumi.Input<number>;
    /**
     * [string] The UUID of the target group; mandatory for FORWARD action.
     */
    targetGroup?: pulumi.Input<string>;
    /**
     * [string] Type of the Http Rule condition.
     */
    type: pulumi.Input<string>;
}

export interface ApplicationLoadbalancerForwardingruleHttpRuleCondition {
    /**
     * [string] Matching rule for the HTTP rule condition attribute; mandatory for HEADER, PATH, QUERY, METHOD, HOST, and COOKIE types; must be null when type is SOURCE_IP.
     */
    condition?: pulumi.Input<string>;
    /**
     * [string] Must be null when type is PATH, METHOD, HOST, or SOURCE_IP. Key can only be set when type is COOKIES, HEADER, or QUERY.
     */
    key?: pulumi.Input<string>;
    /**
     * [bool] Specifies whether the condition is negated or not; the default is False.
     */
    negate?: pulumi.Input<boolean>;
    /**
     * [string] Type of the Http Rule condition.
     */
    type: pulumi.Input<string>;
    /**
     * [string] Mandatory for conditions CONTAINS, EQUALS, MATCHES, STARTS_WITH, ENDS_WITH; must be null when condition is EXISTS; should be a valid CIDR if provided and if type is SOURCE_IP.
     */
    value?: pulumi.Input<string>;
}

export interface AutoCertificateProviderExternalAccountBinding {
    /**
     * The key ID of the external account binding
     */
    keyId: pulumi.Input<string>;
    /**
     * The secret of the external account binding
     */
    keySecret: pulumi.Input<string>;
}

export interface AutoscalingGroupPolicy {
    /**
     * [string] The Metric that should trigger the scaling actions. Metric values are checked at fixed intervals. Possible values: `INSTANCE_CPU_UTILIZATION_AVERAGE`, `INSTANCE_NETWORK_IN_BYTES`, `INSTANCE_NETWORK_IN_PACKETS`, `INSTANCE_NETWORK_OUT_BYTES`, `INSTANCE_NETWORK_OUT_PACKETS`
     */
    metric: pulumi.Input<string>;
    /**
     * [string] Defines the time range, for which the samples will be aggregated. Default is 120s. *Note that when you set it to values like 5m the API will automatically transform it in PT5M, so the plan will show you a diff in state that should be ignored.*
     */
    range?: pulumi.Input<string>;
    /**
     * [list] Specifies the action to take when the `scaleInThreshold` is exceeded. Hereby, scaling in is always about removing VMs that are currently associated with this autoscaling group. Default termination policy is OLDEST_SERVER_FIRST.
     */
    scaleInAction: pulumi.Input<inputs.AutoscalingGroupPolicyScaleInAction>;
    /**
     * [int] A lower threshold on the value of `metric`. Will be used with `less than` (<) operator. Exceeding this will start a Scale-In Action as specified by the `scaleInAction` property. The value must have a higher minimum delta to the `scaleOutThreshold` depending on the `metric` to avoid competitive actions at the same time.
     */
    scaleInThreshold: pulumi.Input<number>;
    /**
     * [list] Specifies the action to take when the `scaleOutThreshold` is exceeded. Hereby, scaling out is always about adding new VMs to this autoscaling group.
     */
    scaleOutAction: pulumi.Input<inputs.AutoscalingGroupPolicyScaleOutAction>;
    /**
     * [int] The upper threshold for the value of the `metric`. Used with the `greater than` (>) operator. A scale-out action is triggered when this value is exceeded, specified by the `scaleOutAction` property. The value must have a lower minimum delta to the `scaleInThreshold`, depending on the metric, to avoid competing for actions simultaneously. If `properties.policy.unit=TOTAL`, a value >= 40 must be chosen.
     */
    scaleOutThreshold: pulumi.Input<number>;
    /**
     * [string] Units of the applied Metric. Possible values are: `PER_HOUR`, `PER_MINUTE`, `PER_SECOND`, `TOTAL`.
     */
    unit: pulumi.Input<string>;
}

export interface AutoscalingGroupPolicyScaleInAction {
    /**
     * [int] When `amountType=ABSOLUTE` specifies the absolute number of VMs that are added. The value must be between 1 to 10. `amountType=PERCENTAGE` specifies the percentage value that is applied to the current number of replicas of the VM Auto Scaling Group. The value must be between 1 to 200. At least one VM is always added.
     */
    amount: pulumi.Input<number>;
    /**
     * [string] The type for the given amount. Possible values are: `ABSOLUTE`, `PERCENTAGE`.
     */
    amountType: pulumi.Input<string>;
    /**
     * [string] Minimum time to pass after this Scaling action has started, until the next Scaling action will be started. Additionally, if a Scaling action is currently in progress, no second Scaling action will be started for the same autoscaling group. Instead, the Metric will be re-evaluated after the current Scaling action is completed (either successfully or with failures). This is validated with a minimum value of 2 minutes and a maximum of 24 hours currently. Default value is 5 minutes if not given. *Note that when you set it to values like 5m the API will automatically transform it in PT5M, so the plan will show you a diff in state that should be ignored.*
     */
    cooldownPeriod?: pulumi.Input<string>;
    /**
     * [bool] If set to `true`, when deleting a replica during scale in, any attached volume will also be deleted. When set to `false`, all volumes remain in the datacenter and must be deleted manually. Note that every scale-out creates new volumes. When they are not deleted, they will eventually use all of your contracts resource limits. At this point, scaling out would not be possible anymore.
     */
    deleteVolumes: pulumi.Input<boolean>;
    /**
     * [string] The type of the termination policy for the autoscaling group so that a specific pattern is followed for Scaling-In replicas. Default termination policy is `OLDEST_SERVER_FIRST`. Possible values are: `OLDEST_SERVER_FIRST`, `NEWEST_SERVER_FIRST`, `RANDOM`
     */
    terminationPolicyType?: pulumi.Input<string>;
}

export interface AutoscalingGroupPolicyScaleOutAction {
    /**
     * [int] When `amountType=ABSOLUTE` specifies the absolute number of VMs that are added. The value must be between 1 to 10. `amountType=PERCENTAGE` specifies the percentage value that is applied to the current number of replicas of the VM Auto Scaling Group. The value must be between 1 to 200. At least one VM is always added.
     */
    amount: pulumi.Input<number>;
    /**
     * [string] The type for the given amount. Possible values are: `ABSOLUTE`, `PERCENTAGE`.
     */
    amountType: pulumi.Input<string>;
    /**
     * [string] Minimum time to pass after this Scaling action has started, until the next Scaling action will be started. Additionally, if a Scaling action is currently in progress, no second Scaling action will be started for the same autoscaling group. Instead, the Metric will be re-evaluated after the current Scaling action is completed (either successfully or with failures). This is validated with a minimum value of 2 minutes and a maximum of 24 hours currently. Default value is 5 minutes if not given. *Note that when you set it to values like 5m the API will automatically transform it in PT5M, so the plan will show you a diff in state that should be ignored.*
     */
    cooldownPeriod?: pulumi.Input<string>;
}

export interface AutoscalingGroupReplicaConfiguration {
    /**
     * [string] The zone where the VMs are created using this configuration. Possible values are: `AUTO`, `ZONE_1`, `ZONE_2`.
     */
    availabilityZone: pulumi.Input<string>;
    /**
     * [int] The total number of cores for the VMs.
     */
    cores: pulumi.Input<number>;
    /**
     * [string] PU family for the VMs created using this configuration. If null, the VM will be created with the default CPU family for the assigned location. Possible values are: `INTEL_SKYLAKE`, `INTEL_XEON`.
     */
    cpuFamily?: pulumi.Input<string>;
    /**
     * Set of NICs associated with this Replica.
     */
    nics?: pulumi.Input<pulumi.Input<inputs.AutoscalingGroupReplicaConfigurationNic>[]>;
    /**
     * [int] The amount of memory for the VMs in MB, e.g. 2048. Size must be specified in multiples of 256 MB with a minimum of 256 MB; however, if you set ramHotPlug to TRUE then you must use a minimum of 1024 MB. If you set the RAM size more than 240GB, then ramHotPlug will be set to FALSE and can not be set to TRUE unless RAM size not set to less than 240GB.
     */
    ram: pulumi.Input<number>;
    /**
     * [list] List of volumes associated with this Replica.
     */
    volumes?: pulumi.Input<pulumi.Input<inputs.AutoscalingGroupReplicaConfigurationVolume>[]>;
}

export interface AutoscalingGroupReplicaConfigurationNic {
    /**
     * [bool] Dhcp flag for this replica Nic. This is an optional attribute with default value of `true` if not given in the request payload or given as null.
     */
    dhcp?: pulumi.Input<boolean>;
    /**
     * [bool] Firewall active flag.
     */
    firewallActive?: pulumi.Input<boolean>;
    /**
     * List of all firewall rules for the specified NIC.
     */
    firewallRules?: pulumi.Input<pulumi.Input<inputs.AutoscalingGroupReplicaConfigurationNicFirewallRule>[]>;
    /**
     * [string] The type of firewall rules that will be allowed on the NIC. Valid values: INGRESS EGRESS BIDIRECTIONAL. If not specified, the default INGRESS value is used.
     */
    firewallType?: pulumi.Input<string>;
    /**
     * [list] Only 1 flow log can be configured. Only the name field can change as part of an update. Flow logs holistically capture network information such as source and destination IP addresses, source and destination ports, number of packets, amount of bytes, the start and end time of the recording, and the type of protocol – and log the extent to which your instances are being accessed.
     */
    flowLogs?: pulumi.Input<pulumi.Input<inputs.AutoscalingGroupReplicaConfigurationNicFlowLog>[]>;
    /**
     * [int] Lan ID for this replica Nic.
     */
    lan: pulumi.Input<number>;
    /**
     * [string] Name for this replica volume.
     */
    name: pulumi.Input<string>;
    /**
     * [list] In order to link VM to ALB, target group must be provided
     */
    targetGroup?: pulumi.Input<inputs.AutoscalingGroupReplicaConfigurationNicTargetGroup>;
}

export interface AutoscalingGroupReplicaConfigurationNicFirewallRule {
    /**
     * [int] Defines the allowed code (from 0 to 254) if protocol ICMP is chosen.
     */
    icmpCode?: pulumi.Input<number>;
    /**
     * [string] Defines the allowed code (from 0 to 254) if protocol ICMP is chosen. Value null allows all codes.
     */
    icmpType?: pulumi.Input<number>;
    /**
     * [string] Name for this replica volume.
     */
    name?: pulumi.Input<string>;
    /**
     * [int] Defines the end range of the allowed port (from 1 to 65534) if the protocol TCP or UDP is chosen. Leave portRangeStart and portRangeEnd null to allow all ports.
     */
    portRangeEnd?: pulumi.Input<number>;
    /**
     * [int] Defines the start range of the allowed port (from 1 to 65534) if protocol TCP or UDP is chosen. Leave portRangeStart and portRangeEnd null to allow all ports.
     */
    portRangeStart?: pulumi.Input<number>;
    /**
     * [string] The protocol for the rule: TCP, UDP, ICMP, ANY. Property cannot be modified after creation (disallowed in update requests).
     */
    protocol: pulumi.Input<string>;
    /**
     * [string] Only traffic originating from the respective IPv4 address is allowed. Value null allows all source IPs.
     */
    sourceIp?: pulumi.Input<string>;
    /**
     * [string] Only traffic originating from the respective MAC address is allowed. Valid format: aa:bb:cc:dd:ee:ff. Value null allows all source MAC address. Valid format: aa:bb:cc:dd:ee:ff.
     */
    sourceMac?: pulumi.Input<string>;
    /**
     * [string] In case the target NIC has multiple IP addresses, only traffic directed to the respective IP address of the NIC is allowed. Value null allows all target IPs.
     */
    targetIp?: pulumi.Input<string>;
    /**
     * [string] Storage Type for this replica volume. Possible values: `SSD`, `HDD`, `SSD_STANDARD` or `SSD_PREMIUM`.
     */
    type?: pulumi.Input<string>;
}

export interface AutoscalingGroupReplicaConfigurationNicFlowLog {
    /**
     * [string] Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL. Immutable, forces re-creation.
     */
    action: pulumi.Input<string>;
    /**
     * [string] Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist. Immutable, forces re-creation.
     */
    bucket: pulumi.Input<string>;
    /**
     * [string] Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, forces re-creation.
     */
    direction: pulumi.Input<string>;
    /**
     * The resource's unique identifier.
     */
    id?: pulumi.Input<string>;
    /**
     * [string] Name for this replica volume.
     */
    name: pulumi.Input<string>;
}

export interface AutoscalingGroupReplicaConfigurationNicTargetGroup {
    /**
     * [int] The port of the target group.
     */
    port: pulumi.Input<number>;
    /**
     * [string] The ID of the target group.
     */
    targetGroupId: pulumi.Input<string>;
    /**
     * [int] The weight of the target group.
     */
    weight: pulumi.Input<number>;
}

export interface AutoscalingGroupReplicaConfigurationVolume {
    /**
     * [string] The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either `public image` or `imageAlias` in conjunction with this property.
     */
    backupUnitId?: pulumi.Input<string>;
    /**
     * [string] Determines whether the volume will be used as a boot volume. Set to NONE, the volume will not be used as boot volume. Set to PRIMARY, the volume will be used as boot volume and set to AUTO will delegate the decision to the provisioning engine to decide whether to use the volume as boot volume.
     * Notice that exactly one volume can be set to PRIMARY or all of them set to AUTO.
     */
    bootOrder: pulumi.Input<string>;
    /**
     * [string] The bus type of the volume. Default setting is `VIRTIO`. The bus type `IDE` is also supported.
     */
    bus?: pulumi.Input<string>;
    /**
     * [string] The image installed on the volume. Only the UUID of the image is presently supported.
     */
    image?: pulumi.Input<string>;
    /**
     * [string] The image installed on the volume. Must be an `imageAlias` as specified via the images API. Note that one of `image` or `imageAlias` must be set, but not both.
     */
    imageAlias?: pulumi.Input<string>;
    /**
     * [string] Image password for this replica volume.
     */
    imagePassword?: pulumi.Input<string>;
    /**
     * [string] Name for this replica volume.
     */
    name: pulumi.Input<string>;
    /**
     * [int] Name for this replica volume.
     */
    size: pulumi.Input<number>;
    /**
     * List of ssh keys, supports values or paths to files. Cannot be changed at update.
     */
    sshKeys?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * [string] Storage Type for this replica volume. Possible values: `SSD`, `HDD`, `SSD_STANDARD` or `SSD_PREMIUM`.
     */
    type: pulumi.Input<string>;
    /**
     * [string] User-data (Cloud Init) for this replica volume. Make sure you provide a Cloud Init compatible image in conjunction with this parameter.
     */
    userData?: pulumi.Input<string>;
}

export interface CdnDistributionRoutingRule {
    /**
     * [string] The prefix of the routing rule.
     */
    prefix: pulumi.Input<string>;
    /**
     * [string] The scheme of the routing rule.
     */
    scheme: pulumi.Input<string>;
    /**
     * [map] - A map of properties for the rule
     */
    upstream: pulumi.Input<inputs.CdnDistributionRoutingRuleUpstream>;
}

export interface CdnDistributionRoutingRuleUpstream {
    /**
     * [bool] Enable or disable caching. If enabled, the CDN will cache the responses from the upstream host. Subsequent requests for the same resource will be served from the cache.
     */
    caching: pulumi.Input<boolean>;
    /**
     * [map] - A map of geo_restrictions
     */
    geoRestrictions?: pulumi.Input<inputs.CdnDistributionRoutingRuleUpstreamGeoRestrictions>;
    /**
     * [string] The upstream host that handles the requests if not already cached. This host will be protected by the WAF if the option is enabled.
     */
    host: pulumi.Input<string>;
    /**
     * [string] Rate limit class that will be applied to limit the number of incoming requests per IP.
     */
    rateLimitClass: pulumi.Input<string>;
    /**
     * [string] The SNI (Server Name Indication) mode of the upstream. It supports two modes: 1) `distribution`: for outgoing connections to the upstream host, the CDN requires the upstream host to present a valid certificate that matches the configured domain of the CDN distribution; 2) `origin`: for outgoing connections to the upstream host, the CDN requires the upstream host to present a valid certificate that matches the configured upstream/origin hostname.
     */
    sniMode: pulumi.Input<string>;
    /**
     * [bool] Enable or disable WAF to protect the upstream host.
     */
    waf: pulumi.Input<boolean>;
}

export interface CdnDistributionRoutingRuleUpstreamGeoRestrictions {
    /**
     * [string] List of allowed countries
     */
    allowLists?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * [string] List of blocked countries
     */
    blockLists?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ContainerRegistryFeatures {
    /**
     * [bool] Enables or disables the Vulnerability Scanning feature for the Container Registry. To disable this feature, set the attribute to false when creating the CR resource.
     *
     * > **⚠ WARNING** `Container Registry Vulnerability Scanning` is a paid feature which is enabled by default, and cannot be turned off after activation. To disable this feature for a Container Registry, ensure `vulnerabilityScanning` is set to false on resource creation.
     */
    vulnerabilityScanning?: pulumi.Input<boolean>;
}

export interface ContainerRegistryGarbageCollectionSchedule {
    /**
     * [list] Elements of list must have one of the values: `Saturday`, `Sunday`, `Monday`, `Tuesday`,  `Wednesday`,  `Thursday`,  `Friday`
     */
    days: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * [string]
     */
    time: pulumi.Input<string>;
}

export interface ContainerRegistryStorageUsage {
    bytes?: pulumi.Input<number>;
    updatedAt?: pulumi.Input<string>;
}

export interface ContainerRegistryTokenCredential {
    password: pulumi.Input<string>;
    username: pulumi.Input<string>;
}

export interface ContainerRegistryTokenScope {
    /**
     * [string] Example: ["pull", "push", "delete"]
     */
    actions: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * [string]
     */
    name: pulumi.Input<string>;
    /**
     * [string]
     */
    type: pulumi.Input<string>;
}

export interface CubeServerNic {
    deviceNumber?: pulumi.Input<number>;
    dhcp?: pulumi.Input<boolean>;
    /**
     * Indicates whether this NIC receives an IPv6 address through DHCP.
     */
    dhcpv6?: pulumi.Input<boolean>;
    firewall?: pulumi.Input<inputs.CubeServerNicFirewall>;
    firewallActive?: pulumi.Input<boolean>;
    firewallType?: pulumi.Input<string>;
    ips?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * IPv6 CIDR block assigned to the NIC.
     */
    ipv6CidrBlock?: pulumi.Input<string>;
    /**
     * Collection for IPv6 addresses assigned to a nic. Explicitly assigned IPv6 addresses need to come from inside the IPv6 CIDR block assigned to the nic.
     */
    ipv6Ips?: pulumi.Input<pulumi.Input<string>[]>;
    lan: pulumi.Input<number>;
    mac?: pulumi.Input<string>;
    /**
     * [string] The name of the server.
     */
    name?: pulumi.Input<string>;
    pciSlot?: pulumi.Input<number>;
}

export interface CubeServerNicFirewall {
    icmpCode?: pulumi.Input<string>;
    icmpType?: pulumi.Input<string>;
    /**
     * [string] The name of the server.
     */
    name?: pulumi.Input<string>;
    portRangeEnd?: pulumi.Input<number>;
    portRangeStart?: pulumi.Input<number>;
    protocol: pulumi.Input<string>;
    sourceIp?: pulumi.Input<string>;
    sourceMac?: pulumi.Input<string>;
    targetIp?: pulumi.Input<string>;
    type?: pulumi.Input<string>;
}

export interface CubeServerVolume {
    /**
     * [string] The availability zone in which the server should exist. This property is immutable.
     */
    availabilityZone?: pulumi.Input<string>;
    /**
     * The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
     */
    backupUnitId?: pulumi.Input<string>;
    /**
     * The UUID of the attached server.
     */
    bootServer?: pulumi.Input<string>;
    bus?: pulumi.Input<string>;
    cpuHotPlug?: pulumi.Input<boolean>;
    deviceNumber?: pulumi.Input<number>;
    discVirtioHotPlug?: pulumi.Input<boolean>;
    discVirtioHotUnplug?: pulumi.Input<boolean>;
    diskType: pulumi.Input<string>;
    /**
     * [string] Required if `sshKeyPath` is not provided.
     *
     * > **⚠ WARNING**
     * >
     * > Image_name under volume level is deprecated, please use imageName under server level
     *
     *
     * > **⚠ WARNING**
     * >
     * > For creating a **CUBE** server, you can not set `volume.size` argument.
     * >
     *
     * @deprecated Please use imagePassword under server level
     */
    imagePassword?: pulumi.Input<string>;
    /**
     * [string] Sets the OS type of the server.
     */
    licenceType?: pulumi.Input<string>;
    /**
     * [string] The name of the server.
     */
    name?: pulumi.Input<string>;
    nicHotPlug?: pulumi.Input<boolean>;
    nicHotUnplug?: pulumi.Input<boolean>;
    pciSlot?: pulumi.Input<number>;
    ramHotPlug?: pulumi.Input<boolean>;
    /**
     * [list] List of paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images. Required for IonosCloud Linux images. Required if `imagePassword` is not provided.
     *
     * @deprecated Please use sshKeyPath under server level
     */
    sshKeyPaths?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
     */
    userData?: pulumi.Input<string>;
}

export interface DataplatformClusterLan {
    /**
     * [bool] Indicates if the Kubernetes node pool LAN will reserve an IP using DHCP. The default value is 'true'.
     */
    dhcp?: pulumi.Input<boolean>;
    /**
     * [string] The LAN ID of an existing LAN at the related data center.
     */
    lanId: pulumi.Input<string>;
    /**
     * [list] An array of additional LANs attached to worker nodes.
     */
    routes?: pulumi.Input<pulumi.Input<inputs.DataplatformClusterLanRoute>[]>;
}

export interface DataplatformClusterLanRoute {
    /**
     * [string] IPv4 or IPv6 gateway IP for the route.
     */
    gateway: pulumi.Input<string>;
    /**
     * [string] IPv4 or IPv6 CIDR to be routed via the interface.
     */
    network: pulumi.Input<string>;
}

export interface DataplatformClusterMaintenanceWindow {
    /**
     * [string] Must be set with one the values `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday` or `Sunday`.
     */
    dayOfTheWeek: pulumi.Input<string>;
    /**
     * [string] Time at which the maintenance should start. Must conform to the 'HH:MM:SS' 24-hour format. This pattern matches the "HH:MM:SS 24-hour format with leading 0" format. For more information take a look at [this link](https://stackoverflow.com/questions/7536755/regular-expression-for-matching-hhmm-time-format).
     */
    time: pulumi.Input<string>;
}

export interface DataplatformNodePoolMaintenanceWindow {
    /**
     * [string] Must be set with one the values `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday` or `Sunday`.
     */
    dayOfTheWeek: pulumi.Input<string>;
    /**
     * [string] Time at which the maintenance should start. Must conform to the 'HH:MM:SS' 24-hour format. This pattern matches the "HH:MM:SS 24-hour format with leading 0" format. For more information take a look at [this link](https://stackoverflow.com/questions/7536755/regular-expression-for-matching-hhmm-time-format).
     */
    time: pulumi.Input<string>;
}

export interface GetIpblockIpConsumer {
    datacenterId?: string;
    datacenterName?: string;
    ip?: string;
    k8sClusterUuid?: string;
    k8sNodepoolUuid?: string;
    mac?: string;
    nicId?: string;
    serverId?: string;
    serverName?: string;
}

export interface GetIpblockIpConsumerArgs {
    datacenterId?: pulumi.Input<string>;
    datacenterName?: pulumi.Input<string>;
    ip?: pulumi.Input<string>;
    k8sClusterUuid?: pulumi.Input<string>;
    k8sNodepoolUuid?: pulumi.Input<string>;
    mac?: pulumi.Input<string>;
    nicId?: pulumi.Input<string>;
    serverId?: pulumi.Input<string>;
    serverName?: pulumi.Input<string>;
}

export interface GetK8sClustersFilter {
    name: string;
    value: string;
}

export interface GetK8sClustersFilterArgs {
    name: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface GetMongoUserRole {
    database?: string;
    /**
     * A list of mongodb user roles. Examples: read, readWrite, readAnyDatabase
     */
    role?: string;
}

export interface GetMongoUserRoleArgs {
    database?: pulumi.Input<string>;
    /**
     * A list of mongodb user roles. Examples: read, readWrite, readAnyDatabase
     */
    role?: pulumi.Input<string>;
}

export interface GetNfsShareClientGroup {
    /**
     * Optional description for the clients groups.
     */
    description?: string;
    /**
     * A singular host allowed to connect to the share. The host can be specified as IP address and can be either IPv4 or IPv6.
     */
    hosts?: string[];
    /**
     * The allowed host or network to which the export is being shared. The IP address can be either IPv4 or IPv6 and has to be given with CIDR notation.
     */
    ipNetworks?: string[];
    /**
     * The NFS configuration for the client group. Each NFS configuration supports the following:
     */
    nfs?: inputs.GetNfsShareClientGroupNf[];
}

export interface GetNfsShareClientGroupArgs {
    /**
     * Optional description for the clients groups.
     */
    description?: pulumi.Input<string>;
    /**
     * A singular host allowed to connect to the share. The host can be specified as IP address and can be either IPv4 or IPv6.
     */
    hosts?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The allowed host or network to which the export is being shared. The IP address can be either IPv4 or IPv6 and has to be given with CIDR notation.
     */
    ipNetworks?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The NFS configuration for the client group. Each NFS configuration supports the following:
     */
    nfs?: pulumi.Input<pulumi.Input<inputs.GetNfsShareClientGroupNfArgs>[]>;
}

export interface GetNfsShareClientGroupNf {
    /**
     * The squash mode for the export. The squash mode can be: none - No squash mode. no mapping, root-anonymous - Map root user to anonymous uid, all-anonymous - Map all users to anonymous uid.
     */
    squash?: string;
}

export interface GetNfsShareClientGroupNfArgs {
    /**
     * The squash mode for the export. The squash mode can be: none - No squash mode. no mapping, root-anonymous - Map root user to anonymous uid, all-anonymous - Map all users to anonymous uid.
     */
    squash?: pulumi.Input<string>;
}

export interface GetServersFilter {
    name: string;
    value: string;
}

export interface GetServersFilterArgs {
    name: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface KafkaClusterConnections {
    /**
     * [list] IP address and port of cluster brokers.
     */
    brokerAddresses: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * [string] The datacenter to connect your instance to.
     */
    datacenterId: pulumi.Input<string>;
    /**
     * [string] The numeric LAN ID to connect your instance to.
     */
    lanId: pulumi.Input<string>;
}

export interface LoggingPipelineLog {
    /**
     * [list] The configuration of the logs datastore, a list that contains elements with the following structure:
     */
    destinations?: pulumi.Input<pulumi.Input<inputs.LoggingPipelineLogDestination>[]>;
    /**
     * [string] "Protocol to use as intake. Possible values are: http, tcp."
     */
    protocol: pulumi.Input<string>;
    /**
     * [bool]
     */
    public?: pulumi.Input<boolean>;
    /**
     * [string] The source parser to be used.
     */
    source: pulumi.Input<string>;
    /**
     * [string] The tag is used to distinguish different pipelines. Must be unique amongst the pipeline's array items.
     */
    tag: pulumi.Input<string>;
}

export interface LoggingPipelineLogDestination {
    /**
     * [int] Defines the number of days a log record should be kept in loki. Works with loki destination type only. Can be one of: 7, 14, 30.
     */
    retentionInDays?: pulumi.Input<number>;
    /**
     * [string] The internal output stream to send logs to.
     */
    type?: pulumi.Input<string>;
}

export interface NatgatewayLan {
    /**
     * [list] Collection of gateway IP addresses of the NAT gateway. Will be auto-generated if not provided. Should ideally be an IP belonging to the same subnet as the LAN.
     */
    gatewayIps?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * [int] Id for the LAN connected to the NAT gateway.
     */
    id: pulumi.Input<number>;
}

export interface NatgatewayRuleTargetPortRange {
    /**
     * [int] Target port range end associated with the NAT gateway rule.
     */
    end?: pulumi.Input<number>;
    /**
     * [int] Target port range start associated with the NAT gateway rule.
     */
    start?: pulumi.Input<number>;
}

export interface NetworkloadbalancerFlowlog {
    /**
     * [string] Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL. Immutable, forces re-creation.
     */
    action: pulumi.Input<string>;
    /**
     * [string] Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist. Immutable, forces re-creation.
     */
    bucket: pulumi.Input<string>;
    /**
     * [string] Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, forces re-creation.
     */
    direction: pulumi.Input<string>;
    /**
     * The resource's unique identifier.
     */
    id?: pulumi.Input<string>;
    /**
     * [string] Specifies the name of the flow log.
     *
     * ⚠️ **Note:**: Removing the `flowlog` forces re-creation of the network load balancer resource.
     */
    name: pulumi.Input<string>;
}

export interface NetworkloadbalancerForwardingruleHealthCheck {
    /**
     * [int] ClientTimeout is expressed in milliseconds. This inactivity timeout applies when the client is expected to acknowledge or send data. If unset the default of 50 seconds will be used.
     */
    clientTimeout?: pulumi.Input<number>;
    /**
     * [int] It specifies the maximum time (in milliseconds) to wait for a connection attempt to a target VM to succeed. If unset, the default of 5 seconds will be used.
     */
    connectTimeout?: pulumi.Input<number>;
    /**
     * [int] Retries specifies the number of retries to perform on a target VM after a connection failure. If unset, the default value of 3 will be used.
     */
    retries?: pulumi.Input<number>;
    /**
     * [int] TargetTimeout specifies the maximum inactivity time (in milliseconds) on the target VM side. If unset, the default of 50 seconds will be used.
     */
    targetTimeout?: pulumi.Input<number>;
}

export interface NetworkloadbalancerForwardingruleTarget {
    /**
     * Health check attributes for Network Load Balancer forwarding rule target.
     */
    healthCheck?: pulumi.Input<inputs.NetworkloadbalancerForwardingruleTargetHealthCheck>;
    /**
     * [string] IP of a balanced target VM.
     */
    ip: pulumi.Input<string>;
    /**
     * [int] Port of the balanced target service. (range: 1 to 65535).
     */
    port: pulumi.Input<number>;
    /**
     * [string] The proxy protocol version. Accepted values are `none`, `v1`, `v2`, `v2ssl`. If unspecified, the default value of `none` is used.
     */
    proxyProtocol?: pulumi.Input<string>;
    /**
     * [int] Weight parameter is used to adjust the target VM's weight relative to other target VMs.
     */
    weight: pulumi.Input<number>;
}

export interface NetworkloadbalancerForwardingruleTargetHealthCheck {
    /**
     * [boolean] Check specifies whether the target VM's health is checked.
     */
    check?: pulumi.Input<boolean>;
    /**
     * [int] CheckInterval determines the duration (in milliseconds) between consecutive health checks. If unspecified a default of 2000 ms is used.
     */
    checkInterval?: pulumi.Input<number>;
    /**
     * [boolean] Maintenance specifies if a target VM should be marked as down, even if it is not.
     */
    maintenance?: pulumi.Input<boolean>;
}

export interface NfsClusterConnections {
    /**
     * The ID of the datacenter where the Network File Storage cluster is located.
     */
    datacenterId: pulumi.Input<string>;
    /**
     * The IP address and prefix of the Network File Storage cluster. The IP address can be either IPv4 or IPv6. The IP address has to be given with CIDR notation.
     */
    ipAddress: pulumi.Input<string>;
    /**
     * The Private LAN to which the Network File Storage cluster must be connected.
     */
    lan: pulumi.Input<string>;
}

export interface NfsClusterNfs {
    /**
     * The minimum supported version of the NFS cluster. Supported values: `4.2`. Default is `4.2`.
     */
    minVersion?: pulumi.Input<string>;
}

export interface NfsShareClientGroup {
    /**
     * Optional description for the clients groups.
     */
    description?: pulumi.Input<string>;
    /**
     * A singular host allowed to connect to the share. The host can be specified as IP address and can be either IPv4 or IPv6.
     */
    hosts: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The allowed host or network to which the export is being shared. The IP address can be either IPv4 or IPv6 and has to be given with CIDR notation.
     */
    ipNetworks: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * NFS specific configurations. Each configuration includes:
     */
    nfs?: pulumi.Input<inputs.NfsShareClientGroupNfs>;
}

export interface NfsShareClientGroupNfs {
    /**
     * The squash mode for the export. The squash mode can be:
     */
    squash?: pulumi.Input<string>;
}

export interface PrivateCrossconnectConnectableDatacenter {
    /**
     * The UUID of the connectable datacenter
     */
    id?: pulumi.Input<string>;
    /**
     * The location of the cross-connected datacenter
     */
    location?: pulumi.Input<string>;
    /**
     * The name of the connectable datacenter
     */
    name?: pulumi.Input<string>;
}

export interface PrivateCrossconnectPeer {
    /**
     * The id of the cross-connected datacenter
     */
    datacenterId?: pulumi.Input<string>;
    /**
     * The name of the cross-connected datacenter
     */
    datacenterName?: pulumi.Input<string>;
    /**
     * The id of the cross-connected LAN
     */
    lanId?: pulumi.Input<string>;
    /**
     * The name of the cross-connected LAN
     */
    lanName?: pulumi.Input<string>;
    /**
     * The location of the cross-connected datacenter
     */
    location?: pulumi.Input<string>;
}

export interface TargetGroupHealthCheck {
    /**
     * [int] The interval in milliseconds between consecutive health checks; default is 2000.
     */
    checkInterval?: pulumi.Input<number>;
    /**
     * [int] The maximum time in milliseconds to wait for a target to respond to a check. For target VMs with 'Check Interval' set, the lesser of the two  values is used once the TCP connection is established.
     */
    checkTimeout?: pulumi.Input<number>;
    /**
     * [int] The maximum number of attempts to reconnect to a target after a connection failure. Valid range is 0 to 65535, and default is three reconnection.
     */
    retries?: pulumi.Input<number>;
}

export interface TargetGroupHttpHealthCheck {
    /**
     * [string]
     */
    matchType: pulumi.Input<string>;
    /**
     * [string] The method for the HTTP health check.
     */
    method?: pulumi.Input<string>;
    /**
     * [bool]
     */
    negate?: pulumi.Input<boolean>;
    /**
     * [string] The path (destination URL) for the HTTP health check request; the default is /.
     */
    path?: pulumi.Input<string>;
    /**
     * [bool]
     */
    regex?: pulumi.Input<boolean>;
    /**
     * [string] The response returned by the request, depending on the match type.
     */
    response: pulumi.Input<string>;
}

export interface TargetGroupTarget {
    /**
     * [bool] Makes the target available only if it accepts periodic health check TCP connection attempts; when turned off, the target is considered always available. The health check only consists of a connection attempt to the address and port of the target. Default is True.
     */
    healthCheckEnabled?: pulumi.Input<boolean>;
    /**
     * [string] The IP of the balanced target VM.
     */
    ip: pulumi.Input<string>;
    /**
     * [bool] Maintenance mode prevents the target from receiving balanced traffic.
     */
    maintenanceEnabled?: pulumi.Input<boolean>;
    /**
     * [int] The port of the balanced target service; valid range is 1 to 65535.
     */
    port: pulumi.Input<number>;
    /**
     * [string] The proxy protocol version. Accepted values are `none`, `v1`, `v2`, `v2ssl`. If unspecified, the default value of `none` is used.
     */
    proxyProtocol?: pulumi.Input<string>;
    /**
     * [int] Traffic is distributed in proportion to target weight, relative to the combined weight of all targets. A target with higher weight receives a greater share of traffic. Valid range is 0 to 256 and default is 1; targets with weight of 0 do not participate in load balancing but still accept persistent connections. It is best use values in the middle of the range to leave room for later adjustments.
     */
    weight: pulumi.Input<number>;
}

export interface VcpuServerLabel {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface VcpuServerNic {
    deviceNumber?: pulumi.Input<number>;
    dhcp?: pulumi.Input<boolean>;
    dhcpv6?: pulumi.Input<boolean>;
    firewallActive?: pulumi.Input<boolean>;
    firewallType?: pulumi.Input<string>;
    /**
     * Allows to define firewall rules inline in the server. See the Firewall section.
     */
    firewalls?: pulumi.Input<pulumi.Input<inputs.VcpuServerNicFirewall>[]>;
    id?: pulumi.Input<string>;
    /**
     * Collection of IP addresses assigned to a nic. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.
     */
    ips?: pulumi.Input<pulumi.Input<string>[]>;
    ipv6CidrBlock?: pulumi.Input<string>;
    ipv6Ips?: pulumi.Input<pulumi.Input<string>[]>;
    lan: pulumi.Input<number>;
    mac?: pulumi.Input<string>;
    /**
     * [string] The name of the server.
     */
    name?: pulumi.Input<string>;
    pciSlot?: pulumi.Input<number>;
}

export interface VcpuServerNicFirewall {
    icmpCode?: pulumi.Input<string>;
    icmpType?: pulumi.Input<string>;
    id?: pulumi.Input<string>;
    /**
     * [string] The name of the server.
     */
    name?: pulumi.Input<string>;
    portRangeEnd?: pulumi.Input<number>;
    portRangeStart?: pulumi.Input<number>;
    protocol: pulumi.Input<string>;
    sourceIp?: pulumi.Input<string>;
    sourceMac?: pulumi.Input<string>;
    targetIp?: pulumi.Input<string>;
    type?: pulumi.Input<string>;
}

export interface VcpuServerVolume {
    /**
     * [string] The availability zone in which the server should exist. E.g: `AUTO`, `ZONE_1`, `ZONE_2`. This property is immutable.
     */
    availabilityZone?: pulumi.Input<string>;
    /**
     * The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
     */
    backupUnitId?: pulumi.Input<string>;
    /**
     * The UUID of the attached server.
     */
    bootServer?: pulumi.Input<string>;
    bus?: pulumi.Input<string>;
    cpuHotPlug?: pulumi.Input<boolean>;
    deviceNumber?: pulumi.Input<number>;
    discVirtioHotPlug?: pulumi.Input<boolean>;
    discVirtioHotUnplug?: pulumi.Input<boolean>;
    diskType: pulumi.Input<string>;
    /**
     * [string] Sets the OS type of the server.
     */
    licenceType?: pulumi.Input<string>;
    /**
     * [string] The name of the server.
     */
    name?: pulumi.Input<string>;
    nicHotPlug?: pulumi.Input<boolean>;
    nicHotUnplug?: pulumi.Input<boolean>;
    pciSlot?: pulumi.Input<number>;
    ramHotPlug?: pulumi.Input<boolean>;
    /**
     * The size of the volume in GB.
     */
    size?: pulumi.Input<number>;
    /**
     * The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
     */
    userData?: pulumi.Input<string>;
}
export namespace compute {
    export interface DatacenterCpuArchitecture {
        /**
         * A valid CPU family name
         */
        cpuFamily?: pulumi.Input<string>;
        /**
         * The maximum number of cores available
         */
        maxCores?: pulumi.Input<number>;
        /**
         * The maximum number of RAM in MB
         */
        maxRam?: pulumi.Input<number>;
        /**
         * A valid CPU vendor name
         */
        vendor?: pulumi.Input<string>;
    }

    export interface GroupUser {
        administrator?: pulumi.Input<boolean>;
        email?: pulumi.Input<string>;
        firstName?: pulumi.Input<string>;
        forceSecAuth?: pulumi.Input<boolean>;
        id?: pulumi.Input<string>;
        lastName?: pulumi.Input<string>;
        password?: pulumi.Input<string>;
    }

    export interface IPBlockIpConsumer {
        datacenterId?: pulumi.Input<string>;
        datacenterName?: pulumi.Input<string>;
        ip?: pulumi.Input<string>;
        k8sClusterUuid?: pulumi.Input<string>;
        k8sNodepoolUuid?: pulumi.Input<string>;
        mac?: pulumi.Input<string>;
        nicId?: pulumi.Input<string>;
        serverId?: pulumi.Input<string>;
        serverName?: pulumi.Input<string>;
    }

    export interface LanIpFailover {
        ip?: pulumi.Input<string>;
        nicUuid?: pulumi.Input<string>;
    }

    export interface NicFlowlog {
        /**
         * Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL. Immutable, update forces re-creation.
         */
        action: pulumi.Input<string>;
        /**
         * Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist. Immutable, update forces re-creation.
         */
        bucket: pulumi.Input<string>;
        /**
         * Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, update forces re-creation.
         */
        direction: pulumi.Input<string>;
        /**
         * The ID of the NIC.
         */
        id?: pulumi.Input<string>;
        /**
         * Specifies the name of the flow log.
         *
         * ⚠️ **Note:**: Removing the `flowlog` forces re-creation of the NIC resource.
         */
        name: pulumi.Input<string>;
    }

    export interface ServerLabel {
        /**
         * [string] The key of the label.
         */
        key: pulumi.Input<string>;
        /**
         * [string] The value of the label.
         */
        value: pulumi.Input<string>;
    }

    export interface ServerNic {
        deviceNumber?: pulumi.Input<number>;
        dhcp?: pulumi.Input<boolean>;
        /**
         * Indicates whether this NIC receives an IPv6 address through DHCP.
         */
        dhcpv6?: pulumi.Input<boolean>;
        firewallActive?: pulumi.Input<boolean>;
        firewallType?: pulumi.Input<string>;
        /**
         * Allows to define firewall rules inline in the server. See the Firewall section.
         */
        firewalls?: pulumi.Input<pulumi.Input<inputs.compute.ServerNicFirewall>[]>;
        id?: pulumi.Input<string>;
        /**
         * Collection of IP addresses assigned to a nic. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.
         */
        ips?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * IPv6 CIDR block assigned to the NIC.
         */
        ipv6CidrBlock?: pulumi.Input<string>;
        /**
         * Collection for IPv6 addresses assigned to a nic. Explicitly assigned IPv6 addresses need to come from inside the IPv6 CIDR block assigned to the nic.
         */
        ipv6Ips?: pulumi.Input<pulumi.Input<string>[]>;
        lan: pulumi.Input<number>;
        mac?: pulumi.Input<string>;
        /**
         * [string] The name of the server.
         */
        name?: pulumi.Input<string>;
        pciSlot?: pulumi.Input<number>;
    }

    export interface ServerNicFirewall {
        icmpCode?: pulumi.Input<string>;
        icmpType?: pulumi.Input<string>;
        id?: pulumi.Input<string>;
        /**
         * [string] The name of the server.
         */
        name?: pulumi.Input<string>;
        portRangeEnd?: pulumi.Input<number>;
        portRangeStart?: pulumi.Input<number>;
        protocol: pulumi.Input<string>;
        sourceIp?: pulumi.Input<string>;
        sourceMac?: pulumi.Input<string>;
        targetIp?: pulumi.Input<string>;
        /**
         * (Computed)[string] Server usages: [ENTERPRISE](https://docs.ionos.com/cloud/compute-engine/virtual-servers/virtual-servers) or [CUBE](https://docs.ionos.com/cloud/compute-engine/virtual-servers/cloud-cubes). This property is immutable.
         */
        type?: pulumi.Input<string>;
    }

    export interface ServerVolume {
        /**
         * [string] The availability zone in which the server should exist. E.g: `AUTO`, `ZONE_1`, `ZONE_2`. This property is immutable.
         */
        availabilityZone?: pulumi.Input<string>;
        /**
         * The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
         */
        backupUnitId?: pulumi.Input<string>;
        /**
         * The UUID of the attached server.
         */
        bootServer?: pulumi.Input<string>;
        bus?: pulumi.Input<string>;
        cpuHotPlug?: pulumi.Input<boolean>;
        deviceNumber?: pulumi.Input<number>;
        discVirtioHotPlug?: pulumi.Input<boolean>;
        discVirtioHotUnplug?: pulumi.Input<boolean>;
        diskType: pulumi.Input<string>;
        /**
         * [string] Required if `sshKeyPath` is not provided.
         *
         * @deprecated Please use imagePassword under server level
         */
        imagePassword?: pulumi.Input<string>;
        /**
         * [string] Sets the OS type of the server.
         */
        licenceType?: pulumi.Input<string>;
        /**
         * [string] The name of the server.
         */
        name?: pulumi.Input<string>;
        nicHotPlug?: pulumi.Input<boolean>;
        nicHotUnplug?: pulumi.Input<boolean>;
        pciSlot?: pulumi.Input<number>;
        ramHotPlug?: pulumi.Input<boolean>;
        /**
         * The size of the volume in GB.
         */
        size?: pulumi.Input<number>;
        /**
         * [list] List of absolute paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images.  Also accepts ssh keys directly. Required for IonosCloud Linux images. Required if `imagePassword` is not provided. Does not support `~` expansion to homedir in the given path. This property is immutable.
         *
         * @deprecated Please use sshKeyPath under server level
         */
        sshKeyPaths?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * [list] Immutable List of absolute or relative paths to files containing public SSH key that will be injected into IonosCloud provided Linux images. Also accepts ssh keys directly. Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key. This field may only be set in creation requests. When reading, it always returns null. SSH keys are only supported if a public Linux image is used for the volume creation. Does not support `~` expansion to homedir in the given path.
         *
         * @deprecated Please use sshKeys under server level
         */
        sshKeys?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
         */
        userData?: pulumi.Input<string>;
    }
}

export namespace dbaas {
    export interface InMemoryDBReplicaSetConnections {
        /**
         * The IP and subnet for your instance. Note the following unavailable IP ranges: 10.233.64.0/18, 10.233.0.0/18, 10.233.114.0/24
         */
        cidr: pulumi.Input<string>;
        /**
         * The datacenter to connect your instance to.
         */
        datacenterId: pulumi.Input<string>;
        /**
         * The numeric LAN ID to connect your instance to.
         */
        lanId: pulumi.Input<string>;
    }

    export interface InMemoryDBReplicaSetCredentials {
        /**
         * The hashed password for a InMemoryDB user.
         */
        hashedPassword?: pulumi.Input<inputs.dbaas.InMemoryDBReplicaSetCredentialsHashedPassword>;
        /**
         * The password for a InMemoryDB user.
         */
        plainTextPassword?: pulumi.Input<string>;
        /**
         * The username for the initial InMemoryDB user. Some system usernames are restricted (e.g. 'admin', 'standby').
         */
        username: pulumi.Input<string>;
    }

    export interface InMemoryDBReplicaSetCredentialsHashedPassword {
        algorithm: pulumi.Input<string>;
        hash: pulumi.Input<string>;
    }

    export interface InMemoryDBReplicaSetMaintenanceWindow {
        /**
         * The name of the week day.
         */
        dayOfTheWeek: pulumi.Input<string>;
        /**
         * Start of the maintenance window in UTC time.
         */
        time: pulumi.Input<string>;
    }

    export interface InMemoryDBReplicaSetResources {
        /**
         * The number of CPU cores per instance.
         */
        cores: pulumi.Input<number>;
        /**
         * The amount of memory per instance in gigabytes (GB).
         */
        ram: pulumi.Input<number>;
        /**
         * The size of the storage in GB. The size is derived from the amount of RAM and the persistence mode and is not configurable.
         */
        storage?: pulumi.Input<number>;
    }

    export interface MariaDBClusterConnections {
        /**
         * The IP and subnet for your cluster.
         */
        cidr: pulumi.Input<string>;
        /**
         * The datacenter to connect your cluster to.
         */
        datacenterId: pulumi.Input<string>;
        /**
         * The numeric LAN ID to connect your cluster to.
         */
        lanId: pulumi.Input<string>;
    }

    export interface MariaDBClusterCredentials {
        /**
         * The password for a MariaDB user.
         */
        password: pulumi.Input<string>;
        /**
         * The username for the initial MariaDB user. Some system usernames are restricted (e.g 'mariadb', 'admin', 'standby').
         */
        username: pulumi.Input<string>;
    }

    export interface MariaDBClusterMaintenanceWindow {
        /**
         * The name of the week day.
         */
        dayOfTheWeek: pulumi.Input<string>;
        /**
         * Start of the maintenance window in UTC time.
         */
        time: pulumi.Input<string>;
    }

    export interface MongoClusterBackup {
        /**
         * The location where the cluster backups will be stored. If not set, the backup is stored in the nearest location of the cluster. Examples: de, eu-sounth-2, eu-central-2
         */
        location?: pulumi.Input<string>;
        /**
         * Number of hours in the past for which a point-in-time snapshot can be created.
         */
        pointInTimeWindowHours?: pulumi.Input<number>;
        /**
         * Number of hours between snapshots.
         */
        snapshotIntervalHours?: pulumi.Input<number>;
    }

    export interface MongoClusterBiConnector {
        /**
         * Enable or disable the BiConnector.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * The host where this new BI Connector is installed.
         */
        host?: pulumi.Input<string>;
        /**
         * Port number used when connecting to this new BI Connector.
         */
        port?: pulumi.Input<string>;
    }

    export interface MongoClusterConnections {
        /**
         * The list of IPs and subnet for your cluster. Note the following unavailable IP ranges:10.233.64.0/18, 10.233.0.0/18, 10.233.114.0/24. example: [192.168.1.100/24, 192.168.1.101/24]
         */
        cidrLists: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The datacenter to connect your cluster to.
         */
        datacenterId: pulumi.Input<string>;
        /**
         * The LAN to connect your cluster to.
         */
        lanId: pulumi.Input<string>;
    }

    export interface MongoClusterMaintenanceWindow {
        dayOfTheWeek: pulumi.Input<string>;
        time: pulumi.Input<string>;
    }

    export interface MongoUserRole {
        database?: pulumi.Input<string>;
        /**
         * A list of mongodb user roles. Examples: read, readWrite, readAnyDatabase
         */
        role?: pulumi.Input<string>;
    }

    export interface PSQLClusterConnectionPooler {
        enabled: pulumi.Input<boolean>;
        /**
         * Represents different modes of connection pooling for the connection pooler
         */
        poolMode: pulumi.Input<string>;
    }

    export interface PSQLClusterConnections {
        /**
         * The IP and subnet for the database.
         *           Note the following unavailable IP ranges:
         *           10.233.64.0/18
         *           10.233.0.0/18
         *           10.233.114.0/24
         */
        cidr: pulumi.Input<string>;
        /**
         * The datacenter to connect your cluster to.
         */
        datacenterId: pulumi.Input<string>;
        /**
         * The LAN to connect your cluster to.
         */
        lanId: pulumi.Input<string>;
    }

    export interface PSQLClusterCredentials {
        password: pulumi.Input<string>;
        /**
         * the username for the initial postgres user. some system usernames are restricted (e.g. "postgres", "admin", "standby")
         */
        username: pulumi.Input<string>;
    }

    export interface PSQLClusterFromBackup {
        /**
         * The unique ID of the backup you want to restore.
         */
        backupId: pulumi.Input<string>;
        /**
         * If this value is supplied as ISO 8601 timestamp, the backup will be replayed up until the given timestamp. If empty, the backup will be applied completely.
         */
        recoveryTargetTime?: pulumi.Input<string>;
    }

    export interface PSQLClusterMaintenanceWindow {
        dayOfTheWeek: pulumi.Input<string>;
        time: pulumi.Input<string>;
    }
}

export namespace k8s {
    export interface ClusterMaintenanceWindow {
        /**
         * [string] Day of the week when maintenance is allowed
         */
        dayOfTheWeek: pulumi.Input<string>;
        /**
         * [string] A clock time in the day when maintenance is allowed
         */
        time: pulumi.Input<string>;
    }

    export interface ClusterS3Bucket {
        /**
         * [string] The name of the Kubernetes Cluster.
         */
        name?: pulumi.Input<string>;
    }

    export interface NodePoolAutoScaling {
        /**
         * [int] The maximum number of worker nodes that the node pool can scale to. Should be greater than min_node_count
         */
        maxNodeCount: pulumi.Input<number>;
        /**
         * [int] The minimum number of worker nodes the node pool can scale down to. Should be less than max_node_count
         */
        minNodeCount: pulumi.Input<number>;
    }

    export interface NodePoolLan {
        /**
         * [boolean] Indicates if the Kubernetes Node Pool LAN will reserve an IP using DHCP. Default value is `true`
         */
        dhcp?: pulumi.Input<boolean>;
        /**
         * [int] The LAN ID of an existing LAN at the related datacenter
         */
        id: pulumi.Input<number>;
        /**
         * An array of additional LANs attached to worker nodes
         */
        routes?: pulumi.Input<pulumi.Input<inputs.k8s.NodePoolLanRoute>[]>;
    }

    export interface NodePoolLanRoute {
        /**
         * [string] IPv4 or IPv6 Gateway IP for the route
         */
        gatewayIp: pulumi.Input<string>;
        /**
         * [string] IPv4 or IPv6 CIDR to be routed via the interface
         */
        network: pulumi.Input<string>;
    }

    export interface NodePoolMaintenanceWindow {
        /**
         * [string] Day of the week when maintenance is allowed
         */
        dayOfTheWeek: pulumi.Input<string>;
        /**
         * [string] A clock time in the day when maintenance is allowed
         */
        time: pulumi.Input<string>;
    }
}

export namespace vpn {
    export interface IpsecGatewayConnection {
        /**
         * [string] The datacenter to connect your VPN Gateway to.
         */
        datacenterId: pulumi.Input<string>;
        /**
         * [string] Describes the private ipv4 subnet in your LAN that should be accessible by the
         * VPN Gateway. Note: this should be the subnet already assigned to the LAN
         */
        ipv4Cidr: pulumi.Input<string>;
        /**
         * [string] Describes the ipv6 subnet in your LAN that should be accessible by the VPN
         * Gateway. **Note**: this should be the subnet already assigned to the LAN
         */
        ipv6Cidr?: pulumi.Input<string>;
        /**
         * [string] The numeric LAN ID to connect your VPN Gateway to.
         */
        lanId: pulumi.Input<string>;
    }

    export interface IpsecTunnelAuth {
        /**
         * [string] The authentication method to use for IPSec Authentication. Possible values: `PSK`.
         * Default value: `PSK`.
         */
        method?: pulumi.Input<string>;
        /**
         * [string] The pre-shared key to use for IPSec Authentication. **Note**: Required if method is
         * PSK.
         */
        pskKey?: pulumi.Input<string>;
    }

    export interface IpsecTunnelEsp {
        /**
         * [string] The Diffie-Hellman Group to use for IPSec Encryption. Possible
         * values: `15-MODP3072`, `16-MODP4096`, `19-ECP256`, `20-ECP384`, `21-ECP521`, `28-ECP256BP`, `29-ECP384BP`, `30-ECP512BP`.
         * Default value: `16-MODP4096`.
         */
        diffieHellmanGroup?: pulumi.Input<string>;
        /**
         * [string] The encryption algorithm to use for IPSec Encryption. Possible
         * values: `AES128`, `AES256`, `AES128-CTR`, `AES256-CTR`, `AES128-GCM-16`, `AES256-GCM-16`, `AES128-GCM-12`, `AES256-GCM-12`, `AES128-CCM-12`,
         * `AES256-CCM-12`. Default value: `AES256`.
         */
        encryptionAlgorithm?: pulumi.Input<string>;
        /**
         * [string] The integrity algorithm to use for IPSec Encryption. Possible
         * values: `SHA256`, `SHA384`, `SHA512`, `AES-XCBC`. Default value: `SHA256`.
         */
        integrityAlgorithm?: pulumi.Input<string>;
        /**
         * [string] The phase lifetime in seconds. Minimum value: `3600`. Maximum value: `86400`.
         * Default value: `86400`.
         */
        lifetime?: pulumi.Input<number>;
    }

    export interface IpsecTunnelIke {
        /**
         * [string] The Diffie-Hellman Group to use for IPSec Encryption. Possible
         * values: `15-MODP3072`, `16-MODP4096`, `19-ECP256`, `20-ECP384`, `21-ECP521`, `28-ECP256BP`, `29-ECP384BP`, `30-ECP512BP`.
         * Default value: `16-MODP4096`.
         */
        diffieHellmanGroup?: pulumi.Input<string>;
        /**
         * [string] The encryption algorithm to use for IPSec Encryption. Possible
         * values: `AES128`, `AES256`, `AES128-CTR`, `AES256-CTR`, `AES128-GCM-16`, `AES256-GCM-16`, `AES128-GCM-12`, `AES256-GCM-12`, `AES128-CCM-12`,
         * `AES256-CCM-12`. Default value: `AES256`.
         */
        encryptionAlgorithm?: pulumi.Input<string>;
        /**
         * [string] The integrity algorithm to use for IPSec Encryption. Possible
         * values: `SHA256`, `SHA384`, `SHA512`, `AES-XCBC`. Default value: `SHA256`.
         */
        integrityAlgorithm?: pulumi.Input<string>;
        /**
         * [string] The phase lifetime in seconds. Minimum value: `3600`. Maximum value: `86400`.
         * Default value: `86400`.
         */
        lifetime?: pulumi.Input<number>;
    }

    export interface WireguardGatewayConnection {
        /**
         * [String] The ID of the datacenter where the WireGuard Gateway is located.
         */
        datacenterId: pulumi.Input<string>;
        /**
         * [String] The IPv4 CIDR for the WireGuard Gateway connection.
         */
        ipv4Cidr?: pulumi.Input<string>;
        /**
         * [String] The IPv6 CIDR for the WireGuard Gateway connection.
         */
        ipv6Cidr?: pulumi.Input<string>;
        /**
         * [String] The ID of the LAN where the WireGuard Gateway is connected.
         */
        lanId: pulumi.Input<string>;
    }

    export interface WireguardPeerEndpoint {
        /**
         * [string] The hostname or IPV4 address that the WireGuard Server will connect to.
         */
        host: pulumi.Input<string>;
        /**
         * [int] The port that the WireGuard Server will connect to. Defaults to `51820`.
         */
        port?: pulumi.Input<number>;
    }
}
