// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ApigatewayCustomDomain {
    /**
     * [string] The certificate ID for the domain. Must be a valid certificate in UUID form.
     */
    certificateId?: string;
    /**
     * [string] The domain name. Externally reachable.
     */
    name: string;
}

export interface ApigatewayRouteUpstream {
    /**
     * [string] The host of the upstream.
     */
    host: string;
    /**
     * [string] The load balancer algorithm. Default value: `roundrobin`.
     */
    loadbalancer?: string;
    /**
     * [int] The port of the upstream. Default value: `80`.
     */
    port?: number;
    /**
     * [string] The target URL of the upstream. Default value: `http`.
     */
    scheme?: string;
    /**
     * [int] Weight with which to split traffic to the upstream. Default value: `100`.
     */
    weight?: number;
}

export interface ApplicationLoadbalancerFlowlog {
    /**
     * [string] Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL. Immutable, forces re-creation.
     */
    action: string;
    /**
     * [string] Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist. Immutable, forces re-creation.
     */
    bucket: string;
    /**
     * [string] Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, forces re-creation.
     */
    direction: string;
    /**
     * The resource's unique identifier.
     */
    id: string;
    /**
     * [string] Specifies the name of the flow log.
     *
     * ⚠️ **Note:**: Removing the `flowlog` forces re-creation of the application load balancer resource.
     */
    name: string;
}

export interface ApplicationLoadbalancerForwardingruleHttpRule {
    /**
     * [list] - An array of items in the collection.The action is only performed if each and every condition is met; if no conditions are set, the rule will always be performed.
     */
    conditions: outputs.ApplicationLoadbalancerForwardingruleHttpRuleCondition[];
    /**
     * [string] Valid only for STATIC actions.
     */
    contentType: string;
    /**
     * [bool] Default is false; valid only for REDIRECT actions.
     */
    dropQuery?: boolean;
    /**
     * [string] The location for redirecting; mandatory and valid only for REDIRECT actions.
     */
    location?: string;
    /**
     * [string] The unique name of the Application Load Balancer HTTP rule.
     */
    name: string;
    /**
     * [string] The response message of the request; mandatory for STATIC action.
     */
    responseMessage?: string;
    /**
     * [int] Valid only for REDIRECT and STATIC actions. For REDIRECT actions, default is 301 and possible values are 301, 302, 303, 307, and 308. For STATIC actions, default is 503 and valid range is 200 to 599.
     */
    statusCode: number;
    /**
     * [string] The UUID of the target group; mandatory for FORWARD action.
     */
    targetGroup?: string;
    /**
     * [string] Type of the Http Rule condition.
     */
    type: string;
}

export interface ApplicationLoadbalancerForwardingruleHttpRuleCondition {
    /**
     * [string] Matching rule for the HTTP rule condition attribute; mandatory for HEADER, PATH, QUERY, METHOD, HOST, and COOKIE types; must be null when type is SOURCE_IP.
     */
    condition?: string;
    /**
     * [string] Must be null when type is PATH, METHOD, HOST, or SOURCE_IP. Key can only be set when type is COOKIES, HEADER, or QUERY.
     */
    key?: string;
    /**
     * [bool] Specifies whether the condition is negated or not; the default is False.
     */
    negate?: boolean;
    /**
     * [string] Type of the Http Rule condition.
     */
    type: string;
    /**
     * [string] Mandatory for conditions CONTAINS, EQUALS, MATCHES, STARTS_WITH, ENDS_WITH; must be null when condition is EXISTS; should be a valid CIDR if provided and if type is SOURCE_IP.
     */
    value?: string;
}

export interface AutoCertificateProviderExternalAccountBinding {
    /**
     * The key ID of the external account binding
     */
    keyId: string;
    /**
     * The secret of the external account binding
     */
    keySecret: string;
}

export interface AutoscalingGroupPolicy {
    /**
     * [string] The Metric that should trigger the scaling actions. Metric values are checked at fixed intervals. Possible values: `INSTANCE_CPU_UTILIZATION_AVERAGE`, `INSTANCE_NETWORK_IN_BYTES`, `INSTANCE_NETWORK_IN_PACKETS`, `INSTANCE_NETWORK_OUT_BYTES`, `INSTANCE_NETWORK_OUT_PACKETS`
     */
    metric: string;
    /**
     * [string] Defines the time range, for which the samples will be aggregated. Default is 120s. *Note that when you set it to values like 5m the API will automatically transform it in PT5M, so the plan will show you a diff in state that should be ignored.*
     */
    range?: string;
    /**
     * [list] Specifies the action to take when the `scaleInThreshold` is exceeded. Hereby, scaling in is always about removing VMs that are currently associated with this autoscaling group. Default termination policy is OLDEST_SERVER_FIRST.
     */
    scaleInAction: outputs.AutoscalingGroupPolicyScaleInAction;
    /**
     * [int] A lower threshold on the value of `metric`. Will be used with `less than` (<) operator. Exceeding this will start a Scale-In Action as specified by the `scaleInAction` property. The value must have a higher minimum delta to the `scaleOutThreshold` depending on the `metric` to avoid competitive actions at the same time.
     */
    scaleInThreshold: number;
    /**
     * [list] Specifies the action to take when the `scaleOutThreshold` is exceeded. Hereby, scaling out is always about adding new VMs to this autoscaling group.
     */
    scaleOutAction: outputs.AutoscalingGroupPolicyScaleOutAction;
    /**
     * [int] The upper threshold for the value of the `metric`. Used with the `greater than` (>) operator. A scale-out action is triggered when this value is exceeded, specified by the `scaleOutAction` property. The value must have a lower minimum delta to the `scaleInThreshold`, depending on the metric, to avoid competing for actions simultaneously. If `properties.policy.unit=TOTAL`, a value >= 40 must be chosen.
     */
    scaleOutThreshold: number;
    /**
     * [string] Units of the applied Metric. Possible values are: `PER_HOUR`, `PER_MINUTE`, `PER_SECOND`, `TOTAL`.
     */
    unit: string;
}

export interface AutoscalingGroupPolicyScaleInAction {
    /**
     * [int] When `amountType=ABSOLUTE` specifies the absolute number of VMs that are added. The value must be between 1 to 10. `amountType=PERCENTAGE` specifies the percentage value that is applied to the current number of replicas of the VM Auto Scaling Group. The value must be between 1 to 200. At least one VM is always added.
     */
    amount: number;
    /**
     * [string] The type for the given amount. Possible values are: `ABSOLUTE`, `PERCENTAGE`.
     */
    amountType: string;
    /**
     * [string] Minimum time to pass after this Scaling action has started, until the next Scaling action will be started. Additionally, if a Scaling action is currently in progress, no second Scaling action will be started for the same autoscaling group. Instead, the Metric will be re-evaluated after the current Scaling action is completed (either successfully or with failures). This is validated with a minimum value of 2 minutes and a maximum of 24 hours currently. Default value is 5 minutes if not given. *Note that when you set it to values like 5m the API will automatically transform it in PT5M, so the plan will show you a diff in state that should be ignored.*
     */
    cooldownPeriod: string;
    /**
     * [bool] If set to `true`, when deleting a replica during scale in, any attached volume will also be deleted. When set to `false`, all volumes remain in the datacenter and must be deleted manually. Note that every scale-out creates new volumes. When they are not deleted, they will eventually use all of your contracts resource limits. At this point, scaling out would not be possible anymore.
     */
    deleteVolumes: boolean;
    /**
     * [string] The type of the termination policy for the autoscaling group so that a specific pattern is followed for Scaling-In replicas. Default termination policy is `OLDEST_SERVER_FIRST`. Possible values are: `OLDEST_SERVER_FIRST`, `NEWEST_SERVER_FIRST`, `RANDOM`
     */
    terminationPolicyType: string;
}

export interface AutoscalingGroupPolicyScaleOutAction {
    /**
     * [int] When `amountType=ABSOLUTE` specifies the absolute number of VMs that are added. The value must be between 1 to 10. `amountType=PERCENTAGE` specifies the percentage value that is applied to the current number of replicas of the VM Auto Scaling Group. The value must be between 1 to 200. At least one VM is always added.
     */
    amount: number;
    /**
     * [string] The type for the given amount. Possible values are: `ABSOLUTE`, `PERCENTAGE`.
     */
    amountType: string;
    /**
     * [string] Minimum time to pass after this Scaling action has started, until the next Scaling action will be started. Additionally, if a Scaling action is currently in progress, no second Scaling action will be started for the same autoscaling group. Instead, the Metric will be re-evaluated after the current Scaling action is completed (either successfully or with failures). This is validated with a minimum value of 2 minutes and a maximum of 24 hours currently. Default value is 5 minutes if not given. *Note that when you set it to values like 5m the API will automatically transform it in PT5M, so the plan will show you a diff in state that should be ignored.*
     */
    cooldownPeriod: string;
}

export interface AutoscalingGroupReplicaConfiguration {
    /**
     * [string] The zone where the VMs are created using this configuration. Possible values are: `AUTO`, `ZONE_1`, `ZONE_2`.
     */
    availabilityZone: string;
    /**
     * [int] The total number of cores for the VMs.
     */
    cores: number;
    /**
     * [string] PU family for the VMs created using this configuration. If null, the VM will be created with the default CPU family for the assigned location. Possible values are: `INTEL_SKYLAKE`, `INTEL_XEON`.
     */
    cpuFamily?: string;
    /**
     * Set of NICs associated with this Replica.
     */
    nics?: outputs.AutoscalingGroupReplicaConfigurationNic[];
    /**
     * [int] The amount of memory for the VMs in MB, e.g. 2048. Size must be specified in multiples of 256 MB with a minimum of 256 MB; however, if you set ramHotPlug to TRUE then you must use a minimum of 1024 MB. If you set the RAM size more than 240GB, then ramHotPlug will be set to FALSE and can not be set to TRUE unless RAM size not set to less than 240GB.
     */
    ram: number;
    /**
     * [list] List of volumes associated with this Replica.
     */
    volumes?: outputs.AutoscalingGroupReplicaConfigurationVolume[];
}

export interface AutoscalingGroupReplicaConfigurationNic {
    /**
     * [bool] Dhcp flag for this replica Nic. This is an optional attribute with default value of `true` if not given in the request payload or given as null.
     */
    dhcp?: boolean;
    /**
     * [bool] Firewall active flag.
     */
    firewallActive?: boolean;
    /**
     * List of all firewall rules for the specified NIC.
     */
    firewallRules?: outputs.AutoscalingGroupReplicaConfigurationNicFirewallRule[];
    /**
     * [string] The type of firewall rules that will be allowed on the NIC. Valid values: INGRESS EGRESS BIDIRECTIONAL. If not specified, the default INGRESS value is used.
     */
    firewallType?: string;
    /**
     * [list] Only 1 flow log can be configured. Only the name field can change as part of an update. Flow logs holistically capture network information such as source and destination IP addresses, source and destination ports, number of packets, amount of bytes, the start and end time of the recording, and the type of protocol – and log the extent to which your instances are being accessed.
     */
    flowLogs?: outputs.AutoscalingGroupReplicaConfigurationNicFlowLog[];
    /**
     * [int] Lan ID for this replica Nic.
     */
    lan: number;
    /**
     * [string] Name for this replica volume.
     */
    name: string;
    /**
     * [list] In order to link VM to ALB, target group must be provided
     */
    targetGroup?: outputs.AutoscalingGroupReplicaConfigurationNicTargetGroup;
}

export interface AutoscalingGroupReplicaConfigurationNicFirewallRule {
    /**
     * [int] Defines the allowed code (from 0 to 254) if protocol ICMP is chosen.
     */
    icmpCode?: number;
    /**
     * [string] Defines the allowed code (from 0 to 254) if protocol ICMP is chosen. Value null allows all codes.
     */
    icmpType?: number;
    /**
     * [string] Name for this replica volume.
     */
    name?: string;
    /**
     * [int] Defines the end range of the allowed port (from 1 to 65534) if the protocol TCP or UDP is chosen. Leave portRangeStart and portRangeEnd null to allow all ports.
     */
    portRangeEnd?: number;
    /**
     * [int] Defines the start range of the allowed port (from 1 to 65534) if protocol TCP or UDP is chosen. Leave portRangeStart and portRangeEnd null to allow all ports.
     */
    portRangeStart?: number;
    /**
     * [string] The protocol for the rule: TCP, UDP, ICMP, ANY. Property cannot be modified after creation (disallowed in update requests).
     */
    protocol: string;
    /**
     * [string] Only traffic originating from the respective IPv4 address is allowed. Value null allows all source IPs.
     */
    sourceIp?: string;
    /**
     * [string] Only traffic originating from the respective MAC address is allowed. Valid format: aa:bb:cc:dd:ee:ff. Value null allows all source MAC address. Valid format: aa:bb:cc:dd:ee:ff.
     */
    sourceMac?: string;
    /**
     * [string] In case the target NIC has multiple IP addresses, only traffic directed to the respective IP address of the NIC is allowed. Value null allows all target IPs.
     */
    targetIp?: string;
    /**
     * [string] Storage Type for this replica volume. Possible values: `SSD`, `HDD`, `SSD_STANDARD` or `SSD_PREMIUM`.
     */
    type: string;
}

export interface AutoscalingGroupReplicaConfigurationNicFlowLog {
    /**
     * [string] Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL. Immutable, forces re-creation.
     */
    action: string;
    /**
     * [string] Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist. Immutable, forces re-creation.
     */
    bucket: string;
    /**
     * [string] Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, forces re-creation.
     */
    direction: string;
    /**
     * The resource's unique identifier.
     */
    id: string;
    /**
     * [string] Name for this replica volume.
     */
    name: string;
}

export interface AutoscalingGroupReplicaConfigurationNicTargetGroup {
    /**
     * [int] The port of the target group.
     */
    port: number;
    /**
     * [string] The ID of the target group.
     */
    targetGroupId: string;
    /**
     * [int] The weight of the target group.
     */
    weight: number;
}

export interface AutoscalingGroupReplicaConfigurationVolume {
    /**
     * [string] The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either `public image` or `imageAlias` in conjunction with this property.
     */
    backupUnitId: string;
    /**
     * [string] Determines whether the volume will be used as a boot volume. Set to NONE, the volume will not be used as boot volume. Set to PRIMARY, the volume will be used as boot volume and set to AUTO will delegate the decision to the provisioning engine to decide whether to use the volume as boot volume.
     * Notice that exactly one volume can be set to PRIMARY or all of them set to AUTO.
     */
    bootOrder: string;
    /**
     * [string] The bus type of the volume. Default setting is `VIRTIO`. The bus type `IDE` is also supported.
     */
    bus?: string;
    /**
     * [string] The image installed on the volume. Only the UUID of the image is presently supported.
     */
    image?: string;
    /**
     * [string] The image installed on the volume. Must be an `imageAlias` as specified via the images API. Note that one of `image` or `imageAlias` must be set, but not both.
     */
    imageAlias?: string;
    /**
     * [string] Image password for this replica volume.
     */
    imagePassword?: string;
    /**
     * [string] Name for this replica volume.
     */
    name: string;
    /**
     * [int] Name for this replica volume.
     */
    size: number;
    /**
     * List of ssh keys, supports values or paths to files. Cannot be changed at update.
     */
    sshKeys?: string[];
    /**
     * [string] Storage Type for this replica volume. Possible values: `SSD`, `HDD`, `SSD_STANDARD` or `SSD_PREMIUM`.
     */
    type: string;
    /**
     * [string] User-data (Cloud Init) for this replica volume. Make sure you provide a Cloud Init compatible image in conjunction with this parameter.
     */
    userData: string;
}

export interface GetApigatewayCustomDomain {
    /**
     * The ID of the certificate to use for the distribution.
     */
    certificateId: string;
    /**
     * Name of an existing API Gateway that you want to search for.
     */
    name: string;
}

export interface GetApigatewayRouteUpstream {
    /**
     * The host of the upstream.
     */
    host: string;
    /**
     * The load balancer algorithm.
     */
    loadbalancer: string;
    /**
     * The port of the upstream.
     */
    port: number;
    /**
     * The target URL of the upstream.
     */
    scheme: string;
    /**
     * Weight with which to split traffic to the upstream.
     */
    weight: number;
}

export interface GetApplicationLoadbalancerFlowlog {
    /**
     * Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL. Immutable, forces re-creation.
     */
    action: string;
    /**
     * Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist. Immutable, forces re-creation.
     */
    bucket: string;
    /**
     * Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, forces re-creation.
     */
    direction: string;
    /**
     * ID of the application load balancer you want to search for.
     */
    id: string;
    /**
     * Name of an existing application load balancer that you want to search for. Search by name is case-insensitive. The whole resource name is required if `partialMatch` parameter is not set to true.
     */
    name: string;
}

export interface GetApplicationLoadbalancerForwardingruleHttpRule {
    /**
     * An array of items in the collection.The action is only performed if each and every condition is met; if no conditions are set, the rule will always be performed.
     */
    conditions: outputs.GetApplicationLoadbalancerForwardingruleHttpRuleCondition[];
    /**
     * Valid only for STATIC actions.
     */
    contentType: string;
    /**
     * Default is false; valid only for REDIRECT actions.
     */
    dropQuery: boolean;
    /**
     * The location for redirecting; mandatory and valid only for REDIRECT actions.
     */
    location: string;
    /**
     * Name of an existing application load balancer that you want to search for. Search by name is case-insensitive. The whole resource name is required if `partialMatch` parameter is not set to true.
     */
    name: string;
    /**
     * The response message of the request; mandatory for STATIC action.
     */
    responseMessage: string;
    /**
     * Valid only for REDIRECT and STATIC actions. For REDIRECT actions, default is 301 and possible values are 301, 302, 303, 307, and 308. For STATIC actions, default is 503 and valid range is 200 to 599.
     */
    statusCode: number;
    /**
     * The UUID of the target group; mandatory for FORWARD action.
     */
    targetGroup: string;
    /**
     * Type of the Http Rule condition.
     */
    type: string;
}

export interface GetApplicationLoadbalancerForwardingruleHttpRuleCondition {
    /**
     * Matching rule for the HTTP rule condition attribute; mandatory for HEADER, PATH, QUERY, METHOD, HOST, and COOKIE types; must be null when type is SOURCE_IP.
     */
    condition: string;
    /**
     * Must be null when type is PATH, METHOD, HOST, or SOURCE_IP. Key can only be set when type is COOKIES, HEADER, or QUERY.
     */
    key: string;
    /**
     * Specifies whether the condition is negated or not; the default is False.
     */
    negate: boolean;
    /**
     * Type of the Http Rule condition.
     */
    type: string;
    /**
     * Mandatory for conditions CONTAINS, EQUALS, MATCHES, STARTS_WITH, ENDS_WITH; must be null when condition is EXISTS; should be a valid CIDR if provided and if type is SOURCE_IP.
     */
    value: string;
}

export interface GetAutoCertificateProviderExternalAccountBinding {
    /**
     * The key ID of the external account binding
     */
    keyId: string;
}

export interface GetAutoscalingGroupPolicy {
    /**
     * The Metric that should trigger Scaling Actions. The values of the Metric are checked in fixed intervals.
     */
    metric: string;
    /**
     * Defines the range of time from which samples will be aggregated. Default is 120s.
     * *Note that when you set it to values like 5m the API will automatically transform it in PT5M, so the plan will show you a diff in state that should be ignored.*
     */
    range: string;
    /**
     * Specifies the Action to take when the `scaleInThreshold`
     */
    scaleInActions: outputs.GetAutoscalingGroupPolicyScaleInAction[];
    /**
     * A lower threshold on the value of `metric`. Will be used with `less than` (<) operator. Exceeding this will start a Scale-In Action as specified by the `scaleInAction` property. The value must have a higher minimum delta to the `scaleOutThreshold` depending on the `metric` to avoid competitive actions at the same time.
     */
    scaleInThreshold: number;
    /**
     * Specifies the action to take when the `scaleOutThreshold` is exceeded. Hereby, scaling out is always about adding new VMs to this autoscaling group
     */
    scaleOutActions: outputs.GetAutoscalingGroupPolicyScaleOutAction[];
    /**
     * The upper threshold for the value of the `metric`. Used with the `greater than` (>) operator. A scale-out action is triggered when this value is exceeded, specified by the `scaleOutAction` property. The value must have a lower minimum delta to the `scaleInThreshold`, depending on the metric, to avoid competing for actions simultaneously. If `properties.policy.unit=TOTAL`, a value >= 40 must be chosen.
     */
    scaleOutThreshold: number;
    /**
     * Specifies the Action to take when the `scaleInThreshold` is exceeded. Hereby, scaling in is always about removing VMs that are currently associated with this Autoscaling Group.
     */
    unit: string;
}

export interface GetAutoscalingGroupPolicyScaleInAction {
    /**
     * When `amountType == ABSOLUTE`, this is the number of VMs added or removed in one step. When `amountType == PERCENTAGE`, this is a percentage value, which will be applied to the Autoscaling Group's current `targetReplicaCount` in order to derive the number of VMs that will be added or removed in one step. There will always be at least one VM added or removed.
     */
    amount: number;
    /**
     * The type for the given amount. Possible values are: [ABSOLUTE, PERCENTAGE].
     */
    amountType: string;
    /**
     * Minimum time to pass after this Scaling Action has started, until the next Scaling Action will be started. Additionally, if a Scaling Action is currently in progress, no second Scaling Action will be started for the same Autoscaling Group. Instead, the Metric will be re-evaluated after the current Scaling Action completed (either successful or with failures).
     * *Note that when you set it to values like 5m the API will automatically transform it in PT5M, so the plan will show you a diff in state that should be ignored.*
     */
    cooldownPeriod: string;
    /**
     * If set to 'true', when deleting an replica during scale in, any attached volume will also be deleted. When set to 'false', all volumes remain in the datacenter and must be deleted manually. Note that every scale-out creates new volumes. When they are not deleted, they will eventually use all of your contracts resource limits. At this point, scaling out would not be possible anymore.
     */
    deleteVolumes: boolean;
    /**
     * The type of the termination policy for the autoscaling group so that a specific pattern is followed for Scaling-In instances. Default termination policy is OLDEST_SERVER_FIRST.
     */
    terminationPolicyType: string;
}

export interface GetAutoscalingGroupPolicyScaleOutAction {
    /**
     * When `amountType == ABSOLUTE`, this is the number of VMs added or removed in one step. When `amountType == PERCENTAGE`, this is a percentage value, which will be applied to the Autoscaling Group's current `targetReplicaCount` in order to derive the number of VMs that will be added or removed in one step. There will always be at least one VM added or removed.
     */
    amount: number;
    /**
     * The type for the given amount. Possible values are: [ABSOLUTE, PERCENTAGE].
     */
    amountType: string;
    /**
     * Minimum time to pass after this Scaling Action has started, until the next Scaling Action will be started. Additionally, if a Scaling Action is currently in progress, no second Scaling Action will be started for the same Autoscaling Group. Instead, the Metric will be re-evaluated after the current Scaling Action completed (either successful or with failures).
     * *Note that when you set it to values like 5m the API will automatically transform it in PT5M, so the plan will show you a diff in state that should be ignored.*
     */
    cooldownPeriod: string;
}

export interface GetAutoscalingGroupReplicaConfiguration {
    /**
     * The zone where the VMs are created using this configuration.
     */
    availabilityZone: string;
    /**
     * The total number of cores for the VMs.
     */
    cores: number;
    /**
     * The zone where the VMs are created using this configuration.
     */
    cpuFamily: string;
    /**
     * List of NICs associated with this Replica.
     */
    nics: outputs.GetAutoscalingGroupReplicaConfigurationNic[];
    /**
     * The amount of memory for the VMs in MB, e.g. 2048. Size must be specified in multiples of 256 MB with a minimum of 256 MB; however, if you set ramHotPlug to TRUE then you must use a minimum of 1024 MB. If you set the RAM size more than 240GB, then ramHotPlug will be set to FALSE and can not be set to TRUE unless RAM size not set to less than 240GB.
     */
    ram: number;
    /**
     * List of volumes associated with this Replica. Only a single volume is currently supported.
     */
    volumes: outputs.GetAutoscalingGroupReplicaConfigurationVolume[];
}

export interface GetAutoscalingGroupReplicaConfigurationNic {
    /**
     * Dhcp flag for this replica Nic. This is an optional attribute with default value of 'true' if not given in the request payload or given as null.
     */
    dhcp: boolean;
    /**
     * Activate or deactivate the firewall. By default, an active firewall without any defined rules will block all incoming network traffic except for the firewall rules that explicitly allows certain protocols, IP addresses and ports.
     */
    firewallActive: boolean;
    /**
     * List of all firewall rules for the specified NIC.
     */
    firewallRules: outputs.GetAutoscalingGroupReplicaConfigurationNicFirewallRule[];
    /**
     * The type of firewall rules that will be allowed on the NIC. If not specified, the default INGRESS value is used.
     */
    firewallType: string;
    /**
     * Flow log configuration for the NIC. By default, the flow log is inactive. If you want to activate the flow log, you must specify the target resource and the type of traffic to log.
     */
    flowLogs: outputs.GetAutoscalingGroupReplicaConfigurationNicFlowLog[];
    /**
     * Lan ID for this replica Nic.
     */
    lan: number;
    /**
     * Name of an existing Autoscaling Group that you want to search for.
     *
     * Either `name` or `id` must be provided. If none or both are provided, the datasource will return an error.
     */
    name: string;
    /**
     * In order to link VM to ALB, target group must be provided.
     */
    targetGroups: outputs.GetAutoscalingGroupReplicaConfigurationNicTargetGroup[];
}

export interface GetAutoscalingGroupReplicaConfigurationNicFirewallRule {
    /**
     * Sets the allowed code (from 0 to 254) when ICMP protocol is selected. The value 'null' allows all codes.
     */
    icmpCode: number;
    /**
     * Sets the allowed type (from 0 to 254) if the protocol ICMP is selected. The value 'null' allows all types.
     */
    icmpType: number;
    /**
     * Name of an existing Autoscaling Group that you want to search for.
     *
     * Either `name` or `id` must be provided. If none or both are provided, the datasource will return an error.
     */
    name: string;
    /**
     * Sets the end range of the allowed port (from 1 to 65535) if the protocol TCP or UDP is selected. The value 'null' for 'port_range_start' and 'port_range_end' allows all ports.
     */
    portRangeEnd: number;
    /**
     * Sets the initial range of the allowed port (from 1 to 65535) if the protocol TCP or UDP is selected. The value 'null' for 'port_range_start' and 'port_range_end' allows all ports.
     */
    portRangeStart: number;
    /**
     * The protocol for the rule. The property cannot be modified after its creation (not allowed in update requests).
     */
    protocol: string;
    /**
     * Only traffic originating from the respective IPv4 address is permitted. The value 'null' allows traffic from any IP address.
     */
    sourceIp: string;
    /**
     * Only traffic originating from the respective MAC address is permitted. Valid format: 'aa:bb:cc:dd:ee:ff'. The value 'null' allows traffic from any MAC address.
     */
    sourceMac: string;
    /**
     * If the target NIC has multiple IP addresses, only the traffic directed to the respective IP address of the NIC is allowed. The value 'null' allows traffic to any target IP address.
     */
    targetIp: string;
    /**
     * Type of resource
     */
    type: string;
}

export interface GetAutoscalingGroupReplicaConfigurationNicFlowLog {
    /**
     * Specifies the traffic direction pattern. Valid values: ACCEPTED, REJECTED, ALL.
     */
    action: string;
    /**
     * The bucket name of an existing IONOS Object Storage bucket.
     */
    bucket: string;
    /**
     * Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL.
     */
    direction: string;
    /**
     * Id of an existing Autoscaling Group that you want to search for.
     */
    id: string;
    /**
     * Name of an existing Autoscaling Group that you want to search for.
     *
     * Either `name` or `id` must be provided. If none or both are provided, the datasource will return an error.
     */
    name: string;
}

export interface GetAutoscalingGroupReplicaConfigurationNicTargetGroup {
    /**
     * The port for the target group.
     */
    port: number;
    /**
     * The ID of the target group.
     */
    targetGroupId: string;
    /**
     * The weight for the target group.
     */
    weight: number;
}

export interface GetAutoscalingGroupReplicaConfigurationVolume {
    /**
     * The uuid of the Backup Unit that user has access to.
     */
    backupUnitId: string;
    /**
     * Determines whether the volume will be used as a boot volume: NONE - the volume will not be used as boot volume, PRIMARY - the volume will be used as boot volume, AUTO - will delegate the decision to the provisioning engine to decide whether to use the volume as boot volume.
     */
    bootOrder: string;
    /**
     * The bus type of the volume. Default setting is 'VIRTIO'. The bus type 'IDE' is also supported.
     */
    bus: string;
    /**
     * The image installed on the volume. Only the UUID of the image is presently supported.
     */
    image: string;
    /**
     * The image installed on the volume. Must be an 'imageAlias' as specified via the images API.
     */
    imageAlias: string;
    /**
     * Name of an existing Autoscaling Group that you want to search for.
     *
     * Either `name` or `id` must be provided. If none or both are provided, the datasource will return an error.
     */
    name: string;
    /**
     * User-defined size for this replica volume in GB.
     */
    size: number;
    sshKeys: string[];
    /**
     * Type of resource
     */
    type: string;
}

export interface GetAutoscalingGroupServersServer {
    /**
     * The unique ID of the server.
     */
    id: string;
}

export interface GetCdnDistributionRoutingRule {
    /**
     * The prefix of the routing rule.
     */
    prefix: string;
    /**
     * The scheme of the routing rule.
     */
    scheme: string;
    /**
     * A map of properties for the rule
     */
    upstreams: outputs.GetCdnDistributionRoutingRuleUpstream[];
}

export interface GetCdnDistributionRoutingRuleUpstream {
    /**
     * Enable or disable caching. If enabled, the CDN will cache the responses from the upstream host. Subsequent requests for the same resource will be served from the cache.
     */
    caching: boolean;
    /**
     * A map of geo_restrictions
     */
    geoRestrictions: outputs.GetCdnDistributionRoutingRuleUpstreamGeoRestriction[];
    /**
     * The upstream host that handles the requests if not already cached. This host will be protected by the WAF if the option is enabled.
     */
    host: string;
    /**
     * Rate limit class that will be applied to limit the number of incoming requests per IP.
     */
    rateLimitClass: string;
    /**
     * The SNI (Server Name Indication) mode of the upstream. It supports two modes: 1) `distribution`: for outgoing connections to the upstream host, the CDN requires the upstream host to present a valid certificate that matches the configured domain of the CDN distribution; 2) `origin`: for outgoing connections to the upstream host, the CDN requires the upstream host to present a valid certificate that matches the configured upstream/origin hostname.
     */
    sniMode: string;
    /**
     * Enable or disable WAF to protect the upstream host.
     */
    waf: boolean;
}

export interface GetCdnDistributionRoutingRuleUpstreamGeoRestriction {
    /**
     * List of allowed countries
     */
    allowLists: string[];
    /**
     * List of blocked countries
     */
    blockLists: string[];
}

export interface GetContainerRegistryFeature {
    vulnerabilityScanning: boolean;
}

export interface GetContainerRegistryGarbageCollectionSchedule {
    days: string[];
    time: string;
}

export interface GetContainerRegistryMaintenanceWindow {
    days: string[];
    time: string;
}

export interface GetContainerRegistryStorageUsage {
    bytes: number;
    updatedAt: string;
}

export interface GetContainerRegistryTokenCredential {
    /**
     * * `expiry-date`
     */
    username: string;
}

export interface GetContainerRegistryTokenScope {
    actions: string[];
    /**
     * Name of an existing container registry token that you want to search for. Search by name is case-insensitive. The whole resource name is required if `partialMatch` parameter is not set to true.
     */
    name: string;
    type: string;
}

export interface GetCubeServerCdrom {
    /**
     * Cloud init compatibility
     */
    cloudInit: string;
    /**
     * Is capable of CPU hot plug (no reboot required)
     */
    cpuHotPlug: boolean;
    /**
     * Is capable of CPU hot unplug (no reboot required)
     */
    cpuHotUnplug: boolean;
    /**
     * Description of cdrom
     */
    description: string;
    /**
     * Is capable of SCSI drive hot plug (no reboot required)
     */
    discScsiHotPlug: boolean;
    /**
     * Is capable of SCSI drive hot unplug (no reboot required)
     */
    discScsiHotUnplug: boolean;
    /**
     * Is capable of Virt-IO drive hot plug (no reboot required)
     */
    discVirtioHotPlug: boolean;
    /**
     * Is capable of Virt-IO drive hot unplug (no reboot required)
     */
    discVirtioHotUnplug: boolean;
    /**
     * ID of the server you want to search for.
     *
     * `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
     */
    id: string;
    /**
     * List of image aliases mapped for this Image
     */
    imageAliases: string[];
    /**
     * Type of image
     */
    imageType: string;
    /**
     * OS type of this volume
     */
    licenceType: string;
    /**
     * Location of that image/snapshot
     */
    location: string;
    /**
     * Name of an existing server that you want to search for.
     */
    name: string;
    /**
     * Is capable of nic hot plug (no reboot required)
     */
    nicHotPlug: boolean;
    /**
     * Is capable of nic hot unplug (no reboot required)
     */
    nicHotUnplug: boolean;
    /**
     * Indicates if the image is part of the public repository or not
     */
    public: boolean;
    /**
     * Is capable of memory hot plug (no reboot required)
     */
    ramHotPlug: boolean;
    /**
     * Is capable of memory hot unplug (no reboot required)
     */
    ramHotUnplug: boolean;
    /**
     * The size of the image in GB
     */
    size: number;
}

export interface GetCubeServerNic {
    /**
     * The Logical Unit Number (LUN) of the storage volume
     */
    deviceNumber: number;
    /**
     * Indicates if the nic will reserve an IP using DHCP
     */
    dhcp: boolean;
    dhcpv6?: boolean;
    /**
     * Activate or deactivate the firewall
     */
    firewallActive: boolean;
    /**
     * list of
     */
    firewallRules: outputs.GetCubeServerNicFirewallRule[];
    /**
     * The type of firewall rules that will be allowed on the NIC
     */
    firewallType: string;
    /**
     * ID of the server you want to search for.
     *
     * `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
     */
    id: string;
    /**
     * Collection of IP addresses assigned to a nic
     */
    ips: string[];
    ipv6CidrBlock: string;
    ipv6Ips: string[];
    /**
     * The LAN ID the NIC will sit on
     */
    lan: number;
    /**
     * The MAC address of the NIC
     */
    mac: string;
    /**
     * Name of an existing server that you want to search for.
     */
    name: string;
    /**
     * The PCI slot number of the Nic
     */
    pciSlot: number;
}

export interface GetCubeServerNicFirewallRule {
    /**
     * Defines the allowed code (from 0 to 254) if protocol ICMP is chosen
     */
    icmpCode: number;
    /**
     * Defines the allowed type (from 0 to 254) if the protocol ICMP is chosen
     */
    icmpType: number;
    /**
     * ID of the server you want to search for.
     *
     * `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
     */
    id: string;
    /**
     * Name of an existing server that you want to search for.
     */
    name: string;
    /**
     * Defines the end range of the allowed port (from 1 to 65534) if the protocol TCP or UDP is chosen
     */
    portRangeEnd: number;
    /**
     * Defines the start range of the allowed port (from 1 to 65534) if protocol TCP or UDP is chosen
     */
    portRangeStart: number;
    /**
     * he protocol for the rule
     */
    protocol: string;
    /**
     * Only traffic originating from the respective IPv4 address is allowed. Value null allows all source IPs
     */
    sourceIp: string;
    /**
     * Only traffic originating from the respective MAC address is allowed
     */
    sourceMac: string;
    /**
     * In case the target NIC has multiple IP addresses, only traffic directed to the respective IP address of the NIC is allowed
     */
    targetIp: string;
    /**
     * The type of firewall rule
     */
    type: string;
}

export interface GetCubeServerVolume {
    /**
     * The availability zone in which the volume should exist
     */
    availabilityZone: string;
    /**
     * The uuid of the Backup Unit that user has access to
     */
    backupUnitId: string;
    /**
     * The UUID of the attached server.
     */
    bootServer: string;
    /**
     * The bus type of the volume
     */
    bus: string;
    /**
     * Is capable of CPU hot plug (no reboot required)
     */
    cpuHotPlug: boolean;
    /**
     * The Logical Unit Number (LUN) of the storage volume
     */
    deviceNumber: number;
    /**
     * Is capable of Virt-IO drive hot plug (no reboot required)
     */
    discVirtioHotPlug: boolean;
    /**
     * Is capable of Virt-IO drive hot unplug (no reboot required)
     */
    discVirtioHotUnplug: boolean;
    /**
     * ID of the server you want to search for.
     *
     * `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
     */
    id: string;
    imageName: string;
    /**
     * Initial password to be set for installed OS
     */
    imagePassword: string;
    /**
     * OS type of this volume
     */
    licenceType: string;
    /**
     * Name of an existing server that you want to search for.
     */
    name: string;
    /**
     * Is capable of nic hot plug (no reboot required)
     */
    nicHotPlug: boolean;
    /**
     * Is capable of nic hot unplug (no reboot required)
     */
    nicHotUnplug: boolean;
    /**
     * The PCI slot number of the Nic
     */
    pciSlot: number;
    /**
     * Is capable of memory hot plug (no reboot required)
     */
    ramHotPlug: boolean;
    /**
     * Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key
     */
    sshKeys: string[];
    /**
     * The type of firewall rule
     */
    type: string;
    /**
     * The cloud-init configuration for the volume as base64 encoded string
     */
    userData?: string;
}

export interface GetDatacenterCpuArchitecture {
    /**
     * A valid CPU family name
     */
    cpuFamily: string;
    /**
     * The maximum number of cores available
     */
    maxCores: number;
    /**
     * The maximum number of RAM in MB
     */
    maxRam: number;
    /**
     * A valid CPU vendor name
     */
    vendor: string;
}

export interface GetDataplatformClusterConfig {
    apiVersion: string;
    clusters: outputs.GetDataplatformClusterConfigCluster[];
    contexts: outputs.GetDataplatformClusterConfigContext[];
    currentContext: string;
    kind: string;
    users: outputs.GetDataplatformClusterConfigUser[];
}

export interface GetDataplatformClusterConfigCluster {
    cluster: {[key: string]: string};
    /**
     * Name of an existing cluster that you want to search for. Search by name is case-insensitive. The whole resource name is required if `partialMatch` parameter is not set to true.
     */
    name: string;
}

export interface GetDataplatformClusterConfigContext {
    context: {[key: string]: string};
    /**
     * Name of an existing cluster that you want to search for. Search by name is case-insensitive. The whole resource name is required if `partialMatch` parameter is not set to true.
     */
    name: string;
}

export interface GetDataplatformClusterConfigUser {
    /**
     * Name of an existing cluster that you want to search for. Search by name is case-insensitive. The whole resource name is required if `partialMatch` parameter is not set to true.
     */
    name: string;
    user: {[key: string]: string};
}

export interface GetDataplatformClusterLan {
    /**
     * Indicates if the Kubernetes node pool LAN will reserve an IP using DHCP. The default value is 'true'.
     */
    dhcp: boolean;
    /**
     * The LAN ID of an existing LAN at the related data center
     */
    lanId: string;
    /**
     * An array of additional LANs attached to worker nodes
     */
    routes: outputs.GetDataplatformClusterLanRoute[];
}

export interface GetDataplatformClusterLanRoute {
    /**
     * IPv4 or IPv6 gateway IP for the route
     */
    gateway: string;
    /**
     * IPv4 or IPv6 CIDR to be routed via the interface
     */
    network: string;
}

export interface GetDataplatformClusterMaintenanceWindow {
    dayOfTheWeek: string;
    /**
     * Time at which the maintenance should start.
     */
    time: string;
}

export interface GetDataplatformNodePoolMaintenanceWindow {
    dayOfTheWeek: string;
    /**
     * Time at which the maintenance should start.
     */
    time: string;
}

export interface GetDataplatformNodePoolsNodePool {
    /**
     * Key-value pairs attached to node pool resource as kubernetes annotations
     */
    annotations: {[key: string]: string};
    /**
     * The availability zone of the virtual datacenter region where the node pool resources should be provisioned.
     */
    availabilityZone: string;
    /**
     * The number of CPU cores per node.
     */
    coresCount: number;
    /**
     * A valid CPU family name or `AUTO` if the platform shall choose the best fitting option. Available CPU architectures can be retrieved from the datacenter resource.
     */
    cpuFamily: string;
    /**
     * The UUID of the virtual data center (VDC) in which the node pool is provisioned
     */
    datacenterId: string;
    id: string;
    /**
     * Key-value pairs attached to the node pool resource as kubernetes labels
     */
    labels: {[key: string]: string};
    /**
     * Starting time of a weekly 4 hour-long window, during which maintenance might occur in hh:mm:ss format
     */
    maintenanceWindows: outputs.GetDataplatformNodePoolsNodePoolMaintenanceWindow[];
    /**
     * Name of an existing cluster that you want to search for. Search by name is case-insensitive. The whole resource name is required if `partialMatch` parameter is not set to true.
     */
    name: string;
    /**
     * The number of nodes that make up the node pool.
     */
    nodeCount: number;
    /**
     * The RAM size for one node in MB. Must be set in multiples of 1024 MB, with a minimum size is of 2048 MB.
     */
    ramSize: number;
    /**
     * The size of the volume in GB. The size must be greater than 10GB.
     */
    storageSize: number;
    /**
     * The type of hardware for the volume.
     */
    storageType: string;
    /**
     * The version of the Data Platform.
     */
    version: string;
}

export interface GetDataplatformNodePoolsNodePoolMaintenanceWindow {
    dayOfTheWeek: string;
    /**
     * Time at which the maintenance should start. Must conform to the 'HH:MM:SS' 24-hour format.
     */
    time: string;
}

export interface GetGroupUser {
    administrator: boolean;
    email: string;
    firstName: string;
    forceSecAuth: boolean;
    /**
     * ID of the group you want to search for.
     *
     * Either `name` or `id` must be provided. If none, or both are provided, the datasource will return an error.
     */
    id: string;
    lastName: string;
}

export interface GetInmemorydbReplicasetConnection {
    /**
     * The IP and subnet for your Replicaset.
     */
    cidr: string;
    /**
     * The datacenter to connect your Replicaset to.
     */
    datacenterId: string;
    /**
     * The numeric LAN ID to connect your Replicaset to.
     */
    lanId: string;
}

export interface GetInmemorydbReplicasetCredential {
    /**
     * The username for your Replicaset.
     */
    username: string;
}

export interface GetInmemorydbReplicasetMaintenanceWindow {
    /**
     * The name of the week day.
     */
    dayOfTheWeek: string;
    /**
     * Start of the maintenance window in UTC time.
     */
    time: string;
}

export interface GetInmemorydbReplicasetResource {
    /**
     * The number of CPU cores per instance.
     */
    cores: number;
    /**
     * The amount of memory per instance in gigabytes (GB).
     */
    ram: number;
    /**
     * The amount of storage per instance in gigabytes (GB).
     */
    storage: number;
}

export interface GetInmemorydbSnapshotMetadata {
    /**
     * The ISO 8601 creation timestamp.
     */
    createdDate: string;
    /**
     * The ID of the datacenter the snapshot was created in. Please mind, that the snapshot is not available in other datacenters.
     */
    datacenterId: string;
    /**
     * The ISO 8601 modified timestamp.
     */
    lastModifiedDate: string;
    /**
     * The ID of the InMemoryDB replica set the snapshot is taken from.
     */
    replicaSetId: string;
    /**
     * The time the snapshot was dumped from the replica set.
     */
    snapshotTime: string;
}

export interface GetIpblockIpConsumer {
    datacenterId: string;
    datacenterName: string;
    ip: string;
    k8sClusterUuid: string;
    k8sNodepoolUuid: string;
    mac: string;
    nicId: string;
    serverId: string;
    serverName: string;
}

export interface GetK8sClusterConfig {
    apiVersion: string;
    clusters: outputs.GetK8sClusterConfigCluster[];
    contexts: outputs.GetK8sClusterConfigContext[];
    currentContext: string;
    kind: string;
    users: outputs.GetK8sClusterConfigUser[];
}

export interface GetK8sClusterConfigCluster {
    cluster: {[key: string]: string};
    /**
     * Name of an existing cluster that you want to search for.
     */
    name: string;
}

export interface GetK8sClusterConfigContext {
    context: {[key: string]: string};
    /**
     * Name of an existing cluster that you want to search for.
     */
    name: string;
}

export interface GetK8sClusterConfigUser {
    /**
     * Name of an existing cluster that you want to search for.
     */
    name: string;
    user: {[key: string]: string};
}

export interface GetK8sClusterMaintenanceWindow {
    /**
     * Day of the week when maintenance is allowed
     */
    dayOfTheWeek: string;
    /**
     * A clock time in the day when maintenance is allowed
     */
    time: string;
}

export interface GetK8sClusterS3Bucket {
    /**
     * Name of an existing cluster that you want to search for.
     */
    name: string;
}

export interface GetK8sClustersCluster {
    /**
     * Access to the K8s API server is restricted to these CIDRs. Cluster-internal traffic is not affected by this restriction. If no allowlist is specified, access is not restricted. If an IP without subnet mask is provided, the default value will be used: 32 for IPv4 and 128 for IPv6.
     */
    apiSubnetAllowLists: string[];
    /**
     * A list of available versions for upgrading the cluster
     */
    availableUpgradeVersions: string[];
    caCrt: string;
    configs: outputs.GetK8sClustersClusterConfig[];
    id?: string;
    k8sVersion: string;
    kubeConfig: string;
    location: string;
    /**
     * A maintenance window comprise of a day of the week and a time for maintenance to be allowed
     */
    maintenanceWindows: outputs.GetK8sClustersClusterMaintenanceWindow[];
    name?: string;
    /**
     * The NAT gateway IP of the cluster if the cluster is private.
     */
    natGatewayIp: string;
    nodePools: string[];
    /**
     * The node subnet of the cluster, if the cluster is private.
     */
    nodeSubnet: string;
    /**
     * The indicator if the cluster is public or private.
     */
    public: boolean;
    /**
     * List of Object Storage bucket configured for K8s usage. For now it contains only an Object Storage bucket used to store K8s API audit logs.
     */
    s3Buckets: outputs.GetK8sClustersClusterS3Bucket[];
    server: string;
    state: string;
    userTokens: {[key: string]: string};
    /**
     * A list of versions that may be used for node pools under this cluster
     */
    viableNodePoolVersions: string[];
}

export interface GetK8sClustersClusterConfig {
    apiVersion: string;
    clusters: outputs.GetK8sClustersClusterConfigCluster[];
    contexts: outputs.GetK8sClustersClusterConfigContext[];
    currentContext: string;
    kind: string;
    users: outputs.GetK8sClustersClusterConfigUser[];
}

export interface GetK8sClustersClusterConfigCluster {
    cluster: {[key: string]: string};
    name: string;
}

export interface GetK8sClustersClusterConfigContext {
    context: {[key: string]: string};
    name: string;
}

export interface GetK8sClustersClusterConfigUser {
    name: string;
    user: {[key: string]: string};
}

export interface GetK8sClustersClusterMaintenanceWindow {
    /**
     * Day of the week when maintenance is allowed
     */
    dayOfTheWeek: string;
    /**
     * A clock time in the day when maintenance is allowed
     */
    time: string;
}

export interface GetK8sClustersClusterS3Bucket {
    /**
     * Name of the Object Storage bucket
     */
    name: string;
}

export interface GetK8sClustersFilter {
    name: string;
    value: string;
}

export interface GetK8sNodePoolAutoScaling {
    /**
     * The maximum number of worker nodes that the node pool can scale to
     */
    maxNodeCount: number;
    /**
     * The minimum number of worker nodes the node pool can scale down to
     */
    minNodeCount: number;
}

export interface GetK8sNodePoolLan {
    /**
     * Indicates if the Kubernetes Node Pool LAN will reserve an IP using DHCP
     */
    dhcp: boolean;
    /**
     * ID of the node pool you want to search for.
     *
     * `k8sClusterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
     */
    id: number;
    /**
     * An array of additional LANs attached to worker nodes
     */
    routes?: outputs.GetK8sNodePoolLanRoute[];
}

export interface GetK8sNodePoolLanRoute {
    /**
     * IPv4 or IPv6 Gateway IP for the route
     */
    gatewayIp: string;
    /**
     * IPv4 or IPv6 CIDR to be routed via the interface
     */
    network: string;
}

export interface GetK8sNodePoolMaintenanceWindow {
    /**
     * Day of the week when maintenance is allowed
     */
    dayOfTheWeek: string;
    /**
     * A clock time in the day when maintenance is allowed
     */
    time: string;
}

export interface GetK8sNodePoolNodesNode {
    id?: string;
    /**
     * The kubernetes version
     */
    k8sVersion: string;
    /**
     * The kubernetes node name
     */
    name?: string;
    /**
     * A valid private IP
     */
    privateIp?: string;
    /**
     * A valid public IP
     */
    publicIp?: string;
}

export interface GetKafkaClusterConnection {
    /**
     * IP address and port of cluster brokers.
     */
    brokerAddresses: string[];
    /**
     * The datacenter that your instance is connected to.
     */
    datacenterId: string;
    /**
     * The numeric LAN ID your instance is connected to.
     */
    lanId: string;
}

export interface GetLanIpFailover {
    ip: string;
    nicUuid: string;
}

export interface GetLocationCpuArchitecture {
    /**
     * A valid CPU family name.
     */
    cpuFamily: string;
    /**
     * The maximum number of cores available.
     */
    maxCores: number;
    /**
     * The maximum number of RAM in MB.
     */
    maxRam: number;
    /**
     * A valid CPU vendor name.
     */
    vendor: string;
}

export interface GetLoggingPipelineLog {
    /**
     * [list] The configuration of the logs datastore, a list that contains elements with the following structure:
     */
    destinations: outputs.GetLoggingPipelineLogDestination[];
    /**
     * [string] "Protocol to use as intake. Possible values are: http, tcp."
     */
    protocol: string;
    /**
     * [bool]
     */
    public: boolean;
    /**
     * [string] The source parser to be used.
     */
    source: string;
    /**
     * [string] The tag is used to distinguish different pipelines. Must be unique amongst the pipeline's array items.
     */
    tag: string;
}

export interface GetLoggingPipelineLogDestination {
    /**
     * [int] Defines the number of days a log record should be kept in loki. Works with loki destination type only.
     */
    retentionInDays: number;
    /**
     * [string] The internal output stream to send logs to.
     */
    type: string;
}

export interface GetMariadbBackupsBackup {
    /**
     * The list of backups for the specified cluster
     */
    baseBackups: outputs.GetMariadbBackupsBackupBaseBackup[];
    /**
     * The unique ID of the cluster that was backed up
     */
    clusterId: string;
    /**
     * The oldest available timestamp to which you can restore
     */
    earliestRecoveryTargetTime: string;
    /**
     * Size of all base backups in Mebibytes (MiB). This is at least the sum of all base backup sizes
     */
    size: number;
}

export interface GetMariadbBackupsBackupBaseBackup {
    /**
     * The ISO 8601 creation timestamp
     */
    created: string;
    /**
     * The size of the backup in Mebibytes (MiB). This is the size of the binary backup file that was stored
     */
    size: number;
}

export interface GetMariadbClusterConnection {
    /**
     * The IP and subnet for your cluster.
     */
    cidr: string;
    /**
     * The datacenter to connect your cluster to.
     */
    datacenterId: string;
    /**
     * The numeric LAN ID to connect your cluster to.
     */
    lanId: string;
}

export interface GetMariadbClusterMaintenanceWindow {
    /**
     * The name of the week day.
     */
    dayOfTheWeek: string;
    /**
     * Start of the maintenance window in UTC time.
     */
    time: string;
}

export interface GetMongoClusterBackup {
    /**
     * The location where the cluster backups will be stored. If not set, the backup is stored in the nearest location of the cluster. Examples: de, eu-sounth-2, eu-central-2
     */
    location: string;
}

export interface GetMongoClusterBiConnector {
    /**
     * Enable or disable the BiConnector
     */
    enabled: boolean;
    /**
     * The host where this new BI Connector is installed
     */
    host: string;
    /**
     * Port number used when connecting to this new BI Connector
     */
    port: string;
}

export interface GetMongoClusterConnection {
    /**
     * The list of IPs and subnet for your cluster.
     *           Note the following unavailable IP ranges:
     *           10.233.64.0/18
     *           10.233.0.0/18
     *           10.233.114.0/24 		
     *  example: [192.168.1.100/24, 192.168.1.101/24]
     */
    cidrLists: string[];
    /**
     * The datacenter to connect your cluster to
     */
    datacenterId: string;
    /**
     * The LAN to connect your cluster to
     */
    lanId: string;
}

export interface GetMongoClusterMaintenanceWindow {
    dayOfTheWeek: string;
    time: string;
}

export interface GetMongoUserRole {
    database: string;
    /**
     * A list of mongodb user roles. Examples: read, readWrite, readAnyDatabase
     */
    role: string;
}

export interface GetNatgatewayLan {
    /**
     * Collection of gateway IP addresses of the NAT gateway. Will be auto-generated if not provided. Should ideally be an IP belonging to the same subnet as the LAN
     */
    gatewayIps: string[];
    /**
     * ID of the network load balancer forwarding rule you want to search for.
     *
     * `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
     */
    id: number;
}

export interface GetNatgatewayRuleTargetPortRange {
    /**
     * Target port range end associated with the NAT gateway rule.
     */
    end: number;
    /**
     * Target port range start associated with the NAT gateway rule.
     */
    start: number;
}

export interface GetNetworkloadbalancerFlowlog {
    /**
     * Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL. Immutable, forces re-creation.
     */
    action: string;
    /**
     * Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist. Immutable, forces re-creation.
     */
    bucket: string;
    /**
     * Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, forces re-creation.
     */
    direction: string;
    /**
     * ID of the network load balancer you want to search for.
     *
     * `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
     */
    id: string;
    /**
     * Name of an existing network load balancer that you want to search for.
     */
    name: string;
}

export interface GetNetworkloadbalancerForwardingruleHealthCheck {
    /**
     * ClientTimeout is expressed in milliseconds. This inactivity timeout applies when the client is expected to acknowledge or send data. If unset the default of 50 seconds will be used.
     */
    clientTimeout: number;
    /**
     * It specifies the maximum time (in milliseconds) to wait for a connection attempt to a target VM to succeed. If unset, the default of 5 seconds will be used.
     */
    connectTimeout: number;
    /**
     * Retries specifies the number of retries to perform on a target VM after a connection failure. If unset, the default value of 3 will be used.
     */
    retries: number;
    /**
     * TargetTimeout specifies the maximum inactivity time (in milliseconds) on the target VM side. If unset, the default of 50 seconds will be used.
     */
    targetTimeout: number;
}

export interface GetNetworkloadbalancerForwardingruleTarget {
    /**
     * Health check attributes for Network Load Balancer forwarding rule target.
     */
    healthChecks: outputs.GetNetworkloadbalancerForwardingruleTargetHealthCheck[];
    /**
     * IP of a balanced target VM.
     */
    ip: string;
    /**
     * Port of the balanced target service. (range: 1 to 65535).
     */
    port: number;
    /**
     * The proxy protocol version.
     */
    proxyProtocol: string;
    /**
     * Weight parameter is used to adjust the target VM's weight relative to other target VMs.
     */
    weight: number;
}

export interface GetNetworkloadbalancerForwardingruleTargetHealthCheck {
    /**
     * Check specifies whether the target VM's health is checked.
     */
    check: boolean;
    /**
     * CheckInterval determines the duration (in milliseconds) between consecutive health checks. If unspecified a default of 2000 ms is used.
     */
    checkInterval: number;
    /**
     * Maintenance specifies if a target VM should be marked as down, even if it is not.
     */
    maintenance: boolean;
}

export interface GetNfsClusterConnection {
    /**
     * The ID of the datacenter where the Network File Storage cluster is located.
     */
    datacenterId: string;
    /**
     * The IP address and prefix of the Network File Storage cluster. The IP address can be either IPv4 or IPv6. The IP address has to be given with CIDR notation.
     */
    ipAddress: string;
    /**
     * The Private LAN to which the Network File Storage cluster must be connected.
     */
    lan: string;
}

export interface GetNfsClusterNf {
    /**
     * The minimum supported version of the NFS cluster. Default is `4.2`
     */
    minVersion: string;
}

export interface GetNfsShareClientGroup {
    /**
     * Optional description for the clients groups.
     */
    description: string;
    /**
     * A singular host allowed to connect to the share. The host can be specified as IP address and can be either IPv4 or IPv6.
     */
    hosts: string[];
    /**
     * The allowed host or network to which the export is being shared. The IP address can be either IPv4 or IPv6 and has to be given with CIDR notation.
     */
    ipNetworks: string[];
    /**
     * The NFS configuration for the client group. Each NFS configuration supports the following:
     */
    nfs: outputs.GetNfsShareClientGroupNf[];
}

export interface GetNfsShareClientGroupNf {
    /**
     * The squash mode for the export. The squash mode can be: none - No squash mode. no mapping, root-anonymous - Map root user to anonymous uid, all-anonymous - Map all users to anonymous uid.
     */
    squash: string;
}

export interface GetNicFlowlog {
    /**
     * Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL.
     */
    action: string;
    /**
     * Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist.
     */
    bucket: string;
    /**
     * Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL.
     */
    direction: string;
    /**
     * ID of the nic you want to search for.
     *
     * `datacenterId` and either `name` or `id` must be provided.
     * If none, are provided, the datasource will return an error.
     */
    id: string;
    /**
     * [string] The name of the LAN.
     */
    name: string;
}

export interface GetPgBackupsClusterBackup {
    /**
     * The unique ID of the cluster
     */
    clusterId: string;
    /**
     * The oldest available timestamp to which you can restore.
     */
    earliestRecoveryTargetTime: string;
    /**
     * The unique ID of the resource.
     */
    id: string;
    /**
     * Whether a cluster currently backs up data to this backup.
     */
    isActive: boolean;
    /**
     * The Object Storage location where the backups will be stored.
     */
    location: string;
    /**
     * Metadata of the resource
     */
    metadatas: outputs.GetPgBackupsClusterBackupMetadata[];
    /**
     * Size of all base backups including the wal size in MB.
     */
    size: number;
    type: string;
    /**
     * The PostgreSQL version this backup was created from.
     */
    version: string;
}

export interface GetPgBackupsClusterBackupMetadata {
    /**
     * The ISO 8601 creation timestamp.
     */
    createdDate: string;
}

export interface GetPgClusterConnection {
    /**
     * The IP and subnet for the database. Note the following unavailable IP ranges: 10.233.64.0/18, 10.233.0.0/18, 10.233.114.0/24
     */
    cidr: string;
    /**
     * The datacenter to connect your cluster to.
     */
    datacenterId: string;
    /**
     * The LAN to connect your cluster to.
     */
    lanId: string;
}

export interface GetPgClusterConnectionPooler {
    enabled: boolean;
    /**
     * Represents different modes of connection pooling for the connection pooler
     */
    poolMode: string;
}

export interface GetPgClusterFromBackup {
    /**
     * The unique ID of the backup you want to restore.
     */
    backupId: string;
    /**
     * If this value is supplied as ISO 8601 timestamp, the backup will be replayed up until the given timestamp. If empty, the backup will be applied completely.
     */
    recoveryTargetTime: string;
}

export interface GetPgClusterMaintenanceWindow {
    dayOfTheWeek: string;
    time: string;
}

export interface GetPgDatabasesDatabase {
    id: string;
    name: string;
    owner: string;
}

export interface GetPrivateCrossconnectConnectableDatacenter {
    /**
     * ID of the cross connect you want to search for.
     *
     * Either `name` or `id` must be provided. If none, or both are provided, the datasource will return an error.
     */
    id: string;
    /**
     * The physical location of the connectable datacenter
     */
    location: string;
    /**
     * Name of an existing cross connect that you want to search for.
     */
    name: string;
}

export interface GetPrivateCrossconnectPeer {
    /**
     * The id of the cross-connected datacenter
     */
    datacenterId: string;
    /**
     * The name of the cross-connected datacenter
     */
    datacenterName: string;
    /**
     * The id of the cross-connected LAN
     */
    lanId: string;
    /**
     * The name of the cross-connected LAN
     */
    lanName: string;
    /**
     * The physical location of the connectable datacenter
     */
    location: string;
}

export interface GetServerCdrom {
    /**
     * Cloud init compatibility
     */
    cloudInit: string;
    /**
     * Is capable of CPU hot plug (no reboot required)
     */
    cpuHotPlug: boolean;
    /**
     * Is capable of CPU hot unplug (no reboot required)
     */
    cpuHotUnplug: boolean;
    /**
     * Description of cdrom
     */
    description: string;
    /**
     * Is capable of SCSI drive hot plug (no reboot required)
     */
    discScsiHotPlug: boolean;
    /**
     * Is capable of SCSI drive hot unplug (no reboot required)
     */
    discScsiHotUnplug: boolean;
    /**
     * Is capable of Virt-IO drive hot plug (no reboot required)
     */
    discVirtioHotPlug: boolean;
    /**
     * Is capable of Virt-IO drive hot unplug (no reboot required)
     */
    discVirtioHotUnplug: boolean;
    /**
     * ID of the server you want to search for.
     *
     * `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
     */
    id: string;
    /**
     * List of image aliases mapped for this Image
     */
    imageAliases: string[];
    /**
     * Type of image
     */
    imageType: string;
    /**
     * OS type of this volume
     */
    licenceType: string;
    /**
     * Location of that image/snapshot
     */
    location: string;
    /**
     * Name of an existing server that you want to search for.
     */
    name: string;
    /**
     * Is capable of nic hot plug (no reboot required)
     */
    nicHotPlug: boolean;
    /**
     * Is capable of nic hot unplug (no reboot required)
     */
    nicHotUnplug: boolean;
    /**
     * Indicates if the image is part of the public repository or not
     */
    public: boolean;
    /**
     * Is capable of memory hot plug (no reboot required)
     */
    ramHotPlug: boolean;
    /**
     * Is capable of memory hot unplug (no reboot required)
     */
    ramHotUnplug: boolean;
    /**
     * The size of the volume in GB
     */
    size: number;
}

export interface GetServerLabel {
    /**
     * ID of the server you want to search for.
     *
     * `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
     */
    id: string;
    /**
     * The key of the label
     */
    key: string;
    /**
     * The value of the label
     */
    value: string;
}

export interface GetServerNic {
    /**
     * The Logical Unit Number (LUN) of the storage volume
     */
    deviceNumber: number;
    /**
     * Indicates if the nic will reserve an IP using DHCP
     */
    dhcp: boolean;
    dhcpv6?: boolean;
    /**
     * Activate or deactivate the firewall
     */
    firewallActive: boolean;
    /**
     * list of
     */
    firewallRules: outputs.GetServerNicFirewallRule[];
    /**
     * The type of firewall rules that will be allowed on the NIC
     */
    firewallType: string;
    /**
     * ID of the server you want to search for.
     *
     * `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
     */
    id: string;
    /**
     * Collection of IP addresses assigned to a nic
     */
    ips: string[];
    ipv6CidrBlock: string;
    ipv6Ips: string[];
    /**
     * The LAN ID the NIC will sit on
     */
    lan: number;
    /**
     * The MAC address of the NIC
     */
    mac: string;
    /**
     * Name of an existing server that you want to search for.
     */
    name: string;
    /**
     * The PCI slot number of the Nic
     */
    pciSlot: number;
}

export interface GetServerNicFirewallRule {
    /**
     * Defines the allowed code (from 0 to 254) if protocol ICMP is chosen
     */
    icmpCode: number;
    /**
     * Defines the allowed type (from 0 to 254) if the protocol ICMP is chosen
     */
    icmpType: number;
    /**
     * ID of the server you want to search for.
     *
     * `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
     */
    id: string;
    /**
     * Name of an existing server that you want to search for.
     */
    name: string;
    /**
     * Defines the end range of the allowed port (from 1 to 65534) if the protocol TCP or UDP is chosen
     */
    portRangeEnd: number;
    /**
     * Defines the start range of the allowed port (from 1 to 65534) if protocol TCP or UDP is chosen
     */
    portRangeStart: number;
    /**
     * he protocol for the rule
     */
    protocol: string;
    /**
     * Only traffic originating from the respective IPv4 address is allowed. Value null allows all source IPs
     */
    sourceIp: string;
    /**
     * Only traffic originating from the respective MAC address is allowed
     */
    sourceMac: string;
    /**
     * In case the target NIC has multiple IP addresses, only traffic directed to the respective IP address of the NIC is allowed
     */
    targetIp: string;
    /**
     * The type of firewall rule
     */
    type: string;
}

export interface GetServerVolume {
    /**
     * The availability zone in which the volume should exist
     */
    availabilityZone: string;
    /**
     * The uuid of the Backup Unit that user has access to
     */
    backupUnitId: string;
    /**
     * The UUID of the attached server.
     */
    bootServer: string;
    /**
     * The bus type of the volume
     */
    bus: string;
    /**
     * Is capable of CPU hot plug (no reboot required)
     */
    cpuHotPlug: boolean;
    /**
     * The Logical Unit Number (LUN) of the storage volume
     */
    deviceNumber: number;
    /**
     * Is capable of Virt-IO drive hot plug (no reboot required)
     */
    discVirtioHotPlug: boolean;
    /**
     * Is capable of Virt-IO drive hot unplug (no reboot required)
     */
    discVirtioHotUnplug: boolean;
    /**
     * ID of the server you want to search for.
     *
     * `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
     */
    id: string;
    imageName: string;
    /**
     * Initial password to be set for installed OS
     */
    imagePassword: string;
    /**
     * OS type of this volume
     */
    licenceType: string;
    /**
     * Name of an existing server that you want to search for.
     */
    name: string;
    /**
     * Is capable of nic hot plug (no reboot required)
     */
    nicHotPlug: boolean;
    /**
     * Is capable of nic hot unplug (no reboot required)
     */
    nicHotUnplug: boolean;
    /**
     * The PCI slot number of the Nic
     */
    pciSlot: number;
    /**
     * Is capable of memory hot plug (no reboot required)
     */
    ramHotPlug: boolean;
    /**
     * The size of the volume in GB
     */
    size: number;
    /**
     * Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key
     */
    sshKeys: string[];
    /**
     * The type of firewall rule
     */
    type: string;
    /**
     * The cloud-init configuration for the volume as base64 encoded string
     */
    userData?: string;
}

export interface GetServersFilter {
    name: string;
    value: string;
}

export interface GetServersServer {
    availabilityZone: string;
    bootCdrom: string;
    bootImage: string;
    bootVolume: string;
    cdroms: outputs.GetServersServerCdrom[];
    cores: number;
    cpuFamily: string;
    /**
     * The unique ID of the server.
     */
    id: string;
    labels: outputs.GetServersServerLabel[];
    name?: string;
    nics: outputs.GetServersServerNic[];
    ram: number;
    templateUuid?: string;
    token: string;
    type: string;
    vmState: string;
    volumes: outputs.GetServersServerVolume[];
}

export interface GetServersServerCdrom {
    cloudInit: string;
    cpuHotPlug: boolean;
    cpuHotUnplug: boolean;
    description: string;
    discScsiHotPlug: boolean;
    discScsiHotUnplug: boolean;
    discVirtioHotPlug: boolean;
    discVirtioHotUnplug: boolean;
    id: string;
    imageAliases: string[];
    imageType: string;
    licenceType: string;
    location: string;
    name: string;
    nicHotPlug: boolean;
    nicHotUnplug: boolean;
    public: boolean;
    ramHotPlug: boolean;
    ramHotUnplug: boolean;
    size: number;
}

export interface GetServersServerLabel {
    id: string;
    key: string;
    value: string;
}

export interface GetServersServerNic {
    deviceNumber: number;
    dhcp: boolean;
    dhcpv6?: boolean;
    firewallActive: boolean;
    firewallRules: outputs.GetServersServerNicFirewallRule[];
    firewallType: string;
    id: string;
    ips: string[];
    ipv6CidrBlock: string;
    ipv6Ips: string[];
    lan: number;
    mac: string;
    name: string;
    pciSlot: number;
}

export interface GetServersServerNicFirewallRule {
    icmpCode: number;
    icmpType: number;
    id: string;
    name: string;
    portRangeEnd: number;
    portRangeStart: number;
    protocol: string;
    sourceIp: string;
    sourceMac: string;
    targetIp: string;
    type: string;
}

export interface GetServersServerVolume {
    availabilityZone: string;
    backupUnitId: string;
    /**
     * The UUID of the attached server.
     */
    bootServer: string;
    bus: string;
    cpuHotPlug: boolean;
    deviceNumber: number;
    discVirtioHotPlug: boolean;
    discVirtioHotUnplug: boolean;
    diskType: string;
    id: string;
    imageName: string;
    imagePassword: string;
    licenceType: string;
    name: string;
    nicHotPlug: boolean;
    nicHotUnplug: boolean;
    pciSlot: number;
    ramHotPlug: boolean;
    size: number;
    sshKeys: string[];
    userData?: string;
}

export interface GetTargetGroupHealthCheck {
    /**
     * The interval in milliseconds between consecutive health checks; default is 2000.
     */
    checkInterval: number;
    /**
     * The maximum time in milliseconds to wait for a target to respond to a check. For target VMs with 'Check Interval' set, the lesser of the two  values is used once the TCP connection is established.
     */
    checkTimeout: number;
    /**
     * The maximum number of attempts to reconnect to a target after a connection failure. Valid range is 0 to 65535, and default is three reconnection.
     */
    retries: number;
}

export interface GetTargetGroupHttpHealthCheck {
    matchType: string;
    /**
     * The method for the HTTP health check.
     */
    method: string;
    negate: boolean;
    /**
     * The path (destination URL) for the HTTP health check request; the default is /.
     */
    path: string;
    regex: boolean;
    /**
     * The response returned by the request, depending on the match type.
     */
    response: string;
}

export interface GetTargetGroupTarget {
    /**
     * Makes the target available only if it accepts periodic health check TCP connection attempts; when turned off, the target is considered always available. The health check only consists of a connection attempt to the address and port of the target. Default is True.
     */
    healthCheckEnabled: boolean;
    /**
     * The IP of the balanced target VM.
     */
    ip: string;
    /**
     * Maintenance mode prevents the target from receiving balanced traffic.
     */
    maintenanceEnabled: boolean;
    /**
     * The port of the balanced target service; valid range is 1 to 65535.
     */
    port: number;
    /**
     * The proxy protocol version.
     */
    proxyProtocol: string;
    /**
     * Traffic is distributed in proportion to target weight, relative to the combined weight of all targets. A target with higher weight receives a greater share of traffic. Valid range is 0 to 256 and default is 1; targets with weight of 0 do not participate in load balancing but still accept persistent connections. It is best use values in the middle of the range to leave room for later adjustments.
     */
    weight: number;
}

export interface GetUserGroup {
    /**
     * ID of the user you want to search for.
     *
     * Either `email` or `id` can be provided. If no argument is set, the provider will search for the **email that was provided for the configuration**. If none is found, the provider will return an error.
     */
    id: string;
    name: string;
}

export interface GetVcpuServerCdrom {
    /**
     * Cloud init compatibility
     */
    cloudInit: string;
    /**
     * Is capable of CPU hot plug (no reboot required)
     */
    cpuHotPlug: boolean;
    /**
     * Is capable of CPU hot unplug (no reboot required)
     */
    cpuHotUnplug: boolean;
    /**
     * Description of cdrom
     */
    description: string;
    /**
     * Is capable of SCSI drive hot plug (no reboot required)
     */
    discScsiHotPlug: boolean;
    /**
     * Is capable of SCSI drive hot unplug (no reboot required)
     */
    discScsiHotUnplug: boolean;
    /**
     * Is capable of Virt-IO drive hot plug (no reboot required)
     */
    discVirtioHotPlug: boolean;
    /**
     * Is capable of Virt-IO drive hot unplug (no reboot required)
     */
    discVirtioHotUnplug: boolean;
    /**
     * ID of the server you want to search for.
     *
     * `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
     */
    id: string;
    /**
     * List of image aliases mapped for this Image
     */
    imageAliases: string[];
    /**
     * Type of image
     */
    imageType: string;
    /**
     * OS type of this volume
     */
    licenceType: string;
    /**
     * Location of that image/snapshot
     */
    location: string;
    /**
     * Name of an existing server that you want to search for.
     */
    name: string;
    /**
     * Is capable of nic hot plug (no reboot required)
     */
    nicHotPlug: boolean;
    /**
     * Is capable of nic hot unplug (no reboot required)
     */
    nicHotUnplug: boolean;
    /**
     * Indicates if the image is part of the public repository or not
     */
    public: boolean;
    /**
     * Is capable of memory hot plug (no reboot required)
     */
    ramHotPlug: boolean;
    /**
     * Is capable of memory hot unplug (no reboot required)
     */
    ramHotUnplug: boolean;
    /**
     * The size of the volume in GB
     */
    size: number;
}

export interface GetVcpuServerLabel {
    /**
     * ID of the server you want to search for.
     *
     * `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
     */
    id: string;
    /**
     * The key of the label
     */
    key: string;
    /**
     * The value of the label
     */
    value: string;
}

export interface GetVcpuServerNic {
    /**
     * The Logical Unit Number (LUN) of the storage volume
     */
    deviceNumber: number;
    /**
     * Indicates if the nic will reserve an IP using DHCP
     */
    dhcp: boolean;
    dhcpv6?: boolean;
    /**
     * Activate or deactivate the firewall
     */
    firewallActive: boolean;
    /**
     * list of
     */
    firewallRules: outputs.GetVcpuServerNicFirewallRule[];
    /**
     * The type of firewall rules that will be allowed on the NIC
     */
    firewallType: string;
    /**
     * ID of the server you want to search for.
     *
     * `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
     */
    id: string;
    /**
     * Collection of IP addresses assigned to a nic
     */
    ips: string[];
    ipv6CidrBlock: string;
    ipv6Ips: string[];
    /**
     * The LAN ID the NIC will sit on
     */
    lan: number;
    /**
     * The MAC address of the NIC
     */
    mac: string;
    /**
     * Name of an existing server that you want to search for.
     */
    name: string;
    /**
     * The PCI slot number of the Nic
     */
    pciSlot: number;
}

export interface GetVcpuServerNicFirewallRule {
    /**
     * Defines the allowed code (from 0 to 254) if protocol ICMP is chosen
     */
    icmpCode: number;
    /**
     * Defines the allowed type (from 0 to 254) if the protocol ICMP is chosen
     */
    icmpType: number;
    /**
     * ID of the server you want to search for.
     *
     * `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
     */
    id: string;
    /**
     * Name of an existing server that you want to search for.
     */
    name: string;
    /**
     * Defines the end range of the allowed port (from 1 to 65534) if the protocol TCP or UDP is chosen
     */
    portRangeEnd: number;
    /**
     * Defines the start range of the allowed port (from 1 to 65534) if protocol TCP or UDP is chosen
     */
    portRangeStart: number;
    /**
     * he protocol for the rule
     */
    protocol: string;
    /**
     * Only traffic originating from the respective IPv4 address is allowed. Value null allows all source IPs
     */
    sourceIp: string;
    /**
     * Only traffic originating from the respective MAC address is allowed
     */
    sourceMac: string;
    /**
     * In case the target NIC has multiple IP addresses, only traffic directed to the respective IP address of the NIC is allowed
     */
    targetIp: string;
    /**
     * The type of firewall rule
     */
    type: string;
}

export interface GetVcpuServerVolume {
    /**
     * The availability zone in which the volume should exist
     */
    availabilityZone: string;
    /**
     * The uuid of the Backup Unit that user has access to
     */
    backupUnitId: string;
    /**
     * The UUID of the attached server.
     */
    bootServer: string;
    /**
     * The bus type of the volume
     */
    bus: string;
    /**
     * Is capable of CPU hot plug (no reboot required)
     */
    cpuHotPlug: boolean;
    /**
     * The Logical Unit Number (LUN) of the storage volume
     */
    deviceNumber: number;
    /**
     * Is capable of Virt-IO drive hot plug (no reboot required)
     */
    discVirtioHotPlug: boolean;
    /**
     * Is capable of Virt-IO drive hot unplug (no reboot required)
     */
    discVirtioHotUnplug: boolean;
    /**
     * ID of the server you want to search for.
     *
     * `datacenterId` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.
     */
    id: string;
    imageName: string;
    /**
     * Initial password to be set for installed OS
     */
    imagePassword: string;
    /**
     * OS type of this volume
     */
    licenceType: string;
    /**
     * Name of an existing server that you want to search for.
     */
    name: string;
    /**
     * Is capable of nic hot plug (no reboot required)
     */
    nicHotPlug: boolean;
    /**
     * Is capable of nic hot unplug (no reboot required)
     */
    nicHotUnplug: boolean;
    /**
     * The PCI slot number of the Nic
     */
    pciSlot: number;
    /**
     * Is capable of memory hot plug (no reboot required)
     */
    ramHotPlug: boolean;
    /**
     * The size of the volume in GB
     */
    size: number;
    /**
     * Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key
     */
    sshKeys: string[];
    /**
     * The type of firewall rule
     */
    type: string;
    /**
     * The cloud-init configuration for the volume as base64 encoded string
     */
    userData?: string;
}

export interface GetVpnIpsecGatewayConnection {
    /**
     * The datacenter to connect your VPN Gateway to.
     */
    datacenterId: string;
    /**
     * Describes the private ipv4 subnet in your LAN that should be accessible by the
     * VPN Gateway.
     */
    ipv4Cidr: string;
    /**
     * Describes the ipv6 subnet in your LAN that should be accessible by the VPN Gateway.
     */
    ipv6Cidr: string;
    /**
     * The numeric LAN ID to connect your VPN Gateway to.
     */
    lanId: string;
}

export interface GetVpnIpsecTunnelAuth {
    /**
     * The Authentication Method to use for IPSec Authentication.
     */
    method: string;
}

export interface GetVpnIpsecTunnelEsp {
    /**
     * The Diffie-Hellman Group to use for IPSec Encryption.
     */
    diffieHellmanGroup: string;
    /**
     * The encryption algorithm to use for IPSec Encryption.
     */
    encryptionAlgorithm: string;
    /**
     * The integrity algorithm to use for IPSec Encryption.
     */
    integrityAlgorithm: string;
    /**
     * The phase lifetime in seconds.
     */
    lifetime: number;
}

export interface GetVpnIpsecTunnelIke {
    /**
     * The Diffie-Hellman Group to use for IPSec Encryption.
     */
    diffieHellmanGroup: string;
    /**
     * The encryption algorithm to use for IPSec Encryption.
     */
    encryptionAlgorithm: string;
    /**
     * The integrity algorithm to use for IPSec Encryption.
     */
    integrityAlgorithm: string;
    /**
     * The phase lifetime in seconds.
     */
    lifetime: number;
}

export interface GetVpnWireguardGatewayConnection {
    /**
     * The ID of the datacenter where the WireGuard Gateway is located.
     */
    datacenterId: string;
    /**
     * The IPv4 CIDR for the WireGuard Gateway connection.
     */
    ipv4Cidr: string;
    /**
     * The IPv6 CIDR for the WireGuard Gateway connection.
     */
    ipv6Cidr: string;
    /**
     * The ID of the LAN where the WireGuard Gateway is connected.
     */
    lanId: string;
}

export interface GetVpnWireguardPeerEndpoint {
    /**
     * Hostname or IPV4 address that the WireGuard Server will connect to.
     */
    host: string;
    /**
     * Port that the WireGuard Server will connect to. Default: 51820
     */
    port: number;
}

export interface KafkaClusterConnections {
    /**
     * [list] IP address and port of cluster brokers.
     */
    brokerAddresses: string[];
    /**
     * [string] The datacenter to connect your instance to.
     */
    datacenterId: string;
    /**
     * [string] The numeric LAN ID to connect your instance to.
     */
    lanId: string;
}

export interface LoggingPipelineLog {
    /**
     * [list] The configuration of the logs datastore, a list that contains elements with the following structure:
     */
    destinations: outputs.LoggingPipelineLogDestination[];
    /**
     * [string] "Protocol to use as intake. Possible values are: http, tcp."
     */
    protocol: string;
    /**
     * [bool]
     */
    public: boolean;
    /**
     * [string] The source parser to be used.
     */
    source: string;
    /**
     * [string] The tag is used to distinguish different pipelines. Must be unique amongst the pipeline's array items.
     */
    tag: string;
}

export interface LoggingPipelineLogDestination {
    /**
     * [int] Defines the number of days a log record should be kept in loki. Works with loki destination type only. Can be one of: 7, 14, 30.
     */
    retentionInDays: number;
    /**
     * [string] The internal output stream to send logs to.
     */
    type: string;
}

export interface NetworkloadbalancerFlowlog {
    /**
     * [string] Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL. Immutable, forces re-creation.
     */
    action: string;
    /**
     * [string] Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist. Immutable, forces re-creation.
     */
    bucket: string;
    /**
     * [string] Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, forces re-creation.
     */
    direction: string;
    /**
     * The resource's unique identifier.
     */
    id: string;
    /**
     * [string] Specifies the name of the flow log.
     *
     * ⚠️ **Note:**: Removing the `flowlog` forces re-creation of the network load balancer resource.
     */
    name: string;
}

export interface NetworkloadbalancerForwardingruleHealthCheck {
    /**
     * [int] ClientTimeout is expressed in milliseconds. This inactivity timeout applies when the client is expected to acknowledge or send data. If unset the default of 50 seconds will be used.
     */
    clientTimeout: number;
    /**
     * [int] It specifies the maximum time (in milliseconds) to wait for a connection attempt to a target VM to succeed. If unset, the default of 5 seconds will be used.
     */
    connectTimeout: number;
    /**
     * [int] Retries specifies the number of retries to perform on a target VM after a connection failure. If unset, the default value of 3 will be used.
     */
    retries: number;
    /**
     * [int] TargetTimeout specifies the maximum inactivity time (in milliseconds) on the target VM side. If unset, the default of 50 seconds will be used.
     */
    targetTimeout: number;
}

export interface NetworkloadbalancerForwardingruleTarget {
    /**
     * Health check attributes for Network Load Balancer forwarding rule target.
     */
    healthCheck: outputs.NetworkloadbalancerForwardingruleTargetHealthCheck;
    /**
     * [string] IP of a balanced target VM.
     */
    ip: string;
    /**
     * [int] Port of the balanced target service. (range: 1 to 65535).
     */
    port: number;
    /**
     * [string] The proxy protocol version. Accepted values are `none`, `v1`, `v2`, `v2ssl`. If unspecified, the default value of `none` is used.
     */
    proxyProtocol?: string;
    /**
     * [int] Weight parameter is used to adjust the target VM's weight relative to other target VMs.
     */
    weight: number;
}

export interface NetworkloadbalancerForwardingruleTargetHealthCheck {
    /**
     * [boolean] Check specifies whether the target VM's health is checked.
     */
    check: boolean;
    /**
     * [int] CheckInterval determines the duration (in milliseconds) between consecutive health checks. If unspecified a default of 2000 ms is used.
     */
    checkInterval: number;
    /**
     * [boolean] Maintenance specifies if a target VM should be marked as down, even if it is not.
     */
    maintenance: boolean;
}

export interface TargetGroupHealthCheck {
    /**
     * [int] The interval in milliseconds between consecutive health checks; default is 2000.
     */
    checkInterval: number;
    /**
     * [int] The maximum time in milliseconds to wait for a target to respond to a check. For target VMs with 'Check Interval' set, the lesser of the two  values is used once the TCP connection is established.
     */
    checkTimeout: number;
    /**
     * [int] The maximum number of attempts to reconnect to a target after a connection failure. Valid range is 0 to 65535, and default is three reconnection.
     */
    retries: number;
}

export interface TargetGroupHttpHealthCheck {
    /**
     * [string]
     */
    matchType: string;
    /**
     * [string] The method for the HTTP health check.
     */
    method: string;
    /**
     * [bool]
     */
    negate?: boolean;
    /**
     * [string] The path (destination URL) for the HTTP health check request; the default is /.
     */
    path: string;
    /**
     * [bool]
     */
    regex?: boolean;
    /**
     * [string] The response returned by the request, depending on the match type.
     */
    response: string;
}

export interface TargetGroupTarget {
    /**
     * [bool] Makes the target available only if it accepts periodic health check TCP connection attempts; when turned off, the target is considered always available. The health check only consists of a connection attempt to the address and port of the target. Default is True.
     */
    healthCheckEnabled: boolean;
    /**
     * [string] The IP of the balanced target VM.
     */
    ip: string;
    /**
     * [bool] Maintenance mode prevents the target from receiving balanced traffic.
     */
    maintenanceEnabled?: boolean;
    /**
     * [int] The port of the balanced target service; valid range is 1 to 65535.
     */
    port: number;
    /**
     * [string] The proxy protocol version. Accepted values are `none`, `v1`, `v2`, `v2ssl`. If unspecified, the default value of `none` is used.
     */
    proxyProtocol?: string;
    /**
     * [int] Traffic is distributed in proportion to target weight, relative to the combined weight of all targets. A target with higher weight receives a greater share of traffic. Valid range is 0 to 256 and default is 1; targets with weight of 0 do not participate in load balancing but still accept persistent connections. It is best use values in the middle of the range to leave room for later adjustments.
     */
    weight: number;
}

export namespace cdn {
    export interface DistributionRoutingRule {
        /**
         * [string] The prefix of the routing rule.
         */
        prefix: string;
        /**
         * [string] The scheme of the routing rule.
         */
        scheme: string;
        /**
         * [map] - A map of properties for the rule
         */
        upstream: outputs.cdn.DistributionRoutingRuleUpstream;
    }

    export interface DistributionRoutingRuleUpstream {
        /**
         * [bool] Enable or disable caching. If enabled, the CDN will cache the responses from the upstream host. Subsequent requests for the same resource will be served from the cache.
         */
        caching: boolean;
        /**
         * [map] - A map of geo_restrictions
         */
        geoRestrictions?: outputs.cdn.DistributionRoutingRuleUpstreamGeoRestrictions;
        /**
         * [string] The upstream host that handles the requests if not already cached. This host will be protected by the WAF if the option is enabled.
         */
        host: string;
        /**
         * [string] Rate limit class that will be applied to limit the number of incoming requests per IP.
         */
        rateLimitClass: string;
        /**
         * [string] The SNI (Server Name Indication) mode of the upstream. It supports two modes: 1) `distribution`: for outgoing connections to the upstream host, the CDN requires the upstream host to present a valid certificate that matches the configured domain of the CDN distribution; 2) `origin`: for outgoing connections to the upstream host, the CDN requires the upstream host to present a valid certificate that matches the configured upstream/origin hostname.
         */
        sniMode: string;
        /**
         * [bool] Enable or disable WAF to protect the upstream host.
         */
        waf: boolean;
    }

    export interface DistributionRoutingRuleUpstreamGeoRestrictions {
        /**
         * [string] List of allowed countries
         */
        allowLists?: string[];
        /**
         * [string] List of blocked countries
         */
        blockLists?: string[];
    }

}

export namespace compute {
    export interface CrossconnectConnectableDatacenter {
        /**
         * The UUID of the connectable datacenter
         */
        id: string;
        /**
         * The location of the cross-connected datacenter
         */
        location: string;
        /**
         * The name of the connectable datacenter
         */
        name: string;
    }

    export interface CrossconnectPeer {
        /**
         * The id of the cross-connected datacenter
         */
        datacenterId: string;
        /**
         * The name of the cross-connected datacenter
         */
        datacenterName: string;
        /**
         * The id of the cross-connected LAN
         */
        lanId: string;
        /**
         * The name of the cross-connected LAN
         */
        lanName: string;
        /**
         * The location of the cross-connected datacenter
         */
        location: string;
    }

    export interface CubeServerNic {
        deviceNumber: number;
        dhcp?: boolean;
        /**
         * Indicates whether this NIC receives an IPv6 address through DHCP.
         */
        dhcpv6?: boolean;
        firewall?: outputs.compute.CubeServerNicFirewall;
        firewallActive?: boolean;
        firewallType: string;
        ips: string[];
        /**
         * IPv6 CIDR block assigned to the NIC.
         */
        ipv6CidrBlock: string;
        /**
         * Collection for IPv6 addresses assigned to a nic. Explicitly assigned IPv6 addresses need to come from inside the IPv6 CIDR block assigned to the nic.
         */
        ipv6Ips: string[];
        lan: number;
        mac: string;
        /**
         * [string] The name of the server.
         */
        name?: string;
        pciSlot: number;
    }

    export interface CubeServerNicFirewall {
        icmpCode?: string;
        icmpType?: string;
        /**
         * [string] The name of the server.
         */
        name?: string;
        portRangeEnd?: number;
        portRangeStart?: number;
        protocol: string;
        sourceIp?: string;
        sourceMac?: string;
        targetIp?: string;
        type: string;
    }

    export interface CubeServerVolume {
        /**
         * [string] The availability zone in which the server should exist. This property is immutable.
         */
        availabilityZone: string;
        /**
         * The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
         */
        backupUnitId: string;
        /**
         * The UUID of the attached server.
         */
        bootServer: string;
        bus: string;
        cpuHotPlug: boolean;
        deviceNumber: number;
        discVirtioHotPlug: boolean;
        discVirtioHotUnplug: boolean;
        diskType: string;
        /**
         * [string] Required if `sshKeyPath` is not provided.
         *
         * > **⚠ WARNING**
         * >
         * > Image_name under volume level is deprecated, please use imageName under server level
         *
         *
         * > **⚠ WARNING**
         * >
         * > For creating a **CUBE** server, you can not set `volume.size` argument.
         * >
         *
         * @deprecated Please use imagePassword under server level
         */
        imagePassword?: string;
        /**
         * [string] Sets the OS type of the server.
         */
        licenceType: string;
        /**
         * [string] The name of the server.
         */
        name?: string;
        nicHotPlug: boolean;
        nicHotUnplug: boolean;
        pciSlot: number;
        ramHotPlug: boolean;
        /**
         * [list] List of paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images. Required for IonosCloud Linux images. Required if `imagePassword` is not provided.
         *
         * @deprecated Please use sshKeyPath under server level
         */
        sshKeyPaths: string[];
        /**
         * The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
         */
        userData: string;
    }

    export interface DatacenterCpuArchitecture {
        /**
         * A valid CPU family name
         */
        cpuFamily: string;
        /**
         * The maximum number of cores available
         */
        maxCores: number;
        /**
         * The maximum number of RAM in MB
         */
        maxRam: number;
        /**
         * A valid CPU vendor name
         */
        vendor: string;
    }

    export interface GroupUser {
        administrator: boolean;
        email: string;
        firstName: string;
        forceSecAuth: boolean;
        id: string;
        lastName: string;
        password: string;
    }

    export interface IPBlockIpConsumer {
        datacenterId: string;
        datacenterName: string;
        ip: string;
        k8sClusterUuid: string;
        k8sNodepoolUuid: string;
        mac: string;
        nicId: string;
        serverId: string;
        serverName: string;
    }

    export interface LanIpFailover {
        ip: string;
        nicUuid: string;
    }

    export interface NatGatewayLan {
        /**
         * [list] Collection of gateway IP addresses of the NAT gateway. Will be auto-generated if not provided. Should ideally be an IP belonging to the same subnet as the LAN.
         */
        gatewayIps: string[];
        /**
         * [int] Id for the LAN connected to the NAT gateway.
         */
        id: number;
    }

    export interface NatGatewayRuleTargetPortRange {
        /**
         * [int] Target port range end associated with the NAT gateway rule.
         */
        end: number;
        /**
         * [int] Target port range start associated with the NAT gateway rule.
         */
        start: number;
    }

    export interface NicFlowlog {
        /**
         * Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL. Immutable, update forces re-creation.
         */
        action: string;
        /**
         * Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist. Immutable, update forces re-creation.
         */
        bucket: string;
        /**
         * Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, update forces re-creation.
         */
        direction: string;
        /**
         * The ID of the NIC.
         */
        id: string;
        /**
         * Specifies the name of the flow log.
         *
         * ⚠️ **Note:**: Removing the `flowlog` forces re-creation of the NIC resource.
         */
        name: string;
    }

    export interface ServerLabel {
        /**
         * [string] The key of the label.
         */
        key: string;
        /**
         * [string] The value of the label.
         */
        value: string;
    }

    export interface ServerNic {
        deviceNumber: number;
        dhcp?: boolean;
        /**
         * Indicates whether this NIC receives an IPv6 address through DHCP.
         */
        dhcpv6?: boolean;
        firewallActive?: boolean;
        firewallType: string;
        /**
         * Allows to define firewall rules inline in the server. See the Firewall section.
         */
        firewalls?: outputs.compute.ServerNicFirewall[];
        id: string;
        /**
         * Collection of IP addresses assigned to a nic. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.
         */
        ips: string[];
        /**
         * IPv6 CIDR block assigned to the NIC.
         */
        ipv6CidrBlock: string;
        /**
         * Collection for IPv6 addresses assigned to a nic. Explicitly assigned IPv6 addresses need to come from inside the IPv6 CIDR block assigned to the nic.
         */
        ipv6Ips: string[];
        lan: number;
        mac: string;
        /**
         * [string] The name of the server.
         */
        name?: string;
        pciSlot: number;
    }

    export interface ServerNicFirewall {
        icmpCode?: string;
        icmpType?: string;
        id: string;
        /**
         * [string] The name of the server.
         */
        name?: string;
        portRangeEnd?: number;
        portRangeStart?: number;
        protocol: string;
        sourceIp?: string;
        sourceMac?: string;
        targetIp?: string;
        /**
         * (Computed)[string] Server usages: [ENTERPRISE](https://docs.ionos.com/cloud/compute-engine/virtual-servers/virtual-servers) or [CUBE](https://docs.ionos.com/cloud/compute-engine/virtual-servers/cloud-cubes). This property is immutable.
         */
        type: string;
    }

    export interface ServerVolume {
        /**
         * [string] The availability zone in which the server should exist. E.g: `AUTO`, `ZONE_1`, `ZONE_2`. This property is immutable.
         */
        availabilityZone: string;
        /**
         * The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
         */
        backupUnitId: string;
        /**
         * The UUID of the attached server.
         */
        bootServer: string;
        bus: string;
        cpuHotPlug: boolean;
        deviceNumber: number;
        discVirtioHotPlug: boolean;
        discVirtioHotUnplug: boolean;
        diskType: string;
        /**
         * [string] Required if `sshKeyPath` is not provided.
         *
         * @deprecated Please use imagePassword under server level
         */
        imagePassword?: string;
        /**
         * [string] Sets the OS type of the server.
         */
        licenceType: string;
        /**
         * [string] The name of the server.
         */
        name?: string;
        nicHotPlug: boolean;
        nicHotUnplug: boolean;
        pciSlot: number;
        ramHotPlug: boolean;
        /**
         * The size of the volume in GB.
         */
        size: number;
        /**
         * [list] List of absolute paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images.  Also accepts ssh keys directly. Required for IonosCloud Linux images. Required if `imagePassword` is not provided. Does not support `~` expansion to homedir in the given path. This property is immutable.
         *
         * @deprecated Please use sshKeyPath under server level
         */
        sshKeyPaths?: string[];
        /**
         * [list] Immutable List of absolute or relative paths to files containing public SSH key that will be injected into IonosCloud provided Linux images. Also accepts ssh keys directly. Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key. This field may only be set in creation requests. When reading, it always returns null. SSH keys are only supported if a public Linux image is used for the volume creation. Does not support `~` expansion to homedir in the given path.
         *
         * @deprecated Please use sshKeys under server level
         */
        sshKeys: string[];
        /**
         * The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
         */
        userData: string;
    }

    export interface VCPUServerLabel {
        key: string;
        value: string;
    }

    export interface VCPUServerNic {
        deviceNumber: number;
        dhcp?: boolean;
        dhcpv6?: boolean;
        firewallActive?: boolean;
        firewallType: string;
        /**
         * Allows to define firewall rules inline in the server. See the Firewall section.
         */
        firewalls?: outputs.compute.VCPUServerNicFirewall[];
        id: string;
        /**
         * Collection of IP addresses assigned to a nic. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.
         */
        ips: string[];
        ipv6CidrBlock: string;
        ipv6Ips: string[];
        lan: number;
        mac: string;
        /**
         * [string] The name of the server.
         */
        name?: string;
        pciSlot: number;
    }

    export interface VCPUServerNicFirewall {
        icmpCode?: string;
        icmpType?: string;
        id: string;
        /**
         * [string] The name of the server.
         */
        name?: string;
        portRangeEnd?: number;
        portRangeStart?: number;
        protocol: string;
        sourceIp?: string;
        sourceMac?: string;
        targetIp?: string;
        type: string;
    }

    export interface VCPUServerVolume {
        /**
         * [string] The availability zone in which the server should exist. E.g: `AUTO`, `ZONE_1`, `ZONE_2`. This property is immutable.
         */
        availabilityZone: string;
        /**
         * The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
         */
        backupUnitId: string;
        /**
         * The UUID of the attached server.
         */
        bootServer: string;
        bus: string;
        cpuHotPlug: boolean;
        deviceNumber: number;
        discVirtioHotPlug: boolean;
        discVirtioHotUnplug: boolean;
        diskType: string;
        /**
         * [string] Sets the OS type of the server.
         */
        licenceType: string;
        /**
         * [string] The name of the server.
         */
        name?: string;
        nicHotPlug: boolean;
        nicHotUnplug: boolean;
        pciSlot: number;
        ramHotPlug: boolean;
        /**
         * The size of the volume in GB.
         */
        size: number;
        /**
         * The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
         */
        userData: string;
    }

}

export namespace creg {
    export interface RegistryFeatures {
        /**
         * [bool] Enables or disables the Vulnerability Scanning feature for the Container Registry. To disable this feature, set the attribute to false when creating the CR resource.
         *
         * > **⚠ WARNING** `Container Registry Vulnerability Scanning` is a paid feature which is enabled by default, and cannot be turned off after activation. To disable this feature for a Container Registry, ensure `vulnerabilityScanning` is set to false on resource creation.
         */
        vulnerabilityScanning: boolean;
    }

    export interface RegistryGarbageCollectionSchedule {
        /**
         * [list] Elements of list must have one of the values: `Saturday`, `Sunday`, `Monday`, `Tuesday`,  `Wednesday`,  `Thursday`,  `Friday`
         */
        days: string[];
        /**
         * [string]
         */
        time: string;
    }

    export interface RegistryStorageUsage {
        bytes: number;
        updatedAt: string;
    }

    export interface RegistryTokenCredential {
        password: string;
        username: string;
    }

    export interface RegistryTokenScope {
        /**
         * [string] Example: ["pull", "push", "delete"]
         */
        actions: string[];
        /**
         * [string]
         */
        name: string;
        /**
         * [string]
         */
        type: string;
    }

}

export namespace dbaas {
    export interface InMemoryDBReplicaSetConnections {
        /**
         * The IP and subnet for your instance. Note the following unavailable IP ranges: 10.233.64.0/18, 10.233.0.0/18, 10.233.114.0/24
         */
        cidr: string;
        /**
         * The datacenter to connect your instance to.
         */
        datacenterId: string;
        /**
         * The numeric LAN ID to connect your instance to.
         */
        lanId: string;
    }

    export interface InMemoryDBReplicaSetCredentials {
        /**
         * The hashed password for a InMemoryDB user.
         */
        hashedPassword?: outputs.dbaas.InMemoryDBReplicaSetCredentialsHashedPassword;
        /**
         * The password for a InMemoryDB user.
         */
        plainTextPassword?: string;
        /**
         * The username for the initial InMemoryDB user. Some system usernames are restricted (e.g. 'admin', 'standby').
         */
        username: string;
    }

    export interface InMemoryDBReplicaSetCredentialsHashedPassword {
        algorithm: string;
        hash: string;
    }

    export interface InMemoryDBReplicaSetMaintenanceWindow {
        /**
         * The name of the week day.
         */
        dayOfTheWeek: string;
        /**
         * Start of the maintenance window in UTC time.
         */
        time: string;
    }

    export interface InMemoryDBReplicaSetResources {
        /**
         * The number of CPU cores per instance.
         */
        cores: number;
        /**
         * The amount of memory per instance in gigabytes (GB).
         */
        ram: number;
        /**
         * The size of the storage in GB. The size is derived from the amount of RAM and the persistence mode and is not configurable.
         */
        storage: number;
    }

    export interface MariaDBClusterConnections {
        /**
         * The IP and subnet for your cluster.
         */
        cidr: string;
        /**
         * The datacenter to connect your cluster to.
         */
        datacenterId: string;
        /**
         * The numeric LAN ID to connect your cluster to.
         */
        lanId: string;
    }

    export interface MariaDBClusterCredentials {
        /**
         * The password for a MariaDB user.
         */
        password: string;
        /**
         * The username for the initial MariaDB user. Some system usernames are restricted (e.g 'mariadb', 'admin', 'standby').
         */
        username: string;
    }

    export interface MariaDBClusterMaintenanceWindow {
        /**
         * The name of the week day.
         */
        dayOfTheWeek: string;
        /**
         * Start of the maintenance window in UTC time.
         */
        time: string;
    }

    export interface MongoClusterBackup {
        /**
         * The location where the cluster backups will be stored. If not set, the backup is stored in the nearest location of the cluster. Examples: de, eu-sounth-2, eu-central-2
         */
        location?: string;
        /**
         * Number of hours in the past for which a point-in-time snapshot can be created.
         */
        pointInTimeWindowHours?: number;
        /**
         * Number of hours between snapshots.
         */
        snapshotIntervalHours?: number;
    }

    export interface MongoClusterBiConnector {
        /**
         * Enable or disable the BiConnector.
         */
        enabled?: boolean;
        /**
         * The host where this new BI Connector is installed.
         */
        host: string;
        /**
         * Port number used when connecting to this new BI Connector.
         */
        port: string;
    }

    export interface MongoClusterConnections {
        /**
         * The list of IPs and subnet for your cluster. Note the following unavailable IP ranges:10.233.64.0/18, 10.233.0.0/18, 10.233.114.0/24. example: [192.168.1.100/24, 192.168.1.101/24]
         */
        cidrLists: string[];
        /**
         * The datacenter to connect your cluster to.
         */
        datacenterId: string;
        /**
         * The LAN to connect your cluster to.
         */
        lanId: string;
    }

    export interface MongoClusterMaintenanceWindow {
        dayOfTheWeek: string;
        time: string;
    }

    export interface MongoUserRole {
        database?: string;
        /**
         * A list of mongodb user roles. Examples: read, readWrite, readAnyDatabase
         */
        role?: string;
    }

    export interface PSQLClusterConnectionPooler {
        enabled: boolean;
        /**
         * Represents different modes of connection pooling for the connection pooler
         */
        poolMode: string;
    }

    export interface PSQLClusterConnections {
        /**
         * The IP and subnet for the database.
         *           Note the following unavailable IP ranges:
         *           10.233.64.0/18
         *           10.233.0.0/18
         *           10.233.114.0/24
         */
        cidr: string;
        /**
         * The datacenter to connect your cluster to.
         */
        datacenterId: string;
        /**
         * The LAN to connect your cluster to.
         */
        lanId: string;
    }

    export interface PSQLClusterCredentials {
        password: string;
        /**
         * the username for the initial postgres user. some system usernames are restricted (e.g. "postgres", "admin", "standby")
         */
        username: string;
    }

    export interface PSQLClusterFromBackup {
        /**
         * The unique ID of the backup you want to restore.
         */
        backupId: string;
        /**
         * If this value is supplied as ISO 8601 timestamp, the backup will be replayed up until the given timestamp. If empty, the backup will be applied completely.
         */
        recoveryTargetTime?: string;
    }

    export interface PSQLClusterMaintenanceWindow {
        dayOfTheWeek: string;
        time: string;
    }

}

export namespace dsaas {
    export interface ClusterLan {
        /**
         * [bool] Indicates if the Kubernetes node pool LAN will reserve an IP using DHCP. The default value is 'true'.
         */
        dhcp?: boolean;
        /**
         * [string] The LAN ID of an existing LAN at the related data center.
         */
        lanId: string;
        /**
         * [list] An array of additional LANs attached to worker nodes.
         */
        routes?: outputs.dsaas.ClusterLanRoute[];
    }

    export interface ClusterLanRoute {
        /**
         * [string] IPv4 or IPv6 gateway IP for the route.
         */
        gateway: string;
        /**
         * [string] IPv4 or IPv6 CIDR to be routed via the interface.
         */
        network: string;
    }

    export interface ClusterMaintenanceWindow {
        /**
         * [string] Must be set with one the values `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday` or `Sunday`.
         */
        dayOfTheWeek: string;
        /**
         * [string] Time at which the maintenance should start. Must conform to the 'HH:MM:SS' 24-hour format. This pattern matches the "HH:MM:SS 24-hour format with leading 0" format. For more information take a look at [this link](https://stackoverflow.com/questions/7536755/regular-expression-for-matching-hhmm-time-format).
         */
        time: string;
    }

    export interface NodePoolMaintenanceWindow {
        /**
         * [string] Must be set with one the values `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday` or `Sunday`.
         */
        dayOfTheWeek: string;
        /**
         * [string] Time at which the maintenance should start. Must conform to the 'HH:MM:SS' 24-hour format. This pattern matches the "HH:MM:SS 24-hour format with leading 0" format. For more information take a look at [this link](https://stackoverflow.com/questions/7536755/regular-expression-for-matching-hhmm-time-format).
         */
        time: string;
    }

}

export namespace k8s {
    export interface ClusterMaintenanceWindow {
        /**
         * [string] Day of the week when maintenance is allowed
         */
        dayOfTheWeek: string;
        /**
         * [string] A clock time in the day when maintenance is allowed
         */
        time: string;
    }

    export interface ClusterS3Bucket {
        /**
         * [string] The name of the Kubernetes Cluster.
         */
        name?: string;
    }

    export interface NodePoolAutoScaling {
        /**
         * [int] The maximum number of worker nodes that the node pool can scale to. Should be greater than min_node_count
         */
        maxNodeCount: number;
        /**
         * [int] The minimum number of worker nodes the node pool can scale down to. Should be less than max_node_count
         */
        minNodeCount: number;
    }

    export interface NodePoolLan {
        /**
         * [boolean] Indicates if the Kubernetes Node Pool LAN will reserve an IP using DHCP. Default value is `true`
         */
        dhcp?: boolean;
        /**
         * [int] The LAN ID of an existing LAN at the related datacenter
         */
        id: number;
        /**
         * An array of additional LANs attached to worker nodes
         */
        routes?: outputs.k8s.NodePoolLanRoute[];
    }

    export interface NodePoolLanRoute {
        /**
         * [string] IPv4 or IPv6 Gateway IP for the route
         */
        gatewayIp: string;
        /**
         * [string] IPv4 or IPv6 CIDR to be routed via the interface
         */
        network: string;
    }

    export interface NodePoolMaintenanceWindow {
        /**
         * [string] Day of the week when maintenance is allowed
         */
        dayOfTheWeek: string;
        /**
         * [string] A clock time in the day when maintenance is allowed
         */
        time: string;
    }

}

export namespace nfs {
    export interface ClusterConnections {
        /**
         * The ID of the datacenter where the Network File Storage cluster is located.
         */
        datacenterId: string;
        /**
         * The IP address and prefix of the Network File Storage cluster. The IP address can be either IPv4 or IPv6. The IP address has to be given with CIDR notation.
         */
        ipAddress: string;
        /**
         * The Private LAN to which the Network File Storage cluster must be connected.
         */
        lan: string;
    }

    export interface ClusterNfs {
        /**
         * The minimum supported version of the NFS cluster. Supported values: `4.2`. Default is `4.2`.
         */
        minVersion?: string;
    }

    export interface ShareClientGroup {
        /**
         * Optional description for the clients groups.
         */
        description?: string;
        /**
         * A singular host allowed to connect to the share. The host can be specified as IP address and can be either IPv4 or IPv6.
         */
        hosts: string[];
        /**
         * The allowed host or network to which the export is being shared. The IP address can be either IPv4 or IPv6 and has to be given with CIDR notation.
         */
        ipNetworks: string[];
        /**
         * NFS specific configurations. Each configuration includes:
         */
        nfs?: outputs.nfs.ShareClientGroupNfs;
    }

    export interface ShareClientGroupNfs {
        /**
         * The squash mode for the export. The squash mode can be:
         */
        squash?: string;
    }

}

export namespace vpn {
    export interface IpsecGatewayConnection {
        /**
         * [string] The datacenter to connect your VPN Gateway to.
         */
        datacenterId: string;
        /**
         * [string] Describes the private ipv4 subnet in your LAN that should be accessible by the
         * VPN Gateway. Note: this should be the subnet already assigned to the LAN
         */
        ipv4Cidr: string;
        /**
         * [string] Describes the ipv6 subnet in your LAN that should be accessible by the VPN
         * Gateway. **Note**: this should be the subnet already assigned to the LAN
         */
        ipv6Cidr?: string;
        /**
         * [string] The numeric LAN ID to connect your VPN Gateway to.
         */
        lanId: string;
    }

    export interface IpsecTunnelAuth {
        /**
         * [string] The authentication method to use for IPSec Authentication. Possible values: `PSK`.
         * Default value: `PSK`.
         */
        method?: string;
        /**
         * [string] The pre-shared key to use for IPSec Authentication. **Note**: Required if method is
         * PSK.
         */
        pskKey?: string;
    }

    export interface IpsecTunnelEsp {
        /**
         * [string] The Diffie-Hellman Group to use for IPSec Encryption. Possible
         * values: `15-MODP3072`, `16-MODP4096`, `19-ECP256`, `20-ECP384`, `21-ECP521`, `28-ECP256BP`, `29-ECP384BP`, `30-ECP512BP`.
         * Default value: `16-MODP4096`.
         */
        diffieHellmanGroup?: string;
        /**
         * [string] The encryption algorithm to use for IPSec Encryption. Possible
         * values: `AES128`, `AES256`, `AES128-CTR`, `AES256-CTR`, `AES128-GCM-16`, `AES256-GCM-16`, `AES128-GCM-12`, `AES256-GCM-12`, `AES128-CCM-12`,
         * `AES256-CCM-12`. Default value: `AES256`.
         */
        encryptionAlgorithm?: string;
        /**
         * [string] The integrity algorithm to use for IPSec Encryption. Possible
         * values: `SHA256`, `SHA384`, `SHA512`, `AES-XCBC`. Default value: `SHA256`.
         */
        integrityAlgorithm?: string;
        /**
         * [string] The phase lifetime in seconds. Minimum value: `3600`. Maximum value: `86400`.
         * Default value: `86400`.
         */
        lifetime?: number;
    }

    export interface IpsecTunnelIke {
        /**
         * [string] The Diffie-Hellman Group to use for IPSec Encryption. Possible
         * values: `15-MODP3072`, `16-MODP4096`, `19-ECP256`, `20-ECP384`, `21-ECP521`, `28-ECP256BP`, `29-ECP384BP`, `30-ECP512BP`.
         * Default value: `16-MODP4096`.
         */
        diffieHellmanGroup?: string;
        /**
         * [string] The encryption algorithm to use for IPSec Encryption. Possible
         * values: `AES128`, `AES256`, `AES128-CTR`, `AES256-CTR`, `AES128-GCM-16`, `AES256-GCM-16`, `AES128-GCM-12`, `AES256-GCM-12`, `AES128-CCM-12`,
         * `AES256-CCM-12`. Default value: `AES256`.
         */
        encryptionAlgorithm?: string;
        /**
         * [string] The integrity algorithm to use for IPSec Encryption. Possible
         * values: `SHA256`, `SHA384`, `SHA512`, `AES-XCBC`. Default value: `SHA256`.
         */
        integrityAlgorithm?: string;
        /**
         * [string] The phase lifetime in seconds. Minimum value: `3600`. Maximum value: `86400`.
         * Default value: `86400`.
         */
        lifetime?: number;
    }

    export interface WireguardGatewayConnection {
        /**
         * [String] The ID of the datacenter where the WireGuard Gateway is located.
         */
        datacenterId: string;
        /**
         * [String] The IPv4 CIDR for the WireGuard Gateway connection.
         */
        ipv4Cidr?: string;
        /**
         * [String] The IPv6 CIDR for the WireGuard Gateway connection.
         */
        ipv6Cidr?: string;
        /**
         * [String] The ID of the LAN where the WireGuard Gateway is connected.
         */
        lanId: string;
    }

    export interface WireguardPeerEndpoint {
        /**
         * [string] The hostname or IPV4 address that the WireGuard Server will connect to.
         */
        host: string;
        /**
         * [int] The port that the WireGuard Server will connect to. Defaults to `51820`.
         */
        port?: number;
    }

}
