// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface GetNsgRule {
    icmpCode: string;
    icmpType: string;
    id: string;
    name: string;
    portRangeEnd: number;
    portRangeStart: number;
    protocol: string;
    sourceIp: string;
    sourceMac: string;
    targetIp: string;
    type: string;
}

export interface GetObjectStorageRegionCapability {
    /**
     * Indicates if IAM policy based access is supported
     */
    iam: boolean;
    /**
     * Indicates if S3 Select is supported
     */
    s3select: boolean;
}

export interface MonitoringPipelineTimeouts {
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    create?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
     */
    delete?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
     */
    read?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    update?: string;
}

export interface ObjectStorageAccesskeyTimeouts {
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    create?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
     */
    delete?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
     */
    read?: string;
}

export namespace alb {
    export interface BalancerFlowlog {
        /**
         * Specifies the traffic direction pattern. Valid values: ACCEPTED, REJECTED, ALL. Immutable, forces re-recreation of the nic resource.
         */
        action: string;
        /**
         * The bucket name of an existing IONOS Object Storage bucket. Immutable, forces re-recreation of the nic resource.
         */
        bucket: string;
        /**
         * Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, forces re-recreation of the nic resource.
         */
        direction: string;
        /**
         * The resource's unique identifier.
         */
        id: string;
        /**
         * The resource name.
         */
        name: string;
    }

    export interface ForwardingRuleHttpRule {
        /**
         * An array of items in the collection.The action is only performed if each and every condition is met; if no conditions are set, the rule will always be performed.
         */
        conditions: outputs.alb.ForwardingRuleHttpRuleCondition[];
        /**
         * Valid only for STATIC actions.
         */
        contentType: string;
        /**
         * Default is false; valid only for REDIRECT actions.
         */
        dropQuery?: boolean;
        /**
         * The location for redirecting; mandatory and valid only for REDIRECT actions.
         */
        location?: string;
        /**
         * The unique name of the Application Load Balancer HTTP rule.
         */
        name: string;
        /**
         * The response message of the request; mandatory for STATIC actions.
         */
        responseMessage?: string;
        /**
         * Valid only for REDIRECT and STATIC actions. For REDIRECT actions, default is 301 and possible values are 301, 302, 303, 307, and 308. For STATIC actions, default is 503 and valid range is 200 to 599.
         */
        statusCode: number;
        /**
         * The ID of the target group; mandatory and only valid for FORWARD actions.
         */
        targetGroup?: string;
        /**
         * Type of the HTTP rule.
         */
        type: string;
    }

    export interface ForwardingRuleHttpRuleCondition {
        /**
         * Matching rule for the HTTP rule condition attribute; mandatory for HEADER, PATH, QUERY, METHOD, HOST, and COOKIE types; must be null when type is SOURCE_IP.
         */
        condition?: string;
        /**
         * Must be null when type is PATH, METHOD, HOST, or SOURCE_IP. Key can only be set when type is COOKIES, HEADER, or QUERY.
         */
        key?: string;
        /**
         * Specifies whether the condition is negated or not; the default is False.
         */
        negate?: boolean;
        /**
         * Type of the HTTP rule condition.
         */
        type: string;
        /**
         * Mandatory for conditions CONTAINS, EQUALS, MATCHES, STARTS_WITH, ENDS_WITH; must be null when condition is EXISTS; should be a valid CIDR if provided and if type is SOURCE_IP.
         */
        value?: string;
    }

    export interface GetBalancerFlowlog {
        /**
         * Specifies the traffic direction pattern. Valid values: ACCEPTED, REJECTED, ALL.
         */
        action: string;
        /**
         * The bucket name of an existing IONOS Object Storage bucket.
         */
        bucket: string;
        /**
         * Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL.
         */
        direction: string;
        /**
         * The resource's unique identifier.
         */
        id: string;
        /**
         * The resource name.
         */
        name: string;
    }

    export interface GetForwardingRuleHttpRule {
        /**
         * An array of items in the collection.The action is only performed if each and every condition is met; if no conditions are set, the rule will always be performed.
         */
        conditions: outputs.alb.GetForwardingRuleHttpRuleCondition[];
        /**
         * Valid only for STATIC actions.
         */
        contentType: string;
        /**
         * Default is false; valid only for REDIRECT actions.
         */
        dropQuery: boolean;
        /**
         * The location for redirecting; mandatory and valid only for REDIRECT actions.
         */
        location: string;
        /**
         * The unique name of the Application Load Balancer HTTP rule.
         */
        name: string;
        /**
         * The response message of the request; mandatory for STATIC actions.
         */
        responseMessage: string;
        /**
         * Valid only for REDIRECT and STATIC actions. For REDIRECT actions, default is 301 and possible values are 301, 302, 303, 307, and 308. For STATIC actions, default is 503 and valid range is 200 to 599.
         */
        statusCode: number;
        /**
         * The ID of the target group; mandatory and only valid for FORWARD actions.
         */
        targetGroup: string;
        /**
         * Type of the HTTP rule.
         */
        type: string;
    }

    export interface GetForwardingRuleHttpRuleCondition {
        /**
         * Matching rule for the HTTP rule condition attribute; mandatory for HEADER, PATH, QUERY, METHOD, HOST, and COOKIE types; must be null when type is SOURCE_IP.
         */
        condition: string;
        /**
         * Must be null when type is PATH, METHOD, HOST, or SOURCE_IP. Key can only be set when type is COOKIES, HEADER, or QUERY.
         */
        key: string;
        /**
         * Specifies whether the condition is negated or not; the default is False.
         */
        negate: boolean;
        /**
         * Type of the HTTP rule condition.
         */
        type: string;
        /**
         * Mandatory for conditions CONTAINS, EQUALS, MATCHES, STARTS_WITH, ENDS_WITH; must be null when condition is EXISTS; should be a valid CIDR if provided and if type is SOURCE_IP.
         */
        value: string;
    }

}

export namespace apigateway {
    export interface ApigatewayCustomDomain {
        /**
         * The certificate ID for the domain.
         */
        certificateId?: string;
        /**
         * The domain name.
         */
        name: string;
    }

    export interface GetApigatewayCustomDomain {
        /**
         * The ID of the certificate to use for the distribution.
         */
        certificateId: string;
        /**
         * The domain name of the distribution.
         */
        name: string;
    }

    export interface GetRouteUpstream {
        /**
         * The host of the upstream.
         */
        host: string;
        /**
         * The load balancer algorithm.
         */
        loadbalancer: string;
        /**
         * The port of the upstream.
         */
        port: number;
        /**
         * The target URL of the upstream.
         */
        scheme: string;
        /**
         * Weight with which to split traffic to the upstream.
         */
        weight: number;
    }

    export interface RouteUpstream {
        /**
         * The host of the upstream.
         */
        host: string;
        /**
         * The load balancer algorithm.
         */
        loadbalancer?: string;
        /**
         * The port of the upstream.
         */
        port?: number;
        /**
         * The target URL of the upstream.
         */
        scheme?: string;
        /**
         * Weight with which to split traffic to the upstream.
         */
        weight?: number;
    }

}

export namespace autoscaling {
    export interface GetGroupPolicy {
        /**
         * The Metric that should trigger the scaling actions. Metric values are checked at fixed intervals.
         */
        metric: string;
        /**
         * Defines the time range, for which the samples will be aggregated. Default is 120s.
         */
        range: string;
        /**
         * Specifies the action to take when the `scaleInThreshold` is exceeded. Hereby, scaling in is always about removing VMs that are currently associated with this autoscaling group. Default termination policy is OLDEST_SERVER_FIRST.
         */
        scaleInActions: outputs.autoscaling.GetGroupPolicyScaleInAction[];
        /**
         * The lower threshold for the value of the `metric`. Will be used with `less than` (<) operator. Exceeding this will start a Scale-In action as specified by the `scaleInAction` property. The value must have a higher minimum delta to the `scaleOutThreshold` depending on the `metric` to avoid competitive actions at the same time.
         */
        scaleInThreshold: number;
        /**
         * Specifies the action to take when the `scaleOutThreshold` is exceeded. Hereby, scaling out is always about adding new VMs to this autoscaling group.
         */
        scaleOutActions: outputs.autoscaling.GetGroupPolicyScaleOutAction[];
        /**
         * The upper threshold for the value of the `metric`. Will be used with `greater than` (>) operator. Exceeding this will start a Scale-Out action as specified by the `scaleOutAction` property. The value must have a lower minimum delta to the `scaleInThreshold` depending on the `metric` to avoid competitive actions at the same time.
         */
        scaleOutThreshold: number;
        /**
         * Units of the applied Metric. Possible values are: PER_HOUR, PER_MINUTE, PER_SECOND, TOTAL.
         */
        unit: string;
    }

    export interface GetGroupPolicyScaleInAction {
        /**
         * When 'amountType=ABSOLUTE' specifies the absolute number of VMs that are removed. The value must be between 1 to 10. 'amountType=PERCENTAGE' specifies the percentage value that is applied to the current number of replicas of the VM Auto Scaling Group. The value must be between 1 to 200. At least one VM is always removed. Note that for 'SCALE_IN' operations, volumes are not deleted after the server is deleted.
         */
        amount: number;
        /**
         * The type for the given amount. Possible values are: [ABSOLUTE, PERCENTAGE].
         */
        amountType: string;
        /**
         * Minimum time to pass after this Scaling action has started, until the next Scaling action will be started. Additionally, if a Scaling action is currently in progress, no second Scaling action will be started for the same autoscaling group. Instead, the Metric will be re-evaluated after the current Scaling action is completed (either successfully or with failures). This is validated with a minimum value of 2 minutes and a maximum of 24 hours currently. Default value is 5 minutes if not given.
         */
        cooldownPeriod: string;
        /**
         * If set to 'true', when deleting an replica during scale in, any attached volume will also be deleted. When set to 'false', all volumes remain in the datacenter and must be deleted manually. Note that every scale-out creates new volumes. When they are not deleted, they will eventually use all of your contracts resource limits. At this point, scaling out would not be possible anymore.
         */
        deleteVolumes: boolean;
        /**
         * The type of the termination policy for the autoscaling group so that a specific pattern is followed for Scaling-In instances. Default termination policy is OLDEST_SERVER_FIRST.
         */
        terminationPolicyType: string;
    }

    export interface GetGroupPolicyScaleOutAction {
        /**
         * When 'amountType=ABSOLUTE' specifies the absolute number of VMs that are added. The value must be between 1 to 10. 'amountType=PERCENTAGE' specifies the percentage value that is applied to the current number of replicas of the VM Auto Scaling Group. The value must be between 1 to 200. At least one VM is always added. Note that for 'SCALE_IN' operations, volumes are not deleted after the server is deleted.
         */
        amount: number;
        /**
         * The type for the given amount. Possible values are: [ABSOLUTE, PERCENTAGE].
         */
        amountType: string;
        /**
         * Minimum time to pass after this Scaling action has started, until the next Scaling action will be started. Additionally, if a Scaling action is currently in progress, no second Scaling action will be started for the same autoscaling group. Instead, the Metric will be re-evaluated after the current Scaling action is completed (either successfully or with failures). This is validated with a minimum value of 2 minutes and a maximum of 24 hours currently. Default value is 5 minutes if not given.
         */
        cooldownPeriod: string;
    }

    export interface GetGroupReplicaConfiguration {
        /**
         * The zone where the VMs are created using this configuration.
         */
        availabilityZone: string;
        /**
         * The total number of cores for the VMs.
         */
        cores: number;
        /**
         * The zone where the VMs are created using this configuration.
         */
        cpuFamily: string;
        /**
         * List of NICs associated with this Replica.
         */
        nics: outputs.autoscaling.GetGroupReplicaConfigurationNic[];
        /**
         * The amount of memory for the VMs in MB, e.g. 2048. Size must be specified in multiples of 256 MB with a minimum of 256 MB; however, if you set ramHotPlug to TRUE then you must use a minimum of 1024 MB. If you set the RAM size more than 240GB, then ramHotPlug will be set to FALSE and can not be set to TRUE unless RAM size not set to less than 240GB.
         */
        ram: number;
        /**
         * List of volumes associated with this Replica. Only a single volume is currently supported.
         */
        volumes: outputs.autoscaling.GetGroupReplicaConfigurationVolume[];
    }

    export interface GetGroupReplicaConfigurationNic {
        /**
         * Dhcp flag for this replica Nic. This is an optional attribute with default value of 'true' if not given in the request payload or given as null.
         */
        dhcp: boolean;
        /**
         * Activate or deactivate the firewall. By default, an active firewall without any defined rules will block all incoming network traffic except for the firewall rules that explicitly allows certain protocols, IP addresses and ports.
         */
        firewallActive: boolean;
        /**
         * List of all firewall rules for the specified NIC.
         */
        firewallRules: outputs.autoscaling.GetGroupReplicaConfigurationNicFirewallRule[];
        /**
         * The type of firewall rules that will be allowed on the NIC. If not specified, the default INGRESS value is used.
         */
        firewallType: string;
        /**
         * Flow log configuration for the NIC. By default, the flow log is inactive. If you want to activate the flow log, you must specify the target resource and the type of traffic to log.
         */
        flowLogs: outputs.autoscaling.GetGroupReplicaConfigurationNicFlowLog[];
        /**
         * Lan ID for this replica Nic.
         */
        lan: number;
        /**
         * Name for this replica NIC.
         */
        name: string;
        /**
         * In order to link VM to ALB, target group must be provided.
         */
        targetGroups: outputs.autoscaling.GetGroupReplicaConfigurationNicTargetGroup[];
    }

    export interface GetGroupReplicaConfigurationNicFirewallRule {
        /**
         * Sets the allowed code (from 0 to 254) when ICMP protocol is selected. The value 'null' allows all codes.
         */
        icmpCode: number;
        /**
         * Sets the allowed type (from 0 to 254) if the protocol ICMP is selected. The value 'null' allows all types.
         */
        icmpType: number;
        /**
         * The name of the firewall rule.
         */
        name: string;
        /**
         * Sets the end range of the allowed port (from 1 to 65535) if the protocol TCP or UDP is selected. The value 'null' for 'port_range_start' and 'port_range_end' allows all ports.
         */
        portRangeEnd: number;
        /**
         * Sets the initial range of the allowed port (from 1 to 65535) if the protocol TCP or UDP is selected. The value 'null' for 'port_range_start' and 'port_range_end' allows all ports.
         */
        portRangeStart: number;
        /**
         * The protocol for the rule. The property cannot be modified after its creation (not allowed in update requests).
         */
        protocol: string;
        /**
         * Only traffic originating from the respective IPv4 address is permitted. The value 'null' allows traffic from any IP address.
         */
        sourceIp: string;
        /**
         * Only traffic originating from the respective MAC address is permitted. Valid format: 'aa:bb:cc:dd:ee:ff'. The value 'null' allows traffic from any MAC address.
         */
        sourceMac: string;
        /**
         * If the target NIC has multiple IP addresses, only the traffic directed to the respective IP address of the NIC is allowed. The value 'null' allows traffic to any target IP address.
         */
        targetIp: string;
        /**
         * The firewall rule type. If not specified, the default value 'INGRESS' is used.
         */
        type: string;
    }

    export interface GetGroupReplicaConfigurationNicFlowLog {
        /**
         * Specifies the traffic direction pattern. Valid values: ACCEPTED, REJECTED, ALL.
         */
        action: string;
        /**
         * The bucket name of an existing IONOS Object Storage bucket.
         */
        bucket: string;
        /**
         * Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL.
         */
        direction: string;
        /**
         * The resource's unique identifier.
         */
        id: string;
        /**
         * The resource name.
         */
        name: string;
    }

    export interface GetGroupReplicaConfigurationNicTargetGroup {
        /**
         * The port for the target group.
         */
        port: number;
        /**
         * The ID of the target group.
         */
        targetGroupId: string;
        /**
         * The weight for the target group.
         */
        weight: number;
    }

    export interface GetGroupReplicaConfigurationVolume {
        /**
         * The uuid of the Backup Unit that user has access to.
         */
        backupUnitId: string;
        /**
         * Determines whether the volume will be used as a boot volume: NONE - the volume will not be used as boot volume, PRIMARY - the volume will be used as boot volume, AUTO - will delegate the decision to the provisioning engine to decide whether to use the volume as boot volume.
         */
        bootOrder: string;
        /**
         * The bus type of the volume. Default setting is 'VIRTIO'. The bus type 'IDE' is also supported.
         */
        bus: string;
        /**
         * The image installed on the volume. Only the UUID of the image is presently supported.
         */
        image: string;
        /**
         * The image installed on the volume. Must be an 'imageAlias' as specified via the images API.
         */
        imageAlias: string;
        /**
         * Name for this replica volume.
         */
        name: string;
        /**
         * User-defined size for this replica volume in GB.
         */
        size: number;
        sshKeys: string[];
        /**
         * Storage Type for this replica volume. Possible values: SSD, HDD, SSD_STANDARD or SSD_PREMIUM
         */
        type: string;
    }

    export interface GetServersServer {
        /**
         * Unique identifier for the resource
         */
        id: string;
    }

    export interface GroupPolicy {
        /**
         * The Metric that should trigger the scaling actions. Metric values are checked at fixed intervals.
         */
        metric: string;
        /**
         * Specifies the time range for which the samples are to be aggregated. Must be >= 2 minutes.
         */
        range?: string;
        /**
         * Defines the action to be taken when the 'scaleInThreshold' is exceeded. Here, scaling is always about removing VMs associated with this VM Auto Scaling Group. By default, the termination policy is 'OLDEST_SERVER_FIRST' is effective.
         */
        scaleInAction: outputs.autoscaling.GroupPolicyScaleInAction;
        /**
         * The upper threshold for the value of the 'metric'. Used with the 'greater than' (>) operator. A scale-out action is triggered when this value is exceeded, specified by the 'scale_out_action' property. The value must have a lower minimum delta to the 'scale_in_threshold', depending on the metric, to avoid competing for actions simultaneously. If 'properties.policy.unit=TOTAL', a value >= 40 must be chosen.
         */
        scaleInThreshold: number;
        /**
         * Defines the action to be performed when the 'scaleOutThreshold' is exceeded. Here, scaling is always about adding new VMs to this VM Auto Scaling Group.
         */
        scaleOutAction: outputs.autoscaling.GroupPolicyScaleOutAction;
        /**
         * The upper threshold for the value of the 'metric'. Used with the 'greater than' (>) operator. A scale-out action is triggered when this value is exceeded, specified by the 'scaleOutAction' property. The value must have a lower minimum delta to the 'scaleInThreshold', depending on the metric, to avoid competing for actions simultaneously. If 'properties.policy.unit=TOTAL', a value >= 40 must be chosen.
         */
        scaleOutThreshold: number;
        /**
         * Units of the applied Metric. Possible values are: PER_HOUR, PER_MINUTE, PER_SECOND, TOTAL.
         */
        unit: string;
    }

    export interface GroupPolicyScaleInAction {
        /**
         * When 'amountType=ABSOLUTE' specifies the absolute number of VMs that are removed. The value must be between 1 to 10. 'amountType=PERCENTAGE' specifies the percentage value that is applied to the current number of replicas of the VM Auto Scaling Group. The value must be between 1 to 200. At least one VM is always removed. Note that for 'SCALE_IN' operations, volumes are not deleted after the server is deleted.
         */
        amount: number;
        /**
         * The type for the given amount. Possible values are: [ABSOLUTE, PERCENTAGE].
         */
        amountType: string;
        /**
         * The minimum time that elapses after the start of this scaling action until the following scaling action is started. While a scaling action is in progress, no second action is initiated for the same VM Auto Scaling Group. Instead, the metric is re-evaluated after the current scaling action completes (either successfully or with errors). This is currently validated with a minimum value of 2 minutes and a maximum of 24 hours. The default value is 5 minutes if not specified.
         */
        cooldownPeriod: string;
        /**
         * If set to 'true', when deleting an replica during scale in, any attached volume will also be deleted. When set to 'false', all volumes remain in the datacenter and must be deleted manually. Note that every scale-out creates new volumes. When they are not deleted, they will eventually use all of your contracts resource limits. At this point, scaling out would not be possible anymore.
         */
        deleteVolumes: boolean;
        /**
         * The type of termination policy for the VM Auto Scaling Group to follow a specific pattern for scaling-in replicas. The default termination policy is 'OLDEST_SERVER_FIRST'.
         */
        terminationPolicyType: string;
    }

    export interface GroupPolicyScaleOutAction {
        /**
         * When 'amountType=ABSOLUTE' specifies the absolute number of VMs that are added. The value must be between 1 to 10. 'amountType=PERCENTAGE' specifies the percentage value that is applied to the current number of replicas of the VM Auto Scaling Group. The value must be between 1 to 200. At least one VM is always added or removed.
         */
        amount: number;
        /**
         * The type for the given amount. Possible values are: [ABSOLUTE, PERCENTAGE].
         */
        amountType: string;
        /**
         * The minimum time that elapses after the start of this scaling action until the following scaling action is started. While a scaling action is in progress, no second action is initiated for the same VM Auto Scaling Group. Instead, the metric is re-evaluated after the current scaling action completes (either successfully or with errors). This is currently validated with a minimum value of 2 minutes and a maximum of 24 hours. The default value is 5 minutes if not specified.
         */
        cooldownPeriod: string;
    }

    export interface GroupReplicaConfiguration {
        /**
         * The zone where the VMs are created using this configuration.
         */
        availabilityZone: string;
        /**
         * The total number of cores for the VMs.
         */
        cores: number;
        /**
         * The zone where the VMs are created using this configuration.
         */
        cpuFamily?: string;
        /**
         * Set of NICs associated with this Replica.
         */
        nics?: outputs.autoscaling.GroupReplicaConfigurationNic[];
        /**
         * The amount of memory for the VMs in MB, e.g. 2048. Size must be specified in multiples of 256 MB with a minimum of 256 MB; however, if you set ramHotPlug to TRUE then you must use a minimum of 1024 MB. If you set the RAM size more than 240GB, then ramHotPlug will be set to FALSE and can not be set to TRUE unless RAM size not set to less than 240GB.
         */
        ram: number;
        /**
         * List of volumes associated with this Replica.
         */
        volumes?: outputs.autoscaling.GroupReplicaConfigurationVolume[];
    }

    export interface GroupReplicaConfigurationNic {
        /**
         * Dhcp flag for this replica Nic. This is an optional attribute with default value of 'true' if not given in the request payload or given as null.
         */
        dhcp?: boolean;
        /**
         * Activate or deactivate the firewall. By default, an active firewall without any defined rules will block all incoming network traffic except for the firewall rules that explicitly allows certain protocols, IP addresses and ports.
         */
        firewallActive?: boolean;
        /**
         * List of all firewall rules for the specified NIC.
         */
        firewallRules?: outputs.autoscaling.GroupReplicaConfigurationNicFirewallRule[];
        /**
         * The type of firewall rules that will be allowed on the NIC. If not specified, the default INGRESS value is used.
         */
        firewallType?: string;
        /**
         * List of all flow logs for the specified NIC.
         */
        flowLogs?: outputs.autoscaling.GroupReplicaConfigurationNicFlowLog[];
        /**
         * Lan ID for this replica Nic.
         */
        lan: number;
        /**
         * Name for this replica NIC.
         */
        name: string;
        /**
         * In order to link VM to ALB, target group must be provided.
         */
        targetGroup?: outputs.autoscaling.GroupReplicaConfigurationNicTargetGroup;
    }

    export interface GroupReplicaConfigurationNicFirewallRule {
        /**
         * Sets the allowed code (from 0 to 254) when ICMP protocol is selected. The value 'null' allows all codes.
         */
        icmpCode?: number;
        /**
         * Sets the allowed type (from 0 to 254) if the protocol ICMP is selected. The value 'null' allows all types.
         */
        icmpType?: number;
        /**
         * The name of the firewall rule.
         */
        name?: string;
        /**
         * Sets the end range of the allowed port (from 1 to 65535) if the protocol TCP or UDP is selected. The value 'null' for 'port_range_start' and 'port_range_end' allows all ports.
         */
        portRangeEnd?: number;
        /**
         * Sets the initial range of the allowed port (from 1 to 65535) if the protocol TCP or UDP is selected. The value 'null' for 'port_range_start' and 'port_range_end' allows all ports.
         */
        portRangeStart?: number;
        /**
         * The protocol for the rule. The property cannot be modified after its creation (not allowed in update requests).
         */
        protocol: string;
        /**
         * Only traffic originating from the respective IPv4 address is permitted. The value 'null' allows traffic from any IP address.
         */
        sourceIp?: string;
        /**
         * Only traffic originating from the respective MAC address is permitted. Valid format: 'aa:bb:cc:dd:ee:ff'. The value 'null' allows traffic from any MAC address.
         */
        sourceMac?: string;
        /**
         * If the target NIC has multiple IP addresses, only the traffic directed to the respective IP address of the NIC is allowed. The value 'null' allows traffic to any target IP address.
         */
        targetIp?: string;
        /**
         * The firewall rule type. If not specified, the default value 'INGRESS' is used.
         */
        type: string;
    }

    export interface GroupReplicaConfigurationNicFlowLog {
        /**
         * Specifies the traffic direction pattern. Valid values: ACCEPTED, REJECTED, ALL. Immutable, forces re-recreation of the nic resource.
         */
        action: string;
        /**
         * The bucket name of an existing IONOS Object Storage bucket. Immutable, forces re-recreation of the nic resource.
         */
        bucket: string;
        /**
         * Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, forces re-recreation of the nic resource.
         */
        direction: string;
        /**
         * The resource's unique identifier.
         */
        id: string;
        /**
         * The resource name.
         */
        name: string;
    }

    export interface GroupReplicaConfigurationNicTargetGroup {
        /**
         * The port for the target group.
         */
        port: number;
        /**
         * The ID of the target group.
         */
        targetGroupId: string;
        /**
         * The weight for the target group.
         */
        weight: number;
    }

    export interface GroupReplicaConfigurationVolume {
        /**
         * The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
         */
        backupUnitId: string;
        /**
         * Determines whether the volume will be used as a boot volume. Set to NONE, the volume will not be used as boot volume. 
         * Set to PRIMARY, the volume will be used as boot volume and set to AUTO will delegate the decision to the provisioning engine to decide whether to use the volume as boot volume.
         * Notice that exactly one volume can be set to PRIMARY or all of them set to AUTO.
         */
        bootOrder: string;
        /**
         * The bus type of the volume. Default setting is 'VIRTIO'. The bus type 'IDE' is also supported.
         */
        bus?: string;
        /**
         * The image installed on the disk. Currently, only the UUID of the image is supported. Note that either 'image' or 'imageAlias' must be specified, but not both.
         */
        image?: string;
        /**
         * The image installed on the volume. Must be an 'imageAlias' as specified via the images API. Note that one of 'image' or 'imageAlias' must be set, but not both.
         */
        imageAlias?: string;
        /**
         * Image password for this replica volume.
         */
        imagePassword?: string;
        /**
         * Name for this replica volume.
         */
        name: string;
        /**
         * User-defined size for this replica volume in GB.
         */
        size: number;
        sshKeys?: string[];
        /**
         * Storage Type for this replica volume. Possible values: SSD, HDD, SSD_STANDARD or SSD_PREMIUM
         */
        type: string;
        /**
         * User-data (Cloud Init) for this replica volume.
         */
        userData: string;
    }

}

export namespace cdn {
    export interface DistributionRoutingRule {
        /**
         * The prefix of the routing rule.
         */
        prefix: string;
        /**
         * The scheme of the routing rule.
         */
        scheme: string;
        upstream: outputs.cdn.DistributionRoutingRuleUpstream;
    }

    export interface DistributionRoutingRuleUpstream {
        /**
         * Enable or disable caching. If enabled, the CDN will cache the responses from the upstream host. Subsequent requests for the same resource will be served from the cache.
         */
        caching: boolean;
        geoRestrictions?: outputs.cdn.DistributionRoutingRuleUpstreamGeoRestrictions;
        /**
         * The upstream host that handles the requests if not already cached. This host will be protected by the WAF if the option is enabled.
         */
        host: string;
        /**
         * Rate limit class that will be applied to limit the number of incoming requests per IP.
         */
        rateLimitClass: string;
        /**
         * The SNI (Server Name Indication) mode of the upstream host. It supports two modes: 'distribution' and 'origin', for more information about these modes please check the resource docs.
         */
        sniMode: string;
        /**
         * Enable or disable WAF to protect the upstream host.
         */
        waf: boolean;
    }

    export interface DistributionRoutingRuleUpstreamGeoRestrictions {
        allowLists?: string[];
        blockLists?: string[];
    }

    export interface GetDistributionRoutingRule {
        /**
         * The prefix of the routing rule.
         */
        prefix: string;
        /**
         * The scheme of the routing rule.
         */
        scheme: string;
        upstreams: outputs.cdn.GetDistributionRoutingRuleUpstream[];
    }

    export interface GetDistributionRoutingRuleUpstream {
        /**
         * Enable or disable caching. If enabled, the CDN will cache the responses from the upstream host. Subsequent requests for the same resource will be served from the cache.
         */
        caching: boolean;
        geoRestrictions: outputs.cdn.GetDistributionRoutingRuleUpstreamGeoRestriction[];
        /**
         * The upstream host that handles the requests if not already cached. This host will be protected by the WAF if the option is enabled.
         */
        host: string;
        /**
         * Rate limit class that will be applied to limit the number of incoming requests per IP.
         */
        rateLimitClass: string;
        /**
         * The SNI (Server Name Indication) mode of the upstream host. It supports two modes: 'distribution' and 'origin', for more information about these modes please check the data source docs.
         */
        sniMode: string;
        /**
         * Enable or disable WAF to protect the upstream host.
         */
        waf: boolean;
    }

    export interface GetDistributionRoutingRuleUpstreamGeoRestriction {
        allowLists: string[];
        blockLists: string[];
    }

}

export namespace cert {
    export interface AutoCertificateProviderExternalAccountBinding {
        /**
         * The key ID of the external account binding
         */
        keyId: string;
        /**
         * The secret of the external account binding
         */
        keySecret: string;
    }

    export interface GetAutoCertificateProviderExternalAccountBinding {
        /**
         * The key ID of the external account binding
         */
        keyId: string;
    }

}

export namespace compute {
    export interface CrossconnectConnectableDatacenter {
        /**
         * The UUID of the connectable datacenter
         */
        id: string;
        /**
         * The physical location of the connectable datacenter
         */
        location: string;
        /**
         * The name of the connectable datacenter
         */
        name: string;
    }

    export interface CrossconnectPeer {
        /**
         * The id of the cross-connected datacenter
         */
        datacenterId: string;
        /**
         * The name of the cross-connected datacenter
         */
        datacenterName: string;
        /**
         * The id of the cross-connected LAN
         */
        lanId: string;
        /**
         * The name of the cross-connected LAN
         */
        lanName: string;
        /**
         * The location of the cross-connected datacenter
         */
        location: string;
    }

    export interface CubeServerNic {
        deviceNumber: number;
        dhcp?: boolean;
        /**
         * Indicates whether this NIC receives an IPv6 address through DHCP.
         */
        dhcpv6?: boolean;
        firewall?: outputs.compute.CubeServerNicFirewall;
        firewallActive?: boolean;
        firewallType: string;
        ips: string[];
        /**
         * IPv6 CIDR block assigned to the NIC.
         */
        ipv6CidrBlock: string;
        /**
         * Collection for IPv6 addresses assigned to a nic. Explicitly assigned IPv6 addresses need to come from inside the IPv6 CIDR block assigned to the nic.
         */
        ipv6Ips: string[];
        lan: number;
        mac: string;
        name?: string;
        pciSlot: number;
        /**
         * The list of Security Group IDs for the NIC
         */
        securityGroupsIds?: string[];
    }

    export interface CubeServerNicFirewall {
        icmpCode?: string;
        icmpType?: string;
        name?: string;
        portRangeEnd?: number;
        portRangeStart?: number;
        protocol: string;
        sourceIp?: string;
        sourceMac?: string;
        targetIp?: string;
        type: string;
    }

    export interface CubeServerVolume {
        availabilityZone: string;
        /**
         * The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
         */
        backupUnitId: string;
        /**
         * The UUID of the attached server.
         */
        bootServer: string;
        bus: string;
        cpuHotPlug: boolean;
        deviceNumber: number;
        discVirtioHotPlug: boolean;
        discVirtioHotUnplug: boolean;
        diskType: string;
        /**
         * @deprecated Please use imagePassword under server level
         */
        imagePassword?: string;
        licenceType: string;
        name?: string;
        nicHotPlug: boolean;
        nicHotUnplug: boolean;
        pciSlot: number;
        ramHotPlug: boolean;
        /**
         * @deprecated Please use sshKeyPath under server level
         */
        sshKeyPaths: string[];
        /**
         * The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
         */
        userData: string;
    }

    export interface DatacenterCpuArchitecture {
        cpuFamily: string;
        maxCores: number;
        maxRam: number;
        vendor: string;
    }

    export interface GetCrossconnectConnectableDatacenter {
        id: string;
        location: string;
        name: string;
    }

    export interface GetCrossconnectPeer {
        /**
         * The id of the cross-connected VDC
         */
        datacenterId: string;
        /**
         * The name of the cross-connected VDC
         */
        datacenterName: string;
        /**
         * The id of the cross-connected LAN
         */
        lanId: string;
        /**
         * The name of the cross-connected LAN
         */
        lanName: string;
        location: string;
    }

    export interface GetCubeServerCdrom {
        cloudInit: string;
        cpuHotPlug: boolean;
        cpuHotUnplug: boolean;
        description: string;
        discScsiHotPlug: boolean;
        discScsiHotUnplug: boolean;
        discVirtioHotPlug: boolean;
        discVirtioHotUnplug: boolean;
        id: string;
        imageAliases: string[];
        imageType: string;
        licenceType: string;
        location: string;
        name: string;
        nicHotPlug: boolean;
        nicHotUnplug: boolean;
        public: boolean;
        ramHotPlug: boolean;
        ramHotUnplug: boolean;
        size: number;
    }

    export interface GetCubeServerNic {
        deviceNumber: number;
        dhcp: boolean;
        dhcpv6?: boolean;
        firewallActive: boolean;
        firewallRules: outputs.compute.GetCubeServerNicFirewallRule[];
        firewallType: string;
        id: string;
        ips: string[];
        ipv6CidrBlock: string;
        ipv6Ips: string[];
        lan: number;
        mac: string;
        name: string;
        pciSlot: number;
        securityGroupsIds: string[];
    }

    export interface GetCubeServerNicFirewallRule {
        icmpCode: number;
        icmpType: number;
        id: string;
        name: string;
        portRangeEnd: number;
        portRangeStart: number;
        protocol: string;
        sourceIp: string;
        sourceMac: string;
        targetIp: string;
        type: string;
    }

    export interface GetCubeServerVolume {
        availabilityZone: string;
        backupUnitId: string;
        /**
         * The UUID of the attached server.
         */
        bootServer: string;
        bus: string;
        cpuHotPlug: boolean;
        deviceNumber: number;
        discVirtioHotPlug: boolean;
        discVirtioHotUnplug: boolean;
        id: string;
        imageName: string;
        imagePassword: string;
        licenceType: string;
        name: string;
        nicHotPlug: boolean;
        nicHotUnplug: boolean;
        pciSlot: number;
        ramHotPlug: boolean;
        sshKeys: string[];
        type: string;
        userData?: string;
    }

    export interface GetDatacenterCpuArchitecture {
        cpuFamily: string;
        maxCores: number;
        maxRam: number;
        vendor: string;
    }

    export interface GetGroupUser {
        administrator: boolean;
        email: string;
        firstName: string;
        forceSecAuth: boolean;
        id: string;
        lastName: string;
    }

    export interface GetIPBlockIpConsumer {
        datacenterId: string;
        datacenterName: string;
        ip: string;
        k8sClusterUuid: string;
        k8sNodepoolUuid: string;
        mac: string;
        nicId: string;
        serverId: string;
        serverName: string;
    }

    export interface GetLanIpFailover {
        ip: string;
        nicUuid: string;
    }

    export interface GetLocationCpuArchitecture {
        cpuFamily: string;
        maxCores: number;
        maxRam: number;
        vendor: string;
    }

    export interface GetNatGatewayLan {
        /**
         * Collection of gateway IP addresses of the NAT gateway. Will be auto-generated if not provided. Should ideally be an IP belonging to the same subnet as the LAN
         */
        gatewayIps: string[];
        /**
         * Id for the LAN connected to the NAT gateway
         */
        id: number;
    }

    export interface GetNatGatewayRuleTargetPortRange {
        /**
         * Target port range end associated with the NAT gateway rule.
         */
        end: number;
        /**
         * Target port range start associated with the NAT gateway rule.
         */
        start: number;
    }

    export interface GetNicFlowlog {
        /**
         * Specifies the traffic direction pattern. Valid values: ACCEPTED, REJECTED, ALL.
         */
        action: string;
        /**
         * The bucket name of an existing IONOS Object Storage bucket.
         */
        bucket: string;
        /**
         * Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL.
         */
        direction: string;
        /**
         * The resource's unique identifier.
         */
        id: string;
        /**
         * The resource name.
         */
        name: string;
    }

    export interface GetServerCdrom {
        cloudInit: string;
        cpuHotPlug: boolean;
        cpuHotUnplug: boolean;
        description: string;
        discScsiHotPlug: boolean;
        discScsiHotUnplug: boolean;
        discVirtioHotPlug: boolean;
        discVirtioHotUnplug: boolean;
        id: string;
        imageAliases: string[];
        imageType: string;
        licenceType: string;
        location: string;
        name: string;
        nicHotPlug: boolean;
        nicHotUnplug: boolean;
        public: boolean;
        ramHotPlug: boolean;
        ramHotUnplug: boolean;
        size: number;
    }

    export interface GetServerLabel {
        id: string;
        key: string;
        value: string;
    }

    export interface GetServerNic {
        deviceNumber: number;
        dhcp: boolean;
        dhcpv6?: boolean;
        firewallActive: boolean;
        firewallRules: outputs.compute.GetServerNicFirewallRule[];
        firewallType: string;
        id: string;
        ips: string[];
        ipv6CidrBlock: string;
        ipv6Ips: string[];
        lan: number;
        mac: string;
        name: string;
        pciSlot: number;
        securityGroupsIds: string[];
    }

    export interface GetServerNicFirewallRule {
        icmpCode: number;
        icmpType: number;
        id: string;
        name: string;
        portRangeEnd: number;
        portRangeStart: number;
        protocol: string;
        sourceIp: string;
        sourceMac: string;
        targetIp: string;
        type: string;
    }

    export interface GetServerVolume {
        availabilityZone: string;
        backupUnitId: string;
        /**
         * The UUID of the attached server.
         */
        bootServer: string;
        bus: string;
        cpuHotPlug: boolean;
        deviceNumber: number;
        discVirtioHotPlug: boolean;
        discVirtioHotUnplug: boolean;
        id: string;
        imageName: string;
        imagePassword: string;
        licenceType: string;
        name: string;
        nicHotPlug: boolean;
        nicHotUnplug: boolean;
        pciSlot: number;
        ramHotPlug: boolean;
        size: number;
        sshKeys: string[];
        type: string;
        userData?: string;
    }

    export interface GetServersFilter {
        name: string;
        value: string;
    }

    export interface GetServersServer {
        availabilityZone: string;
        bootCdrom: string;
        bootImage: string;
        bootVolume: string;
        cdroms: outputs.compute.GetServersServerCdrom[];
        cores: number;
        cpuFamily: string;
        hostname: string;
        /**
         * The unique ID of the server.
         */
        id: string;
        labels: outputs.compute.GetServersServerLabel[];
        name?: string;
        nics: outputs.compute.GetServersServerNic[];
        ram: number;
        templateUuid?: string;
        token: string;
        type: string;
        vmState: string;
        volumes: outputs.compute.GetServersServerVolume[];
    }

    export interface GetServersServerCdrom {
        cloudInit: string;
        cpuHotPlug: boolean;
        cpuHotUnplug: boolean;
        description: string;
        discScsiHotPlug: boolean;
        discScsiHotUnplug: boolean;
        discVirtioHotPlug: boolean;
        discVirtioHotUnplug: boolean;
        id: string;
        imageAliases: string[];
        imageType: string;
        licenceType: string;
        location: string;
        name: string;
        nicHotPlug: boolean;
        nicHotUnplug: boolean;
        public: boolean;
        ramHotPlug: boolean;
        ramHotUnplug: boolean;
        size: number;
    }

    export interface GetServersServerLabel {
        id: string;
        key: string;
        value: string;
    }

    export interface GetServersServerNic {
        deviceNumber: number;
        dhcp: boolean;
        dhcpv6?: boolean;
        firewallActive: boolean;
        firewallRules: outputs.compute.GetServersServerNicFirewallRule[];
        firewallType: string;
        id: string;
        ips: string[];
        ipv6CidrBlock: string;
        ipv6Ips: string[];
        lan: number;
        mac: string;
        name: string;
        pciSlot: number;
        securityGroupsIds: string[];
    }

    export interface GetServersServerNicFirewallRule {
        icmpCode: number;
        icmpType: number;
        id: string;
        name: string;
        portRangeEnd: number;
        portRangeStart: number;
        protocol: string;
        sourceIp: string;
        sourceMac: string;
        targetIp: string;
        type: string;
    }

    export interface GetServersServerVolume {
        availabilityZone: string;
        backupUnitId: string;
        /**
         * The UUID of the attached server.
         */
        bootServer: string;
        bus: string;
        cpuHotPlug: boolean;
        deviceNumber: number;
        discVirtioHotPlug: boolean;
        discVirtioHotUnplug: boolean;
        diskType: string;
        id: string;
        imageName: string;
        imagePassword: string;
        licenceType: string;
        name: string;
        nicHotPlug: boolean;
        nicHotUnplug: boolean;
        pciSlot: number;
        ramHotPlug: boolean;
        size: number;
        sshKeys: string[];
        userData?: string;
    }

    export interface GetTargetGroupHealthCheck {
        /**
         * The interval in milliseconds between consecutive health checks; default is 2000.
         */
        checkInterval: number;
        /**
         * The maximum time in milliseconds to wait for a target to respond to a check. For target VMs with 'Check Interval' set, the lesser of the two  values is used once the TCP connection is established.
         */
        checkTimeout: number;
        /**
         * The maximum number of attempts to reconnect to a target after a connection failure. Valid range is 0 to 65535, and default is three reconnection.
         */
        retries: number;
    }

    export interface GetTargetGroupHttpHealthCheck {
        matchType: string;
        /**
         * The method for the HTTP health check.
         */
        method: string;
        negate: boolean;
        /**
         * The path (destination URL) for the HTTP health check request; the default is /.
         */
        path: string;
        regex: boolean;
        /**
         * The response returned by the request, depending on the match type.
         */
        response: string;
    }

    export interface GetTargetGroupTarget {
        /**
         * Makes the target available only if it accepts periodic health check TCP connection attempts; when turned off, the target is considered always available. The health check only consists of a connection attempt to the address and port of the target. Default is True.
         */
        healthCheckEnabled: boolean;
        /**
         * The IP of the balanced target VM.
         */
        ip: string;
        /**
         * Maintenance mode prevents the target from receiving balanced traffic.
         */
        maintenanceEnabled: boolean;
        /**
         * The port of the balanced target service; valid range is 1 to 65535.
         */
        port: number;
        /**
         * Proxy protocol version
         */
        proxyProtocol: string;
        /**
         * Traffic is distributed in proportion to target weight, relative to the combined weight of all targets. A target with higher weight receives a greater share of traffic. Valid range is 0 to 256 and default is 1; targets with weight of 0 do not participate in load balancing but still accept persistent connections. It is best use values in the middle of the range to leave room for later adjustments.
         */
        weight: number;
    }

    export interface GetUserGroup {
        id: string;
        name: string;
    }

    export interface GetVCPUServerCdrom {
        cloudInit: string;
        cpuHotPlug: boolean;
        cpuHotUnplug: boolean;
        description: string;
        discScsiHotPlug: boolean;
        discScsiHotUnplug: boolean;
        discVirtioHotPlug: boolean;
        discVirtioHotUnplug: boolean;
        id: string;
        imageAliases: string[];
        imageType: string;
        licenceType: string;
        location: string;
        name: string;
        nicHotPlug: boolean;
        nicHotUnplug: boolean;
        public: boolean;
        ramHotPlug: boolean;
        ramHotUnplug: boolean;
        size: number;
    }

    export interface GetVCPUServerLabel {
        id: string;
        key: string;
        value: string;
    }

    export interface GetVCPUServerNic {
        deviceNumber: number;
        dhcp: boolean;
        dhcpv6?: boolean;
        firewallActive: boolean;
        firewallRules: outputs.compute.GetVCPUServerNicFirewallRule[];
        firewallType: string;
        id: string;
        ips: string[];
        ipv6CidrBlock: string;
        ipv6Ips: string[];
        lan: number;
        mac: string;
        name: string;
        pciSlot: number;
        securityGroupsIds: string[];
    }

    export interface GetVCPUServerNicFirewallRule {
        icmpCode: number;
        icmpType: number;
        id: string;
        name: string;
        portRangeEnd: number;
        portRangeStart: number;
        protocol: string;
        sourceIp: string;
        sourceMac: string;
        targetIp: string;
        type: string;
    }

    export interface GetVCPUServerVolume {
        availabilityZone: string;
        backupUnitId: string;
        /**
         * The UUID of the attached server.
         */
        bootServer: string;
        bus: string;
        cpuHotPlug: boolean;
        deviceNumber: number;
        discVirtioHotPlug: boolean;
        discVirtioHotUnplug: boolean;
        id: string;
        imageName: string;
        imagePassword: string;
        licenceType: string;
        name: string;
        nicHotPlug: boolean;
        nicHotUnplug: boolean;
        pciSlot: number;
        ramHotPlug: boolean;
        size: number;
        sshKeys: string[];
        type: string;
        userData?: string;
    }

    export interface GroupUser {
        administrator: boolean;
        email: string;
        firstName: string;
        forceSecAuth: boolean;
        id: string;
        lastName: string;
        password: string;
    }

    export interface IPBlockIpConsumer {
        datacenterId: string;
        datacenterName: string;
        ip: string;
        k8sClusterUuid: string;
        k8sNodepoolUuid: string;
        mac: string;
        nicId: string;
        serverId: string;
        serverName: string;
    }

    export interface LanIpFailover {
        ip: string;
        nicUuid: string;
    }

    export interface NatGatewayLan {
        /**
         * Collection of gateway IP addresses of the NAT gateway. Will be auto-generated if not provided. Should ideally be an IP belonging to the same subnet as the LAN
         */
        gatewayIps: string[];
        /**
         * Id for the LAN connected to the NAT gateway
         */
        id: number;
    }

    export interface NatGatewayRuleTargetPortRange {
        /**
         * Target port range end associated with the NAT gateway rule.
         */
        end: number;
        /**
         * Target port range start associated with the NAT gateway rule.
         */
        start: number;
    }

    export interface NicFlowlog {
        /**
         * Specifies the traffic direction pattern. Valid values: ACCEPTED, REJECTED, ALL. Immutable, forces re-recreation of the nic resource.
         */
        action: string;
        /**
         * The bucket name of an existing IONOS Object Storage bucket. Immutable, forces re-recreation of the nic resource.
         */
        bucket: string;
        /**
         * Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, forces re-recreation of the nic resource.
         */
        direction: string;
        /**
         * The resource's unique identifier.
         */
        id: string;
        /**
         * The resource name.
         */
        name: string;
    }

    export interface ServerLabel {
        key: string;
        value: string;
    }

    export interface ServerNic {
        deviceNumber: number;
        dhcp?: boolean;
        /**
         * Indicates whether this NIC receives an IPv6 address through DHCP.
         */
        dhcpv6?: boolean;
        firewallActive?: boolean;
        firewallType: string;
        /**
         * Firewall rules created in the server resource. The rules can also be created as separate resources outside the server resource
         */
        firewalls?: outputs.compute.ServerNicFirewall[];
        id: string;
        /**
         * Collection of IP addresses assigned to a nic. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.
         */
        ips: string[];
        /**
         * IPv6 CIDR block assigned to the NIC.
         */
        ipv6CidrBlock: string;
        /**
         * Collection for IPv6 addresses assigned to a nic. Explicitly assigned IPv6 addresses need to come from inside the IPv6 CIDR block assigned to the nic.
         */
        ipv6Ips: string[];
        lan: number;
        mac: string;
        name?: string;
        pciSlot: number;
        /**
         * The list of Security Group IDs for the NIC
         */
        securityGroupsIds?: string[];
    }

    export interface ServerNicFirewall {
        icmpCode?: string;
        icmpType?: string;
        id: string;
        name?: string;
        portRangeEnd?: number;
        portRangeStart?: number;
        protocol: string;
        sourceIp?: string;
        sourceMac?: string;
        targetIp?: string;
        type: string;
    }

    export interface ServerVolume {
        availabilityZone: string;
        /**
         * The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
         */
        backupUnitId: string;
        /**
         * The UUID of the attached server.
         */
        bootServer: string;
        bus: string;
        cpuHotPlug: boolean;
        deviceNumber: number;
        discVirtioHotPlug: boolean;
        discVirtioHotUnplug: boolean;
        diskType: string;
        /**
         * @deprecated Please use imagePassword under server level
         */
        imagePassword?: string;
        licenceType: string;
        name?: string;
        nicHotPlug: boolean;
        nicHotUnplug: boolean;
        pciSlot: number;
        ramHotPlug: boolean;
        /**
         * The size of the volume in GB.
         */
        size: number;
        /**
         * Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key. This field may only be set in creation requests. When reading, it always returns null. SSH keys are only supported if a public Linux image is used for the volume creation.
         *
         * @deprecated Please use sshKeyPath under server level
         */
        sshKeyPaths?: string[];
        /**
         * Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key. This field may only be set in creation requests. When reading, it always returns null. SSH keys are only supported if a public Linux image is used for the volume creation.
         *
         * @deprecated Please use sshKeys under server level
         */
        sshKeys: string[];
        /**
         * The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
         */
        userData: string;
    }

    export interface TargetGroupHealthCheck {
        /**
         * The interval in milliseconds between consecutive health checks; default is 2000.
         */
        checkInterval: number;
        /**
         * The maximum time in milliseconds to wait for a target to respond to a check. For target VMs with 'Check Interval' set, the lesser of the two  values is used once the TCP connection is established.
         */
        checkTimeout: number;
        /**
         * The maximum number of attempts to reconnect to a target after a connection failure. Valid range is 0 to 65535, and default is three reconnection.
         */
        retries: number;
    }

    export interface TargetGroupHttpHealthCheck {
        matchType: string;
        /**
         * The method for the HTTP health check.
         */
        method: string;
        negate?: boolean;
        /**
         * The path (destination URL) for the HTTP health check request; the default is /.
         */
        path: string;
        regex?: boolean;
        /**
         * The response returned by the request, depending on the match type.
         */
        response: string;
    }

    export interface TargetGroupTarget {
        /**
         * Makes the target available only if it accepts periodic health check TCP connection attempts; when turned off, the target is considered always available. The health check only consists of a connection attempt to the address and port of the target. Default is True.
         */
        healthCheckEnabled: boolean;
        /**
         * The IP of the balanced target VM.
         */
        ip: string;
        /**
         * Maintenance mode prevents the target from receiving balanced traffic.
         */
        maintenanceEnabled?: boolean;
        /**
         * The port of the balanced target service; valid range is 1 to 65535.
         */
        port: number;
        /**
         * Proxy protocol version
         */
        proxyProtocol?: string;
        /**
         * Traffic is distributed in proportion to target weight, relative to the combined weight of all targets. A target with higher weight receives a greater share of traffic. Valid range is 0 to 256 and default is 1; targets with weight of 0 do not participate in load balancing but still accept persistent connections. It is best use values in the middle of the range to leave room for later adjustments.
         */
        weight: number;
    }

    export interface VCPUServerLabel {
        key: string;
        value: string;
    }

    export interface VCPUServerNic {
        deviceNumber: number;
        dhcp?: boolean;
        dhcpv6?: boolean;
        firewallActive?: boolean;
        firewallType: string;
        /**
         * Firewall rules created in the server resource. The rules can also be created as separate resources outside the server resource
         */
        firewalls?: outputs.compute.VCPUServerNicFirewall[];
        id: string;
        /**
         * Collection of IP addresses assigned to a nic. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.
         */
        ips: string[];
        ipv6CidrBlock: string;
        ipv6Ips: string[];
        lan: number;
        mac: string;
        name?: string;
        pciSlot: number;
        /**
         * The list of Security Group IDs for the NIC
         */
        securityGroupsIds?: string[];
    }

    export interface VCPUServerNicFirewall {
        icmpCode?: string;
        icmpType?: string;
        id: string;
        name?: string;
        portRangeEnd?: number;
        portRangeStart?: number;
        protocol: string;
        sourceIp?: string;
        sourceMac?: string;
        targetIp?: string;
        type: string;
    }

    export interface VCPUServerVolume {
        availabilityZone: string;
        /**
         * The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
         */
        backupUnitId: string;
        /**
         * The UUID of the attached server.
         */
        bootServer: string;
        bus: string;
        cpuHotPlug: boolean;
        deviceNumber: number;
        discVirtioHotPlug: boolean;
        discVirtioHotUnplug: boolean;
        diskType: string;
        licenceType: string;
        name?: string;
        nicHotPlug: boolean;
        nicHotUnplug: boolean;
        pciSlot: number;
        ramHotPlug: boolean;
        /**
         * The size of the volume in GB.
         */
        size: number;
        /**
         * The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
         */
        userData: string;
    }

}

export namespace creg {
    export interface GetRegistryFeature {
        vulnerabilityScanning: boolean;
    }

    export interface GetRegistryGarbageCollectionSchedule {
        days: string[];
        time: string;
    }

    export interface GetRegistryMaintenanceWindow {
        days: string[];
        time: string;
    }

    export interface GetRegistryStorageUsage {
        bytes: number;
        updatedAt: string;
    }

    export interface GetRegistryTokenCredential {
        username: string;
    }

    export interface GetRegistryTokenScope {
        actions: string[];
        name: string;
        type: string;
    }

    export interface RegistryFeatures {
        /**
         * Enables vulnerability scanning for images in the container registry. Note: this feature can incur additional charges
         */
        vulnerabilityScanning: boolean;
    }

    export interface RegistryGarbageCollectionSchedule {
        days: string[];
        /**
         * UTC time of day e.g. 01:00:00 - as defined by partial-time - RFC3339
         */
        time: string;
    }

    export interface RegistryStorageUsage {
        bytes: number;
        updatedAt: string;
    }

    export interface RegistryTokenCredential {
        password: string;
        username: string;
    }

    export interface RegistryTokenScope {
        /**
         * Example: ["pull", "push", "delete"]
         */
        actions: string[];
        name: string;
        type: string;
    }

}

export namespace dbaas {
    export interface GetInMemoryDBReplicaSetConnection {
        /**
         * The IP and subnet for your Replicaset.
         */
        cidr: string;
        /**
         * The datacenter to connect your Replicaset to.
         */
        datacenterId: string;
        /**
         * The numeric LAN ID to connect your Replicaset to.
         */
        lanId: string;
    }

    export interface GetInMemoryDBReplicaSetCredential {
        /**
         * The username for your Replicaset.
         */
        username: string;
    }

    export interface GetInMemoryDBReplicaSetMaintenanceWindow {
        /**
         * The name of the week day.
         */
        dayOfTheWeek: string;
        /**
         * Start of the maintenance window in UTC time.
         */
        time: string;
    }

    export interface GetInMemoryDBReplicaSetResource {
        /**
         * The number of CPU cores per instance.
         */
        cores: number;
        /**
         * The amount of memory per instance in gigabytes (GB).
         */
        ram: number;
        /**
         * The amount of storage per instance in gigabytes (GB).
         */
        storage: number;
    }

    export interface GetInmemorydbSnapshotMetadata {
        /**
         * The ISO 8601 creation timestamp.
         */
        createdDate: string;
        /**
         * The ID of the datacenter the snapshot was created in. Please mind, that the snapshot is not available in other datacenters.
         */
        datacenterId: string;
        /**
         * The ISO 8601 modified timestamp.
         */
        lastModifiedDate: string;
        /**
         * The ID of the InMemoryDB replica set the snapshot is taken from.
         */
        replicaSetId: string;
        /**
         * The time the snapshot was dumped from the replica set.
         */
        snapshotTime: string;
    }

    export interface GetMariaDBBackupsBackup {
        /**
         * The list of backups for the specified cluster
         */
        baseBackups: outputs.dbaas.GetMariaDBBackupsBackupBaseBackup[];
        /**
         * The unique ID of the cluster that was backed up
         */
        clusterId: string;
        /**
         * The oldest available timestamp to which you can restore
         */
        earliestRecoveryTargetTime: string;
        /**
         * Size of all base backups in Mebibytes (MiB). This is at least the sum of all base backup sizes
         */
        size: number;
    }

    export interface GetMariaDBBackupsBackupBaseBackup {
        /**
         * The ISO 8601 creation timestamp
         */
        created: string;
        /**
         * The size of the backup in Mebibytes (MiB). This is the size of the binary backup file that was stored
         */
        size: number;
    }

    export interface GetMariaDBClusterConnection {
        /**
         * The IP and subnet for your cluster.
         */
        cidr: string;
        /**
         * The datacenter to connect your cluster to.
         */
        datacenterId: string;
        /**
         * The numeric LAN ID to connect your cluster to.
         */
        lanId: string;
    }

    export interface GetMariaDBClusterMaintenanceWindow {
        /**
         * The name of the week day.
         */
        dayOfTheWeek: string;
        /**
         * Start of the maintenance window in UTC time.
         */
        time: string;
    }

    export interface GetMongoClusterBackup {
        /**
         * The location where the cluster backups will be stored. If not set, the backup is stored in the nearest location of the cluster. Examples: de, eu-sounth-2, eu-central-2
         */
        location: string;
    }

    export interface GetMongoClusterBiConnector {
        /**
         * Enable or disable the BiConnector
         */
        enabled: boolean;
        /**
         * The host where this new BI Connector is installed
         */
        host: string;
        /**
         * Port number used when connecting to this new BI Connector
         */
        port: string;
    }

    export interface GetMongoClusterConnection {
        /**
         * The list of IPs and subnet for your cluster.
         *           Note the following unavailable IP ranges:
         *           10.233.64.0/18
         *           10.233.0.0/18
         *           10.233.114.0/24 		
         *  example: [192.168.1.100/24, 192.168.1.101/24]
         */
        cidrLists: string[];
        /**
         * The datacenter to connect your cluster to
         */
        datacenterId: string;
        /**
         * The LAN to connect your cluster to
         */
        lanId: string;
    }

    export interface GetMongoClusterMaintenanceWindow {
        dayOfTheWeek: string;
        time: string;
    }

    export interface GetMongoUserRole {
        database: string;
        /**
         * A list of mongodb user roles. Examples: read, readWrite, readAnyDatabase
         */
        role: string;
    }

    export interface GetPSQLBackupsClusterBackup {
        /**
         * The unique ID of the cluster
         */
        clusterId: string;
        /**
         * The oldest available timestamp to which you can restore.
         */
        earliestRecoveryTargetTime: string;
        /**
         * The unique ID of the resource.
         */
        id: string;
        /**
         * Whether a cluster currently backs up data to this backup.
         */
        isActive: boolean;
        /**
         * The Object Storage location where the backups will be stored.
         */
        location: string;
        /**
         * Metadata of the resource
         */
        metadatas: outputs.dbaas.GetPSQLBackupsClusterBackupMetadata[];
        /**
         * Size of all base backups including the wal size in MB.
         */
        size: number;
        type: string;
        /**
         * The PostgreSQL version this backup was created from.
         */
        version: string;
    }

    export interface GetPSQLBackupsClusterBackupMetadata {
        /**
         * The ISO 8601 creation timestamp.
         */
        createdDate: string;
    }

    export interface GetPSQLClusterConnection {
        /**
         * The IP and subnet for the database. Note the following unavailable IP ranges: 10.233.64.0/18, 10.233.0.0/18, 10.233.114.0/24
         */
        cidr: string;
        /**
         * The datacenter to connect your cluster to.
         */
        datacenterId: string;
        /**
         * The LAN to connect your cluster to.
         */
        lanId: string;
    }

    export interface GetPSQLClusterConnectionPooler {
        enabled: boolean;
        /**
         * Represents different modes of connection pooling for the connection pooler
         */
        poolMode: string;
    }

    export interface GetPSQLClusterFromBackup {
        /**
         * The unique ID of the backup you want to restore.
         */
        backupId: string;
        /**
         * If this value is supplied as ISO 8601 timestamp, the backup will be replayed up until the given timestamp. If empty, the backup will be applied completely.
         */
        recoveryTargetTime: string;
    }

    export interface GetPSQLClusterMaintenanceWindow {
        dayOfTheWeek: string;
        time: string;
    }

    export interface GetPSQLDatabasesDatabase {
        id: string;
        name: string;
        owner: string;
    }

    export interface InMemoryDBReplicaSetConnections {
        /**
         * The IP and subnet for your instance. Note the following unavailable IP ranges: 10.233.64.0/18, 10.233.0.0/18, 10.233.114.0/24
         */
        cidr: string;
        /**
         * The datacenter to connect your instance to.
         */
        datacenterId: string;
        /**
         * The numeric LAN ID to connect your instance to.
         */
        lanId: string;
    }

    export interface InMemoryDBReplicaSetCredentials {
        /**
         * The hashed password for a InMemoryDB user.
         */
        hashedPassword?: outputs.dbaas.InMemoryDBReplicaSetCredentialsHashedPassword;
        /**
         * The password for a InMemoryDB user.
         */
        plainTextPassword?: string;
        /**
         * The username for the initial InMemoryDB user. Some system usernames are restricted (e.g. 'admin', 'standby').
         */
        username: string;
    }

    export interface InMemoryDBReplicaSetCredentialsHashedPassword {
        algorithm: string;
        hash: string;
    }

    export interface InMemoryDBReplicaSetMaintenanceWindow {
        /**
         * The name of the week day.
         */
        dayOfTheWeek: string;
        /**
         * Start of the maintenance window in UTC time.
         */
        time: string;
    }

    export interface InMemoryDBReplicaSetResources {
        /**
         * The number of CPU cores per instance.
         */
        cores: number;
        /**
         * The amount of memory per instance in gigabytes (GB).
         */
        ram: number;
        /**
         * The size of the storage in GB. The size is derived from the amount of RAM and the persistence mode and is not configurable.
         */
        storage: number;
    }

    export interface MariaDBClusterConnections {
        /**
         * The IP and subnet for your cluster.
         */
        cidr: string;
        /**
         * The datacenter to connect your cluster to.
         */
        datacenterId: string;
        /**
         * The numeric LAN ID to connect your cluster to.
         */
        lanId: string;
    }

    export interface MariaDBClusterCredentials {
        /**
         * The password for a MariaDB user.
         */
        password: string;
        /**
         * The username for the initial MariaDB user. Some system usernames are restricted (e.g 'mariadb', 'admin', 'standby').
         */
        username: string;
    }

    export interface MariaDBClusterMaintenanceWindow {
        /**
         * The name of the week day.
         */
        dayOfTheWeek: string;
        /**
         * Start of the maintenance window in UTC time.
         */
        time: string;
    }

    export interface MongoClusterBackup {
        /**
         * The location where the cluster backups will be stored. If not set, the backup is stored in the nearest location of the cluster. Examples: de, eu-sounth-2, eu-central-2
         */
        location?: string;
        /**
         * Number of hours in the past for which a point-in-time snapshot can be created.
         */
        pointInTimeWindowHours?: number;
        /**
         * Number of hours between snapshots.
         */
        snapshotIntervalHours?: number;
    }

    export interface MongoClusterBiConnector {
        /**
         * Enable or disable the BiConnector.
         */
        enabled?: boolean;
        /**
         * The host where this new BI Connector is installed.
         */
        host: string;
        /**
         * Port number used when connecting to this new BI Connector.
         */
        port: string;
    }

    export interface MongoClusterConnections {
        /**
         * The list of IPs and subnet for your cluster. Note the following unavailable IP ranges:10.233.64.0/18, 10.233.0.0/18, 10.233.114.0/24. example: [192.168.1.100/24, 192.168.1.101/24]
         */
        cidrLists: string[];
        /**
         * The datacenter to connect your cluster to.
         */
        datacenterId: string;
        /**
         * The LAN to connect your cluster to.
         */
        lanId: string;
    }

    export interface MongoClusterMaintenanceWindow {
        dayOfTheWeek: string;
        time: string;
    }

    export interface MongoUserRole {
        database?: string;
        /**
         * A list of mongodb user roles. Examples: read, readWrite, readAnyDatabase
         */
        role?: string;
    }

    export interface PSQLClusterConnectionPooler {
        enabled: boolean;
        /**
         * Represents different modes of connection pooling for the connection pooler
         */
        poolMode: string;
    }

    export interface PSQLClusterConnections {
        /**
         * The IP and subnet for the database.
         *           Note the following unavailable IP ranges:
         *           10.233.64.0/18
         *           10.233.0.0/18
         *           10.233.114.0/24
         */
        cidr: string;
        /**
         * The datacenter to connect your cluster to.
         */
        datacenterId: string;
        /**
         * The LAN to connect your cluster to.
         */
        lanId: string;
    }

    export interface PSQLClusterCredentials {
        password: string;
        /**
         * the username for the initial postgres user. some system usernames are restricted (e.g. "postgres", "admin", "standby")
         */
        username: string;
    }

    export interface PSQLClusterFromBackup {
        /**
         * The unique ID of the backup you want to restore.
         */
        backupId: string;
        /**
         * If this value is supplied as ISO 8601 timestamp, the backup will be replayed up until the given timestamp. If empty, the backup will be applied completely.
         */
        recoveryTargetTime?: string;
    }

    export interface PSQLClusterMaintenanceWindow {
        dayOfTheWeek: string;
        time: string;
    }

}

export namespace dsaas {
    export interface ClusterLan {
        /**
         * Indicates if the Kubernetes node pool LAN will reserve an IP using DHCP. The default value is 'true'
         */
        dhcp?: boolean;
        /**
         * The LAN ID of an existing LAN at the related data center
         */
        lanId: string;
        /**
         * An array of additional LANs attached to worker nodes
         */
        routes?: outputs.dsaas.ClusterLanRoute[];
    }

    export interface ClusterLanRoute {
        /**
         * IPv4 or IPv6 gateway IP for the route
         */
        gateway: string;
        /**
         * IPv4 or IPv6 CIDR to be routed via the interface
         */
        network: string;
    }

    export interface ClusterMaintenanceWindow {
        dayOfTheWeek: string;
        /**
         * Time at which the maintenance should start.
         */
        time: string;
    }

    export interface GetClusterConfig {
        apiVersion: string;
        clusters: outputs.dsaas.GetClusterConfigCluster[];
        contexts: outputs.dsaas.GetClusterConfigContext[];
        currentContext: string;
        kind: string;
        users: outputs.dsaas.GetClusterConfigUser[];
    }

    export interface GetClusterConfigCluster {
        cluster: {[key: string]: string};
        name: string;
    }

    export interface GetClusterConfigContext {
        context: {[key: string]: string};
        name: string;
    }

    export interface GetClusterConfigUser {
        name: string;
        user: {[key: string]: string};
    }

    export interface GetClusterLan {
        /**
         * Indicates if the Kubernetes node pool LAN will reserve an IP using DHCP. The default value is 'true'
         */
        dhcp: boolean;
        /**
         * The LAN ID of an existing LAN at the related data center
         */
        lanId: string;
        /**
         * An array of additional LANs attached to worker nodes
         */
        routes: outputs.dsaas.GetClusterLanRoute[];
    }

    export interface GetClusterLanRoute {
        /**
         * IPv4 or IPv6 gateway IP for the route
         */
        gateway: string;
        /**
         * IPv4 or IPv6 CIDR to be routed via the interface
         */
        network: string;
    }

    export interface GetClusterMaintenanceWindow {
        dayOfTheWeek: string;
        /**
         * Time at which the maintenance should start. Must conform to the 'HH:MM:SS' 24-hour format.
         */
        time: string;
    }

    export interface GetNodePoolAutoScaling {
        /**
         * The maximum number of worker nodes that the node pool can scale to. Should be greater than min_node_count
         */
        maxNodeCount: number;
        /**
         * The minimum number of worker nodes the node pool can scale down to. Should be less than max_node_count
         */
        minNodeCount: number;
    }

    export interface GetNodePoolMaintenanceWindow {
        dayOfTheWeek: string;
        /**
         * Time at which the maintenance should start. Must conform to the 'HH:MM:SS' 24-hour format.
         */
        time: string;
    }

    export interface GetNodePoolsNodePool {
        /**
         * Key-value pairs attached to node pool resource as kubernetes annotations
         */
        annotations: {[key: string]: string};
        /**
         * The availability zone of the virtual datacenter region where the node pool resources should be provisioned.
         */
        availabilityZone: string;
        /**
         * The number of CPU cores per node.
         */
        coresCount: number;
        /**
         * A valid CPU family name or `AUTO` if the platform shall choose the best fitting option. Available CPU architectures can be retrieved from the datacenter resource.
         */
        cpuFamily: string;
        /**
         * The UUID of the virtual data center (VDC) in which the node pool is provisioned
         */
        datacenterId: string;
        id: string;
        /**
         * Key-value pairs attached to the node pool resource as kubernetes labels
         */
        labels: {[key: string]: string};
        /**
         * Starting time of a weekly 4 hour-long window, during which maintenance might occur in hh:mm:ss format
         */
        maintenanceWindows: outputs.dsaas.GetNodePoolsNodePoolMaintenanceWindow[];
        /**
         * The name of your node pool.
         */
        name: string;
        /**
         * The number of nodes that make up the node pool.
         */
        nodeCount: number;
        /**
         * The RAM size for one node in MB. Must be set in multiples of 1024 MB, with a minimum size is of 2048 MB.
         */
        ramSize: number;
        /**
         * The size of the volume in GB. The size must be greater than 10GB.
         */
        storageSize: number;
        /**
         * The type of hardware for the volume.
         */
        storageType: string;
        /**
         * The version of the Data Platform.
         */
        version: string;
    }

    export interface GetNodePoolsNodePoolMaintenanceWindow {
        dayOfTheWeek: string;
        /**
         * Time at which the maintenance should start. Must conform to the 'HH:MM:SS' 24-hour format.
         */
        time: string;
    }

    export interface NodePoolAutoScaling {
        /**
         * The maximum number of worker nodes that the node pool can scale to. Should be greater than min_node_count
         */
        maxNodeCount: number;
        /**
         * The minimum number of worker nodes the node pool can scale down to. Should be less than max_node_count
         */
        minNodeCount: number;
    }

    export interface NodePoolMaintenanceWindow {
        dayOfTheWeek: string;
        /**
         * Time at which the maintenance should start.
         */
        time: string;
    }

}

export namespace k8s {
    export interface ClusterMaintenanceWindow {
        /**
         * Day of the week when maintenance is allowed
         */
        dayOfTheWeek: string;
        /**
         * A clock time in the day when maintenance is allowed
         */
        time: string;
    }

    export interface ClusterS3Bucket {
        /**
         * Name of the Object Storage bucket
         */
        name?: string;
    }

    export interface GetClusterConfig {
        apiVersion: string;
        clusters: outputs.k8s.GetClusterConfigCluster[];
        contexts: outputs.k8s.GetClusterConfigContext[];
        currentContext: string;
        kind: string;
        users: outputs.k8s.GetClusterConfigUser[];
    }

    export interface GetClusterConfigCluster {
        cluster: {[key: string]: string};
        name: string;
    }

    export interface GetClusterConfigContext {
        context: {[key: string]: string};
        name: string;
    }

    export interface GetClusterConfigUser {
        name: string;
        user: {[key: string]: string};
    }

    export interface GetClusterMaintenanceWindow {
        /**
         * Day of the week when maintenance is allowed
         */
        dayOfTheWeek: string;
        /**
         * A clock time in the day when maintenance is allowed
         */
        time: string;
    }

    export interface GetClusterS3Bucket {
        /**
         * Name of the Object Storage bucket
         */
        name: string;
    }

    export interface GetClustersCluster {
        /**
         * Access to the K8s API server is restricted to these CIDRs. Cluster-internal traffic is not affected by this restriction. If no allowlist is specified, access is not restricted. If an IP without subnet mask is provided, the default value will be used: 32 for IPv4 and 128 for IPv6.
         */
        apiSubnetAllowLists: string[];
        /**
         * A list of available versions for upgrading the cluster
         */
        availableUpgradeVersions: string[];
        caCrt: string;
        configs: outputs.k8s.GetClustersClusterConfig[];
        id: string;
        k8sVersion: string;
        kubeConfig: string;
        location: string;
        /**
         * A maintenance window comprise of a day of the week and a time for maintenance to be allowed
         */
        maintenanceWindows: outputs.k8s.GetClustersClusterMaintenanceWindow[];
        name: string;
        /**
         * The NAT gateway IP of the cluster if the cluster is private.
         */
        natGatewayIp: string;
        nodePools: string[];
        /**
         * The node subnet of the cluster, if the cluster is private.
         */
        nodeSubnet: string;
        /**
         * The indicator if the cluster is public or private.
         */
        public: boolean;
        /**
         * List of Object Storage bucket configured for K8s usage. For now it contains only an Object Storage bucket used to store K8s API audit logs.
         */
        s3Buckets: outputs.k8s.GetClustersClusterS3Bucket[];
        server: string;
        state: string;
        userTokens: {[key: string]: string};
        /**
         * A list of versions that may be used for node pools under this cluster
         */
        viableNodePoolVersions: string[];
    }

    export interface GetClustersClusterConfig {
        apiVersion: string;
        clusters: outputs.k8s.GetClustersClusterConfigCluster[];
        contexts: outputs.k8s.GetClustersClusterConfigContext[];
        currentContext: string;
        kind: string;
        users: outputs.k8s.GetClustersClusterConfigUser[];
    }

    export interface GetClustersClusterConfigCluster {
        cluster: {[key: string]: string};
        name: string;
    }

    export interface GetClustersClusterConfigContext {
        context: {[key: string]: string};
        name: string;
    }

    export interface GetClustersClusterConfigUser {
        name: string;
        user: {[key: string]: string};
    }

    export interface GetClustersClusterMaintenanceWindow {
        /**
         * Day of the week when maintenance is allowed
         */
        dayOfTheWeek: string;
        /**
         * A clock time in the day when maintenance is allowed
         */
        time: string;
    }

    export interface GetClustersClusterS3Bucket {
        /**
         * Name of the Object Storage bucket
         */
        name: string;
    }

    export interface GetClustersFilter {
        name: string;
        value: string;
    }

    export interface GetNodePoolAutoScaling {
        /**
         * The maximum number of worker nodes that the node pool can scale to. Should be greater than min_node_count
         */
        maxNodeCount: number;
        /**
         * The minimum number of worker nodes the node pool can scale down to. Should be less than max_node_count
         */
        minNodeCount: number;
    }

    export interface GetNodePoolLan {
        /**
         * Indicates if the Kubernetes Node Pool LAN will reserve an IP using DHCP
         */
        dhcp: boolean;
        /**
         * The LAN ID of an existing LAN at the related datacenter
         */
        id: number;
        /**
         * An array of additional LANs attached to worker nodes
         */
        routes?: outputs.k8s.GetNodePoolLanRoute[];
    }

    export interface GetNodePoolLanRoute {
        /**
         * IPv4 or IPv6 Gateway IP for the route
         */
        gatewayIp: string;
        /**
         * IPv4 or IPv6 CIDR to be routed via the interface
         */
        network: string;
    }

    export interface GetNodePoolMaintenanceWindow {
        /**
         * Day of the week when maintenance is allowed
         */
        dayOfTheWeek: string;
        /**
         * A clock time in the day when maintenance is allowed
         */
        time: string;
    }

    export interface GetNodePoolNodesNode {
        id: string;
        /**
         * The kubernetes version
         */
        k8sVersion: string;
        /**
         * The kubernetes node name
         */
        name: string;
        /**
         * A valid private IP
         */
        privateIp: string;
        /**
         * A valid public IP
         */
        publicIp: string;
    }

    export interface NodePoolAutoScaling {
        /**
         * The maximum number of worker nodes that the node pool can scale to. Should be greater than min_node_count
         */
        maxNodeCount: number;
        /**
         * The minimum number of worker nodes the node pool can scale down to. Should be less than max_node_count
         */
        minNodeCount: number;
    }

    export interface NodePoolLan {
        /**
         * Indicates if the Kubernetes Node Pool LAN will reserve an IP using DHCP
         */
        dhcp?: boolean;
        /**
         * The LAN ID of an existing LAN at the related datacenter
         */
        id: number;
        /**
         * An array of additional LANs attached to worker nodes
         */
        routes?: outputs.k8s.NodePoolLanRoute[];
    }

    export interface NodePoolLanRoute {
        /**
         * IPv4 or IPv6 Gateway IP for the route
         */
        gatewayIp: string;
        /**
         * IPv4 or IPv6 CIDR to be routed via the interface
         */
        network: string;
    }

    export interface NodePoolMaintenanceWindow {
        /**
         * Day of the week when maintenance is allowed
         */
        dayOfTheWeek: string;
        /**
         * A clock time in the day when maintenance is allowed
         */
        time: string;
    }

}

export namespace kafka {
    export interface ClusterConnections {
        /**
         * The broker addresses of the Kafka Cluster. Can be empty, but must be present.
         */
        brokerAddresses: string[];
        /**
         * The datacenter to connect your Kafka Cluster to.
         */
        datacenterId: string;
        /**
         * The numeric LAN ID to connect your Kafka Cluster to.
         */
        lanId: string;
    }

    export interface GetClusterConnection {
        /**
         * The broker addresses of the Kafka Cluster
         */
        brokerAddresses: string[];
        /**
         * The datacenter to connect your Kafka Cluster to.
         */
        datacenterId: string;
        /**
         * The numeric LAN ID to connect your Kafka Cluster to.
         */
        lanId: string;
    }

}

export namespace logging {
    export interface GetPipelineLog {
        /**
         * The internal output stream to send logs to. Possible values are: loki.
         */
        destinations: outputs.logging.GetPipelineLogDestination[];
        /**
         * Protocol to use as intake. Possible values are: http, tcp.
         */
        protocol: string;
        public: boolean;
        /**
         * The source parser to be used
         */
        source: string;
        /**
         * The tag is used to distinguish different pipelines. Must be unique amongst the pipeline's array items.
         */
        tag: string;
    }

    export interface GetPipelineLogDestination {
        /**
         * Defines the number of days a log record should be kept in loki. Works with loki destination type only. Possible values are: 7, 14, 30.
         */
        retentionInDays: number;
        type: string;
    }

    export interface PipelineLog {
        /**
         * The internal output stream to send logs to. Possible values are: loki.
         */
        destinations: outputs.logging.PipelineLogDestination[];
        /**
         * Protocol to use as intake. Possible values are: http, tcp.
         */
        protocol: string;
        public: boolean;
        /**
         * The source parser to be used
         */
        source: string;
        /**
         * The tag is used to distinguish different pipelines. Must be unique amongst the pipeline's array items.
         */
        tag: string;
    }

    export interface PipelineLogDestination {
        /**
         * Defines the number of days a log record should be kept in loki. Works with loki destination type only. Possible values are: 7, 14, 30.
         */
        retentionInDays: number;
        type: string;
    }

}

export namespace nfs {
    export interface ClusterConnections {
        /**
         * The datacenter to connect your instance to.
         */
        datacenterId: string;
        /**
         * The IP address and subnet for your instance.
         */
        ipAddress: string;
        /**
         * The numeric LAN ID to connect your instance to.
         */
        lan: string;
    }

    export interface ClusterNfs {
        /**
         * The minimum Network File Storage version
         */
        minVersion?: string;
    }

    export interface GetClusterConnection {
        /**
         * The datacenter ID of the connection.
         */
        datacenterId: string;
        /**
         * The IP address of the connection.
         */
        ipAddress: string;
        /**
         * The LAN of the connection.
         */
        lan: string;
    }

    export interface GetClusterNf {
        /**
         * The minimum version of the NFS.
         */
        minVersion: string;
    }

    export interface GetShareClientGroup {
        /**
         * Optional description for the clients groups.
         */
        description: string;
        /**
         * A singular host allowed to connect to the share. The host can be specified as IP address and can be either IPv4 or IPv6.
         */
        hosts: string[];
        /**
         * The allowed host or network to which the export is being shared. The IP address can be either IPv4 or IPv6 and has to be given with CIDR notation.
         */
        ipNetworks: string[];
        nfs: outputs.nfs.GetShareClientGroupNf[];
    }

    export interface GetShareClientGroupNf {
        /**
         * The squash mode for the export. The squash mode can be: none - No squash mode. no mapping, root-anonymous - Map root user to anonymous uid, all-anonymous - Map all users to anonymous uid.
         */
        squash: string;
    }

    export interface ShareClientGroup {
        /**
         * Optional description for the clients groups.
         */
        description?: string;
        /**
         * A singular host allowed to connect to the share. The host can be specified as IP address and can be either IPv4 or IPv6.
         */
        hosts: string[];
        /**
         * The allowed host or network to which the export is being shared. The IP address can be either IPv4 or IPv6 and has to be given with CIDR notation.
         */
        ipNetworks: string[];
        nfs?: outputs.nfs.ShareClientGroupNfs;
    }

    export interface ShareClientGroupNfs {
        /**
         * The squash mode for the export. The squash mode can be: none - No squash mode. no mapping, root-anonymous - Map root user to anonymous uid, all-anonymous - Map all users to anonymous uid.
         */
        squash?: string;
    }

}

export namespace nlb {
    export interface BalancerFlowlog {
        /**
         * Specifies the traffic direction pattern. Valid values: ACCEPTED, REJECTED, ALL. Immutable, forces re-recreation of the nic resource.
         */
        action: string;
        /**
         * The bucket name of an existing IONOS Object Storage bucket. Immutable, forces re-recreation of the nic resource.
         */
        bucket: string;
        /**
         * Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, forces re-recreation of the nic resource.
         */
        direction: string;
        /**
         * The resource's unique identifier.
         */
        id: string;
        /**
         * The resource name.
         */
        name: string;
    }

    export interface ForwardingRuleHealthCheck {
        /**
         * ClientTimeout is expressed in milliseconds. This inactivity timeout applies when the client is expected to acknowledge or send data. If unset the default of 50 seconds will be used.
         */
        clientTimeout: number;
        /**
         * It specifies the maximum time (in milliseconds) to wait for a connection attempt to a target VM to succeed. If unset, the default of 5 seconds will be used.
         */
        connectTimeout: number;
        /**
         * Retries specifies the number of retries to perform on a target VM after a connection failure. If unset, the default value of 3 will be used.
         */
        retries: number;
        /**
         * TargetTimeout specifies the maximum inactivity time (in milliseconds) on the target VM side. If unset, the default of 50 seconds will be used.
         */
        targetTimeout: number;
    }

    export interface ForwardingRuleTarget {
        /**
         * Health check attributes for Network Load Balancer forwarding rule target
         */
        healthCheck: outputs.nlb.ForwardingRuleTargetHealthCheck;
        /**
         * IP of a balanced target VM
         */
        ip: string;
        /**
         * Port of the balanced target service. (range: 1 to 65535)
         */
        port: number;
        /**
         * Proxy protocol version
         */
        proxyProtocol?: string;
        /**
         * Weight parameter is used to adjust the target VM's weight relative to other target VMs
         */
        weight: number;
    }

    export interface ForwardingRuleTargetHealthCheck {
        /**
         * Check specifies whether the target VM's health is checked.
         */
        check: boolean;
        /**
         * CheckInterval determines the duration (in milliseconds) between consecutive health checks. If unspecified a default of 2000 ms is used.
         */
        checkInterval: number;
        /**
         * Maintenance specifies if a target VM should be marked as down, even if it is not.
         */
        maintenance: boolean;
    }

    export interface GetBalancerFlowlog {
        /**
         * Specifies the traffic direction pattern. Valid values: ACCEPTED, REJECTED, ALL.
         */
        action: string;
        /**
         * The bucket name of an existing IONOS Object Storage bucket.
         */
        bucket: string;
        /**
         * Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL.
         */
        direction: string;
        /**
         * The resource's unique identifier.
         */
        id: string;
        /**
         * The resource name.
         */
        name: string;
    }

    export interface GetForwardingRuleHealthCheck {
        /**
         * ClientTimeout is expressed in milliseconds. This inactivity timeout applies when the client is expected to acknowledge or send data. If unset the default of 50 seconds will be used.
         */
        clientTimeout: number;
        /**
         * It specifies the maximum time (in milliseconds) to wait for a connection attempt to a target VM to succeed. If unset, the default of 5 seconds will be used.
         */
        connectTimeout: number;
        /**
         * Retries specifies the number of retries to perform on a target VM after a connection failure. If unset, the default value of 3 will be used.
         */
        retries: number;
        /**
         * TargetTimeout specifies the maximum inactivity time (in milliseconds) on the target VM side. If unset, the default of 50 seconds will be used.
         */
        targetTimeout: number;
    }

    export interface GetForwardingRuleTarget {
        /**
         * Health check attributes for Network Load Balancer forwarding rule target
         */
        healthChecks: outputs.nlb.GetForwardingRuleTargetHealthCheck[];
        /**
         * IP of a balanced target VM
         */
        ip: string;
        /**
         * Port of the balanced target service. (range: 1 to 65535)
         */
        port: number;
        /**
         * Proxy protocol version
         */
        proxyProtocol: string;
        /**
         * Weight parameter is used to adjust the target VM's weight relative to other target VMs
         */
        weight: number;
    }

    export interface GetForwardingRuleTargetHealthCheck {
        /**
         * Check specifies whether the target VM's health is checked.
         */
        check: boolean;
        /**
         * CheckInterval determines the duration (in milliseconds) between consecutive health checks. If unspecified a default of 2000 ms is used.
         */
        checkInterval: number;
        /**
         * Maintenance specifies if a target VM should be marked as down, even if it is not.
         */
        maintenance: boolean;
    }

}

export namespace nsg {
    export interface GetNsgRule {
        icmpCode: string;
        icmpType: string;
        id: string;
        name: string;
        portRangeEnd: number;
        portRangeStart: number;
        protocol: string;
        sourceIp: string;
        sourceMac: string;
        targetIp: string;
        type: string;
    }

}

export namespace objectstorage {
    export interface BucketLifecycleConfigurationRule {
        /**
         * Specifies the days since the initiation of an incomplete multipart upload that IONOS Object Storage Object Storage will wait before permanently removing all parts of the upload.
         */
        abortIncompleteMultipartUpload?: outputs.objectstorage.BucketLifecycleConfigurationRuleAbortIncompleteMultipartUpload;
        /**
         * A lifecycle rule for when an object expires.
         */
        expiration?: outputs.objectstorage.BucketLifecycleConfigurationRuleExpiration;
        /**
         * Unique identifier for the rule.
         */
        id: string;
        /**
         * A lifecycle rule for when non-current object versions expire.
         */
        noncurrentVersionExpiration?: outputs.objectstorage.BucketLifecycleConfigurationRuleNoncurrentVersionExpiration;
        /**
         * Object key prefix identifying one or more objects to which the rule applies.
         */
        prefix: string;
        /**
         * Whether the rule is currently being applied. Valid values: Enabled or Disabled.
         */
        status: string;
    }

    export interface BucketLifecycleConfigurationRuleAbortIncompleteMultipartUpload {
        /**
         * Specifies the number of days after which IONOS Object Storage Object Storage aborts an incomplete multipart upload.
         */
        daysAfterInitiation?: number;
    }

    export interface BucketLifecycleConfigurationRuleExpiration {
        /**
         * Specifies the date when the object expires. Required if 'days' is not specified.
         */
        date?: string;
        /**
         * Specifies the number of days after object creation when the object expires. Required if 'date' is not specified.
         */
        days?: number;
        /**
         * Indicates whether IONOS Object Storage Object Storage will remove a delete marker with no noncurrent versions. If set to true, the delete marker will be expired; if set to false the policy takes no operation. This cannot be specified with Days or Date in a Lifecycle Expiration Policy.
         */
        expiredObjectDeleteMarker?: boolean;
    }

    export interface BucketLifecycleConfigurationRuleNoncurrentVersionExpiration {
        /**
         * Specifies the number of days an object is noncurrent before IONOS Object Storage can perform the associated action.
         */
        noncurrentDays?: number;
    }

    export interface BucketServerSideEncryptionConfigurationRule {
        /**
         * Defines the default encryption settings.
         */
        applyServerSideEncryptionByDefault?: outputs.objectstorage.BucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault;
    }

    export interface BucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault {
        /**
         * Server-side encryption algorithm to use. Valid values are 'AES256'
         */
        sseAlgorithm: string;
    }

    export interface BucketTimeouts {
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        create?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
         */
        delete?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
         */
        read?: string;
        /**
         * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
         */
        update?: string;
    }

    export interface BucketVersioningVersioningConfiguration {
        /**
         * The MFA delete status of the bucket.
         */
        mfaDelete: string;
        /**
         * The versioning status of the bucket.
         */
        status: string;
    }

    export interface CorsConfigurationCorsRule {
        /**
         * Specifies which headers are allowed in a preflight OPTIONS request through the Access-Control-Request-Headers header.
         */
        allowedHeaders?: string[];
        /**
         * An HTTP method that you allow the origin to execute. Valid values are GET, PUT, HEAD, POST, DELETE.
         */
        allowedMethods: string[];
        /**
         * One or more origins you want customers to be able to access the bucket from.
         */
        allowedOrigins: string[];
        /**
         * One or more headers in the response that you want customers to be able to access from their applications.
         */
        exposeHeaders?: string[];
        /**
         * Container for the Contract Number of the owner.
         */
        id?: number;
        /**
         * The time in seconds that your browser is to cache the preflight response for the specified resource.
         */
        maxAgeSeconds?: number;
    }

    export interface ObjectLockConfigurationRule {
        defaultRetention?: outputs.objectstorage.ObjectLockConfigurationRuleDefaultRetention;
    }

    export interface ObjectLockConfigurationRuleDefaultRetention {
        days?: number;
        mode?: string;
        years?: number;
    }

    export interface WebsiteConfigurationErrorDocument {
        /**
         * The object key.
         */
        key?: string;
    }

    export interface WebsiteConfigurationIndexDocument {
        /**
         * A suffix that is appended to a request that is for a directory on the website endpoint (for example, if the suffix is index.html and you make a request to samplebucket/images/ the data that is returned will be for the object with the key name images/index.html) The suffix must not be empty and must not include a slash character. Replacement must be made for object keys containing special characters (such as carriage returns) when using XML requests.
         */
        suffix?: string;
    }

    export interface WebsiteConfigurationRedirectAllRequestsTo {
        /**
         * The host name to use in the redirect request.
         */
        hostName?: string;
        /**
         * Protocol to use when redirecting requests. The default is the protocol that is used in the original request.
         */
        protocol?: string;
    }

    export interface WebsiteConfigurationRoutingRule {
        /**
         * A container for describing a condition that must be met for the specified redirect to apply. For example, 1. If request is for pages in the /docs folder, redirect to the /documents folder. 2. If request results in HTTP error 4xx, redirect request to another host where you might process the error.
         */
        condition?: outputs.objectstorage.WebsiteConfigurationRoutingRuleCondition;
        /**
         * Container for redirect information. You can redirect requests to another host, to another page, or with another protocol. In the event of an error, you can specify a different error code to return.
         */
        redirect?: outputs.objectstorage.WebsiteConfigurationRoutingRuleRedirect;
    }

    export interface WebsiteConfigurationRoutingRuleCondition {
        /**
         * The HTTP error code when the redirect is applied. In the event of an error, if the error code equals this value, then the specified redirect is applied. Required when parent element Condition is specified and sibling KeyPrefixEquals is not specified. If both are specified, then both must be true for the redirect to be applied
         */
        httpErrorCodeReturnedEquals?: string;
        /**
         * The object key name prefix when the redirect is applied. For example, to redirect requests for `ExamplePage.html`, the key prefix will be `ExamplePage.html`. To redirect request for all pages with the prefix `docs/`, the key prefix will be `/docs`, which identifies all objects in the `docs/` folder. Required when the parent element `Condition` is specified and sibling `HTTPErrorCodeReturnedEquals` is not specified. If both conditions are specified, both must be true for the redirect to be applied. Replacement must be made for object keys containing special characters (such as carriage returns) when using XML requests.
         */
        keyPrefixEquals?: string;
    }

    export interface WebsiteConfigurationRoutingRuleRedirect {
        /**
         * The host name to use in the redirect request.
         */
        hostName?: string;
        /**
         * The HTTP redirect code to use on the response.
         */
        httpRedirectCode?: string;
        /**
         * The protocol to use in the redirect request.
         */
        protocol?: string;
        /**
         * The object key prefix to use in the redirect request. For example, to redirect requests for all pages with prefix `docs/` (objects in the `docs/` folder) to `documents/`, you can set a condition block with `KeyPrefixEquals` set to `docs/` and in the Redirect set `ReplaceKeyPrefixWith` to `/documents`. Not required if one of the siblings is present. Can be present only if `ReplaceKeyWith` is not provided.
         */
        replaceKeyPrefixWith?: string;
        /**
         * The specific object key to use in the redirect request. For example, redirect request to error.html. Not required if one of the siblings is present. Can be present only if ReplaceKeyPrefixWith is not provided. Replacement must be made for object keys containing special characters (such as carriage returns) when using XML requests.
         */
        replaceKeyWith?: string;
    }

}

export namespace vpn {
    export interface GetIpsecGatewayConnection {
        /**
         * The datacenter to connect your VPN Gateway to.
         */
        datacenterId: string;
        /**
         * Describes the private ipv4 subnet in your LAN that should be accessible by the VPN Gateway. Note: this should be the subnet already assigned to the LAN
         */
        ipv4Cidr: string;
        /**
         * Describes the ipv6 subnet in your LAN that should be accessible by the VPN Gateway. Note: this should be the subnet already assigned to the LAN
         */
        ipv6Cidr: string;
        /**
         * The numeric LAN ID to connect your VPN Gateway to.
         */
        lanId: string;
    }

    export interface GetIpsecGatewayMaintenanceWindow {
        dayOfTheWeek: string;
        time: string;
    }

    export interface GetIpsecTunnelAuth {
        /**
         * The Authentication Method to use for IPSec Authentication.
         */
        method: string;
    }

    export interface GetIpsecTunnelEsp {
        /**
         * The Diffie-Hellman Group to use for IPSec Encryption.
         */
        diffieHellmanGroup: string;
        /**
         * The encryption algorithm to use for IPSec Encryption.
         */
        encryptionAlgorithm: string;
        /**
         * The integrity algorithm to use for IPSec Encryption.
         */
        integrityAlgorithm: string;
        /**
         * The phase lifetime in seconds.
         */
        lifetime: number;
    }

    export interface GetIpsecTunnelIke {
        /**
         * The Diffie-Hellman Group to use for IPSec Encryption.
         */
        diffieHellmanGroup: string;
        /**
         * The encryption algorithm to use for IPSec Encryption.
         */
        encryptionAlgorithm: string;
        /**
         * The integrity algorithm to use for IPSec Encryption.
         */
        integrityAlgorithm: string;
        /**
         * The phase lifetime in seconds.
         */
        lifetime: number;
    }

    export interface GetWireguardGatewayConnection {
        datacenterId: string;
        ipv4Cidr: string;
        ipv6Cidr: string;
        lanId: string;
    }

    export interface GetWireguardGatewayMaintenanceWindow {
        dayOfTheWeek: string;
        time: string;
    }

    export interface GetWireguardPeerEndpoint {
        host: string;
        port: number;
    }

    export interface IpsecGatewayConnection {
        /**
         * The datacenter to connect your VPN Gateway to.
         */
        datacenterId: string;
        /**
         * Describes the private ipv4 subnet in your LAN that should be accessible by the VPN Gateway. Note: this should be the subnet already assigned to the LAN
         */
        ipv4Cidr: string;
        /**
         * Describes the ipv6 subnet in your LAN that should be accessible by the VPN Gateway. Note: this should be the subnet already assigned to the LAN
         */
        ipv6Cidr?: string;
        /**
         * The numeric LAN ID to connect your VPN Gateway to.
         */
        lanId: string;
    }

    export interface IpsecGatewayMaintenanceWindow {
        /**
         * The name of the week day
         */
        dayOfTheWeek: string;
        /**
         * Start of the maintenance window in UTC time.
         */
        time: string;
    }

    export interface IpsecTunnelAuth {
        /**
         * The Authentication Method to use for IPSec Authentication.
         */
        method?: string;
        /**
         * The Pre-Shared Key to use for IPSec Authentication. Note: Required if method is PSK.
         */
        pskKey?: string;
    }

    export interface IpsecTunnelEsp {
        /**
         * The Diffie-Hellman Group to use for IPSec Encryption.
         */
        diffieHellmanGroup?: string;
        /**
         * The encryption algorithm to use for IPSec Encryption.
         */
        encryptionAlgorithm?: string;
        /**
         * The integrity algorithm to use for IPSec Encryption.
         */
        integrityAlgorithm?: string;
        /**
         * The phase lifetime in seconds.
         */
        lifetime?: number;
    }

    export interface IpsecTunnelIke {
        /**
         * The Diffie-Hellman Group to use for IPSec Encryption.
         */
        diffieHellmanGroup?: string;
        /**
         * The encryption algorithm to use for IPSec Encryption.
         */
        encryptionAlgorithm?: string;
        /**
         * The integrity algorithm to use for IPSec Encryption.
         */
        integrityAlgorithm?: string;
        /**
         * The phase lifetime in seconds.
         */
        lifetime?: number;
    }

    export interface WireguardGatewayConnection {
        datacenterId: string;
        ipv4Cidr?: string;
        ipv6Cidr?: string;
        lanId: string;
    }

    export interface WireguardGatewayMaintenanceWindow {
        /**
         * The name of the week day
         */
        dayOfTheWeek: string;
        /**
         * Start of the maintenance window in UTC time.
         */
        time: string;
    }

    export interface WireguardPeerEndpoint {
        /**
         * Hostname or IPV4 address that the WireGuard Server will connect to.
         */
        host: string;
        /**
         * Port that the WireGuard Server will connect to.
         */
        port?: number;
    }

}
