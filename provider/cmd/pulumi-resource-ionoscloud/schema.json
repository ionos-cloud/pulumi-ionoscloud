{
    "name": "ionoscloud",
    "displayName": "IonosCloud",
    "description": "A Pulumi package for creating and managing ionoscloud cloud resources.",
    "keywords": [
        "ionos-cloud",
        "ionoscloud",
        "category/cloud"
    ],
    "homepage": "https://www.pulumi.com",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`ionoscloud` Terraform Provider](https://github.com/ionos-cloud/terraform-provider-ionoscloud).",
    "repository": "https://github.com/ionos-cloud/pulumi-ionoscloud",
    "publisher": "ionos-cloud",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "language": {
        "csharp": {
            "packageReferences": {
                "Pulumi": "3.*"
            },
            "compatibility": "tfbridge20"
        },
        "go": {
            "importBasePath": "github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud",
            "generateResourceContainerTypes": true,
            "generateExtraInputTypes": true
        },
        "nodejs": {
            "packageDescription": "A Pulumi package for creating and managing ionoscloud cloud resources.",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/ionos-cloud/terraform-provider-ionoscloud)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-ionoscloud` repo](https://github.com/ionos-cloud/pulumi-ionoscloud/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-ionoscloud` repo](https://github.com/ionos-cloud/terraform-provider-ionoscloud/issues).",
            "dependencies": {
                "@pulumi/pulumi": "^3.0.0"
            },
            "devDependencies": {
                "@types/mime": "^2.0.0",
                "@types/node": "^10.0.0"
            },
            "compatibility": "tfbridge20",
            "disableUnionOutputTypes": true
        },
        "python": {
            "packageName": "ionoscloud",
            "requires": {
                "pulumi": "\u003e=3.0.0,\u003c4.0.0"
            },
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/ionos-cloud/terraform-provider-ionoscloud)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-ionoscloud` repo](https://github.com/ionos-cloud/pulumi-ionoscloud/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-ionoscloud` repo](https://github.com/ionos-cloud/terraform-provider-ionoscloud/issues).",
            "compatibility": "tfbridge20",
            "pyproject": {}
        }
    },
    "config": {
        "variables": {
            "contractNumber": {
                "type": "string"
            },
            "endpoint": {
                "type": "string",
                "description": "IonosCloud REST API URL. Usually not necessary to be set, SDKs know internally how to route requests to the API.\n"
            },
            "password": {
                "type": "string",
                "description": "IonosCloud password for API operations. If token is provided, token is preferred\n"
            },
            "retries": {
                "type": "integer",
                "deprecationMessage": "Timeout is used instead of this functionality"
            },
            "s3AccessKey": {
                "type": "string",
                "description": "Access key for IONOS Object Storage operations.\n"
            },
            "s3Region": {
                "type": "string",
                "description": "Region for IONOS Object Storage operations.\n"
            },
            "s3SecretKey": {
                "type": "string",
                "description": "Secret key for IONOS Object Storage operations.\n"
            },
            "token": {
                "type": "string",
                "description": "IonosCloud bearer token for API operations.\n"
            },
            "username": {
                "type": "string",
                "description": "IonosCloud username for API operations. If token is provided, token is preferred\n"
            }
        }
    },
    "types": {
        "ionoscloud:alb/BalancerFlowlog:BalancerFlowlog": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "[string] Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL. Immutable, forces re-creation.\n"
                },
                "bucket": {
                    "type": "string",
                    "description": "[string] Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist. Immutable, forces re-creation.\n"
                },
                "direction": {
                    "type": "string",
                    "description": "[string] Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, forces re-creation.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The resource's unique identifier.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] Specifies the name of the flow log.\n\n⚠️ **Note:**: Removing the `flowlog` forces re-creation of the application load balancer resource.\n"
                }
            },
            "type": "object",
            "required": [
                "action",
                "bucket",
                "direction",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "action",
                        "bucket",
                        "direction",
                        "id",
                        "name"
                    ]
                }
            }
        },
        "ionoscloud:alb/ForwardingRuleHttpRule:ForwardingRuleHttpRule": {
            "properties": {
                "conditions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:alb/ForwardingRuleHttpRuleCondition:ForwardingRuleHttpRuleCondition"
                    },
                    "description": "[list] - An array of items in the collection.The action is only performed if each and every condition is met; if no conditions are set, the rule will always be performed.\n"
                },
                "contentType": {
                    "type": "string",
                    "description": "[string] Valid only for STATIC actions.\n"
                },
                "dropQuery": {
                    "type": "boolean",
                    "description": "[bool] Default is false; valid only for REDIRECT actions.\n"
                },
                "location": {
                    "type": "string",
                    "description": "[string] The location for redirecting; mandatory and valid only for REDIRECT actions.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The unique name of the Application Load Balancer HTTP rule.\n"
                },
                "responseMessage": {
                    "type": "string",
                    "description": "[string] The response message of the request; mandatory for STATIC action.\n"
                },
                "statusCode": {
                    "type": "integer",
                    "description": "[int] Valid only for REDIRECT and STATIC actions. For REDIRECT actions, default is 301 and possible values are 301, 302, 303, 307, and 308. For STATIC actions, default is 503 and valid range is 200 to 599.\n"
                },
                "targetGroup": {
                    "type": "string",
                    "description": "[string] The UUID of the target group; mandatory for FORWARD action.\n"
                },
                "type": {
                    "type": "string",
                    "description": "[string] Type of the Http Rule.\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "conditions",
                        "contentType",
                        "name",
                        "statusCode",
                        "type"
                    ]
                }
            }
        },
        "ionoscloud:alb/ForwardingRuleHttpRuleCondition:ForwardingRuleHttpRuleCondition": {
            "properties": {
                "condition": {
                    "type": "string",
                    "description": "[string] Matching rule for the HTTP rule condition attribute; mandatory for HEADER, PATH, QUERY, METHOD, HOST, and COOKIE types; must be null when type is SOURCE_IP.\n"
                },
                "key": {
                    "type": "string",
                    "description": "[string] Must be null when type is PATH, METHOD, HOST, or SOURCE_IP. Key can only be set when type is COOKIES, HEADER, or QUERY.\n"
                },
                "negate": {
                    "type": "boolean",
                    "description": "[bool] Specifies whether the condition is negated or not; the default is False.\n"
                },
                "type": {
                    "type": "string",
                    "description": "[string] Type of the Http Rule condition.\n"
                },
                "value": {
                    "type": "string",
                    "description": "[string] Mandatory for conditions CONTAINS, EQUALS, MATCHES, STARTS_WITH, ENDS_WITH; must be null when condition is EXISTS; should be a valid CIDR if provided and if type is SOURCE_IP.\n"
                }
            },
            "type": "object",
            "required": [
                "type"
            ]
        },
        "ionoscloud:alb/getBalancerFlowlog:getBalancerFlowlog": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL. Immutable, forces re-creation.\n"
                },
                "bucket": {
                    "type": "string",
                    "description": "Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist. Immutable, forces re-creation.\n"
                },
                "direction": {
                    "type": "string",
                    "description": "Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, forces re-creation.\n"
                },
                "id": {
                    "type": "string",
                    "description": "ID of the application load balancer you want to search for.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of an existing application load balancer that you want to search for. Search by name is case-insensitive. The whole resource name is required if `partial_match` parameter is not set to true.\n"
                }
            },
            "type": "object",
            "required": [
                "action",
                "bucket",
                "direction",
                "id",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:alb/getForwardingRuleHttpRule:getForwardingRuleHttpRule": {
            "properties": {
                "conditions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:alb/getForwardingRuleHttpRuleCondition:getForwardingRuleHttpRuleCondition"
                    },
                    "description": "An array of items in the collection.The action is only performed if each and every condition is met; if no conditions are set, the rule will always be performed.\n"
                },
                "contentType": {
                    "type": "string",
                    "description": "Valid only for STATIC actions.\n"
                },
                "dropQuery": {
                    "type": "boolean",
                    "description": "Default is false; valid only for REDIRECT actions.\n"
                },
                "location": {
                    "type": "string",
                    "description": "The location for redirecting; mandatory and valid only for REDIRECT actions.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of an existing application load balancer that you want to search for. Search by name is case-insensitive. The whole resource name is required if `partial_match` parameter is not set to true.\n"
                },
                "responseMessage": {
                    "type": "string",
                    "description": "The response message of the request; mandatory for STATIC action.\n"
                },
                "statusCode": {
                    "type": "integer",
                    "description": "Valid only for REDIRECT and STATIC actions. For REDIRECT actions, default is 301 and possible values are 301, 302, 303, 307, and 308. For STATIC actions, default is 503 and valid range is 200 to 599.\n"
                },
                "targetGroup": {
                    "type": "string",
                    "description": "The UUID of the target group; mandatory for FORWARD action.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the Http Rule condition.\n"
                }
            },
            "type": "object",
            "required": [
                "conditions",
                "contentType",
                "dropQuery",
                "location",
                "name",
                "responseMessage",
                "statusCode",
                "targetGroup",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:alb/getForwardingRuleHttpRuleCondition:getForwardingRuleHttpRuleCondition": {
            "properties": {
                "condition": {
                    "type": "string",
                    "description": "Matching rule for the HTTP rule condition attribute; mandatory for HEADER, PATH, QUERY, METHOD, HOST, and COOKIE types; must be null when type is SOURCE_IP.\n"
                },
                "key": {
                    "type": "string",
                    "description": "Must be null when type is PATH, METHOD, HOST, or SOURCE_IP. Key can only be set when type is COOKIES, HEADER, or QUERY.\n"
                },
                "negate": {
                    "type": "boolean",
                    "description": "Specifies whether the condition is negated or not; the default is False.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the Http Rule condition.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Mandatory for conditions CONTAINS, EQUALS, MATCHES, STARTS_WITH, ENDS_WITH; must be null when condition is EXISTS; should be a valid CIDR if provided and if type is SOURCE_IP.\n"
                }
            },
            "type": "object",
            "required": [
                "condition",
                "key",
                "negate",
                "type",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:apigateway/ApigatewayCustomDomain:ApigatewayCustomDomain": {
            "properties": {
                "certificateId": {
                    "type": "string",
                    "description": "[string] The certificate ID for the domain. Must be a valid certificate in UUID form.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The domain name. Externally reachable.\n"
                }
            },
            "type": "object",
            "required": [
                "name"
            ]
        },
        "ionoscloud:apigateway/RouteUpstream:RouteUpstream": {
            "properties": {
                "host": {
                    "type": "string",
                    "description": "[string] The host of the upstream.\n"
                },
                "loadbalancer": {
                    "type": "string",
                    "description": "[string] The load balancer algorithm. Default value: `roundrobin`.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "[int] The port of the upstream. Default value: `80`.\n"
                },
                "scheme": {
                    "type": "string",
                    "description": "[string] The target URL of the upstream. Default value: `http`.\n"
                },
                "weight": {
                    "type": "integer",
                    "description": "[int] Weight with which to split traffic to the upstream. Default value: `100`.\n"
                }
            },
            "type": "object",
            "required": [
                "host"
            ]
        },
        "ionoscloud:apigateway/getApigatewayCustomDomain:getApigatewayCustomDomain": {
            "properties": {
                "certificateId": {
                    "type": "string",
                    "description": "The ID of the certificate to use for the distribution.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of an existing API Gateway that you want to search for.\n"
                }
            },
            "type": "object",
            "required": [
                "certificateId",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:apigateway/getRouteUpstream:getRouteUpstream": {
            "properties": {
                "host": {
                    "type": "string",
                    "description": "The host of the upstream.\n"
                },
                "loadbalancer": {
                    "type": "string",
                    "description": "The load balancer algorithm.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "The port of the upstream.\n"
                },
                "scheme": {
                    "type": "string",
                    "description": "The target URL of the upstream.\n"
                },
                "weight": {
                    "type": "integer",
                    "description": "Weight with which to split traffic to the upstream.\n"
                }
            },
            "type": "object",
            "required": [
                "host",
                "loadbalancer",
                "port",
                "scheme",
                "weight"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:autoscaling/GroupPolicy:GroupPolicy": {
            "properties": {
                "metric": {
                    "type": "string",
                    "description": "[string] The Metric that should trigger the scaling actions. Metric values are checked at fixed intervals. Possible values: `INSTANCE_CPU_UTILIZATION_AVERAGE`, `INSTANCE_NETWORK_IN_BYTES`, `INSTANCE_NETWORK_IN_PACKETS`, `INSTANCE_NETWORK_OUT_BYTES`, `INSTANCE_NETWORK_OUT_PACKETS`\n"
                },
                "range": {
                    "type": "string",
                    "description": "[string] Defines the time range, for which the samples will be aggregated. Default is 120s. *Note that when you set it to values like 5m the API will automatically transform it in PT5M, so the plan will show you a diff in state that should be ignored.*\n"
                },
                "scaleInAction": {
                    "$ref": "#/types/ionoscloud:autoscaling/GroupPolicyScaleInAction:GroupPolicyScaleInAction",
                    "description": "[list] Specifies the action to take when the `scaleInThreshold` is exceeded. Hereby, scaling in is always about removing VMs that are currently associated with this autoscaling group. Default termination policy is OLDEST_SERVER_FIRST.\n"
                },
                "scaleInThreshold": {
                    "type": "integer",
                    "description": "[int] A lower threshold on the value of `metric`. Will be used with `less than` (\u003c) operator. Exceeding this will start a Scale-In Action as specified by the `scaleInAction` property. The value must have a higher minimum delta to the `scaleOutThreshold` depending on the `metric` to avoid competitive actions at the same time.\n"
                },
                "scaleOutAction": {
                    "$ref": "#/types/ionoscloud:autoscaling/GroupPolicyScaleOutAction:GroupPolicyScaleOutAction",
                    "description": "[list] Specifies the action to take when the `scaleOutThreshold` is exceeded. Hereby, scaling out is always about adding new VMs to this autoscaling group.\n"
                },
                "scaleOutThreshold": {
                    "type": "integer",
                    "description": "[int] The upper threshold for the value of the `metric`. Used with the `greater than` (\u003e) operator. A scale-out action is triggered when this value is exceeded, specified by the `scaleOutAction` property. The value must have a lower minimum delta to the `scaleInThreshold`, depending on the metric, to avoid competing for actions simultaneously. If `properties.policy.unit=TOTAL`, a value \u003e= 40 must be chosen.\n"
                },
                "unit": {
                    "type": "string",
                    "description": "[string] Units of the applied Metric. Possible values are: `PER_HOUR`, `PER_MINUTE`, `PER_SECOND`, `TOTAL`.\n"
                }
            },
            "type": "object",
            "required": [
                "metric",
                "scaleInAction",
                "scaleInThreshold",
                "scaleOutAction",
                "scaleOutThreshold",
                "unit"
            ]
        },
        "ionoscloud:autoscaling/GroupPolicyScaleInAction:GroupPolicyScaleInAction": {
            "properties": {
                "amount": {
                    "type": "integer",
                    "description": "[int] When `amountType == ABSOLUTE`, this is the number of VMs removed in one step. When `amountType == PERCENTAGE`, this is a percentage value, which will be applied to the autoscaling group's current `targetReplicaCount` in order to derive the number of VMs that will be removed in one step. There will always be at least one VM removed. For SCALE_IN operation new volumes are NOT deleted after the server deletion.\n"
                },
                "amountType": {
                    "type": "string",
                    "description": "[string] The type for the given amount. Possible values are: `ABSOLUTE`, `PERCENTAGE`.\n"
                },
                "cooldownPeriod": {
                    "type": "string",
                    "description": "[string] Minimum time to pass after this Scaling action has started, until the next Scaling action will be started. Additionally, if a Scaling action is currently in progress, no second Scaling action will be started for the same autoscaling group. Instead, the Metric will be re-evaluated after the current Scaling action is completed (either successfully or with failures). This is validated with a minimum value of 2 minutes and a maximum of 24 hours currently. Default value is 5 minutes if not given. *Note that when you set it to values like 5m the API will automatically transform it in PT5M, so the plan will show you a diff in state that should be ignored.*\n"
                },
                "deleteVolumes": {
                    "type": "boolean",
                    "description": "[bool] If set to `true`, when deleting a replica during scale in, any attached volume will also be deleted. When set to `false`, all volumes remain in the datacenter and must be deleted manually. Note that every scale-out creates new volumes. When they are not deleted, they will eventually use all of your contracts resource limits. At this point, scaling out would not be possible anymore.\n"
                },
                "terminationPolicyType": {
                    "type": "string",
                    "description": "[string] The type of the termination policy for the autoscaling group so that a specific pattern is followed for Scaling-In replicas. Default termination policy is `OLDEST_SERVER_FIRST`. Possible values are: `OLDEST_SERVER_FIRST`, `NEWEST_SERVER_FIRST`, `RANDOM`\n"
                }
            },
            "type": "object",
            "required": [
                "amount",
                "amountType",
                "deleteVolumes"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "amount",
                        "amountType",
                        "cooldownPeriod",
                        "deleteVolumes",
                        "terminationPolicyType"
                    ]
                }
            }
        },
        "ionoscloud:autoscaling/GroupPolicyScaleOutAction:GroupPolicyScaleOutAction": {
            "properties": {
                "amount": {
                    "type": "integer",
                    "description": "[int] When `amountType=ABSOLUTE` specifies the absolute number of VMs that are added. The value must be between 1 to 10. `amountType=PERCENTAGE` specifies the percentage value that is applied to the current number of replicas of the VM Auto Scaling Group. The value must be between 1 to 200. At least one VM is always added.\n"
                },
                "amountType": {
                    "type": "string",
                    "description": "[string] The type for the given amount. Possible values are: `ABSOLUTE`, `PERCENTAGE`.\n"
                },
                "cooldownPeriod": {
                    "type": "string",
                    "description": "[string] Minimum time to pass after this Scaling action has started, until the next Scaling action will be started. Additionally, if a Scaling action is currently in progress, no second Scaling action will be started for the same autoscaling group. Instead, the Metric will be re-evaluated after the current Scaling action is completed (either successfully or with failures). This is validated with a minimum value of 2 minutes and a maximum of 24 hours currently. Default value is 5 minutes if not given. *Note that when you set it to values like 5m the API will automatically transform it in PT5M, so the plan will show you a diff in state that should be ignored.*\n"
                }
            },
            "type": "object",
            "required": [
                "amount",
                "amountType"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "amount",
                        "amountType",
                        "cooldownPeriod"
                    ]
                }
            }
        },
        "ionoscloud:autoscaling/GroupReplicaConfiguration:GroupReplicaConfiguration": {
            "properties": {
                "availabilityZone": {
                    "type": "string",
                    "description": "[string] The zone where the VMs are created using this configuration. Possible values are: `AUTO`, `ZONE_1`, `ZONE_2`.\n"
                },
                "cores": {
                    "type": "integer",
                    "description": "[int] The total number of cores for the VMs.\n"
                },
                "cpuFamily": {
                    "type": "string",
                    "description": "[string] PU family for the VMs created using this configuration. If null, the VM will be created with the default CPU family for the assigned location. Possible values are: `INTEL_SKYLAKE`, `INTEL_XEON`.\n"
                },
                "nics": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:autoscaling/GroupReplicaConfigurationNic:GroupReplicaConfigurationNic"
                    },
                    "description": "Set of NICs associated with this Replica.\n"
                },
                "ram": {
                    "type": "integer",
                    "description": "[int] The amount of memory for the VMs in MB, e.g. 2048. Size must be specified in multiples of 256 MB with a minimum of 256 MB; however, if you set ramHotPlug to TRUE then you must use a minimum of 1024 MB. If you set the RAM size more than 240GB, then ramHotPlug will be set to FALSE and can not be set to TRUE unless RAM size not set to less than 240GB.\n"
                },
                "volumes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:autoscaling/GroupReplicaConfigurationVolume:GroupReplicaConfigurationVolume"
                    },
                    "description": "[list] List of volumes associated with this Replica.\n"
                }
            },
            "type": "object",
            "required": [
                "availabilityZone",
                "cores",
                "ram"
            ]
        },
        "ionoscloud:autoscaling/GroupReplicaConfigurationNic:GroupReplicaConfigurationNic": {
            "properties": {
                "dhcp": {
                    "type": "boolean",
                    "description": "Dhcp flag for this replica Nic. This is an optional attribute with default value of 'true' if not given in the request payload or given as null.\n"
                },
                "firewallActive": {
                    "type": "boolean",
                    "description": "Activate or deactivate the firewall. By default, an active firewall without any defined rules will block all incoming network traffic except for the firewall rules that explicitly allows certain protocols, IP addresses and ports.\n"
                },
                "firewallRules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:autoscaling/GroupReplicaConfigurationNicFirewallRule:GroupReplicaConfigurationNicFirewallRule"
                    },
                    "description": "List of all firewall rules for the specified NIC.\n"
                },
                "firewallType": {
                    "type": "string",
                    "description": "The type of firewall rules that will be allowed on the NIC. If not specified, the default INGRESS value is used.\n"
                },
                "flowLogs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:autoscaling/GroupReplicaConfigurationNicFlowLog:GroupReplicaConfigurationNicFlowLog"
                    },
                    "description": "List of all flow logs for the specified NIC.\n"
                },
                "lan": {
                    "type": "integer",
                    "description": "Lan ID for this replica Nic.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] User-defined name for the Autoscaling Group.\n"
                },
                "targetGroup": {
                    "$ref": "#/types/ionoscloud:autoscaling/GroupReplicaConfigurationNicTargetGroup:GroupReplicaConfigurationNicTargetGroup",
                    "description": "In order to link VM to ALB, target group must be provided.\n"
                }
            },
            "type": "object",
            "required": [
                "lan",
                "name"
            ]
        },
        "ionoscloud:autoscaling/GroupReplicaConfigurationNicFirewallRule:GroupReplicaConfigurationNicFirewallRule": {
            "properties": {
                "icmpCode": {
                    "type": "integer",
                    "description": "Sets the allowed code (from 0 to 254) when ICMP protocol is selected. The value 'null' allows all codes.\n"
                },
                "icmpType": {
                    "type": "integer",
                    "description": "Sets the allowed type (from 0 to 254) if the protocol ICMP is selected. The value 'null' allows all types.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] User-defined name for the Autoscaling Group.\n"
                },
                "portRangeEnd": {
                    "type": "integer",
                    "description": "Sets the end range of the allowed port (from 1 to 65535) if the protocol TCP or UDP is selected. The value 'null' for 'port_range_start' and 'port_range_end' allows all ports.\n"
                },
                "portRangeStart": {
                    "type": "integer",
                    "description": "Sets the initial range of the allowed port (from 1 to 65535) if the protocol TCP or UDP is selected. The value 'null' for 'port_range_start' and 'port_range_end' allows all ports.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "The protocol for the rule. The property cannot be modified after its creation (not allowed in update requests).\n"
                },
                "sourceIp": {
                    "type": "string",
                    "description": "Only traffic originating from the respective IPv4 address is permitted. The value 'null' allows traffic from any IP address.\n"
                },
                "sourceMac": {
                    "type": "string",
                    "description": "Only traffic originating from the respective MAC address is permitted. Valid format: 'aa:bb:cc:dd:ee:ff'. The value 'null' allows traffic from any MAC address.\n"
                },
                "targetIp": {
                    "type": "string",
                    "description": "If the target NIC has multiple IP addresses, only the traffic directed to the respective IP address of the NIC is allowed. The value 'null' allows traffic to any target IP address.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The firewall rule type. If not specified, the default value 'INGRESS' is used.\n"
                }
            },
            "type": "object",
            "required": [
                "protocol"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "protocol",
                        "type"
                    ]
                }
            }
        },
        "ionoscloud:autoscaling/GroupReplicaConfigurationNicFlowLog:GroupReplicaConfigurationNicFlowLog": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Specifies the traffic direction pattern. Valid values: ACCEPTED, REJECTED, ALL. Immutable, forces re-recreation of the nic resource.\n"
                },
                "bucket": {
                    "type": "string",
                    "description": "The bucket name of an existing IONOS Object Storage bucket. Immutable, forces re-recreation of the nic resource.\n"
                },
                "direction": {
                    "type": "string",
                    "description": "Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, forces re-recreation of the nic resource.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The resource's unique identifier.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] User-defined name for the Autoscaling Group.\n"
                }
            },
            "type": "object",
            "required": [
                "action",
                "bucket",
                "direction",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "action",
                        "bucket",
                        "direction",
                        "id",
                        "name"
                    ]
                }
            }
        },
        "ionoscloud:autoscaling/GroupReplicaConfigurationNicTargetGroup:GroupReplicaConfigurationNicTargetGroup": {
            "properties": {
                "port": {
                    "type": "integer",
                    "description": "The port for the target group.\n"
                },
                "targetGroupId": {
                    "type": "string",
                    "description": "The ID of the target group.\n"
                },
                "weight": {
                    "type": "integer",
                    "description": "The weight for the target group.\n"
                }
            },
            "type": "object",
            "required": [
                "port",
                "targetGroupId",
                "weight"
            ]
        },
        "ionoscloud:autoscaling/GroupReplicaConfigurationVolume:GroupReplicaConfigurationVolume": {
            "properties": {
                "backupUnitId": {
                    "type": "string",
                    "description": "[string] The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either `public image` or `imageAlias` in conjunction with this property.\n"
                },
                "bootOrder": {
                    "type": "string",
                    "description": "[string] Determines whether the volume will be used as a boot volume. Set to NONE, the volume will not be used as boot volume. Set to PRIMARY, the volume will be used as boot volume and set to AUTO will delegate the decision to the provisioning engine to decide whether to use the volume as boot volume.\nNotice that exactly one volume can be set to PRIMARY or all of them set to AUTO.\n"
                },
                "bus": {
                    "type": "string",
                    "description": "[string] The bus type of the volume. Default setting is `VIRTIO`. The bus type `IDE` is also supported.\n"
                },
                "image": {
                    "type": "string",
                    "description": "[string] The image installed on the volume. Only the UUID of the image is presently supported.\n"
                },
                "imageAlias": {
                    "type": "string",
                    "description": "[string] The image installed on the volume. Must be an `imageAlias` as specified via the images API. Note that one of `image` or `imageAlias` must be set, but not both.\n"
                },
                "imagePassword": {
                    "type": "string",
                    "description": "[string] Image password for this replica volume.\n",
                    "secret": true
                },
                "name": {
                    "type": "string",
                    "description": "[string] Name for this replica volume.\n"
                },
                "size": {
                    "type": "integer",
                    "description": "[int] Name for this replica volume.\n"
                },
                "sshKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of ssh keys, supports values or paths to files. Cannot be changed at update.\n"
                },
                "type": {
                    "type": "string",
                    "description": "[string] Storage Type for this replica volume. Possible values: `SSD`, `HDD`, `SSD_STANDARD` or `SSD_PREMIUM`.\n"
                },
                "userData": {
                    "type": "string",
                    "description": "[string] User-data (Cloud Init) for this replica volume. Make sure you provide a Cloud Init compatible image in conjunction with this parameter.\n"
                }
            },
            "type": "object",
            "required": [
                "bootOrder",
                "name",
                "size",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "backupUnitId",
                        "bootOrder",
                        "name",
                        "size",
                        "type",
                        "userData"
                    ]
                }
            }
        },
        "ionoscloud:autoscaling/getGroupPolicy:getGroupPolicy": {
            "properties": {
                "metric": {
                    "type": "string",
                    "description": "The Metric that should trigger Scaling Actions. The values of the Metric are checked in fixed intervals.\n"
                },
                "range": {
                    "type": "string",
                    "description": "Defines the range of time from which samples will be aggregated. Default is 120s.\n*Note that when you set it to values like 5m the API will automatically transform it in PT5M, so the plan will show you a diff in state that should be ignored.*\n"
                },
                "scaleInActions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:autoscaling/getGroupPolicyScaleInAction:getGroupPolicyScaleInAction"
                    },
                    "description": "Specifies the Action to take when the `scaleInThreshold`\n"
                },
                "scaleInThreshold": {
                    "type": "integer",
                    "description": "A lower threshold on the value of `metric`. Will be used with `less than` (\u003c) operator. Exceeding this will start a Scale-In Action as specified by the `scaleInAction` property. The value must have a higher minimum delta to the `scaleOutThreshold` depending on the `metric` to avoid competitive actions at the same time.\n"
                },
                "scaleOutActions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:autoscaling/getGroupPolicyScaleOutAction:getGroupPolicyScaleOutAction"
                    },
                    "description": "Specifies the action to take when the `scaleOutThreshold` is exceeded. Hereby, scaling out is always about adding new VMs to this autoscaling group\n"
                },
                "scaleOutThreshold": {
                    "type": "integer",
                    "description": "The upper threshold for the value of the `metric`. Used with the `greater than` (\u003e) operator. A scale-out action is triggered when this value is exceeded, specified by the `scaleOutAction` property. The value must have a lower minimum delta to the `scaleInThreshold`, depending on the metric, to avoid competing for actions simultaneously. If `properties.policy.unit=TOTAL`, a value \u003e= 40 must be chosen.\n"
                },
                "unit": {
                    "type": "string",
                    "description": "Specifies the Action to take when the `scaleInThreshold` is exceeded. Hereby, scaling in is always about removing VMs that are currently associated with this Autoscaling Group.\n"
                }
            },
            "type": "object",
            "required": [
                "metric",
                "range",
                "scaleInActions",
                "scaleInThreshold",
                "scaleOutActions",
                "scaleOutThreshold",
                "unit"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:autoscaling/getGroupPolicyScaleInAction:getGroupPolicyScaleInAction": {
            "properties": {
                "amount": {
                    "type": "integer",
                    "description": "When `amountType == ABSOLUTE`, this is the number of VMs added or removed in one step. When `amountType == PERCENTAGE`, this is a percentage value, which will be applied to the Autoscaling Group's current `targetReplicaCount` in order to derive the number of VMs that will be added or removed in one step. There will always be at least one VM added or removed.\n"
                },
                "amountType": {
                    "type": "string",
                    "description": "The type for the given amount. Possible values are: [ABSOLUTE, PERCENTAGE].\n"
                },
                "cooldownPeriod": {
                    "type": "string",
                    "description": "Minimum time to pass after this Scaling Action has started, until the next Scaling Action will be started. Additionally, if a Scaling Action is currently in progress, no second Scaling Action will be started for the same Autoscaling Group. Instead, the Metric will be re-evaluated after the current Scaling Action completed (either successful or with failures).\n*Note that when you set it to values like 5m the API will automatically transform it in PT5M, so the plan will show you a diff in state that should be ignored.*\n"
                },
                "deleteVolumes": {
                    "type": "boolean",
                    "description": "If set to 'true', when deleting an replica during scale in, any attached volume will also be deleted. When set to 'false', all volumes remain in the datacenter and must be deleted manually. Note that every scale-out creates new volumes. When they are not deleted, they will eventually use all of your contracts resource limits. At this point, scaling out would not be possible anymore.\n"
                },
                "terminationPolicyType": {
                    "type": "string",
                    "description": "The type of the termination policy for the autoscaling group so that a specific pattern is followed for Scaling-In instances. Default termination policy is OLDEST_SERVER_FIRST.\n"
                }
            },
            "type": "object",
            "required": [
                "amount",
                "amountType",
                "cooldownPeriod",
                "deleteVolumes",
                "terminationPolicyType"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:autoscaling/getGroupPolicyScaleOutAction:getGroupPolicyScaleOutAction": {
            "properties": {
                "amount": {
                    "type": "integer",
                    "description": "When `amountType == ABSOLUTE`, this is the number of VMs added or removed in one step. When `amountType == PERCENTAGE`, this is a percentage value, which will be applied to the Autoscaling Group's current `targetReplicaCount` in order to derive the number of VMs that will be added or removed in one step. There will always be at least one VM added or removed.\n"
                },
                "amountType": {
                    "type": "string",
                    "description": "The type for the given amount. Possible values are: [ABSOLUTE, PERCENTAGE].\n"
                },
                "cooldownPeriod": {
                    "type": "string",
                    "description": "Minimum time to pass after this Scaling Action has started, until the next Scaling Action will be started. Additionally, if a Scaling Action is currently in progress, no second Scaling Action will be started for the same Autoscaling Group. Instead, the Metric will be re-evaluated after the current Scaling Action completed (either successful or with failures).\n*Note that when you set it to values like 5m the API will automatically transform it in PT5M, so the plan will show you a diff in state that should be ignored.*\n"
                }
            },
            "type": "object",
            "required": [
                "amount",
                "amountType",
                "cooldownPeriod"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:autoscaling/getGroupReplicaConfiguration:getGroupReplicaConfiguration": {
            "properties": {
                "availabilityZone": {
                    "type": "string",
                    "description": "The zone where the VMs are created using this configuration.\n"
                },
                "cores": {
                    "type": "integer",
                    "description": "The total number of cores for the VMs.\n"
                },
                "cpuFamily": {
                    "type": "string",
                    "description": "The zone where the VMs are created using this configuration.\n"
                },
                "nics": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:autoscaling/getGroupReplicaConfigurationNic:getGroupReplicaConfigurationNic"
                    },
                    "description": "List of NICs associated with this Replica.\n"
                },
                "ram": {
                    "type": "integer",
                    "description": "The amount of memory for the VMs in MB, e.g. 2048. Size must be specified in multiples of 256 MB with a minimum of 256 MB; however, if you set ramHotPlug to TRUE then you must use a minimum of 1024 MB. If you set the RAM size more than 240GB, then ramHotPlug will be set to FALSE and can not be set to TRUE unless RAM size not set to less than 240GB.\n"
                },
                "volumes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:autoscaling/getGroupReplicaConfigurationVolume:getGroupReplicaConfigurationVolume"
                    },
                    "description": "List of volumes associated with this Replica. Only a single volume is currently supported.\n"
                }
            },
            "type": "object",
            "required": [
                "availabilityZone",
                "cores",
                "cpuFamily",
                "nics",
                "ram",
                "volumes"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:autoscaling/getGroupReplicaConfigurationNic:getGroupReplicaConfigurationNic": {
            "properties": {
                "dhcp": {
                    "type": "boolean",
                    "description": "Dhcp flag for this replica Nic. This is an optional attribute with default value of 'true' if not given in the request payload or given as null.\n"
                },
                "firewallActive": {
                    "type": "boolean",
                    "description": "Activate or deactivate the firewall. By default, an active firewall without any defined rules will block all incoming network traffic except for the firewall rules that explicitly allows certain protocols, IP addresses and ports.\n"
                },
                "firewallRules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:autoscaling/getGroupReplicaConfigurationNicFirewallRule:getGroupReplicaConfigurationNicFirewallRule"
                    },
                    "description": "List of all firewall rules for the specified NIC.\n"
                },
                "firewallType": {
                    "type": "string",
                    "description": "The type of firewall rules that will be allowed on the NIC. If not specified, the default INGRESS value is used.\n"
                },
                "flowLogs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:autoscaling/getGroupReplicaConfigurationNicFlowLog:getGroupReplicaConfigurationNicFlowLog"
                    },
                    "description": "Flow log configuration for the NIC. By default, the flow log is inactive. If you want to activate the flow log, you must specify the target resource and the type of traffic to log.\n"
                },
                "lan": {
                    "type": "integer",
                    "description": "Lan ID for this replica Nic.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of an existing Autoscaling Group that you want to search for.\n\nEither `name` or `id` must be provided. If none or both are provided, the datasource will return an error.\n"
                },
                "targetGroups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:autoscaling/getGroupReplicaConfigurationNicTargetGroup:getGroupReplicaConfigurationNicTargetGroup"
                    },
                    "description": "In order to link VM to ALB, target group must be provided.\n"
                }
            },
            "type": "object",
            "required": [
                "dhcp",
                "firewallActive",
                "firewallRules",
                "firewallType",
                "flowLogs",
                "lan",
                "name",
                "targetGroups"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:autoscaling/getGroupReplicaConfigurationNicFirewallRule:getGroupReplicaConfigurationNicFirewallRule": {
            "properties": {
                "icmpCode": {
                    "type": "integer",
                    "description": "Sets the allowed code (from 0 to 254) when ICMP protocol is selected. The value 'null' allows all codes.\n"
                },
                "icmpType": {
                    "type": "integer",
                    "description": "Sets the allowed type (from 0 to 254) if the protocol ICMP is selected. The value 'null' allows all types.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of an existing Autoscaling Group that you want to search for.\n\nEither `name` or `id` must be provided. If none or both are provided, the datasource will return an error.\n"
                },
                "portRangeEnd": {
                    "type": "integer",
                    "description": "Sets the end range of the allowed port (from 1 to 65535) if the protocol TCP or UDP is selected. The value 'null' for 'port_range_start' and 'port_range_end' allows all ports.\n"
                },
                "portRangeStart": {
                    "type": "integer",
                    "description": "Sets the initial range of the allowed port (from 1 to 65535) if the protocol TCP or UDP is selected. The value 'null' for 'port_range_start' and 'port_range_end' allows all ports.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "The protocol for the rule. The property cannot be modified after its creation (not allowed in update requests).\n"
                },
                "sourceIp": {
                    "type": "string",
                    "description": "Only traffic originating from the respective IPv4 address is permitted. The value 'null' allows traffic from any IP address.\n"
                },
                "sourceMac": {
                    "type": "string",
                    "description": "Only traffic originating from the respective MAC address is permitted. Valid format: 'aa:bb:cc:dd:ee:ff'. The value 'null' allows traffic from any MAC address.\n"
                },
                "targetIp": {
                    "type": "string",
                    "description": "If the target NIC has multiple IP addresses, only the traffic directed to the respective IP address of the NIC is allowed. The value 'null' allows traffic to any target IP address.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of resource\n"
                }
            },
            "type": "object",
            "required": [
                "icmpCode",
                "icmpType",
                "name",
                "portRangeEnd",
                "portRangeStart",
                "protocol",
                "sourceIp",
                "sourceMac",
                "targetIp",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:autoscaling/getGroupReplicaConfigurationNicFlowLog:getGroupReplicaConfigurationNicFlowLog": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Specifies the traffic direction pattern. Valid values: ACCEPTED, REJECTED, ALL.\n"
                },
                "bucket": {
                    "type": "string",
                    "description": "The bucket name of an existing IONOS Object Storage bucket.\n"
                },
                "direction": {
                    "type": "string",
                    "description": "Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Id of an existing Autoscaling Group that you want to search for.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of an existing Autoscaling Group that you want to search for.\n\nEither `name` or `id` must be provided. If none or both are provided, the datasource will return an error.\n"
                }
            },
            "type": "object",
            "required": [
                "action",
                "bucket",
                "direction",
                "id",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:autoscaling/getGroupReplicaConfigurationNicTargetGroup:getGroupReplicaConfigurationNicTargetGroup": {
            "properties": {
                "port": {
                    "type": "integer",
                    "description": "The port for the target group.\n"
                },
                "targetGroupId": {
                    "type": "string",
                    "description": "The ID of the target group.\n"
                },
                "weight": {
                    "type": "integer",
                    "description": "The weight for the target group.\n"
                }
            },
            "type": "object",
            "required": [
                "port",
                "targetGroupId",
                "weight"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:autoscaling/getGroupReplicaConfigurationVolume:getGroupReplicaConfigurationVolume": {
            "properties": {
                "backupUnitId": {
                    "type": "string",
                    "description": "The uuid of the Backup Unit that user has access to.\n"
                },
                "bootOrder": {
                    "type": "string",
                    "description": "Determines whether the volume will be used as a boot volume: NONE - the volume will not be used as boot volume, PRIMARY - the volume will be used as boot volume, AUTO - will delegate the decision to the provisioning engine to decide whether to use the volume as boot volume.\n"
                },
                "bus": {
                    "type": "string",
                    "description": "The bus type of the volume. Default setting is 'VIRTIO'. The bus type 'IDE' is also supported.\n"
                },
                "image": {
                    "type": "string",
                    "description": "The image installed on the volume. Only the UUID of the image is presently supported.\n"
                },
                "imageAlias": {
                    "type": "string",
                    "description": "The image installed on the volume. Must be an 'imageAlias' as specified via the images API.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of an existing Autoscaling Group that you want to search for.\n\nEither `name` or `id` must be provided. If none or both are provided, the datasource will return an error.\n"
                },
                "size": {
                    "type": "integer",
                    "description": "User-defined size for this replica volume in GB.\n"
                },
                "sshKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "type": {
                    "type": "string",
                    "description": "Type of resource\n"
                }
            },
            "type": "object",
            "required": [
                "backupUnitId",
                "bootOrder",
                "bus",
                "image",
                "imageAlias",
                "name",
                "size",
                "sshKeys",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:autoscaling/getServersServer:getServersServer": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "The unique ID of the server.\n"
                }
            },
            "type": "object",
            "required": [
                "id"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:cdn/DistributionRoutingRule:DistributionRoutingRule": {
            "properties": {
                "prefix": {
                    "type": "string",
                    "description": "[string] The prefix of the routing rule.\n"
                },
                "scheme": {
                    "type": "string",
                    "description": "[string] The scheme of the routing rule.\n"
                },
                "upstream": {
                    "$ref": "#/types/ionoscloud:cdn/DistributionRoutingRuleUpstream:DistributionRoutingRuleUpstream",
                    "description": "[map] - A map of properties for the rule\n"
                }
            },
            "type": "object",
            "required": [
                "prefix",
                "scheme",
                "upstream"
            ]
        },
        "ionoscloud:cdn/DistributionRoutingRuleUpstream:DistributionRoutingRuleUpstream": {
            "properties": {
                "caching": {
                    "type": "boolean",
                    "description": "[bool] Enable or disable caching. If enabled, the CDN will cache the responses from the upstream host. Subsequent requests for the same resource will be served from the cache.\n"
                },
                "geoRestrictions": {
                    "$ref": "#/types/ionoscloud:cdn/DistributionRoutingRuleUpstreamGeoRestrictions:DistributionRoutingRuleUpstreamGeoRestrictions",
                    "description": "[map] - A map of geo_restrictions\n"
                },
                "host": {
                    "type": "string",
                    "description": "[string] The upstream host that handles the requests if not already cached. This host will be protected by the WAF if the option is enabled.\n"
                },
                "rateLimitClass": {
                    "type": "string",
                    "description": "[string] Rate limit class that will be applied to limit the number of incoming requests per IP.\n"
                },
                "sniMode": {
                    "type": "string",
                    "description": "[string] The SNI (Server Name Indication) mode of the upstream. It supports two modes: 1) `distribution`: for outgoing connections to the upstream host, the CDN requires the upstream host to present a valid certificate that matches the configured domain of the CDN distribution; 2) `origin`: for outgoing connections to the upstream host, the CDN requires the upstream host to present a valid certificate that matches the configured upstream/origin hostname.\n"
                },
                "waf": {
                    "type": "boolean",
                    "description": "[bool] Enable or disable WAF to protect the upstream host.\n"
                }
            },
            "type": "object",
            "required": [
                "caching",
                "host",
                "rateLimitClass",
                "sniMode",
                "waf"
            ]
        },
        "ionoscloud:cdn/DistributionRoutingRuleUpstreamGeoRestrictions:DistributionRoutingRuleUpstreamGeoRestrictions": {
            "properties": {
                "allowLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[string] List of allowed countries\n"
                },
                "blockLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[string] List of blocked countries\n"
                }
            },
            "type": "object"
        },
        "ionoscloud:cdn/getDistributionRoutingRule:getDistributionRoutingRule": {
            "properties": {
                "prefix": {
                    "type": "string",
                    "description": "The prefix of the routing rule.\n"
                },
                "scheme": {
                    "type": "string",
                    "description": "The scheme of the routing rule.\n"
                },
                "upstreams": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:cdn/getDistributionRoutingRuleUpstream:getDistributionRoutingRuleUpstream"
                    },
                    "description": "A map of properties for the rule\n"
                }
            },
            "type": "object",
            "required": [
                "prefix",
                "scheme",
                "upstreams"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:cdn/getDistributionRoutingRuleUpstream:getDistributionRoutingRuleUpstream": {
            "properties": {
                "caching": {
                    "type": "boolean",
                    "description": "Enable or disable caching. If enabled, the CDN will cache the responses from the upstream host. Subsequent requests for the same resource will be served from the cache.\n"
                },
                "geoRestrictions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:cdn/getDistributionRoutingRuleUpstreamGeoRestriction:getDistributionRoutingRuleUpstreamGeoRestriction"
                    },
                    "description": "A map of geo_restrictions\n"
                },
                "host": {
                    "type": "string",
                    "description": "The upstream host that handles the requests if not already cached. This host will be protected by the WAF if the option is enabled.\n"
                },
                "rateLimitClass": {
                    "type": "string",
                    "description": "Rate limit class that will be applied to limit the number of incoming requests per IP.\n"
                },
                "sniMode": {
                    "type": "string",
                    "description": "The SNI (Server Name Indication) mode of the upstream. It supports two modes: 1) `distribution`: for outgoing connections to the upstream host, the CDN requires the upstream host to present a valid certificate that matches the configured domain of the CDN distribution; 2) `origin`: for outgoing connections to the upstream host, the CDN requires the upstream host to present a valid certificate that matches the configured upstream/origin hostname.\n"
                },
                "waf": {
                    "type": "boolean",
                    "description": "Enable or disable WAF to protect the upstream host.\n"
                }
            },
            "type": "object",
            "required": [
                "caching",
                "geoRestrictions",
                "host",
                "rateLimitClass",
                "sniMode",
                "waf"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:cdn/getDistributionRoutingRuleUpstreamGeoRestriction:getDistributionRoutingRuleUpstreamGeoRestriction": {
            "properties": {
                "allowLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of allowed countries\n"
                },
                "blockLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of blocked countries\n"
                }
            },
            "type": "object",
            "required": [
                "allowLists",
                "blockLists"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:cert/AutoCertificateProviderExternalAccountBinding:AutoCertificateProviderExternalAccountBinding": {
            "properties": {
                "keyId": {
                    "type": "string",
                    "description": "The key ID of the external account binding\n",
                    "willReplaceOnChanges": true
                },
                "keySecret": {
                    "type": "string",
                    "description": "The secret of the external account binding\n",
                    "secret": true,
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "keyId",
                "keySecret"
            ]
        },
        "ionoscloud:cert/getAutoCertificateProviderExternalAccountBinding:getAutoCertificateProviderExternalAccountBinding": {
            "properties": {
                "keyId": {
                    "type": "string",
                    "description": "[string] The key ID of the external account binding.\n"
                }
            },
            "type": "object",
            "required": [
                "keyId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:compute/CrossconnectConnectableDatacenter:CrossconnectConnectableDatacenter": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "The UUID of the connectable datacenter\n"
                },
                "location": {
                    "type": "string",
                    "description": "The physical location of the connectable datacenter\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the cross-connection.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "id",
                        "location",
                        "name"
                    ]
                }
            }
        },
        "ionoscloud:compute/CrossconnectPeer:CrossconnectPeer": {
            "properties": {
                "datacenterId": {
                    "type": "string",
                    "description": "The id of the cross-connected datacenter\n"
                },
                "datacenterName": {
                    "type": "string",
                    "description": "The name of the cross-connected datacenter\n"
                },
                "lanId": {
                    "type": "string",
                    "description": "The id of the cross-connected LAN\n"
                },
                "lanName": {
                    "type": "string",
                    "description": "The name of the cross-connected LAN\n"
                },
                "location": {
                    "type": "string",
                    "description": "The location of the cross-connected datacenter\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "datacenterId",
                        "datacenterName",
                        "lanId",
                        "lanName",
                        "location"
                    ]
                }
            }
        },
        "ionoscloud:compute/CubeServerNic:CubeServerNic": {
            "properties": {
                "deviceNumber": {
                    "type": "integer"
                },
                "dhcp": {
                    "type": "boolean"
                },
                "dhcpv6": {
                    "type": "boolean",
                    "description": "Indicates whether this NIC receives an IPv6 address through DHCP.\n"
                },
                "firewall": {
                    "$ref": "#/types/ionoscloud:compute/CubeServerNicFirewall:CubeServerNicFirewall"
                },
                "firewallActive": {
                    "type": "boolean"
                },
                "firewallType": {
                    "type": "string"
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "ipv6CidrBlock": {
                    "type": "string",
                    "description": "IPv6 CIDR block assigned to the NIC.\n"
                },
                "ipv6Ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Collection for IPv6 addresses assigned to a nic. Explicitly assigned IPv6 addresses need to come from inside the IPv6 CIDR block assigned to the nic.\n"
                },
                "lan": {
                    "type": "integer"
                },
                "mac": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the server.\n"
                },
                "pciSlot": {
                    "type": "integer"
                }
            },
            "type": "object",
            "required": [
                "lan"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "deviceNumber",
                        "firewallType",
                        "ips",
                        "ipv6CidrBlock",
                        "ipv6Ips",
                        "lan",
                        "mac",
                        "pciSlot"
                    ]
                }
            }
        },
        "ionoscloud:compute/CubeServerNicFirewall:CubeServerNicFirewall": {
            "properties": {
                "icmpCode": {
                    "type": "string"
                },
                "icmpType": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the server.\n"
                },
                "portRangeEnd": {
                    "type": "integer"
                },
                "portRangeStart": {
                    "type": "integer"
                },
                "protocol": {
                    "type": "string"
                },
                "sourceIp": {
                    "type": "string"
                },
                "sourceMac": {
                    "type": "string"
                },
                "targetIp": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "protocol"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "protocol",
                        "type"
                    ]
                }
            }
        },
        "ionoscloud:compute/CubeServerVolume:CubeServerVolume": {
            "properties": {
                "availabilityZone": {
                    "type": "string",
                    "description": "[string] The availability zone in which the server should exist. This property is immutable.\n"
                },
                "backupUnitId": {
                    "type": "string",
                    "description": "The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.\n"
                },
                "bootServer": {
                    "type": "string",
                    "description": "The UUID of the attached server.\n"
                },
                "bus": {
                    "type": "string"
                },
                "cpuHotPlug": {
                    "type": "boolean"
                },
                "deviceNumber": {
                    "type": "integer"
                },
                "discVirtioHotPlug": {
                    "type": "boolean"
                },
                "discVirtioHotUnplug": {
                    "type": "boolean"
                },
                "diskType": {
                    "type": "string"
                },
                "imagePassword": {
                    "type": "string",
                    "description": "[string] Required if `ssh_key_path` is not provided.\n\n\u003e **⚠ WARNING**\n\u003e\n\u003e Image_name under volume level is deprecated, please use image_name under server level\n\n\n\u003e **⚠ WARNING**\n\u003e\n\u003e For creating a **CUBE** server, you can not set `volume.size` argument.\n\u003e\n",
                    "deprecationMessage": "Please use image_password under server level"
                },
                "licenceType": {
                    "type": "string",
                    "description": "[string] Sets the OS type of the server.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the server.\n"
                },
                "nicHotPlug": {
                    "type": "boolean"
                },
                "nicHotUnplug": {
                    "type": "boolean"
                },
                "pciSlot": {
                    "type": "integer"
                },
                "ramHotPlug": {
                    "type": "boolean"
                },
                "sshKeyPaths": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] List of paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images. Required for IonosCloud Linux images. Required if `image_password` is not provided.\n",
                    "deprecationMessage": "Please use ssh_key_path under server level"
                },
                "userData": {
                    "type": "string",
                    "description": "The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.\n"
                }
            },
            "type": "object",
            "required": [
                "diskType"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "availabilityZone",
                        "backupUnitId",
                        "bootServer",
                        "bus",
                        "cpuHotPlug",
                        "deviceNumber",
                        "discVirtioHotPlug",
                        "discVirtioHotUnplug",
                        "diskType",
                        "licenceType",
                        "nicHotPlug",
                        "nicHotUnplug",
                        "pciSlot",
                        "ramHotPlug",
                        "sshKeyPaths",
                        "userData"
                    ]
                }
            }
        },
        "ionoscloud:compute/DatacenterCpuArchitecture:DatacenterCpuArchitecture": {
            "properties": {
                "cpuFamily": {
                    "type": "string",
                    "description": "A valid CPU family name\n"
                },
                "maxCores": {
                    "type": "integer",
                    "description": "The maximum number of cores available\n"
                },
                "maxRam": {
                    "type": "integer",
                    "description": "The maximum number of RAM in MB\n"
                },
                "vendor": {
                    "type": "string",
                    "description": "A valid CPU vendor name\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "cpuFamily",
                        "maxCores",
                        "maxRam",
                        "vendor"
                    ]
                }
            }
        },
        "ionoscloud:compute/GroupUser:GroupUser": {
            "properties": {
                "administrator": {
                    "type": "boolean"
                },
                "email": {
                    "type": "string"
                },
                "firstName": {
                    "type": "string"
                },
                "forceSecAuth": {
                    "type": "boolean"
                },
                "id": {
                    "type": "string"
                },
                "lastName": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "administrator",
                        "email",
                        "firstName",
                        "forceSecAuth",
                        "id",
                        "lastName",
                        "password"
                    ]
                }
            }
        },
        "ionoscloud:compute/IPBlockIpConsumer:IPBlockIpConsumer": {
            "properties": {
                "datacenterId": {
                    "type": "string"
                },
                "datacenterName": {
                    "type": "string"
                },
                "ip": {
                    "type": "string"
                },
                "k8sClusterUuid": {
                    "type": "string"
                },
                "k8sNodepoolUuid": {
                    "type": "string"
                },
                "mac": {
                    "type": "string"
                },
                "nicId": {
                    "type": "string"
                },
                "serverId": {
                    "type": "string"
                },
                "serverName": {
                    "type": "string"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "datacenterId",
                        "datacenterName",
                        "ip",
                        "k8sClusterUuid",
                        "k8sNodepoolUuid",
                        "mac",
                        "nicId",
                        "serverId",
                        "serverName"
                    ]
                }
            }
        },
        "ionoscloud:compute/LanIpFailover:LanIpFailover": {
            "properties": {
                "ip": {
                    "type": "string"
                },
                "nicUuid": {
                    "type": "string"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "ip",
                        "nicUuid"
                    ]
                }
            }
        },
        "ionoscloud:compute/NatGatewayLan:NatGatewayLan": {
            "properties": {
                "gatewayIps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] Collection of gateway IP addresses of the NAT gateway. Will be auto-generated if not provided. Should ideally be an IP belonging to the same subnet as the LAN.\n"
                },
                "id": {
                    "type": "integer",
                    "description": "[int] Id for the LAN connected to the NAT gateway.\n"
                }
            },
            "type": "object",
            "required": [
                "id"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "gatewayIps",
                        "id"
                    ]
                }
            }
        },
        "ionoscloud:compute/NatGatewayRuleTargetPortRange:NatGatewayRuleTargetPortRange": {
            "properties": {
                "end": {
                    "type": "integer",
                    "description": "[int] Target port range end associated with the NAT gateway rule.\n"
                },
                "start": {
                    "type": "integer",
                    "description": "[int] Target port range start associated with the NAT gateway rule.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "end",
                        "start"
                    ]
                }
            }
        },
        "ionoscloud:compute/NicFlowlog:NicFlowlog": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL. Immutable, update forces re-creation.\n"
                },
                "bucket": {
                    "type": "string",
                    "description": "Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist. Immutable, update forces re-creation.\n"
                },
                "direction": {
                    "type": "string",
                    "description": "Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, update forces re-creation.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The ID of the NIC.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the name of the flow log.\n\n⚠️ **Note:**: Removing the `flowlog` forces re-creation of the NIC resource.\n"
                }
            },
            "type": "object",
            "required": [
                "action",
                "bucket",
                "direction",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "action",
                        "bucket",
                        "direction",
                        "id",
                        "name"
                    ]
                }
            }
        },
        "ionoscloud:compute/ServerLabel:ServerLabel": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "[string] The key of the label.\n"
                },
                "value": {
                    "type": "string",
                    "description": "[string] The value of the label.\n"
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ]
        },
        "ionoscloud:compute/ServerNic:ServerNic": {
            "properties": {
                "deviceNumber": {
                    "type": "integer"
                },
                "dhcp": {
                    "type": "boolean"
                },
                "dhcpv6": {
                    "type": "boolean",
                    "description": "Indicates whether this NIC receives an IPv6 address through DHCP.\n"
                },
                "firewallActive": {
                    "type": "boolean"
                },
                "firewallType": {
                    "type": "string"
                },
                "firewalls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:compute/ServerNicFirewall:ServerNicFirewall"
                    },
                    "description": "Allows to define firewall rules inline in the server. See the Firewall section.\n"
                },
                "id": {
                    "type": "string"
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Collection of IP addresses assigned to a nic. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.\n"
                },
                "ipv6CidrBlock": {
                    "type": "string",
                    "description": "IPv6 CIDR block assigned to the NIC.\n"
                },
                "ipv6Ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Collection for IPv6 addresses assigned to a nic. Explicitly assigned IPv6 addresses need to come from inside the IPv6 CIDR block assigned to the nic.\n"
                },
                "lan": {
                    "type": "integer"
                },
                "mac": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the server.\n"
                },
                "pciSlot": {
                    "type": "integer"
                }
            },
            "type": "object",
            "required": [
                "lan"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "deviceNumber",
                        "firewallType",
                        "id",
                        "ips",
                        "ipv6CidrBlock",
                        "ipv6Ips",
                        "lan",
                        "mac",
                        "pciSlot"
                    ]
                }
            }
        },
        "ionoscloud:compute/ServerNicFirewall:ServerNicFirewall": {
            "properties": {
                "icmpCode": {
                    "type": "string"
                },
                "icmpType": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the server.\n"
                },
                "portRangeEnd": {
                    "type": "integer"
                },
                "portRangeStart": {
                    "type": "integer"
                },
                "protocol": {
                    "type": "string"
                },
                "sourceIp": {
                    "type": "string"
                },
                "sourceMac": {
                    "type": "string"
                },
                "targetIp": {
                    "type": "string"
                },
                "type": {
                    "type": "string",
                    "description": "(Computed)[string] Server usages: [ENTERPRISE](https://docs.ionos.com/cloud/compute-engine/virtual-servers/virtual-servers) or [CUBE](https://docs.ionos.com/cloud/compute-engine/virtual-servers/cloud-cubes). This property is immutable.\n"
                }
            },
            "type": "object",
            "required": [
                "protocol"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "id",
                        "protocol",
                        "type"
                    ]
                }
            }
        },
        "ionoscloud:compute/ServerVolume:ServerVolume": {
            "properties": {
                "availabilityZone": {
                    "type": "string",
                    "description": "[string] The availability zone in which the server should exist. E.g: `AUTO`, `ZONE_1`, `ZONE_2`. This property is immutable.\n"
                },
                "backupUnitId": {
                    "type": "string",
                    "description": "The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.\n"
                },
                "bootServer": {
                    "type": "string",
                    "description": "The UUID of the attached server.\n"
                },
                "bus": {
                    "type": "string"
                },
                "cpuHotPlug": {
                    "type": "boolean"
                },
                "deviceNumber": {
                    "type": "integer"
                },
                "discVirtioHotPlug": {
                    "type": "boolean"
                },
                "discVirtioHotUnplug": {
                    "type": "boolean"
                },
                "diskType": {
                    "type": "string"
                },
                "imagePassword": {
                    "type": "string",
                    "description": "[string] Required if `ssh_key_path` is not provided.\n",
                    "deprecationMessage": "Please use image_password under server level"
                },
                "licenceType": {
                    "type": "string",
                    "description": "[string] Sets the OS type of the server.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the server.\n"
                },
                "nicHotPlug": {
                    "type": "boolean"
                },
                "nicHotUnplug": {
                    "type": "boolean"
                },
                "pciSlot": {
                    "type": "integer"
                },
                "ramHotPlug": {
                    "type": "boolean"
                },
                "size": {
                    "type": "integer",
                    "description": "The size of the volume in GB.\n"
                },
                "sshKeyPaths": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] List of absolute paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images.  Also accepts ssh keys directly. Required for IonosCloud Linux images. Required if `image_password` is not provided. Does not support `~` expansion to homedir in the given path. This property is immutable.\n",
                    "deprecationMessage": "Please use ssh_key_path under server level"
                },
                "sshKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] Immutable List of absolute or relative paths to files containing public SSH key that will be injected into IonosCloud provided Linux images. Also accepts ssh keys directly. Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key. This field may only be set in creation requests. When reading, it always returns null. SSH keys are only supported if a public Linux image is used for the volume creation. Does not support `~` expansion to homedir in the given path.\n",
                    "deprecationMessage": "Please use ssh_keys under server level",
                    "willReplaceOnChanges": true
                },
                "userData": {
                    "type": "string",
                    "description": "The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.\n"
                }
            },
            "type": "object",
            "required": [
                "diskType"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "availabilityZone",
                        "backupUnitId",
                        "bootServer",
                        "bus",
                        "cpuHotPlug",
                        "deviceNumber",
                        "discVirtioHotPlug",
                        "discVirtioHotUnplug",
                        "diskType",
                        "licenceType",
                        "nicHotPlug",
                        "nicHotUnplug",
                        "pciSlot",
                        "ramHotPlug",
                        "size",
                        "sshKeys",
                        "userData"
                    ]
                }
            }
        },
        "ionoscloud:compute/TargetGroupHealthCheck:TargetGroupHealthCheck": {
            "properties": {
                "checkInterval": {
                    "type": "integer",
                    "description": "[int] The interval in milliseconds between consecutive health checks; default is 2000.\n"
                },
                "checkTimeout": {
                    "type": "integer",
                    "description": "[int] The maximum time in milliseconds to wait for a target to respond to a check. For target VMs with 'Check Interval' set, the lesser of the two  values is used once the TCP connection is established.\n"
                },
                "retries": {
                    "type": "integer",
                    "description": "[int] The maximum number of attempts to reconnect to a target after a connection failure. Valid range is 0 to 65535, and default is three reconnection.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "checkInterval",
                        "checkTimeout",
                        "retries"
                    ]
                }
            }
        },
        "ionoscloud:compute/TargetGroupHttpHealthCheck:TargetGroupHttpHealthCheck": {
            "properties": {
                "matchType": {
                    "type": "string",
                    "description": "[string]\n"
                },
                "method": {
                    "type": "string",
                    "description": "[string] The method for the HTTP health check.\n"
                },
                "negate": {
                    "type": "boolean",
                    "description": "[bool]\n"
                },
                "path": {
                    "type": "string",
                    "description": "[string] The path (destination URL) for the HTTP health check request; the default is /.\n"
                },
                "regex": {
                    "type": "boolean",
                    "description": "[bool]\n"
                },
                "response": {
                    "type": "string",
                    "description": "[string] The response returned by the request, depending on the match type.\n"
                }
            },
            "type": "object",
            "required": [
                "matchType",
                "response"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "matchType",
                        "method",
                        "path",
                        "response"
                    ]
                }
            }
        },
        "ionoscloud:compute/TargetGroupTarget:TargetGroupTarget": {
            "properties": {
                "healthCheckEnabled": {
                    "type": "boolean",
                    "description": "[bool] Makes the target available only if it accepts periodic health check TCP connection attempts; when turned off, the target is considered always available. The health check only consists of a connection attempt to the address and port of the target. Default is True.\n"
                },
                "ip": {
                    "type": "string",
                    "description": "[string] The IP of the balanced target VM.\n"
                },
                "maintenanceEnabled": {
                    "type": "boolean",
                    "description": "[bool] Maintenance mode prevents the target from receiving balanced traffic.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "[int] The port of the balanced target service; valid range is 1 to 65535.\n"
                },
                "proxyProtocol": {
                    "type": "string",
                    "description": "[string] The proxy protocol version. Accepted values are `none`, `v1`, `v2`, `v2ssl`. If unspecified, the default value of `none` is used.\n"
                },
                "weight": {
                    "type": "integer",
                    "description": "[int] Traffic is distributed in proportion to target weight, relative to the combined weight of all targets. A target with higher weight receives a greater share of traffic. Valid range is 0 to 256 and default is 1; targets with weight of 0 do not participate in load balancing but still accept persistent connections. It is best use values in the middle of the range to leave room for later adjustments.\n"
                }
            },
            "type": "object",
            "required": [
                "ip",
                "port",
                "weight"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "healthCheckEnabled",
                        "ip",
                        "port",
                        "weight"
                    ]
                }
            }
        },
        "ionoscloud:compute/VCPUServerLabel:VCPUServerLabel": {
            "properties": {
                "key": {
                    "type": "string"
                },
                "value": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ]
        },
        "ionoscloud:compute/VCPUServerNic:VCPUServerNic": {
            "properties": {
                "deviceNumber": {
                    "type": "integer"
                },
                "dhcp": {
                    "type": "boolean"
                },
                "dhcpv6": {
                    "type": "boolean"
                },
                "firewallActive": {
                    "type": "boolean"
                },
                "firewallType": {
                    "type": "string"
                },
                "firewalls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:compute/VCPUServerNicFirewall:VCPUServerNicFirewall"
                    },
                    "description": "Allows to define firewall rules inline in the server. See the Firewall section.\n"
                },
                "id": {
                    "type": "string"
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Collection of IP addresses assigned to a nic. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.\n"
                },
                "ipv6CidrBlock": {
                    "type": "string"
                },
                "ipv6Ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "lan": {
                    "type": "integer"
                },
                "mac": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the server.\n"
                },
                "pciSlot": {
                    "type": "integer"
                }
            },
            "type": "object",
            "required": [
                "lan"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "deviceNumber",
                        "firewallType",
                        "id",
                        "ips",
                        "ipv6CidrBlock",
                        "ipv6Ips",
                        "lan",
                        "mac",
                        "pciSlot"
                    ]
                }
            }
        },
        "ionoscloud:compute/VCPUServerNicFirewall:VCPUServerNicFirewall": {
            "properties": {
                "icmpCode": {
                    "type": "string"
                },
                "icmpType": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the server.\n"
                },
                "portRangeEnd": {
                    "type": "integer"
                },
                "portRangeStart": {
                    "type": "integer"
                },
                "protocol": {
                    "type": "string"
                },
                "sourceIp": {
                    "type": "string"
                },
                "sourceMac": {
                    "type": "string"
                },
                "targetIp": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "protocol"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "id",
                        "protocol",
                        "type"
                    ]
                }
            }
        },
        "ionoscloud:compute/VCPUServerVolume:VCPUServerVolume": {
            "properties": {
                "availabilityZone": {
                    "type": "string",
                    "description": "[string] The availability zone in which the server should exist. E.g: `AUTO`, `ZONE_1`, `ZONE_2`. This property is immutable.\n",
                    "willReplaceOnChanges": true
                },
                "backupUnitId": {
                    "type": "string",
                    "description": "The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.\n",
                    "willReplaceOnChanges": true
                },
                "bootServer": {
                    "type": "string",
                    "description": "The UUID of the attached server.\n"
                },
                "bus": {
                    "type": "string"
                },
                "cpuHotPlug": {
                    "type": "boolean"
                },
                "deviceNumber": {
                    "type": "integer"
                },
                "discVirtioHotPlug": {
                    "type": "boolean"
                },
                "discVirtioHotUnplug": {
                    "type": "boolean"
                },
                "diskType": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "licenceType": {
                    "type": "string",
                    "description": "[string] Sets the OS type of the server.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the server.\n"
                },
                "nicHotPlug": {
                    "type": "boolean"
                },
                "nicHotUnplug": {
                    "type": "boolean"
                },
                "pciSlot": {
                    "type": "integer"
                },
                "ramHotPlug": {
                    "type": "boolean"
                },
                "size": {
                    "type": "integer",
                    "description": "The size of the volume in GB.\n"
                },
                "userData": {
                    "type": "string",
                    "description": "The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "diskType"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "availabilityZone",
                        "backupUnitId",
                        "bootServer",
                        "bus",
                        "cpuHotPlug",
                        "deviceNumber",
                        "discVirtioHotPlug",
                        "discVirtioHotUnplug",
                        "diskType",
                        "licenceType",
                        "nicHotPlug",
                        "nicHotUnplug",
                        "pciSlot",
                        "ramHotPlug",
                        "size",
                        "userData"
                    ]
                }
            }
        },
        "ionoscloud:compute/getCrossconnectConnectableDatacenter:getCrossconnectConnectableDatacenter": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "ID of the cross connect you want to search for.\n\nEither `name` or `id` must be provided. If none, or both are provided, the datasource will return an error.\n"
                },
                "location": {
                    "type": "string",
                    "description": "The physical location of the connectable datacenter\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of an existing cross connect that you want to search for.\n"
                }
            },
            "type": "object",
            "required": [
                "id",
                "location",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:compute/getCrossconnectPeer:getCrossconnectPeer": {
            "properties": {
                "datacenterId": {
                    "type": "string",
                    "description": "The id of the cross-connected datacenter\n"
                },
                "datacenterName": {
                    "type": "string",
                    "description": "The name of the cross-connected datacenter\n"
                },
                "lanId": {
                    "type": "string",
                    "description": "The id of the cross-connected LAN\n"
                },
                "lanName": {
                    "type": "string",
                    "description": "The name of the cross-connected LAN\n"
                },
                "location": {
                    "type": "string",
                    "description": "The physical location of the connectable datacenter\n"
                }
            },
            "type": "object",
            "required": [
                "datacenterId",
                "datacenterName",
                "lanId",
                "lanName",
                "location"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:compute/getCubeServerCdrom:getCubeServerCdrom": {
            "properties": {
                "cloudInit": {
                    "type": "string",
                    "description": "Cloud init compatibility\n"
                },
                "cpuHotPlug": {
                    "type": "boolean",
                    "description": "Is capable of CPU hot plug (no reboot required)\n"
                },
                "cpuHotUnplug": {
                    "type": "boolean",
                    "description": "Is capable of CPU hot unplug (no reboot required)\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of cdrom\n"
                },
                "discScsiHotPlug": {
                    "type": "boolean",
                    "description": "Is capable of SCSI drive hot plug (no reboot required)\n"
                },
                "discScsiHotUnplug": {
                    "type": "boolean",
                    "description": "Is capable of SCSI drive hot unplug (no reboot required)\n"
                },
                "discVirtioHotPlug": {
                    "type": "boolean",
                    "description": "Is capable of Virt-IO drive hot plug (no reboot required)\n"
                },
                "discVirtioHotUnplug": {
                    "type": "boolean",
                    "description": "Is capable of Virt-IO drive hot unplug (no reboot required)\n"
                },
                "id": {
                    "type": "string",
                    "description": "ID of the server you want to search for.\n\n`datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.\n"
                },
                "imageAliases": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of image aliases mapped for this Image\n"
                },
                "imageType": {
                    "type": "string",
                    "description": "Type of image\n"
                },
                "licenceType": {
                    "type": "string",
                    "description": "OS type of this volume\n"
                },
                "location": {
                    "type": "string",
                    "description": "Location of that image/snapshot\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of an existing server that you want to search for.\n"
                },
                "nicHotPlug": {
                    "type": "boolean",
                    "description": "Is capable of nic hot plug (no reboot required)\n"
                },
                "nicHotUnplug": {
                    "type": "boolean",
                    "description": "Is capable of nic hot unplug (no reboot required)\n"
                },
                "public": {
                    "type": "boolean",
                    "description": "Indicates if the image is part of the public repository or not\n"
                },
                "ramHotPlug": {
                    "type": "boolean",
                    "description": "Is capable of memory hot plug (no reboot required)\n"
                },
                "ramHotUnplug": {
                    "type": "boolean",
                    "description": "Is capable of memory hot unplug (no reboot required)\n"
                },
                "size": {
                    "type": "number",
                    "description": "The size of the image in GB\n"
                }
            },
            "type": "object",
            "required": [
                "cloudInit",
                "cpuHotPlug",
                "cpuHotUnplug",
                "description",
                "discScsiHotPlug",
                "discScsiHotUnplug",
                "discVirtioHotPlug",
                "discVirtioHotUnplug",
                "id",
                "imageAliases",
                "imageType",
                "licenceType",
                "location",
                "name",
                "nicHotPlug",
                "nicHotUnplug",
                "public",
                "ramHotPlug",
                "ramHotUnplug",
                "size"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:compute/getCubeServerNic:getCubeServerNic": {
            "properties": {
                "deviceNumber": {
                    "type": "integer",
                    "description": "The Logical Unit Number (LUN) of the storage volume\n"
                },
                "dhcp": {
                    "type": "boolean",
                    "description": "Indicates if the nic will reserve an IP using DHCP\n"
                },
                "dhcpv6": {
                    "type": "boolean"
                },
                "firewallActive": {
                    "type": "boolean",
                    "description": "Activate or deactivate the firewall\n"
                },
                "firewallRules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:compute/getCubeServerNicFirewallRule:getCubeServerNicFirewallRule"
                    },
                    "description": "list of\n"
                },
                "firewallType": {
                    "type": "string",
                    "description": "The type of firewall rules that will be allowed on the NIC\n"
                },
                "id": {
                    "type": "string",
                    "description": "ID of the server you want to search for.\n\n`datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.\n"
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Collection of IP addresses assigned to a nic\n"
                },
                "ipv6CidrBlock": {
                    "type": "string"
                },
                "ipv6Ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "lan": {
                    "type": "integer",
                    "description": "The LAN ID the NIC will sit on\n"
                },
                "mac": {
                    "type": "string",
                    "description": "The MAC address of the NIC\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of an existing server that you want to search for.\n"
                },
                "pciSlot": {
                    "type": "integer",
                    "description": "The PCI slot number of the Nic\n"
                }
            },
            "type": "object",
            "required": [
                "deviceNumber",
                "dhcp",
                "firewallActive",
                "firewallRules",
                "firewallType",
                "id",
                "ips",
                "ipv6CidrBlock",
                "ipv6Ips",
                "lan",
                "mac",
                "name",
                "pciSlot"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:compute/getCubeServerNicFirewallRule:getCubeServerNicFirewallRule": {
            "properties": {
                "icmpCode": {
                    "type": "integer",
                    "description": "Defines the allowed code (from 0 to 254) if protocol ICMP is chosen\n"
                },
                "icmpType": {
                    "type": "integer",
                    "description": "Defines the allowed type (from 0 to 254) if the protocol ICMP is chosen\n"
                },
                "id": {
                    "type": "string",
                    "description": "ID of the server you want to search for.\n\n`datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of an existing server that you want to search for.\n"
                },
                "portRangeEnd": {
                    "type": "integer",
                    "description": "Defines the end range of the allowed port (from 1 to 65534) if the protocol TCP or UDP is chosen\n"
                },
                "portRangeStart": {
                    "type": "integer",
                    "description": "Defines the start range of the allowed port (from 1 to 65534) if protocol TCP or UDP is chosen\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "he protocol for the rule\n"
                },
                "sourceIp": {
                    "type": "string",
                    "description": "Only traffic originating from the respective IPv4 address is allowed. Value null allows all source IPs\n"
                },
                "sourceMac": {
                    "type": "string",
                    "description": "Only traffic originating from the respective MAC address is allowed\n"
                },
                "targetIp": {
                    "type": "string",
                    "description": "In case the target NIC has multiple IP addresses, only traffic directed to the respective IP address of the NIC is allowed\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of firewall rule\n"
                }
            },
            "type": "object",
            "required": [
                "icmpCode",
                "icmpType",
                "id",
                "name",
                "portRangeEnd",
                "portRangeStart",
                "protocol",
                "sourceIp",
                "sourceMac",
                "targetIp",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:compute/getCubeServerVolume:getCubeServerVolume": {
            "properties": {
                "availabilityZone": {
                    "type": "string",
                    "description": "The availability zone in which the volume should exist\n"
                },
                "backupUnitId": {
                    "type": "string",
                    "description": "The uuid of the Backup Unit that user has access to\n"
                },
                "bootServer": {
                    "type": "string",
                    "description": "The UUID of the attached server.\n"
                },
                "bus": {
                    "type": "string",
                    "description": "The bus type of the volume\n"
                },
                "cpuHotPlug": {
                    "type": "boolean",
                    "description": "Is capable of CPU hot plug (no reboot required)\n"
                },
                "deviceNumber": {
                    "type": "integer",
                    "description": "The Logical Unit Number (LUN) of the storage volume\n"
                },
                "discVirtioHotPlug": {
                    "type": "boolean",
                    "description": "Is capable of Virt-IO drive hot plug (no reboot required)\n"
                },
                "discVirtioHotUnplug": {
                    "type": "boolean",
                    "description": "Is capable of Virt-IO drive hot unplug (no reboot required)\n"
                },
                "id": {
                    "type": "string",
                    "description": "ID of the server you want to search for.\n\n`datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.\n"
                },
                "imageName": {
                    "type": "string"
                },
                "imagePassword": {
                    "type": "string",
                    "description": "Initial password to be set for installed OS\n"
                },
                "licenceType": {
                    "type": "string",
                    "description": "OS type of this volume\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of an existing server that you want to search for.\n"
                },
                "nicHotPlug": {
                    "type": "boolean",
                    "description": "Is capable of nic hot plug (no reboot required)\n"
                },
                "nicHotUnplug": {
                    "type": "boolean",
                    "description": "Is capable of nic hot unplug (no reboot required)\n"
                },
                "pciSlot": {
                    "type": "integer",
                    "description": "The PCI slot number of the Nic\n"
                },
                "ramHotPlug": {
                    "type": "boolean",
                    "description": "Is capable of memory hot plug (no reboot required)\n"
                },
                "sshKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of firewall rule\n"
                },
                "userData": {
                    "type": "string",
                    "description": "The cloud-init configuration for the volume as base64 encoded string\n"
                }
            },
            "type": "object",
            "required": [
                "availabilityZone",
                "backupUnitId",
                "bootServer",
                "bus",
                "cpuHotPlug",
                "deviceNumber",
                "discVirtioHotPlug",
                "discVirtioHotUnplug",
                "id",
                "imageName",
                "imagePassword",
                "licenceType",
                "name",
                "nicHotPlug",
                "nicHotUnplug",
                "pciSlot",
                "ramHotPlug",
                "sshKeys",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:compute/getDatacenterCpuArchitecture:getDatacenterCpuArchitecture": {
            "properties": {
                "cpuFamily": {
                    "type": "string",
                    "description": "A valid CPU family name\n"
                },
                "maxCores": {
                    "type": "integer",
                    "description": "The maximum number of cores available\n"
                },
                "maxRam": {
                    "type": "integer",
                    "description": "The maximum number of RAM in MB\n"
                },
                "vendor": {
                    "type": "string",
                    "description": "A valid CPU vendor name\n"
                }
            },
            "type": "object",
            "required": [
                "cpuFamily",
                "maxCores",
                "maxRam",
                "vendor"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:compute/getGroupUser:getGroupUser": {
            "properties": {
                "administrator": {
                    "type": "boolean"
                },
                "email": {
                    "type": "string"
                },
                "firstName": {
                    "type": "string"
                },
                "forceSecAuth": {
                    "type": "boolean"
                },
                "id": {
                    "type": "string",
                    "description": "ID of the group you want to search for.\n\nEither `name` or `id` must be provided. If none, or both are provided, the datasource will return an error.\n"
                },
                "lastName": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "administrator",
                "email",
                "firstName",
                "forceSecAuth",
                "id",
                "lastName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:compute/getIPBlockIpConsumer:getIPBlockIpConsumer": {
            "properties": {
                "datacenterId": {
                    "type": "string"
                },
                "datacenterName": {
                    "type": "string"
                },
                "ip": {
                    "type": "string"
                },
                "k8sClusterUuid": {
                    "type": "string"
                },
                "k8sNodepoolUuid": {
                    "type": "string"
                },
                "mac": {
                    "type": "string"
                },
                "nicId": {
                    "type": "string"
                },
                "serverId": {
                    "type": "string"
                },
                "serverName": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "datacenterId",
                "datacenterName",
                "ip",
                "k8sClusterUuid",
                "k8sNodepoolUuid",
                "mac",
                "nicId",
                "serverId",
                "serverName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:compute/getLanIpFailover:getLanIpFailover": {
            "properties": {
                "ip": {
                    "type": "string"
                },
                "nicUuid": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "ip",
                "nicUuid"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:compute/getLocationCpuArchitecture:getLocationCpuArchitecture": {
            "properties": {
                "cpuFamily": {
                    "type": "string",
                    "description": "A valid CPU family name.\n"
                },
                "maxCores": {
                    "type": "integer",
                    "description": "The maximum number of cores available.\n"
                },
                "maxRam": {
                    "type": "integer",
                    "description": "The maximum number of RAM in MB.\n"
                },
                "vendor": {
                    "type": "string",
                    "description": "A valid CPU vendor name.\n"
                }
            },
            "type": "object",
            "required": [
                "cpuFamily",
                "maxCores",
                "maxRam",
                "vendor"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:compute/getNatGatewayLan:getNatGatewayLan": {
            "properties": {
                "gatewayIps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Collection of gateway IP addresses of the NAT gateway. Will be auto-generated if not provided. Should ideally be an IP belonging to the same subnet as the LAN\n"
                },
                "id": {
                    "type": "integer",
                    "description": "ID of the network load balancer forwarding rule you want to search for.\n\n`datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.\n"
                }
            },
            "type": "object",
            "required": [
                "gatewayIps",
                "id"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:compute/getNatGatewayRuleTargetPortRange:getNatGatewayRuleTargetPortRange": {
            "properties": {
                "end": {
                    "type": "integer",
                    "description": "Target port range end associated with the NAT gateway rule.\n"
                },
                "start": {
                    "type": "integer",
                    "description": "Target port range start associated with the NAT gateway rule.\n"
                }
            },
            "type": "object",
            "required": [
                "end",
                "start"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:compute/getNicFlowlog:getNicFlowlog": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL.\n"
                },
                "bucket": {
                    "type": "string",
                    "description": "Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist.\n"
                },
                "direction": {
                    "type": "string",
                    "description": "Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL.\n"
                },
                "id": {
                    "type": "string",
                    "description": "ID of the nic you want to search for.\n\n`datacenter_id` and either `name` or `id` must be provided.\nIf none, are provided, the datasource will return an error.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the LAN.\n"
                }
            },
            "type": "object",
            "required": [
                "action",
                "bucket",
                "direction",
                "id",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:compute/getServerCdrom:getServerCdrom": {
            "properties": {
                "cloudInit": {
                    "type": "string",
                    "description": "Cloud init compatibility\n"
                },
                "cpuHotPlug": {
                    "type": "boolean",
                    "description": "Is capable of CPU hot plug (no reboot required)\n"
                },
                "cpuHotUnplug": {
                    "type": "boolean",
                    "description": "Is capable of CPU hot unplug (no reboot required)\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of cdrom\n"
                },
                "discScsiHotPlug": {
                    "type": "boolean",
                    "description": "Is capable of SCSI drive hot plug (no reboot required)\n"
                },
                "discScsiHotUnplug": {
                    "type": "boolean",
                    "description": "Is capable of SCSI drive hot unplug (no reboot required)\n"
                },
                "discVirtioHotPlug": {
                    "type": "boolean",
                    "description": "Is capable of Virt-IO drive hot plug (no reboot required)\n"
                },
                "discVirtioHotUnplug": {
                    "type": "boolean",
                    "description": "Is capable of Virt-IO drive hot unplug (no reboot required)\n"
                },
                "id": {
                    "type": "string",
                    "description": "ID of the server you want to search for.\n\n`datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.\n"
                },
                "imageAliases": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of image aliases mapped for this Image\n"
                },
                "imageType": {
                    "type": "string",
                    "description": "Type of image\n"
                },
                "licenceType": {
                    "type": "string",
                    "description": "OS type of this volume\n"
                },
                "location": {
                    "type": "string",
                    "description": "Location of that image/snapshot\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of an existing server that you want to search for.\n"
                },
                "nicHotPlug": {
                    "type": "boolean",
                    "description": "Is capable of nic hot plug (no reboot required)\n"
                },
                "nicHotUnplug": {
                    "type": "boolean",
                    "description": "Is capable of nic hot unplug (no reboot required)\n"
                },
                "public": {
                    "type": "boolean",
                    "description": "Indicates if the image is part of the public repository or not\n"
                },
                "ramHotPlug": {
                    "type": "boolean",
                    "description": "Is capable of memory hot plug (no reboot required)\n"
                },
                "ramHotUnplug": {
                    "type": "boolean",
                    "description": "Is capable of memory hot unplug (no reboot required)\n"
                },
                "size": {
                    "type": "number",
                    "description": "The size of the volume in GB\n"
                }
            },
            "type": "object",
            "required": [
                "cloudInit",
                "cpuHotPlug",
                "cpuHotUnplug",
                "description",
                "discScsiHotPlug",
                "discScsiHotUnplug",
                "discVirtioHotPlug",
                "discVirtioHotUnplug",
                "id",
                "imageAliases",
                "imageType",
                "licenceType",
                "location",
                "name",
                "nicHotPlug",
                "nicHotUnplug",
                "public",
                "ramHotPlug",
                "ramHotUnplug",
                "size"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:compute/getServerLabel:getServerLabel": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "ID of the server you want to search for.\n\n`datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.\n"
                },
                "key": {
                    "type": "string",
                    "description": "The key of the label\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value of the label\n"
                }
            },
            "type": "object",
            "required": [
                "id",
                "key",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:compute/getServerNic:getServerNic": {
            "properties": {
                "deviceNumber": {
                    "type": "integer",
                    "description": "The Logical Unit Number (LUN) of the storage volume\n"
                },
                "dhcp": {
                    "type": "boolean",
                    "description": "Indicates if the nic will reserve an IP using DHCP\n"
                },
                "dhcpv6": {
                    "type": "boolean"
                },
                "firewallActive": {
                    "type": "boolean",
                    "description": "Activate or deactivate the firewall\n"
                },
                "firewallRules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:compute/getServerNicFirewallRule:getServerNicFirewallRule"
                    },
                    "description": "list of\n"
                },
                "firewallType": {
                    "type": "string",
                    "description": "The type of firewall rules that will be allowed on the NIC\n"
                },
                "id": {
                    "type": "string",
                    "description": "ID of the server you want to search for.\n\n`datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.\n"
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Collection of IP addresses assigned to a nic\n"
                },
                "ipv6CidrBlock": {
                    "type": "string"
                },
                "ipv6Ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "lan": {
                    "type": "integer",
                    "description": "The LAN ID the NIC will sit on\n"
                },
                "mac": {
                    "type": "string",
                    "description": "The MAC address of the NIC\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of an existing server that you want to search for.\n"
                },
                "pciSlot": {
                    "type": "integer",
                    "description": "The PCI slot number of the Nic\n"
                }
            },
            "type": "object",
            "required": [
                "deviceNumber",
                "dhcp",
                "firewallActive",
                "firewallRules",
                "firewallType",
                "id",
                "ips",
                "ipv6CidrBlock",
                "ipv6Ips",
                "lan",
                "mac",
                "name",
                "pciSlot"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:compute/getServerNicFirewallRule:getServerNicFirewallRule": {
            "properties": {
                "icmpCode": {
                    "type": "integer",
                    "description": "Defines the allowed code (from 0 to 254) if protocol ICMP is chosen\n"
                },
                "icmpType": {
                    "type": "integer",
                    "description": "Defines the allowed type (from 0 to 254) if the protocol ICMP is chosen\n"
                },
                "id": {
                    "type": "string",
                    "description": "ID of the server you want to search for.\n\n`datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of an existing server that you want to search for.\n"
                },
                "portRangeEnd": {
                    "type": "integer",
                    "description": "Defines the end range of the allowed port (from 1 to 65534) if the protocol TCP or UDP is chosen\n"
                },
                "portRangeStart": {
                    "type": "integer",
                    "description": "Defines the start range of the allowed port (from 1 to 65534) if protocol TCP or UDP is chosen\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "he protocol for the rule\n"
                },
                "sourceIp": {
                    "type": "string",
                    "description": "Only traffic originating from the respective IPv4 address is allowed. Value null allows all source IPs\n"
                },
                "sourceMac": {
                    "type": "string",
                    "description": "Only traffic originating from the respective MAC address is allowed\n"
                },
                "targetIp": {
                    "type": "string",
                    "description": "In case the target NIC has multiple IP addresses, only traffic directed to the respective IP address of the NIC is allowed\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of firewall rule\n"
                }
            },
            "type": "object",
            "required": [
                "icmpCode",
                "icmpType",
                "id",
                "name",
                "portRangeEnd",
                "portRangeStart",
                "protocol",
                "sourceIp",
                "sourceMac",
                "targetIp",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:compute/getServerVolume:getServerVolume": {
            "properties": {
                "availabilityZone": {
                    "type": "string",
                    "description": "The availability zone in which the volume should exist\n"
                },
                "backupUnitId": {
                    "type": "string",
                    "description": "The uuid of the Backup Unit that user has access to\n"
                },
                "bootServer": {
                    "type": "string",
                    "description": "The UUID of the attached server.\n"
                },
                "bus": {
                    "type": "string",
                    "description": "The bus type of the volume\n"
                },
                "cpuHotPlug": {
                    "type": "boolean",
                    "description": "Is capable of CPU hot plug (no reboot required)\n"
                },
                "deviceNumber": {
                    "type": "integer",
                    "description": "The Logical Unit Number (LUN) of the storage volume\n"
                },
                "discVirtioHotPlug": {
                    "type": "boolean",
                    "description": "Is capable of Virt-IO drive hot plug (no reboot required)\n"
                },
                "discVirtioHotUnplug": {
                    "type": "boolean",
                    "description": "Is capable of Virt-IO drive hot unplug (no reboot required)\n"
                },
                "id": {
                    "type": "string",
                    "description": "ID of the server you want to search for.\n\n`datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.\n"
                },
                "imageName": {
                    "type": "string"
                },
                "imagePassword": {
                    "type": "string",
                    "description": "Initial password to be set for installed OS\n"
                },
                "licenceType": {
                    "type": "string",
                    "description": "OS type of this volume\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of an existing server that you want to search for.\n"
                },
                "nicHotPlug": {
                    "type": "boolean",
                    "description": "Is capable of nic hot plug (no reboot required)\n"
                },
                "nicHotUnplug": {
                    "type": "boolean",
                    "description": "Is capable of nic hot unplug (no reboot required)\n"
                },
                "pciSlot": {
                    "type": "integer",
                    "description": "The PCI slot number of the Nic\n"
                },
                "ramHotPlug": {
                    "type": "boolean",
                    "description": "Is capable of memory hot plug (no reboot required)\n"
                },
                "size": {
                    "type": "integer",
                    "description": "The size of the volume in GB\n"
                },
                "sshKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of firewall rule\n"
                },
                "userData": {
                    "type": "string",
                    "description": "The cloud-init configuration for the volume as base64 encoded string\n"
                }
            },
            "type": "object",
            "required": [
                "availabilityZone",
                "backupUnitId",
                "bootServer",
                "bus",
                "cpuHotPlug",
                "deviceNumber",
                "discVirtioHotPlug",
                "discVirtioHotUnplug",
                "id",
                "imageName",
                "imagePassword",
                "licenceType",
                "name",
                "nicHotPlug",
                "nicHotUnplug",
                "pciSlot",
                "ramHotPlug",
                "size",
                "sshKeys",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:compute/getServersFilter:getServersFilter": {
            "properties": {
                "name": {
                    "type": "string"
                },
                "value": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "name",
                "value"
            ]
        },
        "ionoscloud:compute/getServersServer:getServersServer": {
            "properties": {
                "availabilityZone": {
                    "type": "string"
                },
                "bootCdrom": {
                    "type": "string"
                },
                "bootImage": {
                    "type": "string"
                },
                "bootVolume": {
                    "type": "string"
                },
                "cdroms": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:compute/getServersServerCdrom:getServersServerCdrom"
                    }
                },
                "cores": {
                    "type": "integer"
                },
                "cpuFamily": {
                    "type": "string"
                },
                "id": {
                    "type": "string",
                    "description": "The unique ID of the server.\n"
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:compute/getServersServerLabel:getServersServerLabel"
                    }
                },
                "name": {
                    "type": "string"
                },
                "nics": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:compute/getServersServerNic:getServersServerNic"
                    }
                },
                "ram": {
                    "type": "integer"
                },
                "templateUuid": {
                    "type": "string"
                },
                "token": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                },
                "vmState": {
                    "type": "string"
                },
                "volumes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:compute/getServersServerVolume:getServersServerVolume"
                    }
                }
            },
            "type": "object",
            "required": [
                "availabilityZone",
                "bootCdrom",
                "bootImage",
                "bootVolume",
                "cdroms",
                "cores",
                "cpuFamily",
                "id",
                "labels",
                "nics",
                "ram",
                "token",
                "type",
                "vmState",
                "volumes"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:compute/getServersServerCdrom:getServersServerCdrom": {
            "properties": {
                "cloudInit": {
                    "type": "string"
                },
                "cpuHotPlug": {
                    "type": "boolean"
                },
                "cpuHotUnplug": {
                    "type": "boolean"
                },
                "description": {
                    "type": "string"
                },
                "discScsiHotPlug": {
                    "type": "boolean"
                },
                "discScsiHotUnplug": {
                    "type": "boolean"
                },
                "discVirtioHotPlug": {
                    "type": "boolean"
                },
                "discVirtioHotUnplug": {
                    "type": "boolean"
                },
                "id": {
                    "type": "string"
                },
                "imageAliases": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "imageType": {
                    "type": "string"
                },
                "licenceType": {
                    "type": "string"
                },
                "location": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "nicHotPlug": {
                    "type": "boolean"
                },
                "nicHotUnplug": {
                    "type": "boolean"
                },
                "public": {
                    "type": "boolean"
                },
                "ramHotPlug": {
                    "type": "boolean"
                },
                "ramHotUnplug": {
                    "type": "boolean"
                },
                "size": {
                    "type": "number"
                }
            },
            "type": "object",
            "required": [
                "cloudInit",
                "cpuHotPlug",
                "cpuHotUnplug",
                "description",
                "discScsiHotPlug",
                "discScsiHotUnplug",
                "discVirtioHotPlug",
                "discVirtioHotUnplug",
                "id",
                "imageAliases",
                "imageType",
                "licenceType",
                "location",
                "name",
                "nicHotPlug",
                "nicHotUnplug",
                "public",
                "ramHotPlug",
                "ramHotUnplug",
                "size"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:compute/getServersServerLabel:getServersServerLabel": {
            "properties": {
                "id": {
                    "type": "string"
                },
                "key": {
                    "type": "string"
                },
                "value": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "id",
                "key",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:compute/getServersServerNic:getServersServerNic": {
            "properties": {
                "deviceNumber": {
                    "type": "integer"
                },
                "dhcp": {
                    "type": "boolean"
                },
                "dhcpv6": {
                    "type": "boolean"
                },
                "firewallActive": {
                    "type": "boolean"
                },
                "firewallRules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:compute/getServersServerNicFirewallRule:getServersServerNicFirewallRule"
                    }
                },
                "firewallType": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "ipv6CidrBlock": {
                    "type": "string"
                },
                "ipv6Ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "lan": {
                    "type": "integer"
                },
                "mac": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "pciSlot": {
                    "type": "integer"
                }
            },
            "type": "object",
            "required": [
                "deviceNumber",
                "dhcp",
                "firewallActive",
                "firewallRules",
                "firewallType",
                "id",
                "ips",
                "ipv6CidrBlock",
                "ipv6Ips",
                "lan",
                "mac",
                "name",
                "pciSlot"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:compute/getServersServerNicFirewallRule:getServersServerNicFirewallRule": {
            "properties": {
                "icmpCode": {
                    "type": "integer"
                },
                "icmpType": {
                    "type": "integer"
                },
                "id": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "portRangeEnd": {
                    "type": "integer"
                },
                "portRangeStart": {
                    "type": "integer"
                },
                "protocol": {
                    "type": "string"
                },
                "sourceIp": {
                    "type": "string"
                },
                "sourceMac": {
                    "type": "string"
                },
                "targetIp": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "icmpCode",
                "icmpType",
                "id",
                "name",
                "portRangeEnd",
                "portRangeStart",
                "protocol",
                "sourceIp",
                "sourceMac",
                "targetIp",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:compute/getServersServerVolume:getServersServerVolume": {
            "properties": {
                "availabilityZone": {
                    "type": "string"
                },
                "backupUnitId": {
                    "type": "string"
                },
                "bootServer": {
                    "type": "string",
                    "description": "The UUID of the attached server.\n"
                },
                "bus": {
                    "type": "string"
                },
                "cpuHotPlug": {
                    "type": "boolean"
                },
                "deviceNumber": {
                    "type": "integer"
                },
                "discVirtioHotPlug": {
                    "type": "boolean"
                },
                "discVirtioHotUnplug": {
                    "type": "boolean"
                },
                "diskType": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "imageName": {
                    "type": "string"
                },
                "imagePassword": {
                    "type": "string"
                },
                "licenceType": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "nicHotPlug": {
                    "type": "boolean"
                },
                "nicHotUnplug": {
                    "type": "boolean"
                },
                "pciSlot": {
                    "type": "integer"
                },
                "ramHotPlug": {
                    "type": "boolean"
                },
                "size": {
                    "type": "integer"
                },
                "sshKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "userData": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "availabilityZone",
                "backupUnitId",
                "bootServer",
                "bus",
                "cpuHotPlug",
                "deviceNumber",
                "discVirtioHotPlug",
                "discVirtioHotUnplug",
                "diskType",
                "id",
                "imageName",
                "imagePassword",
                "licenceType",
                "name",
                "nicHotPlug",
                "nicHotUnplug",
                "pciSlot",
                "ramHotPlug",
                "size",
                "sshKeys"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:compute/getTargetGroupHealthCheck:getTargetGroupHealthCheck": {
            "properties": {
                "checkInterval": {
                    "type": "integer",
                    "description": "The interval in milliseconds between consecutive health checks; default is 2000.\n"
                },
                "checkTimeout": {
                    "type": "integer",
                    "description": "The maximum time in milliseconds to wait for a target to respond to a check. For target VMs with 'Check Interval' set, the lesser of the two  values is used once the TCP connection is established.\n"
                },
                "retries": {
                    "type": "integer",
                    "description": "The maximum number of attempts to reconnect to a target after a connection failure. Valid range is 0 to 65535, and default is three reconnection.\n"
                }
            },
            "type": "object",
            "required": [
                "checkInterval",
                "checkTimeout",
                "retries"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:compute/getTargetGroupHttpHealthCheck:getTargetGroupHttpHealthCheck": {
            "properties": {
                "matchType": {
                    "type": "string"
                },
                "method": {
                    "type": "string",
                    "description": "The method for the HTTP health check.\n"
                },
                "negate": {
                    "type": "boolean"
                },
                "path": {
                    "type": "string",
                    "description": "The path (destination URL) for the HTTP health check request; the default is /.\n"
                },
                "regex": {
                    "type": "boolean"
                },
                "response": {
                    "type": "string",
                    "description": "The response returned by the request, depending on the match type.\n"
                }
            },
            "type": "object",
            "required": [
                "matchType",
                "method",
                "negate",
                "path",
                "regex",
                "response"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:compute/getTargetGroupTarget:getTargetGroupTarget": {
            "properties": {
                "healthCheckEnabled": {
                    "type": "boolean",
                    "description": "Makes the target available only if it accepts periodic health check TCP connection attempts; when turned off, the target is considered always available. The health check only consists of a connection attempt to the address and port of the target. Default is True.\n"
                },
                "ip": {
                    "type": "string",
                    "description": "The IP of the balanced target VM.\n"
                },
                "maintenanceEnabled": {
                    "type": "boolean",
                    "description": "Maintenance mode prevents the target from receiving balanced traffic.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "The port of the balanced target service; valid range is 1 to 65535.\n"
                },
                "proxyProtocol": {
                    "type": "string",
                    "description": "The proxy protocol version.\n"
                },
                "weight": {
                    "type": "integer",
                    "description": "Traffic is distributed in proportion to target weight, relative to the combined weight of all targets. A target with higher weight receives a greater share of traffic. Valid range is 0 to 256 and default is 1; targets with weight of 0 do not participate in load balancing but still accept persistent connections. It is best use values in the middle of the range to leave room for later adjustments.\n"
                }
            },
            "type": "object",
            "required": [
                "healthCheckEnabled",
                "ip",
                "maintenanceEnabled",
                "port",
                "proxyProtocol",
                "weight"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:compute/getUserGroup:getUserGroup": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "ID of the user you want to search for.\n\nEither `email` or `id` can be provided. If no argument is set, the provider will search for the **email that was provided for the configuration**. If none is found, the provider will return an error.\n"
                },
                "name": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "id",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:compute/getVCPUServerCdrom:getVCPUServerCdrom": {
            "properties": {
                "cloudInit": {
                    "type": "string",
                    "description": "Cloud init compatibility\n"
                },
                "cpuHotPlug": {
                    "type": "boolean",
                    "description": "Is capable of CPU hot plug (no reboot required)\n"
                },
                "cpuHotUnplug": {
                    "type": "boolean",
                    "description": "Is capable of CPU hot unplug (no reboot required)\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of cdrom\n"
                },
                "discScsiHotPlug": {
                    "type": "boolean",
                    "description": "Is capable of SCSI drive hot plug (no reboot required)\n"
                },
                "discScsiHotUnplug": {
                    "type": "boolean",
                    "description": "Is capable of SCSI drive hot unplug (no reboot required)\n"
                },
                "discVirtioHotPlug": {
                    "type": "boolean",
                    "description": "Is capable of Virt-IO drive hot plug (no reboot required)\n"
                },
                "discVirtioHotUnplug": {
                    "type": "boolean",
                    "description": "Is capable of Virt-IO drive hot unplug (no reboot required)\n"
                },
                "id": {
                    "type": "string",
                    "description": "ID of the server you want to search for.\n\n`datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.\n"
                },
                "imageAliases": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of image aliases mapped for this Image\n"
                },
                "imageType": {
                    "type": "string",
                    "description": "Type of image\n"
                },
                "licenceType": {
                    "type": "string",
                    "description": "OS type of this volume\n"
                },
                "location": {
                    "type": "string",
                    "description": "Location of that image/snapshot\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of an existing server that you want to search for.\n"
                },
                "nicHotPlug": {
                    "type": "boolean",
                    "description": "Is capable of nic hot plug (no reboot required)\n"
                },
                "nicHotUnplug": {
                    "type": "boolean",
                    "description": "Is capable of nic hot unplug (no reboot required)\n"
                },
                "public": {
                    "type": "boolean",
                    "description": "Indicates if the image is part of the public repository or not\n"
                },
                "ramHotPlug": {
                    "type": "boolean",
                    "description": "Is capable of memory hot plug (no reboot required)\n"
                },
                "ramHotUnplug": {
                    "type": "boolean",
                    "description": "Is capable of memory hot unplug (no reboot required)\n"
                },
                "size": {
                    "type": "number",
                    "description": "The size of the volume in GB\n"
                }
            },
            "type": "object",
            "required": [
                "cloudInit",
                "cpuHotPlug",
                "cpuHotUnplug",
                "description",
                "discScsiHotPlug",
                "discScsiHotUnplug",
                "discVirtioHotPlug",
                "discVirtioHotUnplug",
                "id",
                "imageAliases",
                "imageType",
                "licenceType",
                "location",
                "name",
                "nicHotPlug",
                "nicHotUnplug",
                "public",
                "ramHotPlug",
                "ramHotUnplug",
                "size"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:compute/getVCPUServerLabel:getVCPUServerLabel": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "ID of the server you want to search for.\n\n`datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.\n"
                },
                "key": {
                    "type": "string",
                    "description": "The key of the label\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value of the label\n"
                }
            },
            "type": "object",
            "required": [
                "id",
                "key",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:compute/getVCPUServerNic:getVCPUServerNic": {
            "properties": {
                "deviceNumber": {
                    "type": "integer",
                    "description": "The Logical Unit Number (LUN) of the storage volume\n"
                },
                "dhcp": {
                    "type": "boolean",
                    "description": "Indicates if the nic will reserve an IP using DHCP\n"
                },
                "dhcpv6": {
                    "type": "boolean"
                },
                "firewallActive": {
                    "type": "boolean",
                    "description": "Activate or deactivate the firewall\n"
                },
                "firewallRules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:compute/getVCPUServerNicFirewallRule:getVCPUServerNicFirewallRule"
                    },
                    "description": "list of\n"
                },
                "firewallType": {
                    "type": "string",
                    "description": "The type of firewall rules that will be allowed on the NIC\n"
                },
                "id": {
                    "type": "string",
                    "description": "ID of the server you want to search for.\n\n`datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.\n"
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Collection of IP addresses assigned to a nic\n"
                },
                "ipv6CidrBlock": {
                    "type": "string"
                },
                "ipv6Ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "lan": {
                    "type": "integer",
                    "description": "The LAN ID the NIC will sit on\n"
                },
                "mac": {
                    "type": "string",
                    "description": "The MAC address of the NIC\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of an existing server that you want to search for.\n"
                },
                "pciSlot": {
                    "type": "integer",
                    "description": "The PCI slot number of the Nic\n"
                }
            },
            "type": "object",
            "required": [
                "deviceNumber",
                "dhcp",
                "firewallActive",
                "firewallRules",
                "firewallType",
                "id",
                "ips",
                "ipv6CidrBlock",
                "ipv6Ips",
                "lan",
                "mac",
                "name",
                "pciSlot"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:compute/getVCPUServerNicFirewallRule:getVCPUServerNicFirewallRule": {
            "properties": {
                "icmpCode": {
                    "type": "integer",
                    "description": "Defines the allowed code (from 0 to 254) if protocol ICMP is chosen\n"
                },
                "icmpType": {
                    "type": "integer",
                    "description": "Defines the allowed type (from 0 to 254) if the protocol ICMP is chosen\n"
                },
                "id": {
                    "type": "string",
                    "description": "ID of the server you want to search for.\n\n`datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of an existing server that you want to search for.\n"
                },
                "portRangeEnd": {
                    "type": "integer",
                    "description": "Defines the end range of the allowed port (from 1 to 65534) if the protocol TCP or UDP is chosen\n"
                },
                "portRangeStart": {
                    "type": "integer",
                    "description": "Defines the start range of the allowed port (from 1 to 65534) if protocol TCP or UDP is chosen\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "he protocol for the rule\n"
                },
                "sourceIp": {
                    "type": "string",
                    "description": "Only traffic originating from the respective IPv4 address is allowed. Value null allows all source IPs\n"
                },
                "sourceMac": {
                    "type": "string",
                    "description": "Only traffic originating from the respective MAC address is allowed\n"
                },
                "targetIp": {
                    "type": "string",
                    "description": "In case the target NIC has multiple IP addresses, only traffic directed to the respective IP address of the NIC is allowed\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of firewall rule\n"
                }
            },
            "type": "object",
            "required": [
                "icmpCode",
                "icmpType",
                "id",
                "name",
                "portRangeEnd",
                "portRangeStart",
                "protocol",
                "sourceIp",
                "sourceMac",
                "targetIp",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:compute/getVCPUServerVolume:getVCPUServerVolume": {
            "properties": {
                "availabilityZone": {
                    "type": "string",
                    "description": "The availability zone in which the volume should exist\n"
                },
                "backupUnitId": {
                    "type": "string",
                    "description": "The uuid of the Backup Unit that user has access to\n"
                },
                "bootServer": {
                    "type": "string",
                    "description": "The UUID of the attached server.\n"
                },
                "bus": {
                    "type": "string",
                    "description": "The bus type of the volume\n"
                },
                "cpuHotPlug": {
                    "type": "boolean",
                    "description": "Is capable of CPU hot plug (no reboot required)\n"
                },
                "deviceNumber": {
                    "type": "integer",
                    "description": "The Logical Unit Number (LUN) of the storage volume\n"
                },
                "discVirtioHotPlug": {
                    "type": "boolean",
                    "description": "Is capable of Virt-IO drive hot plug (no reboot required)\n"
                },
                "discVirtioHotUnplug": {
                    "type": "boolean",
                    "description": "Is capable of Virt-IO drive hot unplug (no reboot required)\n"
                },
                "id": {
                    "type": "string",
                    "description": "ID of the server you want to search for.\n\n`datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.\n"
                },
                "imageName": {
                    "type": "string"
                },
                "imagePassword": {
                    "type": "string",
                    "description": "Initial password to be set for installed OS\n"
                },
                "licenceType": {
                    "type": "string",
                    "description": "OS type of this volume\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of an existing server that you want to search for.\n"
                },
                "nicHotPlug": {
                    "type": "boolean",
                    "description": "Is capable of nic hot plug (no reboot required)\n"
                },
                "nicHotUnplug": {
                    "type": "boolean",
                    "description": "Is capable of nic hot unplug (no reboot required)\n"
                },
                "pciSlot": {
                    "type": "integer",
                    "description": "The PCI slot number of the Nic\n"
                },
                "ramHotPlug": {
                    "type": "boolean",
                    "description": "Is capable of memory hot plug (no reboot required)\n"
                },
                "size": {
                    "type": "integer",
                    "description": "The size of the volume in GB\n"
                },
                "sshKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of firewall rule\n"
                },
                "userData": {
                    "type": "string",
                    "description": "The cloud-init configuration for the volume as base64 encoded string\n"
                }
            },
            "type": "object",
            "required": [
                "availabilityZone",
                "backupUnitId",
                "bootServer",
                "bus",
                "cpuHotPlug",
                "deviceNumber",
                "discVirtioHotPlug",
                "discVirtioHotUnplug",
                "id",
                "imageName",
                "imagePassword",
                "licenceType",
                "name",
                "nicHotPlug",
                "nicHotUnplug",
                "pciSlot",
                "ramHotPlug",
                "size",
                "sshKeys",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:creg/RegistryFeatures:RegistryFeatures": {
            "properties": {
                "vulnerabilityScanning": {
                    "type": "boolean",
                    "description": "[bool] Enables or disables the Vulnerability Scanning feature for the Container Registry. To disable this feature, set the attribute to false when creating the CR resource.\n\n\u003e **⚠ WARNING** `Container Registry Vulnerability Scanning` is a paid feature which is enabled by default, and cannot be turned off after activation. To disable this feature for a Container Registry, ensure `vulnerability_scanning` is set to false on resource creation.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "vulnerabilityScanning"
                    ]
                }
            }
        },
        "ionoscloud:creg/RegistryGarbageCollectionSchedule:RegistryGarbageCollectionSchedule": {
            "properties": {
                "days": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] Elements of list must have one of the values: `Saturday`, `Sunday`, `Monday`, `Tuesday`,  `Wednesday`,  `Thursday`,  `Friday`\n"
                },
                "time": {
                    "type": "string",
                    "description": "[string]\n"
                }
            },
            "type": "object",
            "required": [
                "days",
                "time"
            ]
        },
        "ionoscloud:creg/RegistryStorageUsage:RegistryStorageUsage": {
            "properties": {
                "bytes": {
                    "type": "integer"
                },
                "updatedAt": {
                    "type": "string"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "bytes",
                        "updatedAt"
                    ]
                }
            }
        },
        "ionoscloud:creg/RegistryTokenCredential:RegistryTokenCredential": {
            "properties": {
                "password": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "password",
                "username"
            ]
        },
        "ionoscloud:creg/RegistryTokenScope:RegistryTokenScope": {
            "properties": {
                "actions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[string] Example: [\"pull\", \"push\", \"delete\"]\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string]\n"
                },
                "type": {
                    "type": "string",
                    "description": "[string]\n"
                }
            },
            "type": "object",
            "required": [
                "actions",
                "name",
                "type"
            ]
        },
        "ionoscloud:creg/getRegistryFeature:getRegistryFeature": {
            "properties": {
                "vulnerabilityScanning": {
                    "type": "boolean"
                }
            },
            "type": "object",
            "required": [
                "vulnerabilityScanning"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:creg/getRegistryGarbageCollectionSchedule:getRegistryGarbageCollectionSchedule": {
            "properties": {
                "days": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "time": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "days",
                "time"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:creg/getRegistryMaintenanceWindow:getRegistryMaintenanceWindow": {
            "properties": {
                "days": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "time": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "days",
                "time"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:creg/getRegistryStorageUsage:getRegistryStorageUsage": {
            "properties": {
                "bytes": {
                    "type": "integer"
                },
                "updatedAt": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "bytes",
                "updatedAt"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:creg/getRegistryTokenCredential:getRegistryTokenCredential": {
            "properties": {
                "username": {
                    "type": "string",
                    "description": "* `expiry-date`\n"
                }
            },
            "type": "object",
            "required": [
                "username"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:creg/getRegistryTokenScope:getRegistryTokenScope": {
            "properties": {
                "actions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Name of an existing container registry token that you want to search for. Search by name is case-insensitive. The whole resource name is required if `partial_match` parameter is not set to true.\n"
                },
                "type": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "actions",
                "name",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:dbaas/InMemoryDBReplicaSetConnections:InMemoryDBReplicaSetConnections": {
            "properties": {
                "cidr": {
                    "type": "string",
                    "description": "[string] The IP and subnet for your instance. Note the following unavailable IP ranges: 10.233.64.0/18, 10.233.0.0/18, 10.233.114.0/24.\n",
                    "willReplaceOnChanges": true
                },
                "datacenterId": {
                    "type": "string",
                    "description": "[string] The datacenter to connect your instance to.\n",
                    "willReplaceOnChanges": true
                },
                "lanId": {
                    "type": "string",
                    "description": "[string] The numeric LAN ID to connect your instance to.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "cidr",
                "datacenterId",
                "lanId"
            ]
        },
        "ionoscloud:dbaas/InMemoryDBReplicaSetCredentials:InMemoryDBReplicaSetCredentials": {
            "properties": {
                "hashedPassword": {
                    "$ref": "#/types/ionoscloud:dbaas/InMemoryDBReplicaSetCredentialsHashedPassword:InMemoryDBReplicaSetCredentialsHashedPassword",
                    "description": "[object] The hashed password for a InMemoryDB user.\n"
                },
                "plainTextPassword": {
                    "type": "string",
                    "description": "[string] The password for a InMemoryDB user, this is a field that is marked as `Sensitive`.\n",
                    "secret": true,
                    "willReplaceOnChanges": true
                },
                "username": {
                    "type": "string",
                    "description": "[string] The username for the initial InMemoryDB user. Some system usernames are restricted (e.g. 'admin', 'standby').\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "username"
            ]
        },
        "ionoscloud:dbaas/InMemoryDBReplicaSetCredentialsHashedPassword:InMemoryDBReplicaSetCredentialsHashedPassword": {
            "properties": {
                "algorithm": {
                    "type": "string",
                    "description": "[string] The value can be only: \"SHA-256\".\n",
                    "willReplaceOnChanges": true
                },
                "hash": {
                    "type": "string",
                    "description": "[string] The hashed password.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "algorithm",
                "hash"
            ]
        },
        "ionoscloud:dbaas/InMemoryDBReplicaSetMaintenanceWindow:InMemoryDBReplicaSetMaintenanceWindow": {
            "properties": {
                "dayOfTheWeek": {
                    "type": "string",
                    "description": "[string] The name of the week day.\n"
                },
                "time": {
                    "type": "string",
                    "description": "[string] Start of the maintenance window in UTC time.\n"
                }
            },
            "type": "object",
            "required": [
                "dayOfTheWeek",
                "time"
            ]
        },
        "ionoscloud:dbaas/InMemoryDBReplicaSetResources:InMemoryDBReplicaSetResources": {
            "properties": {
                "cores": {
                    "type": "integer",
                    "description": "[int] The number of CPU cores per instance.\n"
                },
                "ram": {
                    "type": "integer",
                    "description": "[int] The amount of memory per instance in gigabytes (GB).\n"
                },
                "storage": {
                    "type": "integer",
                    "description": "[int] The size of the storage in GB. The size is derived from the amount of RAM and the persistence mode and is not configurable.\n"
                }
            },
            "type": "object",
            "required": [
                "cores",
                "ram"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "cores",
                        "ram",
                        "storage"
                    ]
                }
            }
        },
        "ionoscloud:dbaas/MariaDBClusterConnections:MariaDBClusterConnections": {
            "properties": {
                "cidr": {
                    "type": "string",
                    "description": "The IP and subnet for your cluster.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The datacenter to connect your cluster to.\n"
                },
                "lanId": {
                    "type": "string",
                    "description": "The numeric LAN ID to connect your cluster to.\n"
                }
            },
            "type": "object",
            "required": [
                "cidr",
                "datacenterId",
                "lanId"
            ]
        },
        "ionoscloud:dbaas/MariaDBClusterCredentials:MariaDBClusterCredentials": {
            "properties": {
                "password": {
                    "type": "string",
                    "description": "The password for a MariaDB user.\n",
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "The username for the initial MariaDB user. Some system usernames are restricted (e.g 'mariadb', 'admin', 'standby').\n"
                }
            },
            "type": "object",
            "required": [
                "password",
                "username"
            ]
        },
        "ionoscloud:dbaas/MariaDBClusterMaintenanceWindow:MariaDBClusterMaintenanceWindow": {
            "properties": {
                "dayOfTheWeek": {
                    "type": "string",
                    "description": "The name of the week day.\n"
                },
                "time": {
                    "type": "string",
                    "description": "Start of the maintenance window in UTC time.\n"
                }
            },
            "type": "object",
            "required": [
                "dayOfTheWeek",
                "time"
            ]
        },
        "ionoscloud:dbaas/MongoClusterBackup:MongoClusterBackup": {
            "properties": {
                "location": {
                    "type": "string",
                    "description": "[string] - The location where the cluster backups will be stored. If not set, the backup is stored in the nearest location of the cluster. Possible values are de, eu-south-2, or eu-central-2.\n"
                },
                "pointInTimeWindowHours": {
                    "type": "integer",
                    "description": "Number of hours in the past for which a point-in-time snapshot can be created.\n"
                },
                "snapshotIntervalHours": {
                    "type": "integer",
                    "description": "Number of hours between snapshots.\n"
                }
            },
            "type": "object"
        },
        "ionoscloud:dbaas/MongoClusterBiConnector:MongoClusterBiConnector": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "[bool] - The status of the BI Connector. If not set, the BI Connector is disabled.\n"
                },
                "host": {
                    "type": "string",
                    "description": "[string] - The host where this new BI Connector is installed.\n"
                },
                "port": {
                    "type": "string",
                    "description": "[string] - Port number used when connecting to this new BI Connector.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "host",
                        "port"
                    ]
                }
            }
        },
        "ionoscloud:dbaas/MongoClusterConnections:MongoClusterConnections": {
            "properties": {
                "cidrLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[List] The list of IPs and subnet for your cluster. Note the following unavailable IP ranges:10.233.64.0/18, 10.233.0.0/18, 10.233.114.0/24. example: [192.168.1.100/24, 192.168.1.101/24]. See [Private IPs](https://www.ionos.com/help/server-cloud-infrastructure/private-network/private-ip-address-ranges/) and [Cluster Setup - Preparing the network](https://docs.ionos.com/cloud/databases/mongodb/api-howtos/create-a-cluster#preparing-the-network).\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "[string] The datacenter to connect your cluster to.\n"
                },
                "lanId": {
                    "type": "string",
                    "description": "[string] The LAN to connect your cluster to.\n"
                }
            },
            "type": "object",
            "required": [
                "cidrLists",
                "datacenterId",
                "lanId"
            ]
        },
        "ionoscloud:dbaas/MongoClusterMaintenanceWindow:MongoClusterMaintenanceWindow": {
            "properties": {
                "dayOfTheWeek": {
                    "type": "string",
                    "description": "[string]\n"
                },
                "time": {
                    "type": "string",
                    "description": "[string]\n"
                }
            },
            "type": "object",
            "required": [
                "dayOfTheWeek",
                "time"
            ]
        },
        "ionoscloud:dbaas/MongoUserRole:MongoUserRole": {
            "properties": {
                "database": {
                    "type": "string",
                    "description": "[true] Database on which to apply the role.\n\n**NOTE:** MongoDb users do not support update at the moment. Changing any attribute will result in the user being re-created.\n"
                },
                "role": {
                    "type": "string",
                    "description": "[true] Mongodb user role. Examples: read, readWrite, readAnyDatabase, readWriteAnyDatabase, dbAdmin, dbAdminAnyDatabase, clusterMonitor.\n"
                }
            },
            "type": "object"
        },
        "ionoscloud:dbaas/PSQLClusterConnectionPooler:PSQLClusterConnectionPooler": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "[bool]\n"
                },
                "poolMode": {
                    "type": "string",
                    "description": "[string] Represents different modes of connection pooling for the connection pooler.\n"
                }
            },
            "type": "object",
            "required": [
                "enabled",
                "poolMode"
            ]
        },
        "ionoscloud:dbaas/PSQLClusterConnections:PSQLClusterConnections": {
            "properties": {
                "cidr": {
                    "type": "string",
                    "description": "[true] The IP and subnet for the database. Note the following unavailable IP ranges: 10.233.64.0/18, 10.233.0.0/18, 10.233.114.0/24. Please enter in the correct format like IP/Subnet, exp: 192.168.10.0/24. See [Private IPs](https://www.ionos.com/help/server-cloud-infrastructure/private-network/private-ip-address-ranges/) and [Configuring the network](https://docs.ionos.com/cloud/compute-engine/networks/how-tos/configure-networks).\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "[true] The datacenter to connect your cluster to.\n"
                },
                "lanId": {
                    "type": "string",
                    "description": "[true] The LAN to connect your cluster to.\n"
                }
            },
            "type": "object",
            "required": [
                "cidr",
                "datacenterId",
                "lanId"
            ]
        },
        "ionoscloud:dbaas/PSQLClusterCredentials:PSQLClusterCredentials": {
            "properties": {
                "password": {
                    "type": "string",
                    "description": "[string]\n",
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "[string] The username for the initial postgres user. Some system usernames are restricted (e.g. \"postgres\", \"admin\", \"standby\")\n"
                }
            },
            "type": "object",
            "required": [
                "password",
                "username"
            ]
        },
        "ionoscloud:dbaas/PSQLClusterFromBackup:PSQLClusterFromBackup": {
            "properties": {
                "backupId": {
                    "type": "string",
                    "description": "[string] The unique ID of the backup you want to restore.\n"
                },
                "recoveryTargetTime": {
                    "type": "string",
                    "description": "[string] If this value is supplied as ISO 8601 timestamp, the backup will be replayed up until the given timestamp. If empty, the backup will be applied completely.\n"
                }
            },
            "type": "object",
            "required": [
                "backupId"
            ]
        },
        "ionoscloud:dbaas/PSQLClusterMaintenanceWindow:PSQLClusterMaintenanceWindow": {
            "properties": {
                "dayOfTheWeek": {
                    "type": "string",
                    "description": "[string]\n"
                },
                "time": {
                    "type": "string",
                    "description": "[string]\n"
                }
            },
            "type": "object",
            "required": [
                "dayOfTheWeek",
                "time"
            ]
        },
        "ionoscloud:dbaas/getInMemoryDBReplicaSetConnection:getInMemoryDBReplicaSetConnection": {
            "properties": {
                "cidr": {
                    "type": "string",
                    "description": "[string] The IP and subnet for your instance. Note the following unavailable IP ranges: 10.233.64.0/18, 10.233.0.0/18, 10.233.114.0/24.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "[string] The datacenter to connect your instance to.\n"
                },
                "lanId": {
                    "type": "string",
                    "description": "[string] The numeric LAN ID to connect your instance to.\n"
                }
            },
            "type": "object",
            "required": [
                "cidr",
                "datacenterId",
                "lanId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:dbaas/getInMemoryDBReplicaSetCredential:getInMemoryDBReplicaSetCredential": {
            "properties": {
                "username": {
                    "type": "string",
                    "description": "[string] The username for the initial InMemoryDB user. Some system usernames are restricted (e.g. 'admin', 'standby').\n"
                }
            },
            "type": "object",
            "required": [
                "username"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:dbaas/getInMemoryDBReplicaSetMaintenanceWindow:getInMemoryDBReplicaSetMaintenanceWindow": {
            "properties": {
                "dayOfTheWeek": {
                    "type": "string",
                    "description": "[string] The name of the week day.\n"
                },
                "time": {
                    "type": "string",
                    "description": "[string] Start of the maintenance window in UTC time.\n"
                }
            },
            "type": "object",
            "required": [
                "dayOfTheWeek",
                "time"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:dbaas/getInMemoryDBReplicaSetResource:getInMemoryDBReplicaSetResource": {
            "properties": {
                "cores": {
                    "type": "integer",
                    "description": "[int] The number of CPU cores per instance.\n"
                },
                "ram": {
                    "type": "integer",
                    "description": "[int] The amount of memory per instance in gigabytes (GB).\n"
                },
                "storage": {
                    "type": "integer",
                    "description": "[int] The size of the storage in GB. The size is derived from the amount of RAM and the persistence mode and is not configurable.\n"
                }
            },
            "type": "object",
            "required": [
                "cores",
                "ram",
                "storage"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:dbaas/getInmemorydbSnapshotMetadata:getInmemorydbSnapshotMetadata": {
            "properties": {
                "createdDate": {
                    "type": "string",
                    "description": "The ISO 8601 creation timestamp.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The ID of the datacenter in which the snapshot is located.\n"
                },
                "lastModifiedDate": {
                    "type": "string",
                    "description": "The ISO 8601 modified timestamp.\n"
                },
                "replicaSetId": {
                    "type": "string",
                    "description": "The ID of the replica set from which the snapshot was created.\n"
                },
                "snapshotTime": {
                    "type": "string",
                    "description": "The time at which the snapshot was taken.\n"
                }
            },
            "type": "object",
            "required": [
                "createdDate",
                "datacenterId",
                "lastModifiedDate",
                "replicaSetId",
                "snapshotTime"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:dbaas/getMariaDBBackupsBackup:getMariaDBBackupsBackup": {
            "properties": {
                "baseBackups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:dbaas/getMariaDBBackupsBackupBaseBackup:getMariaDBBackupsBackupBaseBackup"
                    },
                    "description": "The list of backups for the specified cluster\n"
                },
                "clusterId": {
                    "type": "string",
                    "description": "[string] The unique ID of the cluster.\n"
                },
                "earliestRecoveryTargetTime": {
                    "type": "string",
                    "description": "The oldest available timestamp to which you can restore.\n"
                },
                "size": {
                    "type": "integer",
                    "description": "The size of the backup in Mebibytes (MiB). This is the size of the binary backup file that was stored\n"
                }
            },
            "type": "object",
            "required": [
                "baseBackups",
                "clusterId",
                "earliestRecoveryTargetTime",
                "size"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:dbaas/getMariaDBBackupsBackupBaseBackup:getMariaDBBackupsBackupBaseBackup": {
            "properties": {
                "created": {
                    "type": "string",
                    "description": "The ISO 8601 creation timestamp\n"
                },
                "size": {
                    "type": "integer",
                    "description": "The size of the backup in Mebibytes (MiB). This is the size of the binary backup file that was stored\n"
                }
            },
            "type": "object",
            "required": [
                "created",
                "size"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:dbaas/getMariaDBClusterConnection:getMariaDBClusterConnection": {
            "properties": {
                "cidr": {
                    "type": "string",
                    "description": "[string] The IP and subnet for your cluster.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "[string] The datacenter to connect your cluster to.\n"
                },
                "lanId": {
                    "type": "string",
                    "description": "[string] The LAN to connect your cluster to.\n"
                }
            },
            "type": "object",
            "required": [
                "cidr",
                "datacenterId",
                "lanId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:dbaas/getMariaDBClusterMaintenanceWindow:getMariaDBClusterMaintenanceWindow": {
            "properties": {
                "dayOfTheWeek": {
                    "type": "string",
                    "description": "[string] The name of the week day.\n"
                },
                "time": {
                    "type": "string",
                    "description": "[string] Start of the maintenance window in UTC time.\n"
                }
            },
            "type": "object",
            "required": [
                "dayOfTheWeek",
                "time"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:dbaas/getMongoClusterBackup:getMongoClusterBackup": {
            "properties": {
                "location": {
                    "type": "string",
                    "description": "The location where the cluster backups will be stored. If not set, the backup is stored in the nearest location of the cluster. Possible values are de, eu-south-2, or eu-central-2.\n"
                }
            },
            "type": "object",
            "required": [
                "location"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:dbaas/getMongoClusterBiConnector:getMongoClusterBiConnector": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Enable or disable the BiConnector\n"
                },
                "host": {
                    "type": "string",
                    "description": "The host where this new BI Connector is installed\n"
                },
                "port": {
                    "type": "string",
                    "description": "Port number used when connecting to this new BI Connector\n"
                }
            },
            "type": "object",
            "required": [
                "enabled",
                "host",
                "port"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:dbaas/getMongoClusterConnection:getMongoClusterConnection": {
            "properties": {
                "cidrLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of IPs and subnet for your cluster.\n          Note the following unavailable IP ranges:\n          10.233.64.0/18\n          10.233.0.0/18\n          10.233.114.0/24 \t\t\n example: [192.168.1.100/24, 192.168.1.101/24]\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The datacenter to connect your cluster to.\n"
                },
                "lanId": {
                    "type": "string",
                    "description": "The LAN to connect your cluster to.\n"
                }
            },
            "type": "object",
            "required": [
                "cidrLists",
                "datacenterId",
                "lanId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:dbaas/getMongoClusterMaintenanceWindow:getMongoClusterMaintenanceWindow": {
            "properties": {
                "dayOfTheWeek": {
                    "type": "string"
                },
                "time": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "dayOfTheWeek",
                "time"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:dbaas/getMongoUserRole:getMongoUserRole": {
            "properties": {
                "database": {
                    "type": "string",
                    "description": "[true] Database on which to apply the role.\n\n**NOTE:** MongoDb users do not support update at the moment. Changing any attribute will result in the user being re-created.\n"
                },
                "role": {
                    "type": "string",
                    "description": "[true] Mongodb user role. Examples: read, readWrite, readAnyDatabase, readWriteAnyDatabase, dbAdmin, dbAdminAnyDatabase, clusterMonitor and enableSharding.\n"
                }
            },
            "type": "object",
            "required": [
                "database",
                "role"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:dbaas/getPSQLBackupsClusterBackup:getPSQLBackupsClusterBackup": {
            "properties": {
                "clusterId": {
                    "type": "string",
                    "description": "The unique ID of the cluster.\n\n`cluster_id` must be provided. If it is not provided, the datasource will return an error.\n"
                },
                "earliestRecoveryTargetTime": {
                    "type": "string",
                    "description": "The oldest available timestamp to which you can restore.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The unique ID of the resource.\n"
                },
                "isActive": {
                    "type": "boolean",
                    "description": "Whether a cluster currently backs up data to this backup.\n"
                },
                "location": {
                    "type": "string",
                    "description": "The IONOS Object Storage location where the backups will be stored.\n"
                },
                "metadatas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:dbaas/getPSQLBackupsClusterBackupMetadata:getPSQLBackupsClusterBackupMetadata"
                    },
                    "description": "Metadata of the resource.\n"
                },
                "size": {
                    "type": "integer",
                    "description": "The size of all base backups including the wal size in MB.\n"
                },
                "type": {
                    "type": "string"
                },
                "version": {
                    "type": "string",
                    "description": "The PostgreSQL version this backup was created from.\n"
                }
            },
            "type": "object",
            "required": [
                "clusterId",
                "earliestRecoveryTargetTime",
                "id",
                "isActive",
                "location",
                "metadatas",
                "size",
                "type",
                "version"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:dbaas/getPSQLBackupsClusterBackupMetadata:getPSQLBackupsClusterBackupMetadata": {
            "properties": {
                "createdDate": {
                    "type": "string",
                    "description": "The ISO 8601 creation timestamp.\n"
                }
            },
            "type": "object",
            "required": [
                "createdDate"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:dbaas/getPSQLClusterConnection:getPSQLClusterConnection": {
            "properties": {
                "cidr": {
                    "type": "string",
                    "description": "The IP and subnet for the database.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The datacenter to connect your cluster to.\n"
                },
                "lanId": {
                    "type": "string",
                    "description": "The LAN to connect your cluster to.\n"
                }
            },
            "type": "object",
            "required": [
                "cidr",
                "datacenterId",
                "lanId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:dbaas/getPSQLClusterConnectionPooler:getPSQLClusterConnectionPooler": {
            "properties": {
                "enabled": {
                    "type": "boolean"
                },
                "poolMode": {
                    "type": "string",
                    "description": "Represents different modes of connection pooling for the connection pooler.\n"
                }
            },
            "type": "object",
            "required": [
                "enabled",
                "poolMode"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:dbaas/getPSQLClusterFromBackup:getPSQLClusterFromBackup": {
            "properties": {
                "backupId": {
                    "type": "string",
                    "description": "The PostgreSQL version of your cluster.\n"
                },
                "recoveryTargetTime": {
                    "type": "string",
                    "description": "If this value is supplied as ISO 8601 timestamp, the backup will be replayed up until the given timestamp.\n"
                }
            },
            "type": "object",
            "required": [
                "backupId",
                "recoveryTargetTime"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:dbaas/getPSQLClusterMaintenanceWindow:getPSQLClusterMaintenanceWindow": {
            "properties": {
                "dayOfTheWeek": {
                    "type": "string"
                },
                "time": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "dayOfTheWeek",
                "time"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:dbaas/getPSQLDatabasesDatabase:getPSQLDatabasesDatabase": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "[string] The ID of the database.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the database.\n"
                },
                "owner": {
                    "type": "string",
                    "description": "[string] Filter using a specific owner.\n"
                }
            },
            "type": "object",
            "required": [
                "id",
                "name",
                "owner"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:dsaas/ClusterLan:ClusterLan": {
            "properties": {
                "dhcp": {
                    "type": "boolean",
                    "description": "[bool] Indicates if the Kubernetes node pool LAN will reserve an IP using DHCP. The default value is 'true'.\n"
                },
                "lanId": {
                    "type": "string",
                    "description": "[string] The LAN ID of an existing LAN at the related data center.\n"
                },
                "routes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:dsaas/ClusterLanRoute:ClusterLanRoute"
                    },
                    "description": "[list] An array of additional LANs attached to worker nodes.\n"
                }
            },
            "type": "object",
            "required": [
                "lanId"
            ]
        },
        "ionoscloud:dsaas/ClusterLanRoute:ClusterLanRoute": {
            "properties": {
                "gateway": {
                    "type": "string",
                    "description": "[string] IPv4 or IPv6 gateway IP for the route.\n"
                },
                "network": {
                    "type": "string",
                    "description": "[string] IPv4 or IPv6 CIDR to be routed via the interface.\n"
                }
            },
            "type": "object",
            "required": [
                "gateway",
                "network"
            ]
        },
        "ionoscloud:dsaas/ClusterMaintenanceWindow:ClusterMaintenanceWindow": {
            "properties": {
                "dayOfTheWeek": {
                    "type": "string",
                    "description": "[string] Must be set with one the values `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday` or `Sunday`.\n"
                },
                "time": {
                    "type": "string",
                    "description": "[string] Time at which the maintenance should start. Must conform to the 'HH:MM:SS' 24-hour format. This pattern matches the \"HH:MM:SS 24-hour format with leading 0\" format. For more information take a look at [this link](https://stackoverflow.com/questions/7536755/regular-expression-for-matching-hhmm-time-format).\n"
                }
            },
            "type": "object",
            "required": [
                "dayOfTheWeek",
                "time"
            ]
        },
        "ionoscloud:dsaas/NodePoolMaintenanceWindow:NodePoolMaintenanceWindow": {
            "properties": {
                "dayOfTheWeek": {
                    "type": "string",
                    "description": "[string] Must be set with one the values `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday` or `Sunday`.\n"
                },
                "time": {
                    "type": "string",
                    "description": "[string] Time at which the maintenance should start. Must conform to the 'HH:MM:SS' 24-hour format. This pattern matches the \"HH:MM:SS 24-hour format with leading 0\" format. For more information take a look at [this link](https://stackoverflow.com/questions/7536755/regular-expression-for-matching-hhmm-time-format).\n"
                }
            },
            "type": "object",
            "required": [
                "dayOfTheWeek",
                "time"
            ]
        },
        "ionoscloud:dsaas/getClusterConfig:getClusterConfig": {
            "properties": {
                "apiVersion": {
                    "type": "string",
                    "secret": true
                },
                "clusters": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:dsaas/getClusterConfigCluster:getClusterConfigCluster"
                    }
                },
                "contexts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:dsaas/getClusterConfigContext:getClusterConfigContext"
                    }
                },
                "currentContext": {
                    "type": "string",
                    "secret": true
                },
                "kind": {
                    "type": "string"
                },
                "users": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:dsaas/getClusterConfigUser:getClusterConfigUser"
                    }
                }
            },
            "type": "object",
            "required": [
                "apiVersion",
                "clusters",
                "contexts",
                "currentContext",
                "kind",
                "users"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:dsaas/getClusterConfigCluster:getClusterConfigCluster": {
            "properties": {
                "cluster": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "secret": true
                },
                "name": {
                    "type": "string",
                    "description": "Name of an existing cluster that you want to search for. Search by name is case-insensitive. The whole resource name is required if `partial_match` parameter is not set to true.\n",
                    "secret": true
                }
            },
            "type": "object",
            "required": [
                "cluster",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:dsaas/getClusterConfigContext:getClusterConfigContext": {
            "properties": {
                "context": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "secret": true
                },
                "name": {
                    "type": "string",
                    "description": "Name of an existing cluster that you want to search for. Search by name is case-insensitive. The whole resource name is required if `partial_match` parameter is not set to true.\n",
                    "secret": true
                }
            },
            "type": "object",
            "required": [
                "context",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:dsaas/getClusterConfigUser:getClusterConfigUser": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of an existing cluster that you want to search for. Search by name is case-insensitive. The whole resource name is required if `partial_match` parameter is not set to true.\n",
                    "secret": true
                },
                "user": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "secret": true
                }
            },
            "type": "object",
            "required": [
                "name",
                "user"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:dsaas/getClusterLan:getClusterLan": {
            "properties": {
                "dhcp": {
                    "type": "boolean",
                    "description": "Indicates if the Kubernetes node pool LAN will reserve an IP using DHCP. The default value is 'true'.\n"
                },
                "lanId": {
                    "type": "string",
                    "description": "The LAN ID of an existing LAN at the related data center\n"
                },
                "routes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:dsaas/getClusterLanRoute:getClusterLanRoute"
                    },
                    "description": "An array of additional LANs attached to worker nodes\n"
                }
            },
            "type": "object",
            "required": [
                "dhcp",
                "lanId",
                "routes"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:dsaas/getClusterLanRoute:getClusterLanRoute": {
            "properties": {
                "gateway": {
                    "type": "string",
                    "description": "IPv4 or IPv6 gateway IP for the route\n"
                },
                "network": {
                    "type": "string",
                    "description": "IPv4 or IPv6 CIDR to be routed via the interface\n"
                }
            },
            "type": "object",
            "required": [
                "gateway",
                "network"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:dsaas/getClusterMaintenanceWindow:getClusterMaintenanceWindow": {
            "properties": {
                "dayOfTheWeek": {
                    "type": "string"
                },
                "time": {
                    "type": "string",
                    "description": "Time at which the maintenance should start.\n"
                }
            },
            "type": "object",
            "required": [
                "dayOfTheWeek",
                "time"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:dsaas/getNodePoolMaintenanceWindow:getNodePoolMaintenanceWindow": {
            "properties": {
                "dayOfTheWeek": {
                    "type": "string"
                },
                "time": {
                    "type": "string",
                    "description": "Time at which the maintenance should start.\n"
                }
            },
            "type": "object",
            "required": [
                "dayOfTheWeek",
                "time"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:dsaas/getNodePoolsNodePool:getNodePoolsNodePool": {
            "properties": {
                "annotations": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Key-value pairs attached to node pool resource as kubernetes annotations\n"
                },
                "availabilityZone": {
                    "type": "string",
                    "description": "The availability zone of the virtual datacenter region where the node pool resources should be provisioned.\n"
                },
                "coresCount": {
                    "type": "integer",
                    "description": "The number of CPU cores per node.\n"
                },
                "cpuFamily": {
                    "type": "string",
                    "description": "A valid CPU family name or `AUTO` if the platform shall choose the best fitting option. Available CPU architectures can be retrieved from the datacenter resource.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The UUID of the virtual data center (VDC) in which the node pool is provisioned\n"
                },
                "id": {
                    "type": "string"
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Key-value pairs attached to the node pool resource as kubernetes labels\n"
                },
                "maintenanceWindows": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:dsaas/getNodePoolsNodePoolMaintenanceWindow:getNodePoolsNodePoolMaintenanceWindow"
                    },
                    "description": "Starting time of a weekly 4 hour-long window, during which maintenance might occur in hh:mm:ss format\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of an existing cluster that you want to search for. Search by name is case-insensitive. The whole resource name is required if `partial_match` parameter is not set to true.\n"
                },
                "nodeCount": {
                    "type": "integer",
                    "description": "The number of nodes that make up the node pool.\n"
                },
                "ramSize": {
                    "type": "integer",
                    "description": "The RAM size for one node in MB. Must be set in multiples of 1024 MB, with a minimum size is of 2048 MB.\n"
                },
                "storageSize": {
                    "type": "integer",
                    "description": "The size of the volume in GB. The size must be greater than 10GB.\n"
                },
                "storageType": {
                    "type": "string",
                    "description": "The type of hardware for the volume.\n"
                },
                "version": {
                    "type": "string",
                    "description": "The version of the Data Platform.\n"
                }
            },
            "type": "object",
            "required": [
                "annotations",
                "availabilityZone",
                "coresCount",
                "cpuFamily",
                "datacenterId",
                "id",
                "labels",
                "maintenanceWindows",
                "name",
                "nodeCount",
                "ramSize",
                "storageSize",
                "storageType",
                "version"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:dsaas/getNodePoolsNodePoolMaintenanceWindow:getNodePoolsNodePoolMaintenanceWindow": {
            "properties": {
                "dayOfTheWeek": {
                    "type": "string"
                },
                "time": {
                    "type": "string",
                    "description": "Time at which the maintenance should start. Must conform to the 'HH:MM:SS' 24-hour format.\n"
                }
            },
            "type": "object",
            "required": [
                "dayOfTheWeek",
                "time"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:k8s/ClusterMaintenanceWindow:ClusterMaintenanceWindow": {
            "properties": {
                "dayOfTheWeek": {
                    "type": "string",
                    "description": "[string] Day of the week when maintenance is allowed\n"
                },
                "time": {
                    "type": "string",
                    "description": "[string] A clock time in the day when maintenance is allowed\n"
                }
            },
            "type": "object",
            "required": [
                "dayOfTheWeek",
                "time"
            ]
        },
        "ionoscloud:k8s/ClusterS3Bucket:ClusterS3Bucket": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "[string] The name of the Kubernetes Cluster.\n"
                }
            },
            "type": "object"
        },
        "ionoscloud:k8s/NodePoolAutoScaling:NodePoolAutoScaling": {
            "properties": {
                "maxNodeCount": {
                    "type": "integer",
                    "description": "[int] The maximum number of worker nodes that the node pool can scale to. Should be greater than min_node_count\n"
                },
                "minNodeCount": {
                    "type": "integer",
                    "description": "[int] The minimum number of worker nodes the node pool can scale down to. Should be less than max_node_count\n"
                }
            },
            "type": "object",
            "required": [
                "maxNodeCount",
                "minNodeCount"
            ]
        },
        "ionoscloud:k8s/NodePoolLan:NodePoolLan": {
            "properties": {
                "dhcp": {
                    "type": "boolean",
                    "description": "[boolean] Indicates if the Kubernetes Node Pool LAN will reserve an IP using DHCP. Default value is `true`\n"
                },
                "id": {
                    "type": "integer",
                    "description": "[int] The LAN ID of an existing LAN at the related datacenter\n"
                },
                "routes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:k8s/NodePoolLanRoute:NodePoolLanRoute"
                    },
                    "description": "An array of additional LANs attached to worker nodes\n"
                }
            },
            "type": "object",
            "required": [
                "id"
            ]
        },
        "ionoscloud:k8s/NodePoolLanRoute:NodePoolLanRoute": {
            "properties": {
                "gatewayIp": {
                    "type": "string",
                    "description": "[string] IPv4 or IPv6 Gateway IP for the route\n"
                },
                "network": {
                    "type": "string",
                    "description": "[string] IPv4 or IPv6 CIDR to be routed via the interface\n"
                }
            },
            "type": "object",
            "required": [
                "gatewayIp",
                "network"
            ]
        },
        "ionoscloud:k8s/NodePoolMaintenanceWindow:NodePoolMaintenanceWindow": {
            "properties": {
                "dayOfTheWeek": {
                    "type": "string",
                    "description": "[string] Day of the week when maintenance is allowed\n"
                },
                "time": {
                    "type": "string",
                    "description": "[string] A clock time in the day when maintenance is allowed\n"
                }
            },
            "type": "object",
            "required": [
                "dayOfTheWeek",
                "time"
            ]
        },
        "ionoscloud:k8s/getClusterConfig:getClusterConfig": {
            "properties": {
                "apiVersion": {
                    "type": "string",
                    "secret": true
                },
                "clusters": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:k8s/getClusterConfigCluster:getClusterConfigCluster"
                    }
                },
                "contexts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:k8s/getClusterConfigContext:getClusterConfigContext"
                    }
                },
                "currentContext": {
                    "type": "string",
                    "secret": true
                },
                "kind": {
                    "type": "string"
                },
                "users": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:k8s/getClusterConfigUser:getClusterConfigUser"
                    }
                }
            },
            "type": "object",
            "required": [
                "apiVersion",
                "clusters",
                "contexts",
                "currentContext",
                "kind",
                "users"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:k8s/getClusterConfigCluster:getClusterConfigCluster": {
            "properties": {
                "cluster": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "secret": true
                },
                "name": {
                    "type": "string",
                    "description": "Name of an existing cluster that you want to search for.\n",
                    "secret": true
                }
            },
            "type": "object",
            "required": [
                "cluster",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:k8s/getClusterConfigContext:getClusterConfigContext": {
            "properties": {
                "context": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "secret": true
                },
                "name": {
                    "type": "string",
                    "description": "Name of an existing cluster that you want to search for.\n",
                    "secret": true
                }
            },
            "type": "object",
            "required": [
                "context",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:k8s/getClusterConfigUser:getClusterConfigUser": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of an existing cluster that you want to search for.\n",
                    "secret": true
                },
                "user": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "secret": true
                }
            },
            "type": "object",
            "required": [
                "name",
                "user"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:k8s/getClusterMaintenanceWindow:getClusterMaintenanceWindow": {
            "properties": {
                "dayOfTheWeek": {
                    "type": "string",
                    "description": "Day of the week when maintenance is allowed\n"
                },
                "time": {
                    "type": "string",
                    "description": "A clock time in the day when maintenance is allowed\n"
                }
            },
            "type": "object",
            "required": [
                "dayOfTheWeek",
                "time"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:k8s/getClusterS3Bucket:getClusterS3Bucket": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of an existing cluster that you want to search for.\n"
                }
            },
            "type": "object",
            "required": [
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:k8s/getClustersCluster:getClustersCluster": {
            "properties": {
                "apiSubnetAllowLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Access to the K8s API server is restricted to these CIDRs. Cluster-internal traffic is not affected by this restriction. If no allowlist is specified, access is not restricted. If an IP without subnet mask is provided, the default value will be used: 32 for IPv4 and 128 for IPv6.\n"
                },
                "availableUpgradeVersions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of available versions for upgrading the cluster\n"
                },
                "caCrt": {
                    "type": "string",
                    "secret": true
                },
                "configs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:k8s/getClustersClusterConfig:getClustersClusterConfig"
                    },
                    "secret": true
                },
                "id": {
                    "type": "string"
                },
                "k8sVersion": {
                    "type": "string"
                },
                "kubeConfig": {
                    "type": "string"
                },
                "location": {
                    "type": "string"
                },
                "maintenanceWindows": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:k8s/getClustersClusterMaintenanceWindow:getClustersClusterMaintenanceWindow"
                    },
                    "description": "A maintenance window comprise of a day of the week and a time for maintenance to be allowed\n"
                },
                "name": {
                    "type": "string"
                },
                "natGatewayIp": {
                    "type": "string",
                    "description": "The NAT gateway IP of the cluster if the cluster is private.\n"
                },
                "nodePools": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "nodeSubnet": {
                    "type": "string",
                    "description": "The node subnet of the cluster, if the cluster is private.\n"
                },
                "public": {
                    "type": "boolean",
                    "description": "The indicator if the cluster is public or private.\n"
                },
                "s3Buckets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:k8s/getClustersClusterS3Bucket:getClustersClusterS3Bucket"
                    },
                    "description": "List of Object Storage bucket configured for K8s usage. For now it contains only an Object Storage bucket used to store K8s API audit logs.\n"
                },
                "server": {
                    "type": "string",
                    "secret": true
                },
                "state": {
                    "type": "string"
                },
                "userTokens": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "secret": true
                },
                "viableNodePoolVersions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of versions that may be used for node pools under this cluster\n"
                }
            },
            "type": "object",
            "required": [
                "apiSubnetAllowLists",
                "availableUpgradeVersions",
                "caCrt",
                "configs",
                "k8sVersion",
                "kubeConfig",
                "location",
                "maintenanceWindows",
                "natGatewayIp",
                "nodePools",
                "nodeSubnet",
                "public",
                "s3Buckets",
                "server",
                "state",
                "userTokens",
                "viableNodePoolVersions"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:k8s/getClustersClusterConfig:getClustersClusterConfig": {
            "properties": {
                "apiVersion": {
                    "type": "string",
                    "secret": true
                },
                "clusters": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:k8s/getClustersClusterConfigCluster:getClustersClusterConfigCluster"
                    }
                },
                "contexts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:k8s/getClustersClusterConfigContext:getClustersClusterConfigContext"
                    }
                },
                "currentContext": {
                    "type": "string",
                    "secret": true
                },
                "kind": {
                    "type": "string"
                },
                "users": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:k8s/getClustersClusterConfigUser:getClustersClusterConfigUser"
                    }
                }
            },
            "type": "object",
            "required": [
                "apiVersion",
                "clusters",
                "contexts",
                "currentContext",
                "kind",
                "users"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:k8s/getClustersClusterConfigCluster:getClustersClusterConfigCluster": {
            "properties": {
                "cluster": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "secret": true
                },
                "name": {
                    "type": "string",
                    "secret": true
                }
            },
            "type": "object",
            "required": [
                "cluster",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:k8s/getClustersClusterConfigContext:getClustersClusterConfigContext": {
            "properties": {
                "context": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "secret": true
                },
                "name": {
                    "type": "string",
                    "secret": true
                }
            },
            "type": "object",
            "required": [
                "context",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:k8s/getClustersClusterConfigUser:getClustersClusterConfigUser": {
            "properties": {
                "name": {
                    "type": "string",
                    "secret": true
                },
                "user": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "secret": true
                }
            },
            "type": "object",
            "required": [
                "name",
                "user"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:k8s/getClustersClusterMaintenanceWindow:getClustersClusterMaintenanceWindow": {
            "properties": {
                "dayOfTheWeek": {
                    "type": "string",
                    "description": "Day of the week when maintenance is allowed\n"
                },
                "time": {
                    "type": "string",
                    "description": "A clock time in the day when maintenance is allowed\n"
                }
            },
            "type": "object",
            "required": [
                "dayOfTheWeek",
                "time"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:k8s/getClustersClusterS3Bucket:getClustersClusterS3Bucket": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of the Object Storage bucket\n"
                }
            },
            "type": "object",
            "required": [
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:k8s/getClustersFilter:getClustersFilter": {
            "properties": {
                "name": {
                    "type": "string"
                },
                "value": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "name",
                "value"
            ]
        },
        "ionoscloud:k8s/getNodePoolAutoScaling:getNodePoolAutoScaling": {
            "properties": {
                "maxNodeCount": {
                    "type": "integer",
                    "description": "The maximum number of worker nodes that the node pool can scale to\n"
                },
                "minNodeCount": {
                    "type": "integer",
                    "description": "The minimum number of worker nodes the node pool can scale down to\n"
                }
            },
            "type": "object",
            "required": [
                "maxNodeCount",
                "minNodeCount"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:k8s/getNodePoolLan:getNodePoolLan": {
            "properties": {
                "dhcp": {
                    "type": "boolean",
                    "description": "Indicates if the Kubernetes Node Pool LAN will reserve an IP using DHCP\n"
                },
                "id": {
                    "type": "integer",
                    "description": "ID of the node pool you want to search for.\n\n`k8s_cluster_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.\n"
                },
                "routes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:k8s/getNodePoolLanRoute:getNodePoolLanRoute"
                    },
                    "description": "An array of additional LANs attached to worker nodes\n"
                }
            },
            "type": "object",
            "required": [
                "dhcp",
                "id"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:k8s/getNodePoolLanRoute:getNodePoolLanRoute": {
            "properties": {
                "gatewayIp": {
                    "type": "string",
                    "description": "IPv4 or IPv6 Gateway IP for the route\n"
                },
                "network": {
                    "type": "string",
                    "description": "IPv4 or IPv6 CIDR to be routed via the interface\n"
                }
            },
            "type": "object",
            "required": [
                "gatewayIp",
                "network"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:k8s/getNodePoolMaintenanceWindow:getNodePoolMaintenanceWindow": {
            "properties": {
                "dayOfTheWeek": {
                    "type": "string",
                    "description": "Day of the week when maintenance is allowed\n"
                },
                "time": {
                    "type": "string",
                    "description": "A clock time in the day when maintenance is allowed\n"
                }
            },
            "type": "object",
            "required": [
                "dayOfTheWeek",
                "time"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:k8s/getNodePoolNodesNode:getNodePoolNodesNode": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "ID of the node pool you want to search for.\n\n`k8s_cluster_id` and `node_pool_id` must be provided.\n"
                },
                "k8sVersion": {
                    "type": "string",
                    "description": "The kubernetes version\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of an existing node pool that you want to search for.\n"
                },
                "privateIp": {
                    "type": "string",
                    "description": "private ip of the node\n"
                },
                "publicIp": {
                    "type": "string",
                    "description": "public ip of the node\n"
                }
            },
            "type": "object",
            "required": [
                "k8sVersion"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:kafka/ClusterConnections:ClusterConnections": {
            "properties": {
                "brokerAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] IP addresses and subnet of cluster brokers. **Note** the following\nunavailable IP range: 10.224.0.0/11\n",
                    "willReplaceOnChanges": true
                },
                "datacenterId": {
                    "type": "string",
                    "description": "[string] The datacenter to connect your instance to.\n",
                    "willReplaceOnChanges": true
                },
                "lanId": {
                    "type": "string",
                    "description": "[string] The numeric LAN ID to connect your instance to.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "brokerAddresses",
                "datacenterId",
                "lanId"
            ]
        },
        "ionoscloud:kafka/getClusterConnection:getClusterConnection": {
            "properties": {
                "brokerAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "IP address and port of cluster brokers.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The datacenter that your instance is connected to.\n"
                },
                "lanId": {
                    "type": "string",
                    "description": "The numeric LAN ID your instance is connected to.\n"
                }
            },
            "type": "object",
            "required": [
                "brokerAddresses",
                "datacenterId",
                "lanId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:logging/PipelineLog:PipelineLog": {
            "properties": {
                "destinations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:logging/PipelineLogDestination:PipelineLogDestination"
                    },
                    "description": "[list] The configuration of the logs datastore, a list that contains elements with the following structure:\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "[string] \"Protocol to use as intake. Possible values are: http, tcp.\"\n"
                },
                "public": {
                    "type": "boolean",
                    "description": "[bool]\n"
                },
                "source": {
                    "type": "string",
                    "description": "[string] The source parser to be used.\n"
                },
                "tag": {
                    "type": "string",
                    "description": "[string] The tag is used to distinguish different pipelines. Must be unique amongst the pipeline's array items.\n"
                }
            },
            "type": "object",
            "required": [
                "protocol",
                "source",
                "tag"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "destinations",
                        "protocol",
                        "public",
                        "source",
                        "tag"
                    ]
                }
            }
        },
        "ionoscloud:logging/PipelineLogDestination:PipelineLogDestination": {
            "properties": {
                "retentionInDays": {
                    "type": "integer",
                    "description": "[int] Defines the number of days a log record should be kept in loki. Works with loki destination type only. Can be one of: 7, 14, 30.\n"
                },
                "type": {
                    "type": "string",
                    "description": "[string] The internal output stream to send logs to.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "retentionInDays",
                        "type"
                    ]
                }
            }
        },
        "ionoscloud:logging/getPipelineLog:getPipelineLog": {
            "properties": {
                "destinations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:logging/getPipelineLogDestination:getPipelineLogDestination"
                    },
                    "description": "[list] The configuration of the logs datastore, a list that contains elements with the following structure:\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "[string] \"Protocol to use as intake. Possible values are: http, tcp.\"\n"
                },
                "public": {
                    "type": "boolean",
                    "description": "[bool]\n"
                },
                "source": {
                    "type": "string",
                    "description": "[string] The source parser to be used.\n"
                },
                "tag": {
                    "type": "string",
                    "description": "[string] The tag is used to distinguish different pipelines. Must be unique amongst the pipeline's array items.\n"
                }
            },
            "type": "object",
            "required": [
                "destinations",
                "protocol",
                "public",
                "source",
                "tag"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:logging/getPipelineLogDestination:getPipelineLogDestination": {
            "properties": {
                "retentionInDays": {
                    "type": "integer",
                    "description": "[int] Defines the number of days a log record should be kept in loki. Works with loki destination type only.\n"
                },
                "type": {
                    "type": "string",
                    "description": "[string] The internal output stream to send logs to.\n"
                }
            },
            "type": "object",
            "required": [
                "retentionInDays",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:nfs/ClusterConnections:ClusterConnections": {
            "properties": {
                "datacenterId": {
                    "type": "string",
                    "description": "The ID of the datacenter where the Network File Storage cluster is located.\n"
                },
                "ipAddress": {
                    "type": "string",
                    "description": "The IP address and prefix of the Network File Storage cluster. The IP address can be either IPv4 or IPv6. The IP address has to be given with CIDR notation.\n"
                },
                "lan": {
                    "type": "string",
                    "description": "The Private LAN to which the Network File Storage cluster must be connected.\n"
                }
            },
            "type": "object",
            "required": [
                "datacenterId",
                "ipAddress",
                "lan"
            ]
        },
        "ionoscloud:nfs/ClusterNfs:ClusterNfs": {
            "properties": {
                "minVersion": {
                    "type": "string",
                    "description": "The minimum supported version of the NFS cluster. Supported values: `4.2`. Default is `4.2`.\n"
                }
            },
            "type": "object"
        },
        "ionoscloud:nfs/ShareClientGroup:ShareClientGroup": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Optional description for the clients groups.\n"
                },
                "hosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A singular host allowed to connect to the share. The host can be specified as IP address and can be either IPv4 or IPv6.\n"
                },
                "ipNetworks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The allowed host or network to which the export is being shared. The IP address can be either IPv4 or IPv6 and has to be given with CIDR notation.\n"
                },
                "nfs": {
                    "$ref": "#/types/ionoscloud:nfs/ShareClientGroupNfs:ShareClientGroupNfs",
                    "description": "NFS specific configurations. Each configuration includes:\n"
                }
            },
            "type": "object",
            "required": [
                "hosts",
                "ipNetworks"
            ]
        },
        "ionoscloud:nfs/ShareClientGroupNfs:ShareClientGroupNfs": {
            "properties": {
                "squash": {
                    "type": "string",
                    "description": "The squash mode for the export. The squash mode can be:\n"
                }
            },
            "type": "object"
        },
        "ionoscloud:nfs/getClusterConnection:getClusterConnection": {
            "properties": {
                "datacenterId": {
                    "type": "string",
                    "description": "The ID of the datacenter where the Network File Storage cluster is located.\n"
                },
                "ipAddress": {
                    "type": "string",
                    "description": "The IP address and prefix of the Network File Storage cluster. The IP address can be either IPv4 or IPv6. The IP address has to be given with CIDR notation.\n"
                },
                "lan": {
                    "type": "string",
                    "description": "The Private LAN to which the Network File Storage cluster must be connected.\n"
                }
            },
            "type": "object",
            "required": [
                "datacenterId",
                "ipAddress",
                "lan"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:nfs/getClusterNf:getClusterNf": {
            "properties": {
                "minVersion": {
                    "type": "string",
                    "description": "The minimum supported version of the NFS cluster. Default is `4.2`\n"
                }
            },
            "type": "object",
            "required": [
                "minVersion"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:nfs/getShareClientGroup:getShareClientGroup": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Optional description for the clients groups.\n"
                },
                "hosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A singular host allowed to connect to the share. The host can be specified as IP address and can be either IPv4 or IPv6.\n"
                },
                "ipNetworks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The allowed host or network to which the export is being shared. The IP address can be either IPv4 or IPv6 and has to be given with CIDR notation.\n"
                },
                "nfs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:nfs/getShareClientGroupNf:getShareClientGroupNf"
                    },
                    "description": "The NFS configuration for the client group. Each NFS configuration supports the following:\n"
                }
            },
            "type": "object",
            "required": [
                "description",
                "hosts",
                "ipNetworks",
                "nfs"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:nfs/getShareClientGroupNf:getShareClientGroupNf": {
            "properties": {
                "squash": {
                    "type": "string",
                    "description": "The squash mode for the export. The squash mode can be: none - No squash mode. no mapping, root-anonymous - Map root user to anonymous uid, all-anonymous - Map all users to anonymous uid.\n"
                }
            },
            "type": "object",
            "required": [
                "squash"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:nlb/BalancerFlowlog:BalancerFlowlog": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "[string] Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL. Immutable, forces re-creation.\n"
                },
                "bucket": {
                    "type": "string",
                    "description": "[string] Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist. Immutable, forces re-creation.\n"
                },
                "direction": {
                    "type": "string",
                    "description": "[string] Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, forces re-creation.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The resource's unique identifier.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] Specifies the name of the flow log.\n\n⚠️ **Note:**: Removing the `flowlog` forces re-creation of the network load balancer resource.\n"
                }
            },
            "type": "object",
            "required": [
                "action",
                "bucket",
                "direction",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "action",
                        "bucket",
                        "direction",
                        "id",
                        "name"
                    ]
                }
            }
        },
        "ionoscloud:nlb/ForwardingRuleHealthCheck:ForwardingRuleHealthCheck": {
            "properties": {
                "clientTimeout": {
                    "type": "integer",
                    "description": "[int] ClientTimeout is expressed in milliseconds. This inactivity timeout applies when the client is expected to acknowledge or send data. If unset the default of 50 seconds will be used.\n"
                },
                "connectTimeout": {
                    "type": "integer",
                    "description": "[int] It specifies the maximum time (in milliseconds) to wait for a connection attempt to a target VM to succeed. If unset, the default of 5 seconds will be used.\n"
                },
                "retries": {
                    "type": "integer",
                    "description": "[int] Retries specifies the number of retries to perform on a target VM after a connection failure. If unset, the default value of 3 will be used.\n"
                },
                "targetTimeout": {
                    "type": "integer",
                    "description": "[int] TargetTimeout specifies the maximum inactivity time (in milliseconds) on the target VM side. If unset, the default of 50 seconds will be used.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "clientTimeout",
                        "connectTimeout",
                        "retries",
                        "targetTimeout"
                    ]
                }
            }
        },
        "ionoscloud:nlb/ForwardingRuleTarget:ForwardingRuleTarget": {
            "properties": {
                "healthCheck": {
                    "$ref": "#/types/ionoscloud:nlb/ForwardingRuleTargetHealthCheck:ForwardingRuleTargetHealthCheck",
                    "description": "Health check attributes for Network Load Balancer forwarding rule target.\n"
                },
                "ip": {
                    "type": "string",
                    "description": "[string] IP of a balanced target VM.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "[int] Port of the balanced target service. (range: 1 to 65535).\n"
                },
                "proxyProtocol": {
                    "type": "string",
                    "description": "[string] The proxy protocol version. Accepted values are `none`, `v1`, `v2`, `v2ssl`. If unspecified, the default value of `none` is used.\n"
                },
                "weight": {
                    "type": "integer",
                    "description": "[int] Weight parameter is used to adjust the target VM's weight relative to other target VMs.\n"
                }
            },
            "type": "object",
            "required": [
                "ip",
                "port",
                "weight"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "healthCheck",
                        "ip",
                        "port",
                        "weight"
                    ]
                }
            }
        },
        "ionoscloud:nlb/ForwardingRuleTargetHealthCheck:ForwardingRuleTargetHealthCheck": {
            "properties": {
                "check": {
                    "type": "boolean",
                    "description": "[boolean] Check specifies whether the target VM's health is checked.\n"
                },
                "checkInterval": {
                    "type": "integer",
                    "description": "[int] CheckInterval determines the duration (in milliseconds) between consecutive health checks. If unspecified a default of 2000 ms is used.\n"
                },
                "maintenance": {
                    "type": "boolean",
                    "description": "[boolean] Maintenance specifies if a target VM should be marked as down, even if it is not.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "check",
                        "checkInterval",
                        "maintenance"
                    ]
                }
            }
        },
        "ionoscloud:nlb/getBalancerFlowlog:getBalancerFlowlog": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Specifies the action to be taken when the rule is matched. Possible values: ACCEPTED, REJECTED, ALL. Immutable, forces re-creation.\n"
                },
                "bucket": {
                    "type": "string",
                    "description": "Specifies the IONOS Object Storage bucket where the flow log data will be stored. The bucket must exist. Immutable, forces re-creation.\n"
                },
                "direction": {
                    "type": "string",
                    "description": "Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, forces re-creation.\n"
                },
                "id": {
                    "type": "string",
                    "description": "ID of the network load balancer you want to search for.\n\n`datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of an existing network load balancer that you want to search for.\n"
                }
            },
            "type": "object",
            "required": [
                "action",
                "bucket",
                "direction",
                "id",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:nlb/getForwardingRuleHealthCheck:getForwardingRuleHealthCheck": {
            "properties": {
                "clientTimeout": {
                    "type": "integer",
                    "description": "ClientTimeout is expressed in milliseconds. This inactivity timeout applies when the client is expected to acknowledge or send data. If unset the default of 50 seconds will be used.\n"
                },
                "connectTimeout": {
                    "type": "integer",
                    "description": "It specifies the maximum time (in milliseconds) to wait for a connection attempt to a target VM to succeed. If unset, the default of 5 seconds will be used.\n"
                },
                "retries": {
                    "type": "integer",
                    "description": "Retries specifies the number of retries to perform on a target VM after a connection failure. If unset, the default value of 3 will be used.\n"
                },
                "targetTimeout": {
                    "type": "integer",
                    "description": "TargetTimeout specifies the maximum inactivity time (in milliseconds) on the target VM side. If unset, the default of 50 seconds will be used.\n"
                }
            },
            "type": "object",
            "required": [
                "clientTimeout",
                "connectTimeout",
                "retries",
                "targetTimeout"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:nlb/getForwardingRuleTarget:getForwardingRuleTarget": {
            "properties": {
                "healthChecks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:nlb/getForwardingRuleTargetHealthCheck:getForwardingRuleTargetHealthCheck"
                    },
                    "description": "Health check attributes for Network Load Balancer forwarding rule target.\n"
                },
                "ip": {
                    "type": "string",
                    "description": "IP of a balanced target VM.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Port of the balanced target service. (range: 1 to 65535).\n"
                },
                "proxyProtocol": {
                    "type": "string",
                    "description": "The proxy protocol version.\n"
                },
                "weight": {
                    "type": "integer",
                    "description": "Weight parameter is used to adjust the target VM's weight relative to other target VMs.\n"
                }
            },
            "type": "object",
            "required": [
                "healthChecks",
                "ip",
                "port",
                "proxyProtocol",
                "weight"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:nlb/getForwardingRuleTargetHealthCheck:getForwardingRuleTargetHealthCheck": {
            "properties": {
                "check": {
                    "type": "boolean",
                    "description": "Check specifies whether the target VM's health is checked.\n"
                },
                "checkInterval": {
                    "type": "integer",
                    "description": "CheckInterval determines the duration (in milliseconds) between consecutive health checks. If unspecified a default of 2000 ms is used.\n"
                },
                "maintenance": {
                    "type": "boolean",
                    "description": "Maintenance specifies if a target VM should be marked as down, even if it is not.\n"
                }
            },
            "type": "object",
            "required": [
                "check",
                "checkInterval",
                "maintenance"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:vpn/IpsecGatewayConnection:IpsecGatewayConnection": {
            "properties": {
                "datacenterId": {
                    "type": "string",
                    "description": "[string] The datacenter to connect your VPN Gateway to.\n"
                },
                "ipv4Cidr": {
                    "type": "string",
                    "description": "[string] Describes the private ipv4 subnet in your LAN that should be accessible by the\nVPN Gateway. Note: this should be the subnet already assigned to the LAN\n"
                },
                "ipv6Cidr": {
                    "type": "string",
                    "description": "[string] Describes the ipv6 subnet in your LAN that should be accessible by the VPN\nGateway. **Note**: this should be the subnet already assigned to the LAN\n"
                },
                "lanId": {
                    "type": "string",
                    "description": "[string] The numeric LAN ID to connect your VPN Gateway to.\n"
                }
            },
            "type": "object",
            "required": [
                "datacenterId",
                "ipv4Cidr",
                "lanId"
            ]
        },
        "ionoscloud:vpn/IpsecTunnelAuth:IpsecTunnelAuth": {
            "properties": {
                "method": {
                    "type": "string",
                    "description": "[string] The authentication method to use for IPSec Authentication. Possible values: `PSK`.\nDefault value: `PSK`.\n"
                },
                "pskKey": {
                    "type": "string",
                    "description": "[string] The pre-shared key to use for IPSec Authentication. **Note**: Required if method is\nPSK.\n",
                    "secret": true
                }
            },
            "type": "object"
        },
        "ionoscloud:vpn/IpsecTunnelEsp:IpsecTunnelEsp": {
            "properties": {
                "diffieHellmanGroup": {
                    "type": "string",
                    "description": "[string] The Diffie-Hellman Group to use for IPSec Encryption. Possible\nvalues: `15-MODP3072`, `16-MODP4096`, `19-ECP256`, `20-ECP384`, `21-ECP521`, `28-ECP256BP`, `29-ECP384BP`, `30-ECP512BP`.\nDefault value: `16-MODP4096`.\n"
                },
                "encryptionAlgorithm": {
                    "type": "string",
                    "description": "[string] The encryption algorithm to use for IPSec Encryption. Possible\nvalues: `AES128`, `AES256`, `AES128-CTR`, `AES256-CTR`, `AES128-GCM-16`, `AES256-GCM-16`, `AES128-GCM-12`, `AES256-GCM-12`, `AES128-CCM-12`,\n`AES256-CCM-12`. Default value: `AES256`.\n"
                },
                "integrityAlgorithm": {
                    "type": "string",
                    "description": "[string] The integrity algorithm to use for IPSec Encryption. Possible\nvalues: `SHA256`, `SHA384`, `SHA512`, `AES-XCBC`. Default value: `SHA256`.\n"
                },
                "lifetime": {
                    "type": "integer",
                    "description": "[string] The phase lifetime in seconds. Minimum value: `3600`. Maximum value: `86400`.\nDefault value: `86400`.\n"
                }
            },
            "type": "object"
        },
        "ionoscloud:vpn/IpsecTunnelIke:IpsecTunnelIke": {
            "properties": {
                "diffieHellmanGroup": {
                    "type": "string",
                    "description": "[string] The Diffie-Hellman Group to use for IPSec Encryption. Possible\nvalues: `15-MODP3072`, `16-MODP4096`, `19-ECP256`, `20-ECP384`, `21-ECP521`, `28-ECP256BP`, `29-ECP384BP`, `30-ECP512BP`.\nDefault value: `16-MODP4096`.\n"
                },
                "encryptionAlgorithm": {
                    "type": "string",
                    "description": "[string] The encryption algorithm to use for IPSec Encryption. Possible\nvalues: `AES128`, `AES256`, `AES128-CTR`, `AES256-CTR`, `AES128-GCM-16`, `AES256-GCM-16`, `AES128-GCM-12`, `AES256-GCM-12`, `AES128-CCM-12`,\n`AES256-CCM-12`. Default value: `AES256`.\n"
                },
                "integrityAlgorithm": {
                    "type": "string",
                    "description": "[string] The integrity algorithm to use for IPSec Encryption. Possible\nvalues: `SHA256`, `SHA384`, `SHA512`, `AES-XCBC`. Default value: `SHA256`.\n"
                },
                "lifetime": {
                    "type": "integer",
                    "description": "[string] The phase lifetime in seconds. Minimum value: `3600`. Maximum value: `86400`.\nDefault value: `86400`.\n"
                }
            },
            "type": "object"
        },
        "ionoscloud:vpn/WireguardGatewayConnection:WireguardGatewayConnection": {
            "properties": {
                "datacenterId": {
                    "type": "string",
                    "description": "[String] The ID of the datacenter where the WireGuard Gateway is located.\n"
                },
                "ipv4Cidr": {
                    "type": "string",
                    "description": "[String] The IPv4 CIDR for the WireGuard Gateway connection.\n"
                },
                "ipv6Cidr": {
                    "type": "string",
                    "description": "[String] The IPv6 CIDR for the WireGuard Gateway connection.\n"
                },
                "lanId": {
                    "type": "string",
                    "description": "[String] The ID of the LAN where the WireGuard Gateway is connected.\n"
                }
            },
            "type": "object",
            "required": [
                "datacenterId",
                "lanId"
            ]
        },
        "ionoscloud:vpn/WireguardPeerEndpoint:WireguardPeerEndpoint": {
            "properties": {
                "host": {
                    "type": "string",
                    "description": "[string] The hostname or IPV4 address that the WireGuard Server will connect to.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "[int] The port that the WireGuard Server will connect to. Defaults to `51820`.\n"
                }
            },
            "type": "object",
            "required": [
                "host"
            ]
        },
        "ionoscloud:vpn/getIpsecGatewayConnection:getIpsecGatewayConnection": {
            "properties": {
                "datacenterId": {
                    "type": "string",
                    "description": "The datacenter to connect your VPN Gateway to.\n"
                },
                "ipv4Cidr": {
                    "type": "string",
                    "description": "Describes the private ipv4 subnet in your LAN that should be accessible by the\nVPN Gateway.\n"
                },
                "ipv6Cidr": {
                    "type": "string",
                    "description": "Describes the ipv6 subnet in your LAN that should be accessible by the VPN Gateway.\n"
                },
                "lanId": {
                    "type": "string",
                    "description": "The numeric LAN ID to connect your VPN Gateway to.\n"
                }
            },
            "type": "object",
            "required": [
                "datacenterId",
                "ipv4Cidr",
                "ipv6Cidr",
                "lanId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:vpn/getIpsecTunnelAuth:getIpsecTunnelAuth": {
            "properties": {
                "method": {
                    "type": "string",
                    "description": "The Authentication Method to use for IPSec Authentication.\n"
                }
            },
            "type": "object",
            "required": [
                "method"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:vpn/getIpsecTunnelEsp:getIpsecTunnelEsp": {
            "properties": {
                "diffieHellmanGroup": {
                    "type": "string",
                    "description": "The Diffie-Hellman Group to use for IPSec Encryption.\n"
                },
                "encryptionAlgorithm": {
                    "type": "string",
                    "description": "The encryption algorithm to use for IPSec Encryption.\n"
                },
                "integrityAlgorithm": {
                    "type": "string",
                    "description": "The integrity algorithm to use for IPSec Encryption.\n"
                },
                "lifetime": {
                    "type": "integer",
                    "description": "The phase lifetime in seconds.\n"
                }
            },
            "type": "object",
            "required": [
                "diffieHellmanGroup",
                "encryptionAlgorithm",
                "integrityAlgorithm",
                "lifetime"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:vpn/getIpsecTunnelIke:getIpsecTunnelIke": {
            "properties": {
                "diffieHellmanGroup": {
                    "type": "string",
                    "description": "The Diffie-Hellman Group to use for IPSec Encryption.\n"
                },
                "encryptionAlgorithm": {
                    "type": "string",
                    "description": "The encryption algorithm to use for IPSec Encryption.\n"
                },
                "integrityAlgorithm": {
                    "type": "string",
                    "description": "The integrity algorithm to use for IPSec Encryption.\n"
                },
                "lifetime": {
                    "type": "integer",
                    "description": "The phase lifetime in seconds.\n"
                }
            },
            "type": "object",
            "required": [
                "diffieHellmanGroup",
                "encryptionAlgorithm",
                "integrityAlgorithm",
                "lifetime"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:vpn/getWireguardGatewayConnection:getWireguardGatewayConnection": {
            "properties": {
                "datacenterId": {
                    "type": "string",
                    "description": "The ID of the datacenter where the WireGuard Gateway is located.\n"
                },
                "ipv4Cidr": {
                    "type": "string",
                    "description": "The IPv4 CIDR for the WireGuard Gateway connection.\n"
                },
                "ipv6Cidr": {
                    "type": "string",
                    "description": "The IPv6 CIDR for the WireGuard Gateway connection.\n"
                },
                "lanId": {
                    "type": "string",
                    "description": "The ID of the LAN where the WireGuard Gateway is connected.\n"
                }
            },
            "type": "object",
            "required": [
                "datacenterId",
                "ipv4Cidr",
                "ipv6Cidr",
                "lanId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "ionoscloud:vpn/getWireguardPeerEndpoint:getWireguardPeerEndpoint": {
            "properties": {
                "host": {
                    "type": "string",
                    "description": "Hostname or IPV4 address that the WireGuard Server will connect to.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Port that the WireGuard Server will connect to. Default: 51820\n"
                }
            },
            "type": "object",
            "required": [
                "host",
                "port"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        }
    },
    "provider": {
        "description": "The provider type for the ionoscloud package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "properties": {
            "contractNumber": {
                "type": "string"
            },
            "endpoint": {
                "type": "string",
                "description": "IonosCloud REST API URL. Usually not necessary to be set, SDKs know internally how to route requests to the API.\n"
            },
            "password": {
                "type": "string",
                "description": "IonosCloud password for API operations. If token is provided, token is preferred\n"
            },
            "retries": {
                "type": "integer",
                "deprecationMessage": "Timeout is used instead of this functionality"
            },
            "s3AccessKey": {
                "type": "string",
                "description": "Access key for IONOS Object Storage operations.\n"
            },
            "s3Region": {
                "type": "string",
                "description": "Region for IONOS Object Storage operations.\n"
            },
            "s3SecretKey": {
                "type": "string",
                "description": "Secret key for IONOS Object Storage operations.\n"
            },
            "token": {
                "type": "string",
                "description": "IonosCloud bearer token for API operations.\n"
            },
            "username": {
                "type": "string",
                "description": "IonosCloud username for API operations. If token is provided, token is preferred\n"
            }
        },
        "inputProperties": {
            "contractNumber": {
                "type": "string"
            },
            "endpoint": {
                "type": "string",
                "description": "IonosCloud REST API URL. Usually not necessary to be set, SDKs know internally how to route requests to the API.\n"
            },
            "password": {
                "type": "string",
                "description": "IonosCloud password for API operations. If token is provided, token is preferred\n"
            },
            "retries": {
                "type": "integer",
                "deprecationMessage": "Timeout is used instead of this functionality"
            },
            "s3AccessKey": {
                "type": "string",
                "description": "Access key for IONOS Object Storage operations.\n"
            },
            "s3Region": {
                "type": "string",
                "description": "Region for IONOS Object Storage operations.\n"
            },
            "s3SecretKey": {
                "type": "string",
                "description": "Secret key for IONOS Object Storage operations.\n"
            },
            "token": {
                "type": "string",
                "description": "IonosCloud bearer token for API operations.\n"
            },
            "username": {
                "type": "string",
                "description": "IonosCloud username for API operations. If token is provided, token is preferred\n"
            }
        }
    },
    "resources": {
        "ionoscloud:alb/balancer:Balancer": {
            "description": "Manages an **Application Load Balancer** on IonosCloud.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst exampleDatacenter = new ionoscloud.compute.Datacenter(\"exampleDatacenter\", {\n    location: \"us/las\",\n    description: \"datacenter description\",\n    secAuthProtection: false,\n});\nconst example1 = new ionoscloud.compute.Lan(\"example1\", {\n    datacenterId: exampleDatacenter.id,\n    \"public\": true,\n});\nconst example2 = new ionoscloud.compute.Lan(\"example2\", {\n    datacenterId: exampleDatacenter.id,\n    \"public\": true,\n});\nconst exampleBalancer = new ionoscloud.alb.Balancer(\"exampleBalancer\", {\n    datacenterId: exampleDatacenter.id,\n    listenerLan: example1.id,\n    ips: [\"10.12.118.224\"],\n    targetLan: example2.id,\n    lbPrivateIps: [\"10.13.72.225/24\"],\n    centralLogging: true,\n    loggingFormat: \"%{+Q}o %{-Q}ci - - [%trg] %r %ST %B \\\"\\\" \\\"\\\" %cp %ms %ft %b %s %TR %Tw %Tc %Tr %Ta %tsc %ac %fc %bc %sc %rc %sq %bq %CC %CS %hrl %hsl\",\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\nexample_datacenter = ionoscloud.compute.Datacenter(\"exampleDatacenter\",\n    location=\"us/las\",\n    description=\"datacenter description\",\n    sec_auth_protection=False)\nexample1 = ionoscloud.compute.Lan(\"example1\",\n    datacenter_id=example_datacenter.id,\n    public=True)\nexample2 = ionoscloud.compute.Lan(\"example2\",\n    datacenter_id=example_datacenter.id,\n    public=True)\nexample_balancer = ionoscloud.alb.Balancer(\"exampleBalancer\",\n    datacenter_id=example_datacenter.id,\n    listener_lan=example1.id,\n    ips=[\"10.12.118.224\"],\n    target_lan=example2.id,\n    lb_private_ips=[\"10.13.72.225/24\"],\n    central_logging=True,\n    logging_format=\"%{+Q}o %{-Q}ci - - [%trg] %r %ST %B \\\"\\\" \\\"\\\" %cp %ms %ft %b %s %TR %Tw %Tc %Tr %Ta %tsc %ac %fc %bc %sc %rc %sq %bq %CC %CS %hrl %hsl\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleDatacenter = new Ionoscloud.Compute.Datacenter(\"exampleDatacenter\", new()\n    {\n        Location = \"us/las\",\n        Description = \"datacenter description\",\n        SecAuthProtection = false,\n    });\n\n    var example1 = new Ionoscloud.Compute.Lan(\"example1\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        Public = true,\n    });\n\n    var example2 = new Ionoscloud.Compute.Lan(\"example2\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        Public = true,\n    });\n\n    var exampleBalancer = new Ionoscloud.Alb.Balancer(\"exampleBalancer\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        ListenerLan = example1.Id,\n        Ips = new[]\n        {\n            \"10.12.118.224\",\n        },\n        TargetLan = example2.Id,\n        LbPrivateIps = new[]\n        {\n            \"10.13.72.225/24\",\n        },\n        CentralLogging = true,\n        LoggingFormat = \"%{+Q}o %{-Q}ci - - [%trg] %r %ST %B \\\"\\\" \\\"\\\" %cp %ms %ft %b %s %TR %Tw %Tc %Tr %Ta %tsc %ac %fc %bc %sc %rc %sq %bq %CC %CS %hrl %hsl\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/alb\"\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleDatacenter, err := compute.NewDatacenter(ctx, \"exampleDatacenter\", \u0026compute.DatacenterArgs{\n\t\t\tLocation:          pulumi.String(\"us/las\"),\n\t\t\tDescription:       pulumi.String(\"datacenter description\"),\n\t\t\tSecAuthProtection: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texample1, err := compute.NewLan(ctx, \"example1\", \u0026compute.LanArgs{\n\t\t\tDatacenterId: exampleDatacenter.ID(),\n\t\t\tPublic:       pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texample2, err := compute.NewLan(ctx, \"example2\", \u0026compute.LanArgs{\n\t\t\tDatacenterId: exampleDatacenter.ID(),\n\t\t\tPublic:       pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = alb.NewBalancer(ctx, \"exampleBalancer\", \u0026alb.BalancerArgs{\n\t\t\tDatacenterId: exampleDatacenter.ID(),\n\t\t\tListenerLan:  example1.ID(),\n\t\t\tIps: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"10.12.118.224\"),\n\t\t\t},\n\t\t\tTargetLan: example2.ID(),\n\t\t\tLbPrivateIps: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"10.13.72.225/24\"),\n\t\t\t},\n\t\t\tCentralLogging: pulumi.Bool(true),\n\t\t\tLoggingFormat:  pulumi.String(\"%{+Q}o %{-Q}ci - - [%trg] %r %ST %B \\\"\\\" \\\"\\\" %cp %ms %ft %b %s %TR %Tw %Tc %Tr %Ta %tsc %ac %fc %bc %sc %rc %sq %bq %CC %CS %hrl %hsl\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.Datacenter;\nimport com.pulumi.ionoscloud.compute.DatacenterArgs;\nimport com.pulumi.ionoscloud.compute.Lan;\nimport com.pulumi.ionoscloud.compute.LanArgs;\nimport com.pulumi.ionoscloud.alb.Balancer;\nimport com.pulumi.ionoscloud.alb.BalancerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleDatacenter = new Datacenter(\"exampleDatacenter\", DatacenterArgs.builder()\n            .location(\"us/las\")\n            .description(\"datacenter description\")\n            .secAuthProtection(false)\n            .build());\n\n        var example1 = new Lan(\"example1\", LanArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .public_(true)\n            .build());\n\n        var example2 = new Lan(\"example2\", LanArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .public_(true)\n            .build());\n\n        var exampleBalancer = new Balancer(\"exampleBalancer\", BalancerArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .listenerLan(example1.id())\n            .ips(\"10.12.118.224\")\n            .targetLan(example2.id())\n            .lbPrivateIps(\"10.13.72.225/24\")\n            .centralLogging(true)\n            .loggingFormat(\"%{+Q}o %{-Q}ci - - [%trg] %r %ST %B \\\"\\\" \\\"\\\" %cp %ms %ft %b %s %TR %Tw %Tc %Tr %Ta %tsc %ac %fc %bc %sc %rc %sq %bq %CC %CS %hrl %hsl\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleDatacenter:\n    type: ionoscloud:compute:Datacenter\n    properties:\n      location: us/las\n      description: datacenter description\n      secAuthProtection: false\n  example1:\n    type: ionoscloud:compute:Lan\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      public: true\n  example2:\n    type: ionoscloud:compute:Lan\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      public: true\n  exampleBalancer:\n    type: ionoscloud:alb:Balancer\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      listenerLan: ${example1.id}\n      ips:\n        - 10.12.118.224\n      targetLan: ${example2.id}\n      lbPrivateIps:\n        - 10.13.72.225/24\n      centralLogging: true\n      loggingFormat: '%{+Q}o %{-Q}ci - - [%trg] %r %ST %B \"\" \"\" %cp %ms %ft %b %s %TR %Tw %Tc %Tr %Ta %tsc %ac %fc %bc %sc %rc %sq %bq %CC %CS %hrl %hsl'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nResource Application Load Balancer can be imported using the `resource id` and `datacenter id`, e.g.\n\n```sh\n$ pulumi import ionoscloud:alb/balancer:Balancer myalb {datacenter uuid}/{applicationLoadBalancer uuid}\n```\n\n",
            "properties": {
                "centralLogging": {
                    "type": "boolean",
                    "description": "[bool] Turn logging on and off for this product. Default value is 'false'.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "[string] ID of the datacenter.\n"
                },
                "flowlog": {
                    "$ref": "#/types/ionoscloud:alb/BalancerFlowlog:BalancerFlowlog",
                    "description": "[list] Only 1 flow log can be configured. Only the name field can change as part of an update. Flow logs holistically capture network information such as source and destination IP addresses, source and destination ports, number of packets, amount of bytes, the start and end time of the recording, and the type of protocol – and log the extent to which your instances are being accessed.\n"
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[set] Collection of the Application Load Balancer IP addresses. (Inbound and outbound) IPs of the listenerLan are customer-reserved public IPs for the public Load Balancers, and private IPs for the private Load Balancers.\n"
                },
                "lbPrivateIps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[set] Collection of private IP addresses with the subnet mask of the Application Load Balancer. IPs must contain valid a subnet mask. If no IP is provided, the system will generate an IP with /24 subnet.\n"
                },
                "listenerLan": {
                    "type": "integer",
                    "description": "[int] ID of the listening (inbound) LAN.\n"
                },
                "loggingFormat": {
                    "type": "string",
                    "description": "Specifies the format of the logs.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the Application Load Balancer.\n"
                },
                "targetLan": {
                    "type": "integer",
                    "description": "[int] ID of the balanced private target LAN (outbound).\n"
                }
            },
            "required": [
                "datacenterId",
                "listenerLan",
                "name",
                "targetLan"
            ],
            "inputProperties": {
                "centralLogging": {
                    "type": "boolean",
                    "description": "[bool] Turn logging on and off for this product. Default value is 'false'.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "[string] ID of the datacenter.\n",
                    "willReplaceOnChanges": true
                },
                "flowlog": {
                    "$ref": "#/types/ionoscloud:alb/BalancerFlowlog:BalancerFlowlog",
                    "description": "[list] Only 1 flow log can be configured. Only the name field can change as part of an update. Flow logs holistically capture network information such as source and destination IP addresses, source and destination ports, number of packets, amount of bytes, the start and end time of the recording, and the type of protocol – and log the extent to which your instances are being accessed.\n"
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[set] Collection of the Application Load Balancer IP addresses. (Inbound and outbound) IPs of the listenerLan are customer-reserved public IPs for the public Load Balancers, and private IPs for the private Load Balancers.\n"
                },
                "lbPrivateIps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[set] Collection of private IP addresses with the subnet mask of the Application Load Balancer. IPs must contain valid a subnet mask. If no IP is provided, the system will generate an IP with /24 subnet.\n"
                },
                "listenerLan": {
                    "type": "integer",
                    "description": "[int] ID of the listening (inbound) LAN.\n"
                },
                "loggingFormat": {
                    "type": "string",
                    "description": "Specifies the format of the logs.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the Application Load Balancer.\n"
                },
                "targetLan": {
                    "type": "integer",
                    "description": "[int] ID of the balanced private target LAN (outbound).\n"
                }
            },
            "requiredInputs": [
                "datacenterId",
                "listenerLan",
                "targetLan"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Balancer resources.\n",
                "properties": {
                    "centralLogging": {
                        "type": "boolean",
                        "description": "[bool] Turn logging on and off for this product. Default value is 'false'.\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "[string] ID of the datacenter.\n",
                        "willReplaceOnChanges": true
                    },
                    "flowlog": {
                        "$ref": "#/types/ionoscloud:alb/BalancerFlowlog:BalancerFlowlog",
                        "description": "[list] Only 1 flow log can be configured. Only the name field can change as part of an update. Flow logs holistically capture network information such as source and destination IP addresses, source and destination ports, number of packets, amount of bytes, the start and end time of the recording, and the type of protocol – and log the extent to which your instances are being accessed.\n"
                    },
                    "ips": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "[set] Collection of the Application Load Balancer IP addresses. (Inbound and outbound) IPs of the listenerLan are customer-reserved public IPs for the public Load Balancers, and private IPs for the private Load Balancers.\n"
                    },
                    "lbPrivateIps": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "[set] Collection of private IP addresses with the subnet mask of the Application Load Balancer. IPs must contain valid a subnet mask. If no IP is provided, the system will generate an IP with /24 subnet.\n"
                    },
                    "listenerLan": {
                        "type": "integer",
                        "description": "[int] ID of the listening (inbound) LAN.\n"
                    },
                    "loggingFormat": {
                        "type": "string",
                        "description": "Specifies the format of the logs.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] The name of the Application Load Balancer.\n"
                    },
                    "targetLan": {
                        "type": "integer",
                        "description": "[int] ID of the balanced private target LAN (outbound).\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:alb/forwardingRule:ForwardingRule": {
            "description": "Manages an **Application Load Balancer Forwarding Rule** on IonosCloud.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as fs from \"fs\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst exampleDatacenter = new ionoscloud.compute.Datacenter(\"exampleDatacenter\", {\n    location: \"us/las\",\n    description: \"datacenter description\",\n    secAuthProtection: false,\n});\nconst example1 = new ionoscloud.compute.Lan(\"example1\", {\n    datacenterId: exampleDatacenter.id,\n    \"public\": true,\n});\nconst example2 = new ionoscloud.compute.Lan(\"example2\", {\n    datacenterId: exampleDatacenter.id,\n    \"public\": true,\n});\nconst exampleBalancer = new ionoscloud.alb.Balancer(\"exampleBalancer\", {\n    datacenterId: exampleDatacenter.id,\n    listenerLan: example1.id,\n    ips: [\"10.12.118.224\"],\n    targetLan: example2.id,\n    lbPrivateIps: [\"10.13.72.225/24\"],\n});\n//optionally you can add a certificate to the application load balancer\nconst cert = new ionoscloud.cert.Certificate(\"cert\", {\n    certificate: fs.readFileSync(\"path_to_cert\", \"utf8\"),\n    certificateChain: fs.readFileSync(\"path_to_cert_chain\", \"utf8\"),\n    privateKey: fs.readFileSync(\"path_to_private_key\", \"utf8\"),\n});\nconst exampleForwardingRule = new ionoscloud.alb.ForwardingRule(\"exampleForwardingRule\", {\n    datacenterId: exampleDatacenter.id,\n    applicationLoadbalancerId: exampleBalancer.id,\n    protocol: \"HTTP\",\n    listenerIp: \"10.12.118.224\",\n    listenerPort: 8080,\n    clientTimeout: 1000,\n    httpRules: [\n        {\n            name: \"http_rule\",\n            type: \"REDIRECT\",\n            dropQuery: true,\n            location: \"www.ionos.com\",\n            statusCode: 301,\n            conditions: [{\n                type: \"HEADER\",\n                condition: \"EQUALS\",\n                negate: true,\n                key: \"key\",\n                value: \"10.12.120.224/24\",\n            }],\n        },\n        {\n            name: \"http_rule_2\",\n            type: \"STATIC\",\n            dropQuery: false,\n            statusCode: 303,\n            responseMessage: \"Response\",\n            contentType: \"text/plain\",\n            conditions: [{\n                type: \"QUERY\",\n                condition: \"MATCHES\",\n                negate: false,\n                key: \"key\",\n                value: \"10.12.120.224/24\",\n            }],\n        },\n    ],\n    serverCertificates: [cert.id],\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\nexample_datacenter = ionoscloud.compute.Datacenter(\"exampleDatacenter\",\n    location=\"us/las\",\n    description=\"datacenter description\",\n    sec_auth_protection=False)\nexample1 = ionoscloud.compute.Lan(\"example1\",\n    datacenter_id=example_datacenter.id,\n    public=True)\nexample2 = ionoscloud.compute.Lan(\"example2\",\n    datacenter_id=example_datacenter.id,\n    public=True)\nexample_balancer = ionoscloud.alb.Balancer(\"exampleBalancer\",\n    datacenter_id=example_datacenter.id,\n    listener_lan=example1.id,\n    ips=[\"10.12.118.224\"],\n    target_lan=example2.id,\n    lb_private_ips=[\"10.13.72.225/24\"])\n#optionally you can add a certificate to the application load balancer\ncert = ionoscloud.cert.Certificate(\"cert\",\n    certificate=(lambda path: open(path).read())(\"path_to_cert\"),\n    certificate_chain=(lambda path: open(path).read())(\"path_to_cert_chain\"),\n    private_key=(lambda path: open(path).read())(\"path_to_private_key\"))\nexample_forwarding_rule = ionoscloud.alb.ForwardingRule(\"exampleForwardingRule\",\n    datacenter_id=example_datacenter.id,\n    application_loadbalancer_id=example_balancer.id,\n    protocol=\"HTTP\",\n    listener_ip=\"10.12.118.224\",\n    listener_port=8080,\n    client_timeout=1000,\n    http_rules=[\n        {\n            \"name\": \"http_rule\",\n            \"type\": \"REDIRECT\",\n            \"drop_query\": True,\n            \"location\": \"www.ionos.com\",\n            \"status_code\": 301,\n            \"conditions\": [{\n                \"type\": \"HEADER\",\n                \"condition\": \"EQUALS\",\n                \"negate\": True,\n                \"key\": \"key\",\n                \"value\": \"10.12.120.224/24\",\n            }],\n        },\n        {\n            \"name\": \"http_rule_2\",\n            \"type\": \"STATIC\",\n            \"drop_query\": False,\n            \"status_code\": 303,\n            \"response_message\": \"Response\",\n            \"content_type\": \"text/plain\",\n            \"conditions\": [{\n                \"type\": \"QUERY\",\n                \"condition\": \"MATCHES\",\n                \"negate\": False,\n                \"key\": \"key\",\n                \"value\": \"10.12.120.224/24\",\n            }],\n        },\n    ],\n    server_certificates=[cert.id])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleDatacenter = new Ionoscloud.Compute.Datacenter(\"exampleDatacenter\", new()\n    {\n        Location = \"us/las\",\n        Description = \"datacenter description\",\n        SecAuthProtection = false,\n    });\n\n    var example1 = new Ionoscloud.Compute.Lan(\"example1\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        Public = true,\n    });\n\n    var example2 = new Ionoscloud.Compute.Lan(\"example2\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        Public = true,\n    });\n\n    var exampleBalancer = new Ionoscloud.Alb.Balancer(\"exampleBalancer\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        ListenerLan = example1.Id,\n        Ips = new[]\n        {\n            \"10.12.118.224\",\n        },\n        TargetLan = example2.Id,\n        LbPrivateIps = new[]\n        {\n            \"10.13.72.225/24\",\n        },\n    });\n\n    //optionally you can add a certificate to the application load balancer\n    var cert = new Ionoscloud.Cert.Certificate(\"cert\", new()\n    {\n        Certificate = File.ReadAllText(\"path_to_cert\"),\n        CertificateChain = File.ReadAllText(\"path_to_cert_chain\"),\n        PrivateKey = File.ReadAllText(\"path_to_private_key\"),\n    });\n\n    var exampleForwardingRule = new Ionoscloud.Alb.ForwardingRule(\"exampleForwardingRule\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        ApplicationLoadbalancerId = exampleBalancer.Id,\n        Protocol = \"HTTP\",\n        ListenerIp = \"10.12.118.224\",\n        ListenerPort = 8080,\n        ClientTimeout = 1000,\n        HttpRules = new[]\n        {\n            new Ionoscloud.Alb.Inputs.ForwardingRuleHttpRuleArgs\n            {\n                Name = \"http_rule\",\n                Type = \"REDIRECT\",\n                DropQuery = true,\n                Location = \"www.ionos.com\",\n                StatusCode = 301,\n                Conditions = new[]\n                {\n                    new Ionoscloud.Alb.Inputs.ForwardingRuleHttpRuleConditionArgs\n                    {\n                        Type = \"HEADER\",\n                        Condition = \"EQUALS\",\n                        Negate = true,\n                        Key = \"key\",\n                        Value = \"10.12.120.224/24\",\n                    },\n                },\n            },\n            new Ionoscloud.Alb.Inputs.ForwardingRuleHttpRuleArgs\n            {\n                Name = \"http_rule_2\",\n                Type = \"STATIC\",\n                DropQuery = false,\n                StatusCode = 303,\n                ResponseMessage = \"Response\",\n                ContentType = \"text/plain\",\n                Conditions = new[]\n                {\n                    new Ionoscloud.Alb.Inputs.ForwardingRuleHttpRuleConditionArgs\n                    {\n                        Type = \"QUERY\",\n                        Condition = \"MATCHES\",\n                        Negate = false,\n                        Key = \"key\",\n                        Value = \"10.12.120.224/24\",\n                    },\n                },\n            },\n        },\n        ServerCertificates = new[]\n        {\n            cert.Id,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"os\"\n\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/alb\"\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/cert\"\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := os.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleDatacenter, err := compute.NewDatacenter(ctx, \"exampleDatacenter\", \u0026compute.DatacenterArgs{\n\t\t\tLocation:          pulumi.String(\"us/las\"),\n\t\t\tDescription:       pulumi.String(\"datacenter description\"),\n\t\t\tSecAuthProtection: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texample1, err := compute.NewLan(ctx, \"example1\", \u0026compute.LanArgs{\n\t\t\tDatacenterId: exampleDatacenter.ID(),\n\t\t\tPublic:       pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texample2, err := compute.NewLan(ctx, \"example2\", \u0026compute.LanArgs{\n\t\t\tDatacenterId: exampleDatacenter.ID(),\n\t\t\tPublic:       pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleBalancer, err := alb.NewBalancer(ctx, \"exampleBalancer\", \u0026alb.BalancerArgs{\n\t\t\tDatacenterId: exampleDatacenter.ID(),\n\t\t\tListenerLan:  example1.ID(),\n\t\t\tIps: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"10.12.118.224\"),\n\t\t\t},\n\t\t\tTargetLan: example2.ID(),\n\t\t\tLbPrivateIps: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"10.13.72.225/24\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// optionally you can add a certificate to the application load balancer\n\t\tcert, err := cert.NewCertificate(ctx, \"cert\", \u0026cert.CertificateArgs{\n\t\t\tCertificate:      pulumi.String(readFileOrPanic(\"path_to_cert\")),\n\t\t\tCertificateChain: pulumi.String(readFileOrPanic(\"path_to_cert_chain\")),\n\t\t\tPrivateKey:       pulumi.String(readFileOrPanic(\"path_to_private_key\")),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = alb.NewForwardingRule(ctx, \"exampleForwardingRule\", \u0026alb.ForwardingRuleArgs{\n\t\t\tDatacenterId:              exampleDatacenter.ID(),\n\t\t\tApplicationLoadbalancerId: exampleBalancer.ID(),\n\t\t\tProtocol:                  pulumi.String(\"HTTP\"),\n\t\t\tListenerIp:                pulumi.String(\"10.12.118.224\"),\n\t\t\tListenerPort:              pulumi.Int(8080),\n\t\t\tClientTimeout:             pulumi.Int(1000),\n\t\t\tHttpRules: alb.ForwardingRuleHttpRuleArray{\n\t\t\t\t\u0026alb.ForwardingRuleHttpRuleArgs{\n\t\t\t\t\tName:       pulumi.String(\"http_rule\"),\n\t\t\t\t\tType:       pulumi.String(\"REDIRECT\"),\n\t\t\t\t\tDropQuery:  pulumi.Bool(true),\n\t\t\t\t\tLocation:   pulumi.String(\"www.ionos.com\"),\n\t\t\t\t\tStatusCode: pulumi.Int(301),\n\t\t\t\t\tConditions: alb.ForwardingRuleHttpRuleConditionArray{\n\t\t\t\t\t\t\u0026alb.ForwardingRuleHttpRuleConditionArgs{\n\t\t\t\t\t\t\tType:      pulumi.String(\"HEADER\"),\n\t\t\t\t\t\t\tCondition: pulumi.String(\"EQUALS\"),\n\t\t\t\t\t\t\tNegate:    pulumi.Bool(true),\n\t\t\t\t\t\t\tKey:       pulumi.String(\"key\"),\n\t\t\t\t\t\t\tValue:     pulumi.String(\"10.12.120.224/24\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026alb.ForwardingRuleHttpRuleArgs{\n\t\t\t\t\tName:            pulumi.String(\"http_rule_2\"),\n\t\t\t\t\tType:            pulumi.String(\"STATIC\"),\n\t\t\t\t\tDropQuery:       pulumi.Bool(false),\n\t\t\t\t\tStatusCode:      pulumi.Int(303),\n\t\t\t\t\tResponseMessage: pulumi.String(\"Response\"),\n\t\t\t\t\tContentType:     pulumi.String(\"text/plain\"),\n\t\t\t\t\tConditions: alb.ForwardingRuleHttpRuleConditionArray{\n\t\t\t\t\t\t\u0026alb.ForwardingRuleHttpRuleConditionArgs{\n\t\t\t\t\t\t\tType:      pulumi.String(\"QUERY\"),\n\t\t\t\t\t\t\tCondition: pulumi.String(\"MATCHES\"),\n\t\t\t\t\t\t\tNegate:    pulumi.Bool(false),\n\t\t\t\t\t\t\tKey:       pulumi.String(\"key\"),\n\t\t\t\t\t\t\tValue:     pulumi.String(\"10.12.120.224/24\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tServerCertificates: pulumi.StringArray{\n\t\t\t\tcert.ID(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.Datacenter;\nimport com.pulumi.ionoscloud.compute.DatacenterArgs;\nimport com.pulumi.ionoscloud.compute.Lan;\nimport com.pulumi.ionoscloud.compute.LanArgs;\nimport com.pulumi.ionoscloud.alb.Balancer;\nimport com.pulumi.ionoscloud.alb.BalancerArgs;\nimport com.pulumi.ionoscloud.cert.Certificate;\nimport com.pulumi.ionoscloud.cert.CertificateArgs;\nimport com.pulumi.ionoscloud.alb.ForwardingRule;\nimport com.pulumi.ionoscloud.alb.ForwardingRuleArgs;\nimport com.pulumi.ionoscloud.alb.inputs.ForwardingRuleHttpRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleDatacenter = new Datacenter(\"exampleDatacenter\", DatacenterArgs.builder()\n            .location(\"us/las\")\n            .description(\"datacenter description\")\n            .secAuthProtection(false)\n            .build());\n\n        var example1 = new Lan(\"example1\", LanArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .public_(true)\n            .build());\n\n        var example2 = new Lan(\"example2\", LanArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .public_(true)\n            .build());\n\n        var exampleBalancer = new Balancer(\"exampleBalancer\", BalancerArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .listenerLan(example1.id())\n            .ips(\"10.12.118.224\")\n            .targetLan(example2.id())\n            .lbPrivateIps(\"10.13.72.225/24\")\n            .build());\n\n        //optionally you can add a certificate to the application load balancer\n        var cert = new Certificate(\"cert\", CertificateArgs.builder()\n            .certificate(Files.readString(Paths.get(\"path_to_cert\")))\n            .certificateChain(Files.readString(Paths.get(\"path_to_cert_chain\")))\n            .privateKey(Files.readString(Paths.get(\"path_to_private_key\")))\n            .build());\n\n        var exampleForwardingRule = new ForwardingRule(\"exampleForwardingRule\", ForwardingRuleArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .applicationLoadbalancerId(exampleBalancer.id())\n            .protocol(\"HTTP\")\n            .listenerIp(\"10.12.118.224\")\n            .listenerPort(8080)\n            .clientTimeout(1000)\n            .httpRules(            \n                ForwardingRuleHttpRuleArgs.builder()\n                    .name(\"http_rule\")\n                    .type(\"REDIRECT\")\n                    .dropQuery(true)\n                    .location(\"www.ionos.com\")\n                    .statusCode(301)\n                    .conditions(ForwardingRuleHttpRuleConditionArgs.builder()\n                        .type(\"HEADER\")\n                        .condition(\"EQUALS\")\n                        .negate(true)\n                        .key(\"key\")\n                        .value(\"10.12.120.224/24\")\n                        .build())\n                    .build(),\n                ForwardingRuleHttpRuleArgs.builder()\n                    .name(\"http_rule_2\")\n                    .type(\"STATIC\")\n                    .dropQuery(false)\n                    .statusCode(303)\n                    .responseMessage(\"Response\")\n                    .contentType(\"text/plain\")\n                    .conditions(ForwardingRuleHttpRuleConditionArgs.builder()\n                        .type(\"QUERY\")\n                        .condition(\"MATCHES\")\n                        .negate(false)\n                        .key(\"key\")\n                        .value(\"10.12.120.224/24\")\n                        .build())\n                    .build())\n            .serverCertificates(cert.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleDatacenter:\n    type: ionoscloud:compute:Datacenter\n    properties:\n      location: us/las\n      description: datacenter description\n      secAuthProtection: false\n  example1:\n    type: ionoscloud:compute:Lan\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      public: true\n  example2:\n    type: ionoscloud:compute:Lan\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      public: true\n  exampleBalancer:\n    type: ionoscloud:alb:Balancer\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      listenerLan: ${example1.id}\n      ips:\n        - 10.12.118.224\n      targetLan: ${example2.id}\n      lbPrivateIps:\n        - 10.13.72.225/24\n  exampleForwardingRule:\n    type: ionoscloud:alb:ForwardingRule\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      applicationLoadbalancerId: ${exampleBalancer.id}\n      protocol: HTTP\n      listenerIp: 10.12.118.224\n      listenerPort: 8080\n      clientTimeout: 1000\n      httpRules:\n        - name: http_rule\n          type: REDIRECT\n          dropQuery: true\n          location: www.ionos.com\n          statusCode: 301\n          conditions:\n            - type: HEADER\n              condition: EQUALS\n              negate: true\n              key: key\n              value: 10.12.120.224/24\n        - name: http_rule_2\n          type: STATIC\n          dropQuery: false\n          statusCode: 303\n          responseMessage: Response\n          contentType: text/plain\n          conditions:\n            - type: QUERY\n              condition: MATCHES\n              negate: false\n              key: key\n              value: 10.12.120.224/24\n      serverCertificates:\n        - ${cert.id}\n  #optionally you can add a certificate to the application load balancer\n  cert:\n    type: ionoscloud:cert:Certificate\n    properties:\n      certificate:\n        fn::readFile: path_to_cert\n      certificateChain:\n        fn::readFile: path_to_cert_chain\n      privateKey:\n        fn::readFile: path_to_private_key\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nResource Application Load Balancer Forwarding Rule can be imported using the `resource id`, `alb id` and `datacenter id`, e.g.\n\n```sh\n$ pulumi import ionoscloud:alb/forwardingRule:ForwardingRule my_application_loadbalancer_forwardingrule {datacenter uuid}/{application_loadbalancer uuid}/{application_loadbalancer_forwardingrule uuid}\n```\n\n",
            "properties": {
                "applicationLoadbalancerId": {
                    "type": "string",
                    "description": "[string] The ID of Application Load Balancer.\n"
                },
                "clientTimeout": {
                    "type": "integer",
                    "description": "[int] The maximum time in milliseconds to wait for the client to acknowledge or send data; default is 50,000 (50 seconds).\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "[string] The ID of a Virtual Data Center.\n"
                },
                "httpRules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:alb/ForwardingRuleHttpRule:ForwardingRuleHttpRule"
                    },
                    "description": "[list] Array of items in that collection\n"
                },
                "listenerIp": {
                    "type": "string",
                    "description": "[string] Listening (inbound) IP.\n"
                },
                "listenerPort": {
                    "type": "integer",
                    "description": "[int] Listening (inbound) port number; valid range is 1 to 65535.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the Application Load Balancer forwarding rule.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "[string] Balancing protocol.\n"
                },
                "serverCertificates": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] Array of certificate ids. You can create certificates with the certificate resource.\n"
                }
            },
            "required": [
                "applicationLoadbalancerId",
                "clientTimeout",
                "datacenterId",
                "listenerIp",
                "listenerPort",
                "name",
                "protocol"
            ],
            "inputProperties": {
                "applicationLoadbalancerId": {
                    "type": "string",
                    "description": "[string] The ID of Application Load Balancer.\n",
                    "willReplaceOnChanges": true
                },
                "clientTimeout": {
                    "type": "integer",
                    "description": "[int] The maximum time in milliseconds to wait for the client to acknowledge or send data; default is 50,000 (50 seconds).\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "[string] The ID of a Virtual Data Center.\n",
                    "willReplaceOnChanges": true
                },
                "httpRules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:alb/ForwardingRuleHttpRule:ForwardingRuleHttpRule"
                    },
                    "description": "[list] Array of items in that collection\n"
                },
                "listenerIp": {
                    "type": "string",
                    "description": "[string] Listening (inbound) IP.\n"
                },
                "listenerPort": {
                    "type": "integer",
                    "description": "[int] Listening (inbound) port number; valid range is 1 to 65535.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the Application Load Balancer forwarding rule.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "[string] Balancing protocol.\n"
                },
                "serverCertificates": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] Array of certificate ids. You can create certificates with the certificate resource.\n"
                }
            },
            "requiredInputs": [
                "applicationLoadbalancerId",
                "datacenterId",
                "listenerIp",
                "listenerPort",
                "protocol"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ForwardingRule resources.\n",
                "properties": {
                    "applicationLoadbalancerId": {
                        "type": "string",
                        "description": "[string] The ID of Application Load Balancer.\n",
                        "willReplaceOnChanges": true
                    },
                    "clientTimeout": {
                        "type": "integer",
                        "description": "[int] The maximum time in milliseconds to wait for the client to acknowledge or send data; default is 50,000 (50 seconds).\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "[string] The ID of a Virtual Data Center.\n",
                        "willReplaceOnChanges": true
                    },
                    "httpRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:alb/ForwardingRuleHttpRule:ForwardingRuleHttpRule"
                        },
                        "description": "[list] Array of items in that collection\n"
                    },
                    "listenerIp": {
                        "type": "string",
                        "description": "[string] Listening (inbound) IP.\n"
                    },
                    "listenerPort": {
                        "type": "integer",
                        "description": "[int] Listening (inbound) port number; valid range is 1 to 65535.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] The name of the Application Load Balancer forwarding rule.\n"
                    },
                    "protocol": {
                        "type": "string",
                        "description": "[string] Balancing protocol.\n"
                    },
                    "serverCertificates": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "[list] Array of certificate ids. You can create certificates with the certificate resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:apigateway/apigateway:Apigateway": {
            "description": "An API gateway consists of the generic rules and configurations.\n\n## Usage example\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = new ionoscloud.apigateway.Apigateway(\"example\", {metrics: true});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\nexample = ionoscloud.apigateway.Apigateway(\"example\", metrics=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Ionoscloud.Apigateway.Apigateway(\"example\", new()\n    {\n        Metrics = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/apigateway\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := apigateway.NewApigateway(ctx, \"example\", \u0026apigateway.ApigatewayArgs{\n\t\t\tMetrics: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.apigateway.Apigateway;\nimport com.pulumi.ionoscloud.apigateway.ApigatewayArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new Apigateway(\"example\", ApigatewayArgs.builder()\n            .metrics(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: ionoscloud:apigateway:Apigateway\n    properties:\n      metrics: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nIn order to import an API Gateway, you can define an empty API Gateway resource in the plan:\n\nresource \"ionoscloud_apigateway\" \"example\" {\n\n}\n\nThe resource can be imported using the `gateway_id`, for example:\n\n```sh\n$ pulumi import ionoscloud:apigateway/apigateway:Apigateway example {gateway_id}\n```\n\n",
            "properties": {
                "customDomains": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:apigateway/ApigatewayCustomDomain:ApigatewayCustomDomain"
                    },
                    "description": "[list] Custom domains for the API Gateway, a list that contains elements with the following structure:\n"
                },
                "logs": {
                    "type": "boolean",
                    "description": "[bool] Enable or disable logging. Defaults to `false`. **NOTE**: Central Logging must be enabled through the Logging API to enable this feature.\n"
                },
                "metrics": {
                    "type": "boolean",
                    "description": "[bool] Enable or disable metrics. Defaults to `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the API Gateway.\n"
                },
                "publicEndpoint": {
                    "type": "string",
                    "description": "[string] The public endpoint of the API Gateway.\n"
                }
            },
            "required": [
                "name",
                "publicEndpoint"
            ],
            "inputProperties": {
                "customDomains": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:apigateway/ApigatewayCustomDomain:ApigatewayCustomDomain"
                    },
                    "description": "[list] Custom domains for the API Gateway, a list that contains elements with the following structure:\n"
                },
                "logs": {
                    "type": "boolean",
                    "description": "[bool] Enable or disable logging. Defaults to `false`. **NOTE**: Central Logging must be enabled through the Logging API to enable this feature.\n"
                },
                "metrics": {
                    "type": "boolean",
                    "description": "[bool] Enable or disable metrics. Defaults to `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the API Gateway.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Apigateway resources.\n",
                "properties": {
                    "customDomains": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:apigateway/ApigatewayCustomDomain:ApigatewayCustomDomain"
                        },
                        "description": "[list] Custom domains for the API Gateway, a list that contains elements with the following structure:\n"
                    },
                    "logs": {
                        "type": "boolean",
                        "description": "[bool] Enable or disable logging. Defaults to `false`. **NOTE**: Central Logging must be enabled through the Logging API to enable this feature.\n"
                    },
                    "metrics": {
                        "type": "boolean",
                        "description": "[bool] Enable or disable metrics. Defaults to `false`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] The name of the API Gateway.\n"
                    },
                    "publicEndpoint": {
                        "type": "string",
                        "description": "[string] The public endpoint of the API Gateway.\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:apigateway/route:Route": {
            "description": "Manages an **API Gateway Route** on IonosCloud.\n\n## Example Usage\n\nThis resource will create an operational API Gateway Route. After this section completes, the provisioner can be called.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = new ionoscloud.apigateway.Apigateway(\"example\", {\n    metrics: true,\n    customDomains: [\n        {\n            name: \"example.com\",\n            certificateId: \"00000000-0000-0000-0000-000000000000\",\n        },\n        {\n            name: \"example.org\",\n            certificateId: \"00000000-0000-0000-0000-000000000000\",\n        },\n    ],\n});\nconst apigatewayRoute = new ionoscloud.apigateway.Route(\"apigatewayRoute\", {\n    type: \"http\",\n    paths: [\n        \"/foo/*\",\n        \"/bar\",\n    ],\n    methods: [\n        \"GET\",\n        \"POST\",\n    ],\n    websocket: false,\n    upstreams: [{\n        scheme: \"http\",\n        loadbalancer: \"roundrobin\",\n        host: \"example.com\",\n        port: 80,\n        weight: 100,\n    }],\n    gatewayId: example.id,\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\nexample = ionoscloud.apigateway.Apigateway(\"example\",\n    metrics=True,\n    custom_domains=[\n        {\n            \"name\": \"example.com\",\n            \"certificate_id\": \"00000000-0000-0000-0000-000000000000\",\n        },\n        {\n            \"name\": \"example.org\",\n            \"certificate_id\": \"00000000-0000-0000-0000-000000000000\",\n        },\n    ])\napigateway_route = ionoscloud.apigateway.Route(\"apigatewayRoute\",\n    type=\"http\",\n    paths=[\n        \"/foo/*\",\n        \"/bar\",\n    ],\n    methods=[\n        \"GET\",\n        \"POST\",\n    ],\n    websocket=False,\n    upstreams=[{\n        \"scheme\": \"http\",\n        \"loadbalancer\": \"roundrobin\",\n        \"host\": \"example.com\",\n        \"port\": 80,\n        \"weight\": 100,\n    }],\n    gateway_id=example.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Ionoscloud.Apigateway.Apigateway(\"example\", new()\n    {\n        Metrics = true,\n        CustomDomains = new[]\n        {\n            new Ionoscloud.Apigateway.Inputs.ApigatewayCustomDomainArgs\n            {\n                Name = \"example.com\",\n                CertificateId = \"00000000-0000-0000-0000-000000000000\",\n            },\n            new Ionoscloud.Apigateway.Inputs.ApigatewayCustomDomainArgs\n            {\n                Name = \"example.org\",\n                CertificateId = \"00000000-0000-0000-0000-000000000000\",\n            },\n        },\n    });\n\n    var apigatewayRoute = new Ionoscloud.Apigateway.Route(\"apigatewayRoute\", new()\n    {\n        Type = \"http\",\n        Paths = new[]\n        {\n            \"/foo/*\",\n            \"/bar\",\n        },\n        Methods = new[]\n        {\n            \"GET\",\n            \"POST\",\n        },\n        Websocket = false,\n        Upstreams = new[]\n        {\n            new Ionoscloud.Apigateway.Inputs.RouteUpstreamArgs\n            {\n                Scheme = \"http\",\n                Loadbalancer = \"roundrobin\",\n                Host = \"example.com\",\n                Port = 80,\n                Weight = 100,\n            },\n        },\n        GatewayId = example.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/apigateway\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := apigateway.NewApigateway(ctx, \"example\", \u0026apigateway.ApigatewayArgs{\n\t\t\tMetrics: pulumi.Bool(true),\n\t\t\tCustomDomains: apigateway.ApigatewayCustomDomainArray{\n\t\t\t\t\u0026apigateway.ApigatewayCustomDomainArgs{\n\t\t\t\t\tName:          pulumi.String(\"example.com\"),\n\t\t\t\t\tCertificateId: pulumi.String(\"00000000-0000-0000-0000-000000000000\"),\n\t\t\t\t},\n\t\t\t\t\u0026apigateway.ApigatewayCustomDomainArgs{\n\t\t\t\t\tName:          pulumi.String(\"example.org\"),\n\t\t\t\t\tCertificateId: pulumi.String(\"00000000-0000-0000-0000-000000000000\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = apigateway.NewRoute(ctx, \"apigatewayRoute\", \u0026apigateway.RouteArgs{\n\t\t\tType: pulumi.String(\"http\"),\n\t\t\tPaths: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"/foo/*\"),\n\t\t\t\tpulumi.String(\"/bar\"),\n\t\t\t},\n\t\t\tMethods: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"GET\"),\n\t\t\t\tpulumi.String(\"POST\"),\n\t\t\t},\n\t\t\tWebsocket: pulumi.Bool(false),\n\t\t\tUpstreams: apigateway.RouteUpstreamArray{\n\t\t\t\t\u0026apigateway.RouteUpstreamArgs{\n\t\t\t\t\tScheme:       pulumi.String(\"http\"),\n\t\t\t\t\tLoadbalancer: pulumi.String(\"roundrobin\"),\n\t\t\t\t\tHost:         pulumi.String(\"example.com\"),\n\t\t\t\t\tPort:         pulumi.Int(80),\n\t\t\t\t\tWeight:       pulumi.Int(100),\n\t\t\t\t},\n\t\t\t},\n\t\t\tGatewayId: example.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.apigateway.Apigateway;\nimport com.pulumi.ionoscloud.apigateway.ApigatewayArgs;\nimport com.pulumi.ionoscloud.apigateway.inputs.ApigatewayCustomDomainArgs;\nimport com.pulumi.ionoscloud.apigateway.Route;\nimport com.pulumi.ionoscloud.apigateway.RouteArgs;\nimport com.pulumi.ionoscloud.apigateway.inputs.RouteUpstreamArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new Apigateway(\"example\", ApigatewayArgs.builder()\n            .metrics(true)\n            .customDomains(            \n                ApigatewayCustomDomainArgs.builder()\n                    .name(\"example.com\")\n                    .certificateId(\"00000000-0000-0000-0000-000000000000\")\n                    .build(),\n                ApigatewayCustomDomainArgs.builder()\n                    .name(\"example.org\")\n                    .certificateId(\"00000000-0000-0000-0000-000000000000\")\n                    .build())\n            .build());\n\n        var apigatewayRoute = new Route(\"apigatewayRoute\", RouteArgs.builder()\n            .type(\"http\")\n            .paths(            \n                \"/foo/*\",\n                \"/bar\")\n            .methods(            \n                \"GET\",\n                \"POST\")\n            .websocket(false)\n            .upstreams(RouteUpstreamArgs.builder()\n                .scheme(\"http\")\n                .loadbalancer(\"roundrobin\")\n                .host(\"example.com\")\n                .port(80)\n                .weight(100)\n                .build())\n            .gatewayId(example.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: ionoscloud:apigateway:Apigateway\n    properties:\n      metrics: true\n      customDomains:\n        - name: example.com\n          certificateId: 00000000-0000-0000-0000-000000000000\n        - name: example.org\n          certificateId: 00000000-0000-0000-0000-000000000000\n  apigatewayRoute:\n    type: ionoscloud:apigateway:Route\n    properties:\n      type: http\n      paths:\n        - /foo/*\n        - /bar\n      methods:\n        - GET\n        - POST\n      websocket: false\n      upstreams:\n        - scheme: http\n          loadbalancer: roundrobin\n          host: example.com\n          port: 80\n          weight: 100\n      gatewayId: ${example.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nAPI Gateway route can be imported using the `apigateway route id`:\n\n```sh\n$ pulumi import ionoscloud:apigateway/route:Route myroute {apigateway uuid}:{apigateway route uuid}\n```\n\n",
            "properties": {
                "gatewayId": {
                    "type": "string",
                    "description": "[string] The ID of the API Gateway that the route belongs to.\n"
                },
                "methods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] The HTTP methods that the route should match. Minimum items: 1. Possible values: `GET`,\n`POST`, `PUT`, `DELETE`, `PATCH`, `OPTIONS`, `HEAD`, `CONNECT`, `TRACE`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] Name of the API Gateway Route. Only alphanumeric characters are allowed.\n"
                },
                "paths": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] The paths that the route should match. Minimum items: 1.\n"
                },
                "type": {
                    "type": "string",
                    "description": "[string] This field specifies the protocol used by the ingress to route traffic to the backend\nservice. Default value: `http`.\n"
                },
                "upstreams": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:apigateway/RouteUpstream:RouteUpstream"
                    },
                    "description": "Upstreams information of the API Gateway Route. Minimum items: 1.\n"
                },
                "websocket": {
                    "type": "boolean",
                    "description": "[bool] To enable websocket support. Default value: `false`.\n"
                }
            },
            "required": [
                "gatewayId",
                "methods",
                "name",
                "paths",
                "upstreams"
            ],
            "inputProperties": {
                "gatewayId": {
                    "type": "string",
                    "description": "[string] The ID of the API Gateway that the route belongs to.\n"
                },
                "methods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] The HTTP methods that the route should match. Minimum items: 1. Possible values: `GET`,\n`POST`, `PUT`, `DELETE`, `PATCH`, `OPTIONS`, `HEAD`, `CONNECT`, `TRACE`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] Name of the API Gateway Route. Only alphanumeric characters are allowed.\n"
                },
                "paths": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] The paths that the route should match. Minimum items: 1.\n"
                },
                "type": {
                    "type": "string",
                    "description": "[string] This field specifies the protocol used by the ingress to route traffic to the backend\nservice. Default value: `http`.\n"
                },
                "upstreams": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:apigateway/RouteUpstream:RouteUpstream"
                    },
                    "description": "Upstreams information of the API Gateway Route. Minimum items: 1.\n"
                },
                "websocket": {
                    "type": "boolean",
                    "description": "[bool] To enable websocket support. Default value: `false`.\n"
                }
            },
            "requiredInputs": [
                "gatewayId",
                "methods",
                "paths",
                "upstreams"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Route resources.\n",
                "properties": {
                    "gatewayId": {
                        "type": "string",
                        "description": "[string] The ID of the API Gateway that the route belongs to.\n"
                    },
                    "methods": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "[list] The HTTP methods that the route should match. Minimum items: 1. Possible values: `GET`,\n`POST`, `PUT`, `DELETE`, `PATCH`, `OPTIONS`, `HEAD`, `CONNECT`, `TRACE`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] Name of the API Gateway Route. Only alphanumeric characters are allowed.\n"
                    },
                    "paths": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "[list] The paths that the route should match. Minimum items: 1.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "[string] This field specifies the protocol used by the ingress to route traffic to the backend\nservice. Default value: `http`.\n"
                    },
                    "upstreams": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:apigateway/RouteUpstream:RouteUpstream"
                        },
                        "description": "Upstreams information of the API Gateway Route. Minimum items: 1.\n"
                    },
                    "websocket": {
                        "type": "boolean",
                        "description": "[bool] To enable websocket support. Default value: `false`.\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:autoscaling/group:Group": {
            "description": "Manages an Autoscaling Group on IonosCloud.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\nimport * as random from \"@pulumi/random\";\n\nconst datacenterExample = new ionoscloud.compute.Datacenter(\"datacenterExample\", {location: \"de/fra\"});\nconst lanExample1 = new ionoscloud.compute.Lan(\"lanExample1\", {\n    datacenterId: datacenterExample.id,\n    \"public\": false,\n});\nconst lanExample2 = new ionoscloud.compute.Lan(\"lanExample2\", {\n    datacenterId: datacenterExample.id,\n    \"public\": false,\n});\nconst autoscalingTargetGroup = new ionoscloud.compute.TargetGroup(\"autoscalingTargetGroup\", {\n    algorithm: \"ROUND_ROBIN\",\n    protocol: \"HTTP\",\n});\nconst serverImagePassword = new random.RandomPassword(\"serverImagePassword\", {\n    length: 16,\n    special: false,\n});\nconst autoscalingGroupExample = new ionoscloud.autoscaling.Group(\"autoscalingGroupExample\", {\n    datacenterId: datacenterExample.id,\n    maxReplicaCount: 2,\n    minReplicaCount: 1,\n    policy: {\n        metric: \"INSTANCE_CPU_UTILIZATION_AVERAGE\",\n        range: \"PT24H\",\n        scaleInAction: {\n            amount: 1,\n            amountType: \"ABSOLUTE\",\n            terminationPolicyType: \"OLDEST_SERVER_FIRST\",\n            cooldownPeriod: \"PT5M\",\n            deleteVolumes: true,\n        },\n        scaleInThreshold: 33,\n        scaleOutAction: {\n            amount: 1,\n            amountType: \"ABSOLUTE\",\n            cooldownPeriod: \"PT5M\",\n        },\n        scaleOutThreshold: 77,\n        unit: \"PER_HOUR\",\n    },\n    replicaConfiguration: {\n        availabilityZone: \"AUTO\",\n        cores: 2,\n        cpuFamily: \"INTEL_SKYLAKE\",\n        ram: 2048,\n        nics: [\n            {\n                lan: lanExample1.id,\n                name: \"nic_example_1\",\n                dhcp: true,\n            },\n            {\n                lan: lanExample2.id,\n                name: \"nic_example_2\",\n                dhcp: true,\n                firewallActive: true,\n                firewallType: \"INGRESS\",\n                firewallRules: [{\n                    name: \"rule_1\",\n                    protocol: \"TCP\",\n                    portRangeStart: 1,\n                    portRangeEnd: 1000,\n                    type: \"INGRESS\",\n                }],\n                flowLogs: [{\n                    name: \"flow_log_1\",\n                    bucket: \"test-de-bucket\",\n                    action: \"ALL\",\n                    direction: \"BIDIRECTIONAL\",\n                }],\n                targetGroup: {\n                    targetGroupId: autoscalingTargetGroup.id,\n                    port: 80,\n                    weight: 50,\n                },\n            },\n        ],\n        volumes: [{\n            imageAlias: \"ubuntu:latest\",\n            name: \"volume_example\",\n            size: 10,\n            type: \"HDD\",\n            userData: \"ZWNobyAiSGVsbG8sIFdvcmxkIgo=\",\n            imagePassword: serverImagePassword.result,\n            bootOrder: \"AUTO\",\n        }],\n    },\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\nimport pulumi_random as random\n\ndatacenter_example = ionoscloud.compute.Datacenter(\"datacenterExample\", location=\"de/fra\")\nlan_example1 = ionoscloud.compute.Lan(\"lanExample1\",\n    datacenter_id=datacenter_example.id,\n    public=False)\nlan_example2 = ionoscloud.compute.Lan(\"lanExample2\",\n    datacenter_id=datacenter_example.id,\n    public=False)\nautoscaling_target_group = ionoscloud.compute.TargetGroup(\"autoscalingTargetGroup\",\n    algorithm=\"ROUND_ROBIN\",\n    protocol=\"HTTP\")\nserver_image_password = random.RandomPassword(\"serverImagePassword\",\n    length=16,\n    special=False)\nautoscaling_group_example = ionoscloud.autoscaling.Group(\"autoscalingGroupExample\",\n    datacenter_id=datacenter_example.id,\n    max_replica_count=2,\n    min_replica_count=1,\n    policy={\n        \"metric\": \"INSTANCE_CPU_UTILIZATION_AVERAGE\",\n        \"range\": \"PT24H\",\n        \"scale_in_action\": {\n            \"amount\": 1,\n            \"amount_type\": \"ABSOLUTE\",\n            \"termination_policy_type\": \"OLDEST_SERVER_FIRST\",\n            \"cooldown_period\": \"PT5M\",\n            \"delete_volumes\": True,\n        },\n        \"scale_in_threshold\": 33,\n        \"scale_out_action\": {\n            \"amount\": 1,\n            \"amount_type\": \"ABSOLUTE\",\n            \"cooldown_period\": \"PT5M\",\n        },\n        \"scale_out_threshold\": 77,\n        \"unit\": \"PER_HOUR\",\n    },\n    replica_configuration={\n        \"availability_zone\": \"AUTO\",\n        \"cores\": 2,\n        \"cpu_family\": \"INTEL_SKYLAKE\",\n        \"ram\": 2048,\n        \"nics\": [\n            {\n                \"lan\": lan_example1.id,\n                \"name\": \"nic_example_1\",\n                \"dhcp\": True,\n            },\n            {\n                \"lan\": lan_example2.id,\n                \"name\": \"nic_example_2\",\n                \"dhcp\": True,\n                \"firewall_active\": True,\n                \"firewall_type\": \"INGRESS\",\n                \"firewall_rules\": [{\n                    \"name\": \"rule_1\",\n                    \"protocol\": \"TCP\",\n                    \"port_range_start\": 1,\n                    \"port_range_end\": 1000,\n                    \"type\": \"INGRESS\",\n                }],\n                \"flow_logs\": [{\n                    \"name\": \"flow_log_1\",\n                    \"bucket\": \"test-de-bucket\",\n                    \"action\": \"ALL\",\n                    \"direction\": \"BIDIRECTIONAL\",\n                }],\n                \"target_group\": {\n                    \"target_group_id\": autoscaling_target_group.id,\n                    \"port\": 80,\n                    \"weight\": 50,\n                },\n            },\n        ],\n        \"volumes\": [{\n            \"image_alias\": \"ubuntu:latest\",\n            \"name\": \"volume_example\",\n            \"size\": 10,\n            \"type\": \"HDD\",\n            \"user_data\": \"ZWNobyAiSGVsbG8sIFdvcmxkIgo=\",\n            \"image_password\": server_image_password.result,\n            \"boot_order\": \"AUTO\",\n        }],\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\nusing Random = Pulumi.Random;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenterExample = new Ionoscloud.Compute.Datacenter(\"datacenterExample\", new()\n    {\n        Location = \"de/fra\",\n    });\n\n    var lanExample1 = new Ionoscloud.Compute.Lan(\"lanExample1\", new()\n    {\n        DatacenterId = datacenterExample.Id,\n        Public = false,\n    });\n\n    var lanExample2 = new Ionoscloud.Compute.Lan(\"lanExample2\", new()\n    {\n        DatacenterId = datacenterExample.Id,\n        Public = false,\n    });\n\n    var autoscalingTargetGroup = new Ionoscloud.Compute.TargetGroup(\"autoscalingTargetGroup\", new()\n    {\n        Algorithm = \"ROUND_ROBIN\",\n        Protocol = \"HTTP\",\n    });\n\n    var serverImagePassword = new Random.RandomPassword(\"serverImagePassword\", new()\n    {\n        Length = 16,\n        Special = false,\n    });\n\n    var autoscalingGroupExample = new Ionoscloud.Autoscaling.Group(\"autoscalingGroupExample\", new()\n    {\n        DatacenterId = datacenterExample.Id,\n        MaxReplicaCount = 2,\n        MinReplicaCount = 1,\n        Policy = new Ionoscloud.Autoscaling.Inputs.GroupPolicyArgs\n        {\n            Metric = \"INSTANCE_CPU_UTILIZATION_AVERAGE\",\n            Range = \"PT24H\",\n            ScaleInAction = new Ionoscloud.Autoscaling.Inputs.GroupPolicyScaleInActionArgs\n            {\n                Amount = 1,\n                AmountType = \"ABSOLUTE\",\n                TerminationPolicyType = \"OLDEST_SERVER_FIRST\",\n                CooldownPeriod = \"PT5M\",\n                DeleteVolumes = true,\n            },\n            ScaleInThreshold = 33,\n            ScaleOutAction = new Ionoscloud.Autoscaling.Inputs.GroupPolicyScaleOutActionArgs\n            {\n                Amount = 1,\n                AmountType = \"ABSOLUTE\",\n                CooldownPeriod = \"PT5M\",\n            },\n            ScaleOutThreshold = 77,\n            Unit = \"PER_HOUR\",\n        },\n        ReplicaConfiguration = new Ionoscloud.Autoscaling.Inputs.GroupReplicaConfigurationArgs\n        {\n            AvailabilityZone = \"AUTO\",\n            Cores = 2,\n            CpuFamily = \"INTEL_SKYLAKE\",\n            Ram = 2048,\n            Nics = new[]\n            {\n                new Ionoscloud.Autoscaling.Inputs.GroupReplicaConfigurationNicArgs\n                {\n                    Lan = lanExample1.Id,\n                    Name = \"nic_example_1\",\n                    Dhcp = true,\n                },\n                new Ionoscloud.Autoscaling.Inputs.GroupReplicaConfigurationNicArgs\n                {\n                    Lan = lanExample2.Id,\n                    Name = \"nic_example_2\",\n                    Dhcp = true,\n                    FirewallActive = true,\n                    FirewallType = \"INGRESS\",\n                    FirewallRules = new[]\n                    {\n                        new Ionoscloud.Autoscaling.Inputs.GroupReplicaConfigurationNicFirewallRuleArgs\n                        {\n                            Name = \"rule_1\",\n                            Protocol = \"TCP\",\n                            PortRangeStart = 1,\n                            PortRangeEnd = 1000,\n                            Type = \"INGRESS\",\n                        },\n                    },\n                    FlowLogs = new[]\n                    {\n                        new Ionoscloud.Autoscaling.Inputs.GroupReplicaConfigurationNicFlowLogArgs\n                        {\n                            Name = \"flow_log_1\",\n                            Bucket = \"test-de-bucket\",\n                            Action = \"ALL\",\n                            Direction = \"BIDIRECTIONAL\",\n                        },\n                    },\n                    TargetGroup = new Ionoscloud.Autoscaling.Inputs.GroupReplicaConfigurationNicTargetGroupArgs\n                    {\n                        TargetGroupId = autoscalingTargetGroup.Id,\n                        Port = 80,\n                        Weight = 50,\n                    },\n                },\n            },\n            Volumes = new[]\n            {\n                new Ionoscloud.Autoscaling.Inputs.GroupReplicaConfigurationVolumeArgs\n                {\n                    ImageAlias = \"ubuntu:latest\",\n                    Name = \"volume_example\",\n                    Size = 10,\n                    Type = \"HDD\",\n                    UserData = \"ZWNobyAiSGVsbG8sIFdvcmxkIgo=\",\n                    ImagePassword = serverImagePassword.Result,\n                    BootOrder = \"AUTO\",\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/autoscaling\"\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi-random/sdk/v4/go/random\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenterExample, err := compute.NewDatacenter(ctx, \"datacenterExample\", \u0026compute.DatacenterArgs{\n\t\t\tLocation: pulumi.String(\"de/fra\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tlanExample1, err := compute.NewLan(ctx, \"lanExample1\", \u0026compute.LanArgs{\n\t\t\tDatacenterId: datacenterExample.ID(),\n\t\t\tPublic:       pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tlanExample2, err := compute.NewLan(ctx, \"lanExample2\", \u0026compute.LanArgs{\n\t\t\tDatacenterId: datacenterExample.ID(),\n\t\t\tPublic:       pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tautoscalingTargetGroup, err := compute.NewTargetGroup(ctx, \"autoscalingTargetGroup\", \u0026compute.TargetGroupArgs{\n\t\t\tAlgorithm: pulumi.String(\"ROUND_ROBIN\"),\n\t\t\tProtocol:  pulumi.String(\"HTTP\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tserverImagePassword, err := random.NewRandomPassword(ctx, \"serverImagePassword\", \u0026random.RandomPasswordArgs{\n\t\t\tLength:  pulumi.Int(16),\n\t\t\tSpecial: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = autoscaling.NewGroup(ctx, \"autoscalingGroupExample\", \u0026autoscaling.GroupArgs{\n\t\t\tDatacenterId:    datacenterExample.ID(),\n\t\t\tMaxReplicaCount: pulumi.Int(2),\n\t\t\tMinReplicaCount: pulumi.Int(1),\n\t\t\tPolicy: \u0026autoscaling.GroupPolicyArgs{\n\t\t\t\tMetric: pulumi.String(\"INSTANCE_CPU_UTILIZATION_AVERAGE\"),\n\t\t\t\tRange:  pulumi.String(\"PT24H\"),\n\t\t\t\tScaleInAction: \u0026autoscaling.GroupPolicyScaleInActionArgs{\n\t\t\t\t\tAmount:                pulumi.Int(1),\n\t\t\t\t\tAmountType:            pulumi.String(\"ABSOLUTE\"),\n\t\t\t\t\tTerminationPolicyType: pulumi.String(\"OLDEST_SERVER_FIRST\"),\n\t\t\t\t\tCooldownPeriod:        pulumi.String(\"PT5M\"),\n\t\t\t\t\tDeleteVolumes:         pulumi.Bool(true),\n\t\t\t\t},\n\t\t\t\tScaleInThreshold: pulumi.Int(33),\n\t\t\t\tScaleOutAction: \u0026autoscaling.GroupPolicyScaleOutActionArgs{\n\t\t\t\t\tAmount:         pulumi.Int(1),\n\t\t\t\t\tAmountType:     pulumi.String(\"ABSOLUTE\"),\n\t\t\t\t\tCooldownPeriod: pulumi.String(\"PT5M\"),\n\t\t\t\t},\n\t\t\t\tScaleOutThreshold: pulumi.Int(77),\n\t\t\t\tUnit:              pulumi.String(\"PER_HOUR\"),\n\t\t\t},\n\t\t\tReplicaConfiguration: \u0026autoscaling.GroupReplicaConfigurationArgs{\n\t\t\t\tAvailabilityZone: pulumi.String(\"AUTO\"),\n\t\t\t\tCores:            pulumi.Int(2),\n\t\t\t\tCpuFamily:        pulumi.String(\"INTEL_SKYLAKE\"),\n\t\t\t\tRam:              pulumi.Int(2048),\n\t\t\t\tNics: autoscaling.GroupReplicaConfigurationNicArray{\n\t\t\t\t\t\u0026autoscaling.GroupReplicaConfigurationNicArgs{\n\t\t\t\t\t\tLan:  lanExample1.ID(),\n\t\t\t\t\t\tName: pulumi.String(\"nic_example_1\"),\n\t\t\t\t\t\tDhcp: pulumi.Bool(true),\n\t\t\t\t\t},\n\t\t\t\t\t\u0026autoscaling.GroupReplicaConfigurationNicArgs{\n\t\t\t\t\t\tLan:            lanExample2.ID(),\n\t\t\t\t\t\tName:           pulumi.String(\"nic_example_2\"),\n\t\t\t\t\t\tDhcp:           pulumi.Bool(true),\n\t\t\t\t\t\tFirewallActive: pulumi.Bool(true),\n\t\t\t\t\t\tFirewallType:   pulumi.String(\"INGRESS\"),\n\t\t\t\t\t\tFirewallRules: autoscaling.GroupReplicaConfigurationNicFirewallRuleArray{\n\t\t\t\t\t\t\t\u0026autoscaling.GroupReplicaConfigurationNicFirewallRuleArgs{\n\t\t\t\t\t\t\t\tName:           pulumi.String(\"rule_1\"),\n\t\t\t\t\t\t\t\tProtocol:       pulumi.String(\"TCP\"),\n\t\t\t\t\t\t\t\tPortRangeStart: pulumi.Int(1),\n\t\t\t\t\t\t\t\tPortRangeEnd:   pulumi.Int(1000),\n\t\t\t\t\t\t\t\tType:           pulumi.String(\"INGRESS\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tFlowLogs: autoscaling.GroupReplicaConfigurationNicFlowLogArray{\n\t\t\t\t\t\t\t\u0026autoscaling.GroupReplicaConfigurationNicFlowLogArgs{\n\t\t\t\t\t\t\t\tName:      pulumi.String(\"flow_log_1\"),\n\t\t\t\t\t\t\t\tBucket:    pulumi.String(\"test-de-bucket\"),\n\t\t\t\t\t\t\t\tAction:    pulumi.String(\"ALL\"),\n\t\t\t\t\t\t\t\tDirection: pulumi.String(\"BIDIRECTIONAL\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tTargetGroup: \u0026autoscaling.GroupReplicaConfigurationNicTargetGroupArgs{\n\t\t\t\t\t\t\tTargetGroupId: autoscalingTargetGroup.ID(),\n\t\t\t\t\t\t\tPort:          pulumi.Int(80),\n\t\t\t\t\t\t\tWeight:        pulumi.Int(50),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tVolumes: autoscaling.GroupReplicaConfigurationVolumeArray{\n\t\t\t\t\t\u0026autoscaling.GroupReplicaConfigurationVolumeArgs{\n\t\t\t\t\t\tImageAlias:    pulumi.String(\"ubuntu:latest\"),\n\t\t\t\t\t\tName:          pulumi.String(\"volume_example\"),\n\t\t\t\t\t\tSize:          pulumi.Int(10),\n\t\t\t\t\t\tType:          pulumi.String(\"HDD\"),\n\t\t\t\t\t\tUserData:      pulumi.String(\"ZWNobyAiSGVsbG8sIFdvcmxkIgo=\"),\n\t\t\t\t\t\tImagePassword: serverImagePassword.Result,\n\t\t\t\t\t\tBootOrder:     pulumi.String(\"AUTO\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.Datacenter;\nimport com.pulumi.ionoscloud.compute.DatacenterArgs;\nimport com.pulumi.ionoscloud.compute.Lan;\nimport com.pulumi.ionoscloud.compute.LanArgs;\nimport com.pulumi.ionoscloud.compute.TargetGroup;\nimport com.pulumi.ionoscloud.compute.TargetGroupArgs;\nimport com.pulumi.random.RandomPassword;\nimport com.pulumi.random.RandomPasswordArgs;\nimport com.pulumi.ionoscloud.autoscaling.Group;\nimport com.pulumi.ionoscloud.autoscaling.GroupArgs;\nimport com.pulumi.ionoscloud.autoscaling.inputs.GroupPolicyArgs;\nimport com.pulumi.ionoscloud.autoscaling.inputs.GroupPolicyScaleInActionArgs;\nimport com.pulumi.ionoscloud.autoscaling.inputs.GroupPolicyScaleOutActionArgs;\nimport com.pulumi.ionoscloud.autoscaling.inputs.GroupReplicaConfigurationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var datacenterExample = new Datacenter(\"datacenterExample\", DatacenterArgs.builder()\n            .location(\"de/fra\")\n            .build());\n\n        var lanExample1 = new Lan(\"lanExample1\", LanArgs.builder()\n            .datacenterId(datacenterExample.id())\n            .public_(false)\n            .build());\n\n        var lanExample2 = new Lan(\"lanExample2\", LanArgs.builder()\n            .datacenterId(datacenterExample.id())\n            .public_(false)\n            .build());\n\n        var autoscalingTargetGroup = new TargetGroup(\"autoscalingTargetGroup\", TargetGroupArgs.builder()\n            .algorithm(\"ROUND_ROBIN\")\n            .protocol(\"HTTP\")\n            .build());\n\n        var serverImagePassword = new RandomPassword(\"serverImagePassword\", RandomPasswordArgs.builder()\n            .length(16)\n            .special(false)\n            .build());\n\n        var autoscalingGroupExample = new Group(\"autoscalingGroupExample\", GroupArgs.builder()\n            .datacenterId(datacenterExample.id())\n            .maxReplicaCount(2)\n            .minReplicaCount(1)\n            .policy(GroupPolicyArgs.builder()\n                .metric(\"INSTANCE_CPU_UTILIZATION_AVERAGE\")\n                .range(\"PT24H\")\n                .scaleInAction(GroupPolicyScaleInActionArgs.builder()\n                    .amount(1)\n                    .amountType(\"ABSOLUTE\")\n                    .terminationPolicyType(\"OLDEST_SERVER_FIRST\")\n                    .cooldownPeriod(\"PT5M\")\n                    .deleteVolumes(true)\n                    .build())\n                .scaleInThreshold(33)\n                .scaleOutAction(GroupPolicyScaleOutActionArgs.builder()\n                    .amount(1)\n                    .amountType(\"ABSOLUTE\")\n                    .cooldownPeriod(\"PT5M\")\n                    .build())\n                .scaleOutThreshold(77)\n                .unit(\"PER_HOUR\")\n                .build())\n            .replicaConfiguration(GroupReplicaConfigurationArgs.builder()\n                .availabilityZone(\"AUTO\")\n                .cores(\"2\")\n                .cpuFamily(\"INTEL_SKYLAKE\")\n                .ram(2048)\n                .nics(                \n                    GroupReplicaConfigurationNicArgs.builder()\n                        .lan(lanExample1.id())\n                        .name(\"nic_example_1\")\n                        .dhcp(true)\n                        .build(),\n                    GroupReplicaConfigurationNicArgs.builder()\n                        .lan(lanExample2.id())\n                        .name(\"nic_example_2\")\n                        .dhcp(true)\n                        .firewallActive(true)\n                        .firewallType(\"INGRESS\")\n                        .firewallRules(GroupReplicaConfigurationNicFirewallRuleArgs.builder()\n                            .name(\"rule_1\")\n                            .protocol(\"TCP\")\n                            .portRangeStart(1)\n                            .portRangeEnd(1000)\n                            .type(\"INGRESS\")\n                            .build())\n                        .flowLogs(GroupReplicaConfigurationNicFlowLogArgs.builder()\n                            .name(\"flow_log_1\")\n                            .bucket(\"test-de-bucket\")\n                            .action(\"ALL\")\n                            .direction(\"BIDIRECTIONAL\")\n                            .build())\n                        .targetGroup(GroupReplicaConfigurationNicTargetGroupArgs.builder()\n                            .targetGroupId(autoscalingTargetGroup.id())\n                            .port(80)\n                            .weight(50)\n                            .build())\n                        .build())\n                .volumes(GroupReplicaConfigurationVolumeArgs.builder()\n                    .imageAlias(\"ubuntu:latest\")\n                    .name(\"volume_example\")\n                    .size(10)\n                    .type(\"HDD\")\n                    .userData(\"ZWNobyAiSGVsbG8sIFdvcmxkIgo=\")\n                    .imagePassword(serverImagePassword.result())\n                    .bootOrder(\"AUTO\")\n                    .build())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  datacenterExample:\n    type: ionoscloud:compute:Datacenter\n    properties:\n      location: de/fra\n  lanExample1:\n    type: ionoscloud:compute:Lan\n    properties:\n      datacenterId: ${datacenterExample.id}\n      public: false\n  lanExample2:\n    type: ionoscloud:compute:Lan\n    properties:\n      datacenterId: ${datacenterExample.id}\n      public: false\n  autoscalingTargetGroup:\n    type: ionoscloud:compute:TargetGroup\n    properties:\n      algorithm: ROUND_ROBIN\n      protocol: HTTP\n  autoscalingGroupExample:\n    type: ionoscloud:autoscaling:Group\n    properties:\n      datacenterId: ${datacenterExample.id}\n      maxReplicaCount: 2\n      minReplicaCount: 1\n      policy:\n        metric: INSTANCE_CPU_UTILIZATION_AVERAGE\n        range: PT24H\n        scaleInAction:\n          amount: 1\n          amountType: ABSOLUTE\n          terminationPolicyType: OLDEST_SERVER_FIRST\n          cooldownPeriod: PT5M\n          deleteVolumes: true\n        scaleInThreshold: 33\n        scaleOutAction:\n          amount: 1\n          amountType: ABSOLUTE\n          cooldownPeriod: PT5M\n        scaleOutThreshold: 77\n        unit: PER_HOUR\n      replicaConfiguration:\n        availabilityZone: AUTO\n        cores: '2'\n        cpuFamily: INTEL_SKYLAKE\n        ram: 2048\n        nics:\n          - lan: ${lanExample1.id}\n            name: nic_example_1\n            dhcp: true\n          - lan: ${lanExample2.id}\n            name: nic_example_2\n            dhcp: true\n            firewallActive: true\n            firewallType: INGRESS\n            firewallRules:\n              - name: rule_1\n                protocol: TCP\n                portRangeStart: 1\n                portRangeEnd: 1000\n                type: INGRESS\n            flowLogs:\n              - name: flow_log_1\n                bucket: test-de-bucket\n                action: ALL\n                direction: BIDIRECTIONAL\n            targetGroup:\n              targetGroupId: ${autoscalingTargetGroup.id}\n              port: 80\n              weight: 50\n        volumes:\n          - imageAlias: ubuntu:latest\n            name: volume_example\n            size: 10\n            type: HDD\n            userData: ZWNobyAiSGVsbG8sIFdvcmxkIgo=\n            imagePassword: ${serverImagePassword.result}\n            bootOrder: AUTO\n  serverImagePassword:\n    type: random:RandomPassword\n    properties:\n      length: 16\n      special: false\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "datacenterId": {
                    "type": "string",
                    "description": "[string] Unique identifier for the resource\n"
                },
                "location": {
                    "type": "string",
                    "description": "Location of the data center.\n"
                },
                "maxReplicaCount": {
                    "type": "integer",
                    "description": "[int] The maximum value for the number of replicas on a VM Auto Scaling Group. Must be \u003e= 0 and \u003c= 200. Will be enforced for both automatic and manual changes.\n"
                },
                "minReplicaCount": {
                    "type": "integer",
                    "description": "[int] The minimum value for the number of replicas on a VM Auto Scaling Group. Must be \u003e= 0 and \u003c= 200. Will be enforced for both automatic and manual changes.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] User-defined name for the Autoscaling Group.\n"
                },
                "policy": {
                    "$ref": "#/types/ionoscloud:autoscaling/GroupPolicy:GroupPolicy",
                    "description": "[List] Specifies the behavior of this Autoscaling Group. A policy consists of Triggers and Actions, whereby an Action is some kind of automated behavior, and a Trigger is defined by the circumstances under which the Action is triggered. Currently, two separate Actions, namely Scaling In and Out are supported, triggered through Thresholds defined on a given Metric.\n"
                },
                "replicaConfiguration": {
                    "$ref": "#/types/ionoscloud:autoscaling/GroupReplicaConfiguration:GroupReplicaConfiguration",
                    "description": "[List]\n"
                }
            },
            "required": [
                "datacenterId",
                "location",
                "maxReplicaCount",
                "minReplicaCount",
                "name",
                "policy",
                "replicaConfiguration"
            ],
            "inputProperties": {
                "datacenterId": {
                    "type": "string",
                    "description": "[string] Unique identifier for the resource\n"
                },
                "maxReplicaCount": {
                    "type": "integer",
                    "description": "[int] The maximum value for the number of replicas on a VM Auto Scaling Group. Must be \u003e= 0 and \u003c= 200. Will be enforced for both automatic and manual changes.\n"
                },
                "minReplicaCount": {
                    "type": "integer",
                    "description": "[int] The minimum value for the number of replicas on a VM Auto Scaling Group. Must be \u003e= 0 and \u003c= 200. Will be enforced for both automatic and manual changes.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] User-defined name for the Autoscaling Group.\n"
                },
                "policy": {
                    "$ref": "#/types/ionoscloud:autoscaling/GroupPolicy:GroupPolicy",
                    "description": "[List] Specifies the behavior of this Autoscaling Group. A policy consists of Triggers and Actions, whereby an Action is some kind of automated behavior, and a Trigger is defined by the circumstances under which the Action is triggered. Currently, two separate Actions, namely Scaling In and Out are supported, triggered through Thresholds defined on a given Metric.\n"
                },
                "replicaConfiguration": {
                    "$ref": "#/types/ionoscloud:autoscaling/GroupReplicaConfiguration:GroupReplicaConfiguration",
                    "description": "[List]\n"
                }
            },
            "requiredInputs": [
                "datacenterId",
                "maxReplicaCount",
                "minReplicaCount",
                "policy",
                "replicaConfiguration"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Group resources.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "[string] Unique identifier for the resource\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "Location of the data center.\n"
                    },
                    "maxReplicaCount": {
                        "type": "integer",
                        "description": "[int] The maximum value for the number of replicas on a VM Auto Scaling Group. Must be \u003e= 0 and \u003c= 200. Will be enforced for both automatic and manual changes.\n"
                    },
                    "minReplicaCount": {
                        "type": "integer",
                        "description": "[int] The minimum value for the number of replicas on a VM Auto Scaling Group. Must be \u003e= 0 and \u003c= 200. Will be enforced for both automatic and manual changes.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] User-defined name for the Autoscaling Group.\n"
                    },
                    "policy": {
                        "$ref": "#/types/ionoscloud:autoscaling/GroupPolicy:GroupPolicy",
                        "description": "[List] Specifies the behavior of this Autoscaling Group. A policy consists of Triggers and Actions, whereby an Action is some kind of automated behavior, and a Trigger is defined by the circumstances under which the Action is triggered. Currently, two separate Actions, namely Scaling In and Out are supported, triggered through Thresholds defined on a given Metric.\n"
                    },
                    "replicaConfiguration": {
                        "$ref": "#/types/ionoscloud:autoscaling/GroupReplicaConfiguration:GroupReplicaConfiguration",
                        "description": "[List]\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:cdn/distribution:Distribution": {
            "description": "Manages a **CDN Distribution** on IonosCloud.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as fs from \"fs\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\n//optionally you can add a certificate to the distribution\nconst cert = new ionoscloud.cert.Certificate(\"cert\", {\n    certificate: fs.readFileSync(\"path_to_cert\", \"utf8\"),\n    certificateChain: fs.readFileSync(\"path_to_cert_chain\", \"utf8\"),\n    privateKey: fs.readFileSync(\"path_to_private_key\", \"utf8\"),\n});\nconst example = new ionoscloud.cdn.Distribution(\"example\", {\n    domain: \"example.com\",\n    certificateId: cert.id,\n    routingRules: [\n        {\n            scheme: \"https\",\n            prefix: \"/api\",\n            upstream: {\n                host: \"server.example.com\",\n                caching: true,\n                waf: true,\n                sniMode: \"distribution\",\n                rateLimitClass: \"R500\",\n                geoRestrictions: {\n                    allowLists: [\n                        \"CN\",\n                        \"RU\",\n                    ],\n                },\n            },\n        },\n        {\n            scheme: \"http/https\",\n            prefix: \"/api2\",\n            upstream: {\n                host: \"server2.example.com\",\n                caching: false,\n                waf: false,\n                sniMode: \"origin\",\n                rateLimitClass: \"R10\",\n                geoRestrictions: {\n                    blockLists: [\n                        \"CN\",\n                        \"RU\",\n                    ],\n                },\n            },\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\n#optionally you can add a certificate to the distribution\ncert = ionoscloud.cert.Certificate(\"cert\",\n    certificate=(lambda path: open(path).read())(\"path_to_cert\"),\n    certificate_chain=(lambda path: open(path).read())(\"path_to_cert_chain\"),\n    private_key=(lambda path: open(path).read())(\"path_to_private_key\"))\nexample = ionoscloud.cdn.Distribution(\"example\",\n    domain=\"example.com\",\n    certificate_id=cert.id,\n    routing_rules=[\n        {\n            \"scheme\": \"https\",\n            \"prefix\": \"/api\",\n            \"upstream\": {\n                \"host\": \"server.example.com\",\n                \"caching\": True,\n                \"waf\": True,\n                \"sni_mode\": \"distribution\",\n                \"rate_limit_class\": \"R500\",\n                \"geo_restrictions\": {\n                    \"allow_lists\": [\n                        \"CN\",\n                        \"RU\",\n                    ],\n                },\n            },\n        },\n        {\n            \"scheme\": \"http/https\",\n            \"prefix\": \"/api2\",\n            \"upstream\": {\n                \"host\": \"server2.example.com\",\n                \"caching\": False,\n                \"waf\": False,\n                \"sni_mode\": \"origin\",\n                \"rate_limit_class\": \"R10\",\n                \"geo_restrictions\": {\n                    \"block_lists\": [\n                        \"CN\",\n                        \"RU\",\n                    ],\n                },\n            },\n        },\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    //optionally you can add a certificate to the distribution\n    var cert = new Ionoscloud.Cert.Certificate(\"cert\", new()\n    {\n        Certificate = File.ReadAllText(\"path_to_cert\"),\n        CertificateChain = File.ReadAllText(\"path_to_cert_chain\"),\n        PrivateKey = File.ReadAllText(\"path_to_private_key\"),\n    });\n\n    var example = new Ionoscloud.Cdn.Distribution(\"example\", new()\n    {\n        Domain = \"example.com\",\n        CertificateId = cert.Id,\n        RoutingRules = new[]\n        {\n            new Ionoscloud.Cdn.Inputs.DistributionRoutingRuleArgs\n            {\n                Scheme = \"https\",\n                Prefix = \"/api\",\n                Upstream = new Ionoscloud.Cdn.Inputs.DistributionRoutingRuleUpstreamArgs\n                {\n                    Host = \"server.example.com\",\n                    Caching = true,\n                    Waf = true,\n                    SniMode = \"distribution\",\n                    RateLimitClass = \"R500\",\n                    GeoRestrictions = new Ionoscloud.Cdn.Inputs.DistributionRoutingRuleUpstreamGeoRestrictionsArgs\n                    {\n                        AllowLists = new[]\n                        {\n                            \"CN\",\n                            \"RU\",\n                        },\n                    },\n                },\n            },\n            new Ionoscloud.Cdn.Inputs.DistributionRoutingRuleArgs\n            {\n                Scheme = \"http/https\",\n                Prefix = \"/api2\",\n                Upstream = new Ionoscloud.Cdn.Inputs.DistributionRoutingRuleUpstreamArgs\n                {\n                    Host = \"server2.example.com\",\n                    Caching = false,\n                    Waf = false,\n                    SniMode = \"origin\",\n                    RateLimitClass = \"R10\",\n                    GeoRestrictions = new Ionoscloud.Cdn.Inputs.DistributionRoutingRuleUpstreamGeoRestrictionsArgs\n                    {\n                        BlockLists = new[]\n                        {\n                            \"CN\",\n                            \"RU\",\n                        },\n                    },\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"os\"\n\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/cdn\"\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/cert\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := os.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// optionally you can add a certificate to the distribution\n\t\tcert, err := cert.NewCertificate(ctx, \"cert\", \u0026cert.CertificateArgs{\n\t\t\tCertificate:      pulumi.String(readFileOrPanic(\"path_to_cert\")),\n\t\t\tCertificateChain: pulumi.String(readFileOrPanic(\"path_to_cert_chain\")),\n\t\t\tPrivateKey:       pulumi.String(readFileOrPanic(\"path_to_private_key\")),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cdn.NewDistribution(ctx, \"example\", \u0026cdn.DistributionArgs{\n\t\t\tDomain:        pulumi.String(\"example.com\"),\n\t\t\tCertificateId: cert.ID(),\n\t\t\tRoutingRules: cdn.DistributionRoutingRuleArray{\n\t\t\t\t\u0026cdn.DistributionRoutingRuleArgs{\n\t\t\t\t\tScheme: pulumi.String(\"https\"),\n\t\t\t\t\tPrefix: pulumi.String(\"/api\"),\n\t\t\t\t\tUpstream: \u0026cdn.DistributionRoutingRuleUpstreamArgs{\n\t\t\t\t\t\tHost:           pulumi.String(\"server.example.com\"),\n\t\t\t\t\t\tCaching:        pulumi.Bool(true),\n\t\t\t\t\t\tWaf:            pulumi.Bool(true),\n\t\t\t\t\t\tSniMode:        pulumi.String(\"distribution\"),\n\t\t\t\t\t\tRateLimitClass: pulumi.String(\"R500\"),\n\t\t\t\t\t\tGeoRestrictions: \u0026cdn.DistributionRoutingRuleUpstreamGeoRestrictionsArgs{\n\t\t\t\t\t\t\tAllowLists: pulumi.StringArray{\n\t\t\t\t\t\t\t\tpulumi.String(\"CN\"),\n\t\t\t\t\t\t\t\tpulumi.String(\"RU\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026cdn.DistributionRoutingRuleArgs{\n\t\t\t\t\tScheme: pulumi.String(\"http/https\"),\n\t\t\t\t\tPrefix: pulumi.String(\"/api2\"),\n\t\t\t\t\tUpstream: \u0026cdn.DistributionRoutingRuleUpstreamArgs{\n\t\t\t\t\t\tHost:           pulumi.String(\"server2.example.com\"),\n\t\t\t\t\t\tCaching:        pulumi.Bool(false),\n\t\t\t\t\t\tWaf:            pulumi.Bool(false),\n\t\t\t\t\t\tSniMode:        pulumi.String(\"origin\"),\n\t\t\t\t\t\tRateLimitClass: pulumi.String(\"R10\"),\n\t\t\t\t\t\tGeoRestrictions: \u0026cdn.DistributionRoutingRuleUpstreamGeoRestrictionsArgs{\n\t\t\t\t\t\t\tBlockLists: pulumi.StringArray{\n\t\t\t\t\t\t\t\tpulumi.String(\"CN\"),\n\t\t\t\t\t\t\t\tpulumi.String(\"RU\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.cert.Certificate;\nimport com.pulumi.ionoscloud.cert.CertificateArgs;\nimport com.pulumi.ionoscloud.cdn.Distribution;\nimport com.pulumi.ionoscloud.cdn.DistributionArgs;\nimport com.pulumi.ionoscloud.cdn.inputs.DistributionRoutingRuleArgs;\nimport com.pulumi.ionoscloud.cdn.inputs.DistributionRoutingRuleUpstreamArgs;\nimport com.pulumi.ionoscloud.cdn.inputs.DistributionRoutingRuleUpstreamGeoRestrictionsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        //optionally you can add a certificate to the distribution\n        var cert = new Certificate(\"cert\", CertificateArgs.builder()\n            .certificate(Files.readString(Paths.get(\"path_to_cert\")))\n            .certificateChain(Files.readString(Paths.get(\"path_to_cert_chain\")))\n            .privateKey(Files.readString(Paths.get(\"path_to_private_key\")))\n            .build());\n\n        var example = new Distribution(\"example\", DistributionArgs.builder()\n            .domain(\"example.com\")\n            .certificateId(cert.id())\n            .routingRules(            \n                DistributionRoutingRuleArgs.builder()\n                    .scheme(\"https\")\n                    .prefix(\"/api\")\n                    .upstream(DistributionRoutingRuleUpstreamArgs.builder()\n                        .host(\"server.example.com\")\n                        .caching(true)\n                        .waf(true)\n                        .sniMode(\"distribution\")\n                        .rateLimitClass(\"R500\")\n                        .geoRestrictions(DistributionRoutingRuleUpstreamGeoRestrictionsArgs.builder()\n                            .allowLists(                            \n                                \"CN\",\n                                \"RU\")\n                            .build())\n                        .build())\n                    .build(),\n                DistributionRoutingRuleArgs.builder()\n                    .scheme(\"http/https\")\n                    .prefix(\"/api2\")\n                    .upstream(DistributionRoutingRuleUpstreamArgs.builder()\n                        .host(\"server2.example.com\")\n                        .caching(false)\n                        .waf(false)\n                        .sniMode(\"origin\")\n                        .rateLimitClass(\"R10\")\n                        .geoRestrictions(DistributionRoutingRuleUpstreamGeoRestrictionsArgs.builder()\n                            .blockLists(                            \n                                \"CN\",\n                                \"RU\")\n                            .build())\n                        .build())\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: ionoscloud:cdn:Distribution\n    properties:\n      domain: example.com\n      certificateId: ${cert.id}\n      routingRules:\n        - scheme: https\n          prefix: /api\n          upstream:\n            host: server.example.com\n            caching: true\n            waf: true\n            sniMode: distribution\n            rateLimitClass: R500\n            geoRestrictions:\n              allowLists:\n                - CN\n                - RU\n        - scheme: http/https\n          prefix: /api2\n          upstream:\n            host: server2.example.com\n            caching: false\n            waf: false\n            sniMode: origin\n            rateLimitClass: R10\n            geoRestrictions:\n              blockLists:\n                - CN\n                - RU\n  #optionally you can add a certificate to the distribution\n  cert:\n    type: ionoscloud:cert:Certificate\n    properties:\n      certificate:\n        fn::readFile: path_to_cert\n      certificateChain:\n        fn::readFile: path_to_cert_chain\n      privateKey:\n        fn::readFile: path_to_private_key\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nResource Distribution can be imported using the `resource id`, e.g.\n\n```sh\n$ pulumi import ionoscloud:cdn/distribution:Distribution myDistribution {distribution uuid}\n```\n\n",
            "properties": {
                "certificateId": {
                    "type": "string",
                    "description": "[string] The ID of the certificate to use for the distribution. You can create certificates with the certificate resource.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "[string] The domain of the distribution.\n"
                },
                "publicEndpointV4": {
                    "type": "string",
                    "description": "IP of the distribution, it has to be included on the domain DNS Zone as A record.\n"
                },
                "publicEndpointV6": {
                    "type": "string",
                    "description": "IP of the distribution, it has to be included on the domain DNS Zone as AAAA record.\n"
                },
                "resourceUrn": {
                    "type": "string",
                    "description": "Unique resource indentifier.\n"
                },
                "routingRules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:cdn/DistributionRoutingRule:DistributionRoutingRule"
                    },
                    "description": "[list] The routing rules for the distribution.\n"
                }
            },
            "required": [
                "domain",
                "publicEndpointV4",
                "publicEndpointV6",
                "resourceUrn",
                "routingRules"
            ],
            "inputProperties": {
                "certificateId": {
                    "type": "string",
                    "description": "[string] The ID of the certificate to use for the distribution. You can create certificates with the certificate resource.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "[string] The domain of the distribution.\n"
                },
                "routingRules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:cdn/DistributionRoutingRule:DistributionRoutingRule"
                    },
                    "description": "[list] The routing rules for the distribution.\n"
                }
            },
            "requiredInputs": [
                "domain",
                "routingRules"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Distribution resources.\n",
                "properties": {
                    "certificateId": {
                        "type": "string",
                        "description": "[string] The ID of the certificate to use for the distribution. You can create certificates with the certificate resource.\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "[string] The domain of the distribution.\n"
                    },
                    "publicEndpointV4": {
                        "type": "string",
                        "description": "IP of the distribution, it has to be included on the domain DNS Zone as A record.\n"
                    },
                    "publicEndpointV6": {
                        "type": "string",
                        "description": "IP of the distribution, it has to be included on the domain DNS Zone as AAAA record.\n"
                    },
                    "resourceUrn": {
                        "type": "string",
                        "description": "Unique resource indentifier.\n"
                    },
                    "routingRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:cdn/DistributionRoutingRule:DistributionRoutingRule"
                        },
                        "description": "[list] The routing rules for the distribution.\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:cert/autoCertificate:AutoCertificate": {
            "properties": {
                "commonName": {
                    "type": "string",
                    "description": "The common name (DNS) of the certificate to issue. The common name needs to be part of a zone in IONOS Cloud DNS\n"
                },
                "keyAlgorithm": {
                    "type": "string",
                    "description": "The key algorithm used to generate the certificate\n"
                },
                "lastIssuedCertificateId": {
                    "type": "string",
                    "description": "The ID of the last certificate that was issued\n"
                },
                "location": {
                    "type": "string",
                    "description": "The location of the auto-certificate\n"
                },
                "name": {
                    "type": "string",
                    "description": "A certificate name used for management purposes\n"
                },
                "providerId": {
                    "type": "string",
                    "description": "The certificate provider used to issue the certificates\n"
                },
                "subjectAlternativeNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Optional additional names to be added to the issued certificate. The additional names needs to be part of a zone in\nIONOS Cloud DNS\n"
                }
            },
            "required": [
                "commonName",
                "keyAlgorithm",
                "lastIssuedCertificateId",
                "location",
                "name",
                "providerId"
            ],
            "inputProperties": {
                "commonName": {
                    "type": "string",
                    "description": "The common name (DNS) of the certificate to issue. The common name needs to be part of a zone in IONOS Cloud DNS\n",
                    "willReplaceOnChanges": true
                },
                "keyAlgorithm": {
                    "type": "string",
                    "description": "The key algorithm used to generate the certificate\n",
                    "willReplaceOnChanges": true
                },
                "location": {
                    "type": "string",
                    "description": "The location of the auto-certificate\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "A certificate name used for management purposes\n"
                },
                "providerId": {
                    "type": "string",
                    "description": "The certificate provider used to issue the certificates\n",
                    "willReplaceOnChanges": true
                },
                "subjectAlternativeNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Optional additional names to be added to the issued certificate. The additional names needs to be part of a zone in\nIONOS Cloud DNS\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "commonName",
                "keyAlgorithm",
                "location",
                "providerId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AutoCertificate resources.\n",
                "properties": {
                    "commonName": {
                        "type": "string",
                        "description": "The common name (DNS) of the certificate to issue. The common name needs to be part of a zone in IONOS Cloud DNS\n",
                        "willReplaceOnChanges": true
                    },
                    "keyAlgorithm": {
                        "type": "string",
                        "description": "The key algorithm used to generate the certificate\n",
                        "willReplaceOnChanges": true
                    },
                    "lastIssuedCertificateId": {
                        "type": "string",
                        "description": "The ID of the last certificate that was issued\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "The location of the auto-certificate\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "A certificate name used for management purposes\n"
                    },
                    "providerId": {
                        "type": "string",
                        "description": "The certificate provider used to issue the certificates\n",
                        "willReplaceOnChanges": true
                    },
                    "subjectAlternativeNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Optional additional names to be added to the issued certificate. The additional names needs to be part of a zone in\nIONOS Cloud DNS\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:cert/autoCertificateProvider:AutoCertificateProvider": {
            "properties": {
                "email": {
                    "type": "string",
                    "description": "The email address of the certificate requester\n"
                },
                "externalAccountBinding": {
                    "$ref": "#/types/ionoscloud:cert/AutoCertificateProviderExternalAccountBinding:AutoCertificateProviderExternalAccountBinding"
                },
                "location": {
                    "type": "string",
                    "description": "The location of the certificate provider\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the certificate provider\n"
                },
                "server": {
                    "type": "string",
                    "description": "The URL of the certificate provider\n"
                }
            },
            "required": [
                "email",
                "location",
                "name",
                "server"
            ],
            "inputProperties": {
                "email": {
                    "type": "string",
                    "description": "The email address of the certificate requester\n",
                    "willReplaceOnChanges": true
                },
                "externalAccountBinding": {
                    "$ref": "#/types/ionoscloud:cert/AutoCertificateProviderExternalAccountBinding:AutoCertificateProviderExternalAccountBinding",
                    "willReplaceOnChanges": true
                },
                "location": {
                    "type": "string",
                    "description": "The location of the certificate provider\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name of the certificate provider\n"
                },
                "server": {
                    "type": "string",
                    "description": "The URL of the certificate provider\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "email",
                "location",
                "server"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AutoCertificateProvider resources.\n",
                "properties": {
                    "email": {
                        "type": "string",
                        "description": "The email address of the certificate requester\n",
                        "willReplaceOnChanges": true
                    },
                    "externalAccountBinding": {
                        "$ref": "#/types/ionoscloud:cert/AutoCertificateProviderExternalAccountBinding:AutoCertificateProviderExternalAccountBinding",
                        "willReplaceOnChanges": true
                    },
                    "location": {
                        "type": "string",
                        "description": "The location of the certificate provider\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the certificate provider\n"
                    },
                    "server": {
                        "type": "string",
                        "description": "The URL of the certificate provider\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:cert/certificate:Certificate": {
            "description": "Manages a **Certificate** on IonosCloud.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as fs from \"fs\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst cert = new ionoscloud.cert.Certificate(\"cert\", {\n    certificate: fs.readFileSync(\"path_to_cert\", \"utf8\"),\n    certificateChain: fs.readFileSync(\"path_to_cert_chain\", \"utf8\"),\n    privateKey: fs.readFileSync(\"path_to_private_key\", \"utf8\"),\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\ncert = ionoscloud.cert.Certificate(\"cert\",\n    certificate=(lambda path: open(path).read())(\"path_to_cert\"),\n    certificate_chain=(lambda path: open(path).read())(\"path_to_cert_chain\"),\n    private_key=(lambda path: open(path).read())(\"path_to_private_key\"))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var cert = new Ionoscloud.Cert.Certificate(\"cert\", new()\n    {\n        Certificate = File.ReadAllText(\"path_to_cert\"),\n        CertificateChain = File.ReadAllText(\"path_to_cert_chain\"),\n        PrivateKey = File.ReadAllText(\"path_to_private_key\"),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"os\"\n\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/cert\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := os.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cert.NewCertificate(ctx, \"cert\", \u0026cert.CertificateArgs{\n\t\t\tCertificate:      pulumi.String(readFileOrPanic(\"path_to_cert\")),\n\t\t\tCertificateChain: pulumi.String(readFileOrPanic(\"path_to_cert_chain\")),\n\t\t\tPrivateKey:       pulumi.String(readFileOrPanic(\"path_to_private_key\")),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.cert.Certificate;\nimport com.pulumi.ionoscloud.cert.CertificateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var cert = new Certificate(\"cert\", CertificateArgs.builder()\n            .certificate(Files.readString(Paths.get(\"path_to_cert\")))\n            .certificateChain(Files.readString(Paths.get(\"path_to_cert_chain\")))\n            .privateKey(Files.readString(Paths.get(\"path_to_private_key\")))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  cert:\n    type: ionoscloud:cert:Certificate\n    properties:\n      certificate:\n        fn::readFile: path_to_cert\n      certificateChain:\n        fn::readFile: path_to_cert_chain\n      privateKey:\n        fn::readFile: path_to_private_key\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n**NOTE**: You can also provide the values as multiline strings, as seen below:\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as fs from \"fs\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst cert = new ionoscloud.cert.Certificate(\"cert\", {\n    certificate: `-----BEGIN CERTIFICATE-----\ncert_body_here\n-----END CERTIFICATE-----\n\n`,\n    certificateChain: fs.readFileSync(\"path_to_cert_chain\", \"utf8\"),\n    privateKey: fs.readFileSync(\"path_to_private_key\", \"utf8\"),\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\ncert = ionoscloud.cert.Certificate(\"cert\",\n    certificate=\"\"\"-----BEGIN CERTIFICATE-----\ncert_body_here\n-----END CERTIFICATE-----\n\n\"\"\",\n    certificate_chain=(lambda path: open(path).read())(\"path_to_cert_chain\"),\n    private_key=(lambda path: open(path).read())(\"path_to_private_key\"))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var cert = new Ionoscloud.Cert.Certificate(\"cert\", new()\n    {\n        Certificate = @\"-----BEGIN CERTIFICATE-----\ncert_body_here\n-----END CERTIFICATE-----\n\n\",\n        CertificateChain = File.ReadAllText(\"path_to_cert_chain\"),\n        PrivateKey = File.ReadAllText(\"path_to_private_key\"),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"os\"\n\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/cert\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := os.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cert.NewCertificate(ctx, \"cert\", \u0026cert.CertificateArgs{\n\t\t\tCertificate:      pulumi.String(\"-----BEGIN CERTIFICATE-----\\ncert_body_here\\n-----END CERTIFICATE-----\\n\\n\"),\n\t\t\tCertificateChain: pulumi.String(readFileOrPanic(\"path_to_cert_chain\")),\n\t\t\tPrivateKey:       pulumi.String(readFileOrPanic(\"path_to_private_key\")),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.cert.Certificate;\nimport com.pulumi.ionoscloud.cert.CertificateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var cert = new Certificate(\"cert\", CertificateArgs.builder()\n            .certificate(\"\"\"\n-----BEGIN CERTIFICATE-----\ncert_body_here\n-----END CERTIFICATE-----\n\n            \"\"\")\n            .certificateChain(Files.readString(Paths.get(\"path_to_cert_chain\")))\n            .privateKey(Files.readString(Paths.get(\"path_to_private_key\")))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  cert:\n    type: ionoscloud:cert:Certificate\n    properties:\n      certificate: |+\n        -----BEGIN CERTIFICATE-----\n        cert_body_here\n        -----END CERTIFICATE-----\n\n      certificateChain:\n        fn::readFile: path_to_cert_chain\n      privateKey:\n        fn::readFile: path_to_private_key\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nResource certificate can be imported using the `resource id`, e.g.\n\n```sh\n$ pulumi import ionoscloud:cert/certificate:Certificate mycert {certificate uuid}\n```\n\n",
            "properties": {
                "certificate": {
                    "type": "string",
                    "description": "[string] The certificate body. Pem encoded. Immutable.\n"
                },
                "certificateChain": {
                    "type": "string",
                    "description": "[string] The certificate chain. Pem encoded. Immutable.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The certificate name\n"
                },
                "privateKey": {
                    "type": "string",
                    "description": "[string] The certificate private key. Immutable. Sensitive.\n",
                    "secret": true
                }
            },
            "required": [
                "certificate",
                "name",
                "privateKey"
            ],
            "inputProperties": {
                "certificate": {
                    "type": "string",
                    "description": "[string] The certificate body. Pem encoded. Immutable.\n"
                },
                "certificateChain": {
                    "type": "string",
                    "description": "[string] The certificate chain. Pem encoded. Immutable.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The certificate name\n"
                },
                "privateKey": {
                    "type": "string",
                    "description": "[string] The certificate private key. Immutable. Sensitive.\n",
                    "secret": true
                }
            },
            "requiredInputs": [
                "certificate",
                "privateKey"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Certificate resources.\n",
                "properties": {
                    "certificate": {
                        "type": "string",
                        "description": "[string] The certificate body. Pem encoded. Immutable.\n"
                    },
                    "certificateChain": {
                        "type": "string",
                        "description": "[string] The certificate chain. Pem encoded. Immutable.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] The certificate name\n"
                    },
                    "privateKey": {
                        "type": "string",
                        "description": "[string] The certificate private key. Immutable. Sensitive.\n",
                        "secret": true
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:compute/backupUnit:BackupUnit": {
            "description": "\n\n## Import\n\nA Backup Unit resource can be imported using its `resource id`, e.g.\n\n```sh\n$ pulumi import ionoscloud:compute/backupUnit:BackupUnit demo {backup_unit_uuid}\n```\n\nThis can be helpful when you want to import backup units which you have already created manually or using other means, outside of terraform. Please note that you need to manually specify the password when first declaring the resource in terraform, as there is no way to retrieve the password from the Cloud API.\n\n",
            "properties": {
                "email": {
                    "type": "string",
                    "description": "[string] The email address assigned to the backup unit\n"
                },
                "login": {
                    "type": "string",
                    "description": "The login associated with the backup unit. Derived from the contract number\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the Backup Unit. This argument is immutable.\n"
                },
                "password": {
                    "type": "string",
                    "description": "[string] The desired password for the Backup Unit\n",
                    "secret": true
                }
            },
            "required": [
                "email",
                "login",
                "name",
                "password"
            ],
            "inputProperties": {
                "email": {
                    "type": "string",
                    "description": "[string] The email address assigned to the backup unit\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the Backup Unit. This argument is immutable.\n"
                },
                "password": {
                    "type": "string",
                    "description": "[string] The desired password for the Backup Unit\n",
                    "secret": true
                }
            },
            "requiredInputs": [
                "email",
                "password"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering BackupUnit resources.\n",
                "properties": {
                    "email": {
                        "type": "string",
                        "description": "[string] The email address assigned to the backup unit\n"
                    },
                    "login": {
                        "type": "string",
                        "description": "The login associated with the backup unit. Derived from the contract number\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] The name of the Backup Unit. This argument is immutable.\n"
                    },
                    "password": {
                        "type": "string",
                        "description": "[string] The desired password for the Backup Unit\n",
                        "secret": true
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:compute/balancer:Balancer": {
            "description": "Manages a Load Balancer on IonosCloud.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\nimport * as random from \"@pulumi/random\";\n\nconst exampleDatacenter = new ionoscloud.compute.Datacenter(\"exampleDatacenter\", {\n    location: \"us/las\",\n    description: \"Datacenter Description\",\n    secAuthProtection: false,\n});\nconst exampleLan = new ionoscloud.compute.Lan(\"exampleLan\", {\n    datacenterId: exampleDatacenter.id,\n    \"public\": true,\n});\nconst serverImagePassword = new random.RandomPassword(\"serverImagePassword\", {\n    length: 16,\n    special: false,\n});\nconst exampleServer = new ionoscloud.compute.Server(\"exampleServer\", {\n    datacenterId: exampleDatacenter.id,\n    cores: 1,\n    ram: 1024,\n    availabilityZone: \"ZONE_1\",\n    cpuFamily: \"INTEL_XEON\",\n    imageName: \"Ubuntu-20.04\",\n    imagePassword: serverImagePassword.result,\n    volume: {\n        name: \"system\",\n        size: 14,\n        diskType: \"SSD\",\n    },\n    nic: {\n        lan: 1,\n        dhcp: true,\n        firewallActive: true,\n    },\n});\nconst exampleBalancer = new ionoscloud.compute.Balancer(\"exampleBalancer\", {\n    datacenterId: exampleDatacenter.id,\n    nicIds: [exampleServer.primaryNic],\n    dhcp: true,\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\nimport pulumi_random as random\n\nexample_datacenter = ionoscloud.compute.Datacenter(\"exampleDatacenter\",\n    location=\"us/las\",\n    description=\"Datacenter Description\",\n    sec_auth_protection=False)\nexample_lan = ionoscloud.compute.Lan(\"exampleLan\",\n    datacenter_id=example_datacenter.id,\n    public=True)\nserver_image_password = random.RandomPassword(\"serverImagePassword\",\n    length=16,\n    special=False)\nexample_server = ionoscloud.compute.Server(\"exampleServer\",\n    datacenter_id=example_datacenter.id,\n    cores=1,\n    ram=1024,\n    availability_zone=\"ZONE_1\",\n    cpu_family=\"INTEL_XEON\",\n    image_name=\"Ubuntu-20.04\",\n    image_password=server_image_password.result,\n    volume={\n        \"name\": \"system\",\n        \"size\": 14,\n        \"disk_type\": \"SSD\",\n    },\n    nic={\n        \"lan\": 1,\n        \"dhcp\": True,\n        \"firewall_active\": True,\n    })\nexample_balancer = ionoscloud.compute.Balancer(\"exampleBalancer\",\n    datacenter_id=example_datacenter.id,\n    nic_ids=[example_server.primary_nic],\n    dhcp=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\nusing Random = Pulumi.Random;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleDatacenter = new Ionoscloud.Compute.Datacenter(\"exampleDatacenter\", new()\n    {\n        Location = \"us/las\",\n        Description = \"Datacenter Description\",\n        SecAuthProtection = false,\n    });\n\n    var exampleLan = new Ionoscloud.Compute.Lan(\"exampleLan\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        Public = true,\n    });\n\n    var serverImagePassword = new Random.RandomPassword(\"serverImagePassword\", new()\n    {\n        Length = 16,\n        Special = false,\n    });\n\n    var exampleServer = new Ionoscloud.Compute.Server(\"exampleServer\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        Cores = 1,\n        Ram = 1024,\n        AvailabilityZone = \"ZONE_1\",\n        CpuFamily = \"INTEL_XEON\",\n        ImageName = \"Ubuntu-20.04\",\n        ImagePassword = serverImagePassword.Result,\n        Volume = new Ionoscloud.Compute.Inputs.ServerVolumeArgs\n        {\n            Name = \"system\",\n            Size = 14,\n            DiskType = \"SSD\",\n        },\n        Nic = new Ionoscloud.Compute.Inputs.ServerNicArgs\n        {\n            Lan = 1,\n            Dhcp = true,\n            FirewallActive = true,\n        },\n    });\n\n    var exampleBalancer = new Ionoscloud.Compute.Balancer(\"exampleBalancer\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        NicIds = new[]\n        {\n            exampleServer.PrimaryNic,\n        },\n        Dhcp = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi-random/sdk/v4/go/random\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleDatacenter, err := compute.NewDatacenter(ctx, \"exampleDatacenter\", \u0026compute.DatacenterArgs{\n\t\t\tLocation:          pulumi.String(\"us/las\"),\n\t\t\tDescription:       pulumi.String(\"Datacenter Description\"),\n\t\t\tSecAuthProtection: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = compute.NewLan(ctx, \"exampleLan\", \u0026compute.LanArgs{\n\t\t\tDatacenterId: exampleDatacenter.ID(),\n\t\t\tPublic:       pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tserverImagePassword, err := random.NewRandomPassword(ctx, \"serverImagePassword\", \u0026random.RandomPasswordArgs{\n\t\t\tLength:  pulumi.Int(16),\n\t\t\tSpecial: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleServer, err := compute.NewServer(ctx, \"exampleServer\", \u0026compute.ServerArgs{\n\t\t\tDatacenterId:     exampleDatacenter.ID(),\n\t\t\tCores:            pulumi.Int(1),\n\t\t\tRam:              pulumi.Int(1024),\n\t\t\tAvailabilityZone: pulumi.String(\"ZONE_1\"),\n\t\t\tCpuFamily:        pulumi.String(\"INTEL_XEON\"),\n\t\t\tImageName:        pulumi.String(\"Ubuntu-20.04\"),\n\t\t\tImagePassword:    serverImagePassword.Result,\n\t\t\tVolume: \u0026compute.ServerVolumeArgs{\n\t\t\t\tName:     pulumi.String(\"system\"),\n\t\t\t\tSize:     pulumi.Int(14),\n\t\t\t\tDiskType: pulumi.String(\"SSD\"),\n\t\t\t},\n\t\t\tNic: \u0026compute.ServerNicArgs{\n\t\t\t\tLan:            pulumi.Int(1),\n\t\t\t\tDhcp:           pulumi.Bool(true),\n\t\t\t\tFirewallActive: pulumi.Bool(true),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = compute.NewBalancer(ctx, \"exampleBalancer\", \u0026compute.BalancerArgs{\n\t\t\tDatacenterId: exampleDatacenter.ID(),\n\t\t\tNicIds: pulumi.StringArray{\n\t\t\t\texampleServer.PrimaryNic,\n\t\t\t},\n\t\t\tDhcp: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.Datacenter;\nimport com.pulumi.ionoscloud.compute.DatacenterArgs;\nimport com.pulumi.ionoscloud.compute.Lan;\nimport com.pulumi.ionoscloud.compute.LanArgs;\nimport com.pulumi.random.RandomPassword;\nimport com.pulumi.random.RandomPasswordArgs;\nimport com.pulumi.ionoscloud.compute.Server;\nimport com.pulumi.ionoscloud.compute.ServerArgs;\nimport com.pulumi.ionoscloud.compute.inputs.ServerVolumeArgs;\nimport com.pulumi.ionoscloud.compute.inputs.ServerNicArgs;\nimport com.pulumi.ionoscloud.compute.Balancer;\nimport com.pulumi.ionoscloud.compute.BalancerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleDatacenter = new Datacenter(\"exampleDatacenter\", DatacenterArgs.builder()\n            .location(\"us/las\")\n            .description(\"Datacenter Description\")\n            .secAuthProtection(false)\n            .build());\n\n        var exampleLan = new Lan(\"exampleLan\", LanArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .public_(true)\n            .build());\n\n        var serverImagePassword = new RandomPassword(\"serverImagePassword\", RandomPasswordArgs.builder()\n            .length(16)\n            .special(false)\n            .build());\n\n        var exampleServer = new Server(\"exampleServer\", ServerArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .cores(1)\n            .ram(1024)\n            .availabilityZone(\"ZONE_1\")\n            .cpuFamily(\"INTEL_XEON\")\n            .imageName(\"Ubuntu-20.04\")\n            .imagePassword(serverImagePassword.result())\n            .volume(ServerVolumeArgs.builder()\n                .name(\"system\")\n                .size(14)\n                .diskType(\"SSD\")\n                .build())\n            .nic(ServerNicArgs.builder()\n                .lan(\"1\")\n                .dhcp(true)\n                .firewallActive(true)\n                .build())\n            .build());\n\n        var exampleBalancer = new Balancer(\"exampleBalancer\", BalancerArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .nicIds(exampleServer.primaryNic())\n            .dhcp(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleDatacenter:\n    type: ionoscloud:compute:Datacenter\n    properties:\n      location: us/las\n      description: Datacenter Description\n      secAuthProtection: false\n  exampleLan:\n    type: ionoscloud:compute:Lan\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      public: true\n  exampleServer:\n    type: ionoscloud:compute:Server\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      cores: 1\n      ram: 1024\n      availabilityZone: ZONE_1\n      cpuFamily: INTEL_XEON\n      imageName: Ubuntu-20.04\n      imagePassword: ${serverImagePassword.result}\n      volume:\n        name: system\n        size: 14\n        diskType: SSD\n      nic:\n        lan: '1'\n        dhcp: true\n        firewallActive: true\n  exampleBalancer:\n    type: ionoscloud:compute:Balancer\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      nicIds:\n        - ${exampleServer.primaryNic}\n      dhcp: true\n  serverImagePassword:\n    type: random:RandomPassword\n    properties:\n      length: 16\n      special: false\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## A note on nics\n\nWhen declaring NIC resources to be used with the load balancer, please make sure\nyou use the \"lifecycle meta-argument\" to make sure changes to the lan attribute\nof the nic are ignored. \n\nPlease see the Nic resource's documentation for an example on how to do that.\n\n## Import\n\nResource Load Balancer can be imported using the `resource id`, e.g.\n\n```sh\n$ pulumi import ionoscloud:compute/balancer:Balancer myloadbalancer {datacenter uuid}/{loadbalancer uuid}\n```\n\n",
            "properties": {
                "datacenterId": {
                    "type": "string",
                    "description": "[string] The ID of a Virtual Data Center.\n"
                },
                "dhcp": {
                    "type": "boolean",
                    "description": "[Boolean] Indicates if the load balancer will reserve an IP using DHCP.\n"
                },
                "ip": {
                    "type": "string",
                    "description": "[string] IPv4 address of the load balancer.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the load balancer.\n"
                },
                "nicIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] A list of NIC IDs that are part of the load balancer.\n"
                }
            },
            "required": [
                "datacenterId",
                "ip",
                "name",
                "nicIds"
            ],
            "inputProperties": {
                "datacenterId": {
                    "type": "string",
                    "description": "[string] The ID of a Virtual Data Center.\n",
                    "willReplaceOnChanges": true
                },
                "dhcp": {
                    "type": "boolean",
                    "description": "[Boolean] Indicates if the load balancer will reserve an IP using DHCP.\n"
                },
                "ip": {
                    "type": "string",
                    "description": "[string] IPv4 address of the load balancer.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the load balancer.\n"
                },
                "nicIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] A list of NIC IDs that are part of the load balancer.\n"
                }
            },
            "requiredInputs": [
                "datacenterId",
                "nicIds"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Balancer resources.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "[string] The ID of a Virtual Data Center.\n",
                        "willReplaceOnChanges": true
                    },
                    "dhcp": {
                        "type": "boolean",
                        "description": "[Boolean] Indicates if the load balancer will reserve an IP using DHCP.\n"
                    },
                    "ip": {
                        "type": "string",
                        "description": "[string] IPv4 address of the load balancer.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] The name of the load balancer.\n"
                    },
                    "nicIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "[list] A list of NIC IDs that are part of the load balancer.\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:compute/bootDeviceSelection:BootDeviceSelection": {
            "description": "Manages the selection of a boot device for IonosCloud Servers. \n\n## Example Usage\n\nThe boot device of a `ionoscloud.compute.Server`, `ionoscloud.compute.VCPUServer` or `ionoscloud.compute.CubeServer` can be selected with this resource.\nDeleting this resource will revert the boot device back to the default volume, which is the first inline volume created together with the server.\nThis resource also allows switching between a `volume` and a `ionoscloud.compute.getImage` CDROM. Note that CDROM images are detached after they are no longer set as boot devices.\n\n### Select an external volume\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst exampleServer = new ionoscloud.compute.Server(\"exampleServer\", {\n    availabilityZone: \"ZONE_2\",\n    imageName: \"ubuntu:latest\",\n    cores: 2,\n    ram: 2048,\n    imagePassword: random_password.server_image_password.result,\n    datacenterId: ionoscloud_datacenter.example.id,\n    volume: {\n        name: \"Inline Updated\",\n        size: 20,\n        diskType: \"SSD Standard\",\n        bus: \"VIRTIO\",\n        availabilityZone: \"AUTO\",\n    },\n    nic: {\n        lan: ionoscloud_lan.example.id,\n        name: \"Nic Example\",\n        dhcp: true,\n        firewallActive: true,\n    },\n});\nconst exampleVolume = new ionoscloud.compute.Volume(\"exampleVolume\", {\n    serverId: exampleServer.id,\n    datacenterId: ionoscloud_datacenter.example.id,\n    size: 10,\n    diskType: \"HDD\",\n    availabilityZone: \"AUTO\",\n    imageName: \"debian:latest\",\n    imagePassword: random_password.server_image_password.result,\n});\nconst exampleBootDeviceSelection = new ionoscloud.compute.BootDeviceSelection(\"exampleBootDeviceSelection\", {\n    datacenterId: ionoscloud_datacenter.example.id,\n    serverId: exampleServer.id,\n    bootDeviceId: exampleVolume.id,\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\nexample_server = ionoscloud.compute.Server(\"exampleServer\",\n    availability_zone=\"ZONE_2\",\n    image_name=\"ubuntu:latest\",\n    cores=2,\n    ram=2048,\n    image_password=random_password[\"server_image_password\"][\"result\"],\n    datacenter_id=ionoscloud_datacenter[\"example\"][\"id\"],\n    volume={\n        \"name\": \"Inline Updated\",\n        \"size\": 20,\n        \"disk_type\": \"SSD Standard\",\n        \"bus\": \"VIRTIO\",\n        \"availability_zone\": \"AUTO\",\n    },\n    nic={\n        \"lan\": ionoscloud_lan[\"example\"][\"id\"],\n        \"name\": \"Nic Example\",\n        \"dhcp\": True,\n        \"firewall_active\": True,\n    })\nexample_volume = ionoscloud.compute.Volume(\"exampleVolume\",\n    server_id=example_server.id,\n    datacenter_id=ionoscloud_datacenter[\"example\"][\"id\"],\n    size=10,\n    disk_type=\"HDD\",\n    availability_zone=\"AUTO\",\n    image_name=\"debian:latest\",\n    image_password=random_password[\"server_image_password\"][\"result\"])\nexample_boot_device_selection = ionoscloud.compute.BootDeviceSelection(\"exampleBootDeviceSelection\",\n    datacenter_id=ionoscloud_datacenter[\"example\"][\"id\"],\n    server_id=example_server.id,\n    boot_device_id=example_volume.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleServer = new Ionoscloud.Compute.Server(\"exampleServer\", new()\n    {\n        AvailabilityZone = \"ZONE_2\",\n        ImageName = \"ubuntu:latest\",\n        Cores = 2,\n        Ram = 2048,\n        ImagePassword = random_password.Server_image_password.Result,\n        DatacenterId = ionoscloud_datacenter.Example.Id,\n        Volume = new Ionoscloud.Compute.Inputs.ServerVolumeArgs\n        {\n            Name = \"Inline Updated\",\n            Size = 20,\n            DiskType = \"SSD Standard\",\n            Bus = \"VIRTIO\",\n            AvailabilityZone = \"AUTO\",\n        },\n        Nic = new Ionoscloud.Compute.Inputs.ServerNicArgs\n        {\n            Lan = ionoscloud_lan.Example.Id,\n            Name = \"Nic Example\",\n            Dhcp = true,\n            FirewallActive = true,\n        },\n    });\n\n    var exampleVolume = new Ionoscloud.Compute.Volume(\"exampleVolume\", new()\n    {\n        ServerId = exampleServer.Id,\n        DatacenterId = ionoscloud_datacenter.Example.Id,\n        Size = 10,\n        DiskType = \"HDD\",\n        AvailabilityZone = \"AUTO\",\n        ImageName = \"debian:latest\",\n        ImagePassword = random_password.Server_image_password.Result,\n    });\n\n    var exampleBootDeviceSelection = new Ionoscloud.Compute.BootDeviceSelection(\"exampleBootDeviceSelection\", new()\n    {\n        DatacenterId = ionoscloud_datacenter.Example.Id,\n        ServerId = exampleServer.Id,\n        BootDeviceId = exampleVolume.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleServer, err := compute.NewServer(ctx, \"exampleServer\", \u0026compute.ServerArgs{\n\t\t\tAvailabilityZone: pulumi.String(\"ZONE_2\"),\n\t\t\tImageName:        pulumi.String(\"ubuntu:latest\"),\n\t\t\tCores:            pulumi.Int(2),\n\t\t\tRam:              pulumi.Int(2048),\n\t\t\tImagePassword:    pulumi.Any(random_password.Server_image_password.Result),\n\t\t\tDatacenterId:     pulumi.Any(ionoscloud_datacenter.Example.Id),\n\t\t\tVolume: \u0026compute.ServerVolumeArgs{\n\t\t\t\tName:             pulumi.String(\"Inline Updated\"),\n\t\t\t\tSize:             pulumi.Int(20),\n\t\t\t\tDiskType:         pulumi.String(\"SSD Standard\"),\n\t\t\t\tBus:              pulumi.String(\"VIRTIO\"),\n\t\t\t\tAvailabilityZone: pulumi.String(\"AUTO\"),\n\t\t\t},\n\t\t\tNic: \u0026compute.ServerNicArgs{\n\t\t\t\tLan:            pulumi.Any(ionoscloud_lan.Example.Id),\n\t\t\t\tName:           pulumi.String(\"Nic Example\"),\n\t\t\t\tDhcp:           pulumi.Bool(true),\n\t\t\t\tFirewallActive: pulumi.Bool(true),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleVolume, err := compute.NewVolume(ctx, \"exampleVolume\", \u0026compute.VolumeArgs{\n\t\t\tServerId:         exampleServer.ID(),\n\t\t\tDatacenterId:     pulumi.Any(ionoscloud_datacenter.Example.Id),\n\t\t\tSize:             pulumi.Int(10),\n\t\t\tDiskType:         pulumi.String(\"HDD\"),\n\t\t\tAvailabilityZone: pulumi.String(\"AUTO\"),\n\t\t\tImageName:        pulumi.String(\"debian:latest\"),\n\t\t\tImagePassword:    pulumi.Any(random_password.Server_image_password.Result),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = compute.NewBootDeviceSelection(ctx, \"exampleBootDeviceSelection\", \u0026compute.BootDeviceSelectionArgs{\n\t\t\tDatacenterId: pulumi.Any(ionoscloud_datacenter.Example.Id),\n\t\t\tServerId:     exampleServer.ID(),\n\t\t\tBootDeviceId: exampleVolume.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.Server;\nimport com.pulumi.ionoscloud.compute.ServerArgs;\nimport com.pulumi.ionoscloud.compute.inputs.ServerVolumeArgs;\nimport com.pulumi.ionoscloud.compute.inputs.ServerNicArgs;\nimport com.pulumi.ionoscloud.compute.Volume;\nimport com.pulumi.ionoscloud.compute.VolumeArgs;\nimport com.pulumi.ionoscloud.compute.BootDeviceSelection;\nimport com.pulumi.ionoscloud.compute.BootDeviceSelectionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleServer = new Server(\"exampleServer\", ServerArgs.builder()\n            .availabilityZone(\"ZONE_2\")\n            .imageName(\"ubuntu:latest\")\n            .cores(2)\n            .ram(2048)\n            .imagePassword(random_password.server_image_password().result())\n            .datacenterId(ionoscloud_datacenter.example().id())\n            .volume(ServerVolumeArgs.builder()\n                .name(\"Inline Updated\")\n                .size(20)\n                .diskType(\"SSD Standard\")\n                .bus(\"VIRTIO\")\n                .availabilityZone(\"AUTO\")\n                .build())\n            .nic(ServerNicArgs.builder()\n                .lan(ionoscloud_lan.example().id())\n                .name(\"Nic Example\")\n                .dhcp(true)\n                .firewallActive(true)\n                .build())\n            .build());\n\n        var exampleVolume = new Volume(\"exampleVolume\", VolumeArgs.builder()\n            .serverId(exampleServer.id())\n            .datacenterId(ionoscloud_datacenter.example().id())\n            .size(10)\n            .diskType(\"HDD\")\n            .availabilityZone(\"AUTO\")\n            .imageName(\"debian:latest\")\n            .imagePassword(random_password.server_image_password().result())\n            .build());\n\n        var exampleBootDeviceSelection = new BootDeviceSelection(\"exampleBootDeviceSelection\", BootDeviceSelectionArgs.builder()\n            .datacenterId(ionoscloud_datacenter.example().id())\n            .serverId(exampleServer.id())\n            .bootDeviceId(exampleVolume.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleBootDeviceSelection:\n    type: ionoscloud:compute:BootDeviceSelection\n    properties:\n      datacenterId: ${ionoscloud_datacenter.example.id}\n      serverId: ${exampleServer.id}\n      bootDeviceId: ${exampleVolume.id}\n  exampleServer:\n    type: ionoscloud:compute:Server\n    properties:\n      availabilityZone: ZONE_2\n      imageName: ubuntu:latest\n      cores: 2\n      ram: 2048\n      imagePassword: ${random_password.server_image_password.result}\n      datacenterId: ${ionoscloud_datacenter.example.id}\n      volume:\n        name: Inline Updated\n        size: 20\n        diskType: SSD Standard\n        bus: VIRTIO\n        availabilityZone: AUTO\n      nic:\n        lan: ${ionoscloud_lan.example.id}\n        name: Nic Example\n        dhcp: true\n        firewallActive: true\n  exampleVolume:\n    type: ionoscloud:compute:Volume\n    properties:\n      serverId: ${exampleServer.id}\n      datacenterId: ${ionoscloud_datacenter.example.id}\n      size: 10\n      diskType: HDD\n      availabilityZone: AUTO\n      imageName: debian:latest\n      imagePassword: ${random_password.server_image_password.result}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Select an inline volume again\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst exampleServer = new ionoscloud.compute.Server(\"exampleServer\", {\n    availabilityZone: \"ZONE_2\",\n    imageName: \"ubuntu:latest\",\n    cores: 2,\n    ram: 2048,\n    imagePassword: random_password.server_image_password.result,\n    datacenterId: ionoscloud_datacenter.example.id,\n    volume: {\n        name: \"Inline Updated\",\n        size: 20,\n        diskType: \"SSD Standard\",\n        bus: \"VIRTIO\",\n        availabilityZone: \"AUTO\",\n    },\n    nic: {\n        lan: ionoscloud_lan.example.id,\n        name: \"Nic Example\",\n        dhcp: true,\n        firewallActive: true,\n    },\n});\nconst exampleBootDeviceSelection = new ionoscloud.compute.BootDeviceSelection(\"exampleBootDeviceSelection\", {\n    datacenterId: ionoscloud_datacenter.example.id,\n    serverId: exampleServer.id,\n    bootDeviceId: exampleServer.inlineVolumeIds[0],\n});\nconst exampleVolume = new ionoscloud.compute.Volume(\"exampleVolume\", {\n    serverId: exampleServer.id,\n    datacenterId: ionoscloud_datacenter.example.id,\n    size: 10,\n    diskType: \"HDD\",\n    availabilityZone: \"AUTO\",\n    imageName: \"debian:latest\",\n    imagePassword: random_password.server_image_password.result,\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\nexample_server = ionoscloud.compute.Server(\"exampleServer\",\n    availability_zone=\"ZONE_2\",\n    image_name=\"ubuntu:latest\",\n    cores=2,\n    ram=2048,\n    image_password=random_password[\"server_image_password\"][\"result\"],\n    datacenter_id=ionoscloud_datacenter[\"example\"][\"id\"],\n    volume={\n        \"name\": \"Inline Updated\",\n        \"size\": 20,\n        \"disk_type\": \"SSD Standard\",\n        \"bus\": \"VIRTIO\",\n        \"availability_zone\": \"AUTO\",\n    },\n    nic={\n        \"lan\": ionoscloud_lan[\"example\"][\"id\"],\n        \"name\": \"Nic Example\",\n        \"dhcp\": True,\n        \"firewall_active\": True,\n    })\nexample_boot_device_selection = ionoscloud.compute.BootDeviceSelection(\"exampleBootDeviceSelection\",\n    datacenter_id=ionoscloud_datacenter[\"example\"][\"id\"],\n    server_id=example_server.id,\n    boot_device_id=example_server.inline_volume_ids[0])\nexample_volume = ionoscloud.compute.Volume(\"exampleVolume\",\n    server_id=example_server.id,\n    datacenter_id=ionoscloud_datacenter[\"example\"][\"id\"],\n    size=10,\n    disk_type=\"HDD\",\n    availability_zone=\"AUTO\",\n    image_name=\"debian:latest\",\n    image_password=random_password[\"server_image_password\"][\"result\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleServer = new Ionoscloud.Compute.Server(\"exampleServer\", new()\n    {\n        AvailabilityZone = \"ZONE_2\",\n        ImageName = \"ubuntu:latest\",\n        Cores = 2,\n        Ram = 2048,\n        ImagePassword = random_password.Server_image_password.Result,\n        DatacenterId = ionoscloud_datacenter.Example.Id,\n        Volume = new Ionoscloud.Compute.Inputs.ServerVolumeArgs\n        {\n            Name = \"Inline Updated\",\n            Size = 20,\n            DiskType = \"SSD Standard\",\n            Bus = \"VIRTIO\",\n            AvailabilityZone = \"AUTO\",\n        },\n        Nic = new Ionoscloud.Compute.Inputs.ServerNicArgs\n        {\n            Lan = ionoscloud_lan.Example.Id,\n            Name = \"Nic Example\",\n            Dhcp = true,\n            FirewallActive = true,\n        },\n    });\n\n    var exampleBootDeviceSelection = new Ionoscloud.Compute.BootDeviceSelection(\"exampleBootDeviceSelection\", new()\n    {\n        DatacenterId = ionoscloud_datacenter.Example.Id,\n        ServerId = exampleServer.Id,\n        BootDeviceId = exampleServer.InlineVolumeIds.Apply(inlineVolumeIds =\u003e inlineVolumeIds[0]),\n    });\n\n    var exampleVolume = new Ionoscloud.Compute.Volume(\"exampleVolume\", new()\n    {\n        ServerId = exampleServer.Id,\n        DatacenterId = ionoscloud_datacenter.Example.Id,\n        Size = 10,\n        DiskType = \"HDD\",\n        AvailabilityZone = \"AUTO\",\n        ImageName = \"debian:latest\",\n        ImagePassword = random_password.Server_image_password.Result,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleServer, err := compute.NewServer(ctx, \"exampleServer\", \u0026compute.ServerArgs{\n\t\t\tAvailabilityZone: pulumi.String(\"ZONE_2\"),\n\t\t\tImageName:        pulumi.String(\"ubuntu:latest\"),\n\t\t\tCores:            pulumi.Int(2),\n\t\t\tRam:              pulumi.Int(2048),\n\t\t\tImagePassword:    pulumi.Any(random_password.Server_image_password.Result),\n\t\t\tDatacenterId:     pulumi.Any(ionoscloud_datacenter.Example.Id),\n\t\t\tVolume: \u0026compute.ServerVolumeArgs{\n\t\t\t\tName:             pulumi.String(\"Inline Updated\"),\n\t\t\t\tSize:             pulumi.Int(20),\n\t\t\t\tDiskType:         pulumi.String(\"SSD Standard\"),\n\t\t\t\tBus:              pulumi.String(\"VIRTIO\"),\n\t\t\t\tAvailabilityZone: pulumi.String(\"AUTO\"),\n\t\t\t},\n\t\t\tNic: \u0026compute.ServerNicArgs{\n\t\t\t\tLan:            pulumi.Any(ionoscloud_lan.Example.Id),\n\t\t\t\tName:           pulumi.String(\"Nic Example\"),\n\t\t\t\tDhcp:           pulumi.Bool(true),\n\t\t\t\tFirewallActive: pulumi.Bool(true),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = compute.NewBootDeviceSelection(ctx, \"exampleBootDeviceSelection\", \u0026compute.BootDeviceSelectionArgs{\n\t\t\tDatacenterId: pulumi.Any(ionoscloud_datacenter.Example.Id),\n\t\t\tServerId:     exampleServer.ID(),\n\t\t\tBootDeviceId: exampleServer.InlineVolumeIds.ApplyT(func(inlineVolumeIds []string) (string, error) {\n\t\t\t\treturn inlineVolumeIds[0], nil\n\t\t\t}).(pulumi.StringOutput),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = compute.NewVolume(ctx, \"exampleVolume\", \u0026compute.VolumeArgs{\n\t\t\tServerId:         exampleServer.ID(),\n\t\t\tDatacenterId:     pulumi.Any(ionoscloud_datacenter.Example.Id),\n\t\t\tSize:             pulumi.Int(10),\n\t\t\tDiskType:         pulumi.String(\"HDD\"),\n\t\t\tAvailabilityZone: pulumi.String(\"AUTO\"),\n\t\t\tImageName:        pulumi.String(\"debian:latest\"),\n\t\t\tImagePassword:    pulumi.Any(random_password.Server_image_password.Result),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.Server;\nimport com.pulumi.ionoscloud.compute.ServerArgs;\nimport com.pulumi.ionoscloud.compute.inputs.ServerVolumeArgs;\nimport com.pulumi.ionoscloud.compute.inputs.ServerNicArgs;\nimport com.pulumi.ionoscloud.compute.BootDeviceSelection;\nimport com.pulumi.ionoscloud.compute.BootDeviceSelectionArgs;\nimport com.pulumi.ionoscloud.compute.Volume;\nimport com.pulumi.ionoscloud.compute.VolumeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleServer = new Server(\"exampleServer\", ServerArgs.builder()\n            .availabilityZone(\"ZONE_2\")\n            .imageName(\"ubuntu:latest\")\n            .cores(2)\n            .ram(2048)\n            .imagePassword(random_password.server_image_password().result())\n            .datacenterId(ionoscloud_datacenter.example().id())\n            .volume(ServerVolumeArgs.builder()\n                .name(\"Inline Updated\")\n                .size(20)\n                .diskType(\"SSD Standard\")\n                .bus(\"VIRTIO\")\n                .availabilityZone(\"AUTO\")\n                .build())\n            .nic(ServerNicArgs.builder()\n                .lan(ionoscloud_lan.example().id())\n                .name(\"Nic Example\")\n                .dhcp(true)\n                .firewallActive(true)\n                .build())\n            .build());\n\n        var exampleBootDeviceSelection = new BootDeviceSelection(\"exampleBootDeviceSelection\", BootDeviceSelectionArgs.builder()\n            .datacenterId(ionoscloud_datacenter.example().id())\n            .serverId(exampleServer.id())\n            .bootDeviceId(exampleServer.inlineVolumeIds().applyValue(inlineVolumeIds -\u003e inlineVolumeIds[0]))\n            .build());\n\n        var exampleVolume = new Volume(\"exampleVolume\", VolumeArgs.builder()\n            .serverId(exampleServer.id())\n            .datacenterId(ionoscloud_datacenter.example().id())\n            .size(10)\n            .diskType(\"HDD\")\n            .availabilityZone(\"AUTO\")\n            .imageName(\"debian:latest\")\n            .imagePassword(random_password.server_image_password().result())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleBootDeviceSelection:\n    type: ionoscloud:compute:BootDeviceSelection\n    properties:\n      datacenterId: ${ionoscloud_datacenter.example.id}\n      serverId: ${exampleServer.id}\n      bootDeviceId: ${exampleServer.inlineVolumeIds[0]}\n  exampleServer:\n    type: ionoscloud:compute:Server\n    properties:\n      availabilityZone: ZONE_2\n      imageName: ubuntu:latest\n      cores: 2\n      ram: 2048\n      imagePassword: ${random_password.server_image_password.result}\n      datacenterId: ${ionoscloud_datacenter.example.id}\n      volume:\n        name: Inline Updated\n        size: 20\n        diskType: SSD Standard\n        bus: VIRTIO\n        availabilityZone: AUTO\n      nic:\n        lan: ${ionoscloud_lan.example.id}\n        name: Nic Example\n        dhcp: true\n        firewallActive: true\n  exampleVolume:\n    type: ionoscloud:compute:Volume\n    properties:\n      serverId: ${exampleServer.id}\n      datacenterId: ${ionoscloud_datacenter.example.id}\n      size: 10\n      diskType: HDD\n      availabilityZone: AUTO\n      imageName: debian:latest\n      imagePassword: ${random_password.server_image_password.result}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Select a CDROM image\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst exampleServer = new ionoscloud.compute.Server(\"exampleServer\", {\n    availabilityZone: \"ZONE_2\",\n    imageName: \"ubuntu:latest\",\n    cores: 2,\n    ram: 2048,\n    imagePassword: random_password.server_image_password.result,\n    datacenterId: ionoscloud_datacenter.example.id,\n    volume: {\n        name: \"Inline Updated\",\n        size: 20,\n        diskType: \"SSD Standard\",\n        bus: \"VIRTIO\",\n        availabilityZone: \"AUTO\",\n    },\n    nic: {\n        lan: ionoscloud_lan.example.id,\n        name: \"Nic Example\",\n        dhcp: true,\n        firewallActive: true,\n    },\n});\nconst exampleImage = ionoscloud.compute.getImage({\n    name: \"ubuntu-20.04\",\n    location: \"de/txl\",\n    type: \"CDROM\",\n});\nconst exampleBootDeviceSelection = new ionoscloud.compute.BootDeviceSelection(\"exampleBootDeviceSelection\", {\n    datacenterId: ionoscloud_datacenter.example.id,\n    serverId: exampleServer.inlineVolumeIds[0],\n    bootDeviceId: exampleImage.then(exampleImage =\u003e exampleImage.id),\n});\nconst exampleVolume = new ionoscloud.compute.Volume(\"exampleVolume\", {\n    serverId: exampleServer.id,\n    datacenterId: ionoscloud_datacenter.example.id,\n    size: 10,\n    diskType: \"HDD\",\n    availabilityZone: \"AUTO\",\n    imageName: \"debian:latest\",\n    imagePassword: random_password.server_image_password.result,\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\nimport pulumi_ionoscloud as ionoscloud\n\nexample_server = ionoscloud.compute.Server(\"exampleServer\",\n    availability_zone=\"ZONE_2\",\n    image_name=\"ubuntu:latest\",\n    cores=2,\n    ram=2048,\n    image_password=random_password[\"server_image_password\"][\"result\"],\n    datacenter_id=ionoscloud_datacenter[\"example\"][\"id\"],\n    volume={\n        \"name\": \"Inline Updated\",\n        \"size\": 20,\n        \"disk_type\": \"SSD Standard\",\n        \"bus\": \"VIRTIO\",\n        \"availability_zone\": \"AUTO\",\n    },\n    nic={\n        \"lan\": ionoscloud_lan[\"example\"][\"id\"],\n        \"name\": \"Nic Example\",\n        \"dhcp\": True,\n        \"firewall_active\": True,\n    })\nexample_image = ionoscloud.compute.get_image(name=\"ubuntu-20.04\",\n    location=\"de/txl\",\n    type=\"CDROM\")\nexample_boot_device_selection = ionoscloud.compute.BootDeviceSelection(\"exampleBootDeviceSelection\",\n    datacenter_id=ionoscloud_datacenter[\"example\"][\"id\"],\n    server_id=example_server.inline_volume_ids[0],\n    boot_device_id=example_image.id)\nexample_volume = ionoscloud.compute.Volume(\"exampleVolume\",\n    server_id=example_server.id,\n    datacenter_id=ionoscloud_datacenter[\"example\"][\"id\"],\n    size=10,\n    disk_type=\"HDD\",\n    availability_zone=\"AUTO\",\n    image_name=\"debian:latest\",\n    image_password=random_password[\"server_image_password\"][\"result\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleServer = new Ionoscloud.Compute.Server(\"exampleServer\", new()\n    {\n        AvailabilityZone = \"ZONE_2\",\n        ImageName = \"ubuntu:latest\",\n        Cores = 2,\n        Ram = 2048,\n        ImagePassword = random_password.Server_image_password.Result,\n        DatacenterId = ionoscloud_datacenter.Example.Id,\n        Volume = new Ionoscloud.Compute.Inputs.ServerVolumeArgs\n        {\n            Name = \"Inline Updated\",\n            Size = 20,\n            DiskType = \"SSD Standard\",\n            Bus = \"VIRTIO\",\n            AvailabilityZone = \"AUTO\",\n        },\n        Nic = new Ionoscloud.Compute.Inputs.ServerNicArgs\n        {\n            Lan = ionoscloud_lan.Example.Id,\n            Name = \"Nic Example\",\n            Dhcp = true,\n            FirewallActive = true,\n        },\n    });\n\n    var exampleImage = Ionoscloud.Compute.GetImage.Invoke(new()\n    {\n        Name = \"ubuntu-20.04\",\n        Location = \"de/txl\",\n        Type = \"CDROM\",\n    });\n\n    var exampleBootDeviceSelection = new Ionoscloud.Compute.BootDeviceSelection(\"exampleBootDeviceSelection\", new()\n    {\n        DatacenterId = ionoscloud_datacenter.Example.Id,\n        ServerId = exampleServer.InlineVolumeIds.Apply(inlineVolumeIds =\u003e inlineVolumeIds[0]),\n        BootDeviceId = exampleImage.Apply(getImageResult =\u003e getImageResult.Id),\n    });\n\n    var exampleVolume = new Ionoscloud.Compute.Volume(\"exampleVolume\", new()\n    {\n        ServerId = exampleServer.Id,\n        DatacenterId = ionoscloud_datacenter.Example.Id,\n        Size = 10,\n        DiskType = \"HDD\",\n        AvailabilityZone = \"AUTO\",\n        ImageName = \"debian:latest\",\n        ImagePassword = random_password.Server_image_password.Result,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleServer, err := compute.NewServer(ctx, \"exampleServer\", \u0026compute.ServerArgs{\n\t\t\tAvailabilityZone: pulumi.String(\"ZONE_2\"),\n\t\t\tImageName:        pulumi.String(\"ubuntu:latest\"),\n\t\t\tCores:            pulumi.Int(2),\n\t\t\tRam:              pulumi.Int(2048),\n\t\t\tImagePassword:    pulumi.Any(random_password.Server_image_password.Result),\n\t\t\tDatacenterId:     pulumi.Any(ionoscloud_datacenter.Example.Id),\n\t\t\tVolume: \u0026compute.ServerVolumeArgs{\n\t\t\t\tName:             pulumi.String(\"Inline Updated\"),\n\t\t\t\tSize:             pulumi.Int(20),\n\t\t\t\tDiskType:         pulumi.String(\"SSD Standard\"),\n\t\t\t\tBus:              pulumi.String(\"VIRTIO\"),\n\t\t\t\tAvailabilityZone: pulumi.String(\"AUTO\"),\n\t\t\t},\n\t\t\tNic: \u0026compute.ServerNicArgs{\n\t\t\t\tLan:            pulumi.Any(ionoscloud_lan.Example.Id),\n\t\t\t\tName:           pulumi.String(\"Nic Example\"),\n\t\t\t\tDhcp:           pulumi.Bool(true),\n\t\t\t\tFirewallActive: pulumi.Bool(true),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleImage, err := compute.GetImage(ctx, \u0026compute.GetImageArgs{\n\t\t\tName:     pulumi.StringRef(\"ubuntu-20.04\"),\n\t\t\tLocation: pulumi.StringRef(\"de/txl\"),\n\t\t\tType:     pulumi.StringRef(\"CDROM\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = compute.NewBootDeviceSelection(ctx, \"exampleBootDeviceSelection\", \u0026compute.BootDeviceSelectionArgs{\n\t\t\tDatacenterId: pulumi.Any(ionoscloud_datacenter.Example.Id),\n\t\t\tServerId: exampleServer.InlineVolumeIds.ApplyT(func(inlineVolumeIds []string) (string, error) {\n\t\t\t\treturn inlineVolumeIds[0], nil\n\t\t\t}).(pulumi.StringOutput),\n\t\t\tBootDeviceId: pulumi.String(exampleImage.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = compute.NewVolume(ctx, \"exampleVolume\", \u0026compute.VolumeArgs{\n\t\t\tServerId:         exampleServer.ID(),\n\t\t\tDatacenterId:     pulumi.Any(ionoscloud_datacenter.Example.Id),\n\t\t\tSize:             pulumi.Int(10),\n\t\t\tDiskType:         pulumi.String(\"HDD\"),\n\t\t\tAvailabilityZone: pulumi.String(\"AUTO\"),\n\t\t\tImageName:        pulumi.String(\"debian:latest\"),\n\t\t\tImagePassword:    pulumi.Any(random_password.Server_image_password.Result),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.Server;\nimport com.pulumi.ionoscloud.compute.ServerArgs;\nimport com.pulumi.ionoscloud.compute.inputs.ServerVolumeArgs;\nimport com.pulumi.ionoscloud.compute.inputs.ServerNicArgs;\nimport com.pulumi.ionoscloud.compute.ComputeFunctions;\nimport com.pulumi.ionoscloud.compute.inputs.GetImageArgs;\nimport com.pulumi.ionoscloud.compute.BootDeviceSelection;\nimport com.pulumi.ionoscloud.compute.BootDeviceSelectionArgs;\nimport com.pulumi.ionoscloud.compute.Volume;\nimport com.pulumi.ionoscloud.compute.VolumeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleServer = new Server(\"exampleServer\", ServerArgs.builder()\n            .availabilityZone(\"ZONE_2\")\n            .imageName(\"ubuntu:latest\")\n            .cores(2)\n            .ram(2048)\n            .imagePassword(random_password.server_image_password().result())\n            .datacenterId(ionoscloud_datacenter.example().id())\n            .volume(ServerVolumeArgs.builder()\n                .name(\"Inline Updated\")\n                .size(20)\n                .diskType(\"SSD Standard\")\n                .bus(\"VIRTIO\")\n                .availabilityZone(\"AUTO\")\n                .build())\n            .nic(ServerNicArgs.builder()\n                .lan(ionoscloud_lan.example().id())\n                .name(\"Nic Example\")\n                .dhcp(true)\n                .firewallActive(true)\n                .build())\n            .build());\n\n        final var exampleImage = ComputeFunctions.getImage(GetImageArgs.builder()\n            .name(\"ubuntu-20.04\")\n            .location(\"de/txl\")\n            .type(\"CDROM\")\n            .build());\n\n        var exampleBootDeviceSelection = new BootDeviceSelection(\"exampleBootDeviceSelection\", BootDeviceSelectionArgs.builder()\n            .datacenterId(ionoscloud_datacenter.example().id())\n            .serverId(exampleServer.inlineVolumeIds().applyValue(inlineVolumeIds -\u003e inlineVolumeIds[0]))\n            .bootDeviceId(exampleImage.applyValue(getImageResult -\u003e getImageResult.id()))\n            .build());\n\n        var exampleVolume = new Volume(\"exampleVolume\", VolumeArgs.builder()\n            .serverId(exampleServer.id())\n            .datacenterId(ionoscloud_datacenter.example().id())\n            .size(10)\n            .diskType(\"HDD\")\n            .availabilityZone(\"AUTO\")\n            .imageName(\"debian:latest\")\n            .imagePassword(random_password.server_image_password().result())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleBootDeviceSelection:\n    type: ionoscloud:compute:BootDeviceSelection\n    properties:\n      datacenterId: ${ionoscloud_datacenter.example.id}\n      serverId: ${exampleServer.inlineVolumeIds[0]}\n      bootDeviceId: ${exampleImage.id}\n  exampleServer:\n    type: ionoscloud:compute:Server\n    properties:\n      availabilityZone: ZONE_2\n      imageName: ubuntu:latest\n      cores: 2\n      ram: 2048\n      imagePassword: ${random_password.server_image_password.result}\n      datacenterId: ${ionoscloud_datacenter.example.id}\n      volume:\n        name: Inline Updated\n        size: 20\n        diskType: SSD Standard\n        bus: VIRTIO\n        availabilityZone: AUTO\n      nic:\n        lan: ${ionoscloud_lan.example.id}\n        name: Nic Example\n        dhcp: true\n        firewallActive: true\n  exampleVolume:\n    type: ionoscloud:compute:Volume\n    properties:\n      serverId: ${exampleServer.id}\n      datacenterId: ${ionoscloud_datacenter.example.id}\n      size: 10\n      diskType: HDD\n      availabilityZone: AUTO\n      imageName: debian:latest\n      imagePassword: ${random_password.server_image_password.result}\nvariables:\n  exampleImage:\n    fn::invoke:\n      function: ionoscloud:compute:getImage\n      arguments:\n        name: ubuntu-20.04\n        location: de/txl\n        type: CDROM\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Perform a network boot\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst exampleServer = new ionoscloud.compute.Server(\"exampleServer\", {\n    availabilityZone: \"ZONE_2\",\n    imageName: \"ubuntu:latest\",\n    cores: 2,\n    ram: 2048,\n    imagePassword: random_password.server_image_password.result,\n    datacenterId: ionoscloud_datacenter.example.id,\n    volume: {\n        name: \"Inline volume\",\n        size: 20,\n        diskType: \"SSD Standard\",\n        bus: \"VIRTIO\",\n        availabilityZone: \"AUTO\",\n    },\n    nic: {\n        lan: ionoscloud_lan.example.id,\n        name: \"Nic Example\",\n        dhcp: true,\n        firewallActive: true,\n    },\n});\nconst exampleBootDeviceSelection = new ionoscloud.compute.BootDeviceSelection(\"exampleBootDeviceSelection\", {\n    datacenterId: ionoscloud_datacenter.example.id,\n    serverId: exampleServer.inlineVolumeIds[0],\n});\n// boot_device_id = data.ionoscloud_image.example.id   VM will boot in the PXE shell when boot_device_id is omitted\nconst exampleVolume = new ionoscloud.compute.Volume(\"exampleVolume\", {\n    serverId: exampleServer.id,\n    datacenterId: ionoscloud_datacenter.example.id,\n    size: 10,\n    diskType: \"HDD\",\n    availabilityZone: \"AUTO\",\n    imageName: \"debian:latest\",\n    imagePassword: random_password.server_image_password.result,\n});\nconst exampleImage = ionoscloud.compute.getImage({\n    name: \"ubuntu-20.04\",\n    location: \"de/txl\",\n    type: \"CDROM\",\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\nimport pulumi_ionoscloud as ionoscloud\n\nexample_server = ionoscloud.compute.Server(\"exampleServer\",\n    availability_zone=\"ZONE_2\",\n    image_name=\"ubuntu:latest\",\n    cores=2,\n    ram=2048,\n    image_password=random_password[\"server_image_password\"][\"result\"],\n    datacenter_id=ionoscloud_datacenter[\"example\"][\"id\"],\n    volume={\n        \"name\": \"Inline volume\",\n        \"size\": 20,\n        \"disk_type\": \"SSD Standard\",\n        \"bus\": \"VIRTIO\",\n        \"availability_zone\": \"AUTO\",\n    },\n    nic={\n        \"lan\": ionoscloud_lan[\"example\"][\"id\"],\n        \"name\": \"Nic Example\",\n        \"dhcp\": True,\n        \"firewall_active\": True,\n    })\nexample_boot_device_selection = ionoscloud.compute.BootDeviceSelection(\"exampleBootDeviceSelection\",\n    datacenter_id=ionoscloud_datacenter[\"example\"][\"id\"],\n    server_id=example_server.inline_volume_ids[0])\n# boot_device_id = data.ionoscloud_image.example.id   VM will boot in the PXE shell when boot_device_id is omitted\nexample_volume = ionoscloud.compute.Volume(\"exampleVolume\",\n    server_id=example_server.id,\n    datacenter_id=ionoscloud_datacenter[\"example\"][\"id\"],\n    size=10,\n    disk_type=\"HDD\",\n    availability_zone=\"AUTO\",\n    image_name=\"debian:latest\",\n    image_password=random_password[\"server_image_password\"][\"result\"])\nexample_image = ionoscloud.compute.get_image(name=\"ubuntu-20.04\",\n    location=\"de/txl\",\n    type=\"CDROM\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleServer = new Ionoscloud.Compute.Server(\"exampleServer\", new()\n    {\n        AvailabilityZone = \"ZONE_2\",\n        ImageName = \"ubuntu:latest\",\n        Cores = 2,\n        Ram = 2048,\n        ImagePassword = random_password.Server_image_password.Result,\n        DatacenterId = ionoscloud_datacenter.Example.Id,\n        Volume = new Ionoscloud.Compute.Inputs.ServerVolumeArgs\n        {\n            Name = \"Inline volume\",\n            Size = 20,\n            DiskType = \"SSD Standard\",\n            Bus = \"VIRTIO\",\n            AvailabilityZone = \"AUTO\",\n        },\n        Nic = new Ionoscloud.Compute.Inputs.ServerNicArgs\n        {\n            Lan = ionoscloud_lan.Example.Id,\n            Name = \"Nic Example\",\n            Dhcp = true,\n            FirewallActive = true,\n        },\n    });\n\n    var exampleBootDeviceSelection = new Ionoscloud.Compute.BootDeviceSelection(\"exampleBootDeviceSelection\", new()\n    {\n        DatacenterId = ionoscloud_datacenter.Example.Id,\n        ServerId = exampleServer.InlineVolumeIds.Apply(inlineVolumeIds =\u003e inlineVolumeIds[0]),\n    });\n\n    // boot_device_id = data.ionoscloud_image.example.id   VM will boot in the PXE shell when boot_device_id is omitted\n    var exampleVolume = new Ionoscloud.Compute.Volume(\"exampleVolume\", new()\n    {\n        ServerId = exampleServer.Id,\n        DatacenterId = ionoscloud_datacenter.Example.Id,\n        Size = 10,\n        DiskType = \"HDD\",\n        AvailabilityZone = \"AUTO\",\n        ImageName = \"debian:latest\",\n        ImagePassword = random_password.Server_image_password.Result,\n    });\n\n    var exampleImage = Ionoscloud.Compute.GetImage.Invoke(new()\n    {\n        Name = \"ubuntu-20.04\",\n        Location = \"de/txl\",\n        Type = \"CDROM\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleServer, err := compute.NewServer(ctx, \"exampleServer\", \u0026compute.ServerArgs{\n\t\t\tAvailabilityZone: pulumi.String(\"ZONE_2\"),\n\t\t\tImageName:        pulumi.String(\"ubuntu:latest\"),\n\t\t\tCores:            pulumi.Int(2),\n\t\t\tRam:              pulumi.Int(2048),\n\t\t\tImagePassword:    pulumi.Any(random_password.Server_image_password.Result),\n\t\t\tDatacenterId:     pulumi.Any(ionoscloud_datacenter.Example.Id),\n\t\t\tVolume: \u0026compute.ServerVolumeArgs{\n\t\t\t\tName:             pulumi.String(\"Inline volume\"),\n\t\t\t\tSize:             pulumi.Int(20),\n\t\t\t\tDiskType:         pulumi.String(\"SSD Standard\"),\n\t\t\t\tBus:              pulumi.String(\"VIRTIO\"),\n\t\t\t\tAvailabilityZone: pulumi.String(\"AUTO\"),\n\t\t\t},\n\t\t\tNic: \u0026compute.ServerNicArgs{\n\t\t\t\tLan:            pulumi.Any(ionoscloud_lan.Example.Id),\n\t\t\t\tName:           pulumi.String(\"Nic Example\"),\n\t\t\t\tDhcp:           pulumi.Bool(true),\n\t\t\t\tFirewallActive: pulumi.Bool(true),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = compute.NewBootDeviceSelection(ctx, \"exampleBootDeviceSelection\", \u0026compute.BootDeviceSelectionArgs{\n\t\t\tDatacenterId: pulumi.Any(ionoscloud_datacenter.Example.Id),\n\t\t\tServerId: exampleServer.InlineVolumeIds.ApplyT(func(inlineVolumeIds []string) (string, error) {\n\t\t\t\treturn inlineVolumeIds[0], nil\n\t\t\t}).(pulumi.StringOutput),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = compute.NewVolume(ctx, \"exampleVolume\", \u0026compute.VolumeArgs{\n\t\t\tServerId:         exampleServer.ID(),\n\t\t\tDatacenterId:     pulumi.Any(ionoscloud_datacenter.Example.Id),\n\t\t\tSize:             pulumi.Int(10),\n\t\t\tDiskType:         pulumi.String(\"HDD\"),\n\t\t\tAvailabilityZone: pulumi.String(\"AUTO\"),\n\t\t\tImageName:        pulumi.String(\"debian:latest\"),\n\t\t\tImagePassword:    pulumi.Any(random_password.Server_image_password.Result),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = compute.GetImage(ctx, \u0026compute.GetImageArgs{\n\t\t\tName:     pulumi.StringRef(\"ubuntu-20.04\"),\n\t\t\tLocation: pulumi.StringRef(\"de/txl\"),\n\t\t\tType:     pulumi.StringRef(\"CDROM\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.Server;\nimport com.pulumi.ionoscloud.compute.ServerArgs;\nimport com.pulumi.ionoscloud.compute.inputs.ServerVolumeArgs;\nimport com.pulumi.ionoscloud.compute.inputs.ServerNicArgs;\nimport com.pulumi.ionoscloud.compute.BootDeviceSelection;\nimport com.pulumi.ionoscloud.compute.BootDeviceSelectionArgs;\nimport com.pulumi.ionoscloud.compute.Volume;\nimport com.pulumi.ionoscloud.compute.VolumeArgs;\nimport com.pulumi.ionoscloud.compute.ComputeFunctions;\nimport com.pulumi.ionoscloud.compute.inputs.GetImageArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleServer = new Server(\"exampleServer\", ServerArgs.builder()\n            .availabilityZone(\"ZONE_2\")\n            .imageName(\"ubuntu:latest\")\n            .cores(2)\n            .ram(2048)\n            .imagePassword(random_password.server_image_password().result())\n            .datacenterId(ionoscloud_datacenter.example().id())\n            .volume(ServerVolumeArgs.builder()\n                .name(\"Inline volume\")\n                .size(20)\n                .diskType(\"SSD Standard\")\n                .bus(\"VIRTIO\")\n                .availabilityZone(\"AUTO\")\n                .build())\n            .nic(ServerNicArgs.builder()\n                .lan(ionoscloud_lan.example().id())\n                .name(\"Nic Example\")\n                .dhcp(true)\n                .firewallActive(true)\n                .build())\n            .build());\n\n        var exampleBootDeviceSelection = new BootDeviceSelection(\"exampleBootDeviceSelection\", BootDeviceSelectionArgs.builder()\n            .datacenterId(ionoscloud_datacenter.example().id())\n            .serverId(exampleServer.inlineVolumeIds().applyValue(inlineVolumeIds -\u003e inlineVolumeIds[0]))\n            .build());\n\n        // boot_device_id = data.ionoscloud_image.example.id   VM will boot in the PXE shell when boot_device_id is omitted\n        var exampleVolume = new Volume(\"exampleVolume\", VolumeArgs.builder()\n            .serverId(exampleServer.id())\n            .datacenterId(ionoscloud_datacenter.example().id())\n            .size(10)\n            .diskType(\"HDD\")\n            .availabilityZone(\"AUTO\")\n            .imageName(\"debian:latest\")\n            .imagePassword(random_password.server_image_password().result())\n            .build());\n\n        final var exampleImage = ComputeFunctions.getImage(GetImageArgs.builder()\n            .name(\"ubuntu-20.04\")\n            .location(\"de/txl\")\n            .type(\"CDROM\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleBootDeviceSelection:\n    type: ionoscloud:compute:BootDeviceSelection\n    properties:\n      datacenterId: ${ionoscloud_datacenter.example.id}\n      serverId: ${exampleServer.inlineVolumeIds[0]}\n  exampleServer:\n    type: ionoscloud:compute:Server\n    properties:\n      availabilityZone: ZONE_2\n      imageName: ubuntu:latest\n      cores: 2\n      ram: 2048\n      imagePassword: ${random_password.server_image_password.result}\n      datacenterId: ${ionoscloud_datacenter.example.id}\n      volume:\n        name: Inline volume\n        size: 20\n        diskType: SSD Standard\n        bus: VIRTIO\n        availabilityZone: AUTO\n      nic:\n        lan: ${ionoscloud_lan.example.id}\n        name: Nic Example\n        dhcp: true\n        firewallActive: true\n  exampleVolume:\n    type: ionoscloud:compute:Volume\n    properties:\n      serverId: ${exampleServer.id}\n      datacenterId: ${ionoscloud_datacenter.example.id}\n      size: 10\n      diskType: HDD\n      availabilityZone: AUTO\n      imageName: debian:latest\n      imagePassword: ${random_password.server_image_password.result}\nvariables:\n  exampleImage:\n    fn::invoke:\n      function: ionoscloud:compute:getImage\n      arguments:\n        name: ubuntu-20.04\n        location: de/txl\n        type: CDROM\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "bootDeviceId": {
                    "type": "string",
                    "description": "[string] The ID of a bootable device such as a volume or an image data source. If this field is omitted from the configuration, the VM will be restarted with no primary boot device, and it will enter the PXE shell for network booting. \n***Note***: If the network booting process started by the PXE shell fails, the VM will still boot into the image of the attached storage as a fallback. This behavior imitates the \"Boot from Network\" option from [DCD](https://dcd.ionos.com/).\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "[string] The ID of a Virtual Data Center.\n"
                },
                "defaultBootVolumeId": {
                    "type": "string",
                    "description": "ID of the first attached volume of the Server, which will be the default boot volume.\n"
                },
                "serverId": {
                    "type": "string",
                    "description": "[string] The ID of a server.\n"
                }
            },
            "required": [
                "datacenterId",
                "defaultBootVolumeId",
                "serverId"
            ],
            "inputProperties": {
                "bootDeviceId": {
                    "type": "string",
                    "description": "[string] The ID of a bootable device such as a volume or an image data source. If this field is omitted from the configuration, the VM will be restarted with no primary boot device, and it will enter the PXE shell for network booting. \n***Note***: If the network booting process started by the PXE shell fails, the VM will still boot into the image of the attached storage as a fallback. This behavior imitates the \"Boot from Network\" option from [DCD](https://dcd.ionos.com/).\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "[string] The ID of a Virtual Data Center.\n",
                    "willReplaceOnChanges": true
                },
                "serverId": {
                    "type": "string",
                    "description": "[string] The ID of a server.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "datacenterId",
                "serverId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering BootDeviceSelection resources.\n",
                "properties": {
                    "bootDeviceId": {
                        "type": "string",
                        "description": "[string] The ID of a bootable device such as a volume or an image data source. If this field is omitted from the configuration, the VM will be restarted with no primary boot device, and it will enter the PXE shell for network booting. \n***Note***: If the network booting process started by the PXE shell fails, the VM will still boot into the image of the attached storage as a fallback. This behavior imitates the \"Boot from Network\" option from [DCD](https://dcd.ionos.com/).\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "[string] The ID of a Virtual Data Center.\n",
                        "willReplaceOnChanges": true
                    },
                    "defaultBootVolumeId": {
                        "type": "string",
                        "description": "ID of the first attached volume of the Server, which will be the default boot volume.\n"
                    },
                    "serverId": {
                        "type": "string",
                        "description": "[string] The ID of a server.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:compute/crossconnect:Crossconnect": {
            "description": "Manages a **Cross Connect** on IonosCloud.\nCross Connect allows you to connect virtual data centers (VDC) with each other using a private LAN. \nThe VDCs to be connected need to belong to the same IONOS Cloud contract and location. \nYou can only use private LANs for a Cross Connect connection. A LAN can only be a part of one Cross Connect.\n\nThe IP addresses of the NICs used for the Cross Connect connection may not be used in more than one NIC and they need to belong to the same IP range.\n\n## Example Usage\n\nTo connect two datacenters we need 2 lans defined, one in each datacenter. After, we reference the cross-connect through which we want the connection to be established.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst crossConnectTestResource = new ionoscloud.compute.Crossconnect(\"crossConnectTestResource\", {description: \"CrossConnectTestResource\"});\nconst dc1 = new ionoscloud.compute.Datacenter(\"dc1\", {location: \"de/txl\"});\nconst dc2 = new ionoscloud.compute.Datacenter(\"dc2\", {location: \"de/txl\"});\nconst dc1lan = new ionoscloud.compute.Lan(\"dc1lan\", {\n    datacenterId: dc1.id,\n    \"public\": false,\n    pcc: crossConnectTestResource.id,\n});\nconst dc2lan = new ionoscloud.compute.Lan(\"dc2lan\", {\n    datacenterId: dc2.id,\n    \"public\": false,\n    pcc: crossConnectTestResource.id,\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\ncross_connect_test_resource = ionoscloud.compute.Crossconnect(\"crossConnectTestResource\", description=\"CrossConnectTestResource\")\ndc1 = ionoscloud.compute.Datacenter(\"dc1\", location=\"de/txl\")\ndc2 = ionoscloud.compute.Datacenter(\"dc2\", location=\"de/txl\")\ndc1lan = ionoscloud.compute.Lan(\"dc1lan\",\n    datacenter_id=dc1.id,\n    public=False,\n    pcc=cross_connect_test_resource.id)\ndc2lan = ionoscloud.compute.Lan(\"dc2lan\",\n    datacenter_id=dc2.id,\n    public=False,\n    pcc=cross_connect_test_resource.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var crossConnectTestResource = new Ionoscloud.Compute.Crossconnect(\"crossConnectTestResource\", new()\n    {\n        Description = \"CrossConnectTestResource\",\n    });\n\n    var dc1 = new Ionoscloud.Compute.Datacenter(\"dc1\", new()\n    {\n        Location = \"de/txl\",\n    });\n\n    var dc2 = new Ionoscloud.Compute.Datacenter(\"dc2\", new()\n    {\n        Location = \"de/txl\",\n    });\n\n    var dc1lan = new Ionoscloud.Compute.Lan(\"dc1lan\", new()\n    {\n        DatacenterId = dc1.Id,\n        Public = false,\n        Pcc = crossConnectTestResource.Id,\n    });\n\n    var dc2lan = new Ionoscloud.Compute.Lan(\"dc2lan\", new()\n    {\n        DatacenterId = dc2.Id,\n        Public = false,\n        Pcc = crossConnectTestResource.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tcrossConnectTestResource, err := compute.NewCrossconnect(ctx, \"crossConnectTestResource\", \u0026compute.CrossconnectArgs{\n\t\t\tDescription: pulumi.String(\"CrossConnectTestResource\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdc1, err := compute.NewDatacenter(ctx, \"dc1\", \u0026compute.DatacenterArgs{\n\t\t\tLocation: pulumi.String(\"de/txl\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdc2, err := compute.NewDatacenter(ctx, \"dc2\", \u0026compute.DatacenterArgs{\n\t\t\tLocation: pulumi.String(\"de/txl\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = compute.NewLan(ctx, \"dc1lan\", \u0026compute.LanArgs{\n\t\t\tDatacenterId: dc1.ID(),\n\t\t\tPublic:       pulumi.Bool(false),\n\t\t\tPcc:          crossConnectTestResource.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = compute.NewLan(ctx, \"dc2lan\", \u0026compute.LanArgs{\n\t\t\tDatacenterId: dc2.ID(),\n\t\t\tPublic:       pulumi.Bool(false),\n\t\t\tPcc:          crossConnectTestResource.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.Crossconnect;\nimport com.pulumi.ionoscloud.compute.CrossconnectArgs;\nimport com.pulumi.ionoscloud.compute.Datacenter;\nimport com.pulumi.ionoscloud.compute.DatacenterArgs;\nimport com.pulumi.ionoscloud.compute.Lan;\nimport com.pulumi.ionoscloud.compute.LanArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var crossConnectTestResource = new Crossconnect(\"crossConnectTestResource\", CrossconnectArgs.builder()\n            .description(\"CrossConnectTestResource\")\n            .build());\n\n        var dc1 = new Datacenter(\"dc1\", DatacenterArgs.builder()\n            .location(\"de/txl\")\n            .build());\n\n        var dc2 = new Datacenter(\"dc2\", DatacenterArgs.builder()\n            .location(\"de/txl\")\n            .build());\n\n        var dc1lan = new Lan(\"dc1lan\", LanArgs.builder()\n            .datacenterId(dc1.id())\n            .public_(false)\n            .pcc(crossConnectTestResource.id())\n            .build());\n\n        var dc2lan = new Lan(\"dc2lan\", LanArgs.builder()\n            .datacenterId(dc2.id())\n            .public_(false)\n            .pcc(crossConnectTestResource.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  crossConnectTestResource:\n    type: ionoscloud:compute:Crossconnect\n    properties:\n      description: CrossConnectTestResource\n  dc1:\n    type: ionoscloud:compute:Datacenter\n    properties:\n      location: de/txl\n  dc2:\n    type: ionoscloud:compute:Datacenter\n    properties:\n      location: de/txl\n  dc1lan:\n    type: ionoscloud:compute:Lan\n    properties:\n      datacenterId: ${dc1.id}\n      public: false\n      pcc: ${crossConnectTestResource.id}\n  dc2lan:\n    type: ionoscloud:compute:Lan\n    properties:\n      datacenterId: ${dc2.id}\n      public: false\n      pcc: ${crossConnectTestResource.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nA Cross Connect resource can be imported using its `resource id`, e.g.\n\n```sh\n$ pulumi import ionoscloud:compute/crossconnect:Crossconnect demo {ionoscloud_private_crossconnect_uuid}\n```\n\nThis can be helpful when you want to import cross-connects which you have already created manually or using other means, outside of terraform.\n\n",
            "properties": {
                "connectableDatacenters": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:compute/CrossconnectConnectableDatacenter:CrossconnectConnectableDatacenter"
                    },
                    "description": "A list containing all the connectable datacenters\n"
                },
                "description": {
                    "type": "string",
                    "description": "[string] A short description for the cross-connection.\n- `connectable datacenters` - (Computed) A list containing all the connectable datacenters\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the cross-connection.\n"
                },
                "peers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:compute/CrossconnectPeer:CrossconnectPeer"
                    },
                    "description": "Lists LAN's joined to this cross connect\n"
                }
            },
            "required": [
                "connectableDatacenters",
                "name",
                "peers"
            ],
            "inputProperties": {
                "connectableDatacenters": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:compute/CrossconnectConnectableDatacenter:CrossconnectConnectableDatacenter"
                    },
                    "description": "A list containing all the connectable datacenters\n"
                },
                "description": {
                    "type": "string",
                    "description": "[string] A short description for the cross-connection.\n- `connectable datacenters` - (Computed) A list containing all the connectable datacenters\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the cross-connection.\n"
                },
                "peers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:compute/CrossconnectPeer:CrossconnectPeer"
                    },
                    "description": "Lists LAN's joined to this cross connect\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Crossconnect resources.\n",
                "properties": {
                    "connectableDatacenters": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:compute/CrossconnectConnectableDatacenter:CrossconnectConnectableDatacenter"
                        },
                        "description": "A list containing all the connectable datacenters\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "[string] A short description for the cross-connection.\n- `connectable datacenters` - (Computed) A list containing all the connectable datacenters\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] The name of the cross-connection.\n"
                    },
                    "peers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:compute/CrossconnectPeer:CrossconnectPeer"
                        },
                        "description": "Lists LAN's joined to this cross connect\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:compute/cubeServer:CubeServer": {
            "description": "Manages a **Cube Server** on IonosCloud.\n\n## Example Usage\n\nThis resource will create an operational server. After this section completes, the provisioner can be called.\n\n### CUBE Server\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\nimport * as random from \"@pulumi/random\";\n\nconst exampleTemplate = ionoscloud.compute.getTemplate({\n    name: \"CUBES XS\",\n});\nconst exampleDatacenter = new ionoscloud.compute.Datacenter(\"exampleDatacenter\", {location: \"de/txl\"});\nconst exampleLan = new ionoscloud.compute.Lan(\"exampleLan\", {\n    datacenterId: exampleDatacenter.id,\n    \"public\": true,\n});\nconst serverImagePassword = new random.RandomPassword(\"serverImagePassword\", {\n    length: 16,\n    special: false,\n});\nconst exampleCubeServer = new ionoscloud.compute.CubeServer(\"exampleCubeServer\", {\n    availabilityZone: \"ZONE_2\",\n    imageName: \"ubuntu:latest\",\n    templateUuid: exampleTemplate.then(exampleTemplate =\u003e exampleTemplate.id),\n    imagePassword: serverImagePassword.result,\n    datacenterId: exampleDatacenter.id,\n    volume: {\n        name: \"Volume Example\",\n        licenceType: \"LINUX\",\n        diskType: \"DAS\",\n    },\n    nic: {\n        lan: exampleLan.id,\n        name: \"Nic Example\",\n        dhcp: true,\n        firewallActive: true,\n    },\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\nimport pulumi_ionoscloud as ionoscloud\nimport pulumi_random as random\n\nexample_template = ionoscloud.compute.get_template(name=\"CUBES XS\")\nexample_datacenter = ionoscloud.compute.Datacenter(\"exampleDatacenter\", location=\"de/txl\")\nexample_lan = ionoscloud.compute.Lan(\"exampleLan\",\n    datacenter_id=example_datacenter.id,\n    public=True)\nserver_image_password = random.RandomPassword(\"serverImagePassword\",\n    length=16,\n    special=False)\nexample_cube_server = ionoscloud.compute.CubeServer(\"exampleCubeServer\",\n    availability_zone=\"ZONE_2\",\n    image_name=\"ubuntu:latest\",\n    template_uuid=example_template.id,\n    image_password=server_image_password.result,\n    datacenter_id=example_datacenter.id,\n    volume={\n        \"name\": \"Volume Example\",\n        \"licence_type\": \"LINUX\",\n        \"disk_type\": \"DAS\",\n    },\n    nic={\n        \"lan\": example_lan.id,\n        \"name\": \"Nic Example\",\n        \"dhcp\": True,\n        \"firewall_active\": True,\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\nusing Random = Pulumi.Random;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleTemplate = Ionoscloud.Compute.GetTemplate.Invoke(new()\n    {\n        Name = \"CUBES XS\",\n    });\n\n    var exampleDatacenter = new Ionoscloud.Compute.Datacenter(\"exampleDatacenter\", new()\n    {\n        Location = \"de/txl\",\n    });\n\n    var exampleLan = new Ionoscloud.Compute.Lan(\"exampleLan\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        Public = true,\n    });\n\n    var serverImagePassword = new Random.RandomPassword(\"serverImagePassword\", new()\n    {\n        Length = 16,\n        Special = false,\n    });\n\n    var exampleCubeServer = new Ionoscloud.Compute.CubeServer(\"exampleCubeServer\", new()\n    {\n        AvailabilityZone = \"ZONE_2\",\n        ImageName = \"ubuntu:latest\",\n        TemplateUuid = exampleTemplate.Apply(getTemplateResult =\u003e getTemplateResult.Id),\n        ImagePassword = serverImagePassword.Result,\n        DatacenterId = exampleDatacenter.Id,\n        Volume = new Ionoscloud.Compute.Inputs.CubeServerVolumeArgs\n        {\n            Name = \"Volume Example\",\n            LicenceType = \"LINUX\",\n            DiskType = \"DAS\",\n        },\n        Nic = new Ionoscloud.Compute.Inputs.CubeServerNicArgs\n        {\n            Lan = exampleLan.Id,\n            Name = \"Nic Example\",\n            Dhcp = true,\n            FirewallActive = true,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi-random/sdk/v4/go/random\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleTemplate, err := compute.GetTemplate(ctx, \u0026compute.GetTemplateArgs{\n\t\t\tName: pulumi.StringRef(\"CUBES XS\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleDatacenter, err := compute.NewDatacenter(ctx, \"exampleDatacenter\", \u0026compute.DatacenterArgs{\n\t\t\tLocation: pulumi.String(\"de/txl\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleLan, err := compute.NewLan(ctx, \"exampleLan\", \u0026compute.LanArgs{\n\t\t\tDatacenterId: exampleDatacenter.ID(),\n\t\t\tPublic:       pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tserverImagePassword, err := random.NewRandomPassword(ctx, \"serverImagePassword\", \u0026random.RandomPasswordArgs{\n\t\t\tLength:  pulumi.Int(16),\n\t\t\tSpecial: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = compute.NewCubeServer(ctx, \"exampleCubeServer\", \u0026compute.CubeServerArgs{\n\t\t\tAvailabilityZone: pulumi.String(\"ZONE_2\"),\n\t\t\tImageName:        pulumi.String(\"ubuntu:latest\"),\n\t\t\tTemplateUuid:     pulumi.String(exampleTemplate.Id),\n\t\t\tImagePassword:    serverImagePassword.Result,\n\t\t\tDatacenterId:     exampleDatacenter.ID(),\n\t\t\tVolume: \u0026compute.CubeServerVolumeArgs{\n\t\t\t\tName:        pulumi.String(\"Volume Example\"),\n\t\t\t\tLicenceType: pulumi.String(\"LINUX\"),\n\t\t\t\tDiskType:    pulumi.String(\"DAS\"),\n\t\t\t},\n\t\t\tNic: \u0026compute.CubeServerNicArgs{\n\t\t\t\tLan:            exampleLan.ID(),\n\t\t\t\tName:           pulumi.String(\"Nic Example\"),\n\t\t\t\tDhcp:           pulumi.Bool(true),\n\t\t\t\tFirewallActive: pulumi.Bool(true),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.ComputeFunctions;\nimport com.pulumi.ionoscloud.compute.inputs.GetTemplateArgs;\nimport com.pulumi.ionoscloud.compute.Datacenter;\nimport com.pulumi.ionoscloud.compute.DatacenterArgs;\nimport com.pulumi.ionoscloud.compute.Lan;\nimport com.pulumi.ionoscloud.compute.LanArgs;\nimport com.pulumi.random.RandomPassword;\nimport com.pulumi.random.RandomPasswordArgs;\nimport com.pulumi.ionoscloud.compute.CubeServer;\nimport com.pulumi.ionoscloud.compute.CubeServerArgs;\nimport com.pulumi.ionoscloud.compute.inputs.CubeServerVolumeArgs;\nimport com.pulumi.ionoscloud.compute.inputs.CubeServerNicArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var exampleTemplate = ComputeFunctions.getTemplate(GetTemplateArgs.builder()\n            .name(\"CUBES XS\")\n            .build());\n\n        var exampleDatacenter = new Datacenter(\"exampleDatacenter\", DatacenterArgs.builder()\n            .location(\"de/txl\")\n            .build());\n\n        var exampleLan = new Lan(\"exampleLan\", LanArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .public_(true)\n            .build());\n\n        var serverImagePassword = new RandomPassword(\"serverImagePassword\", RandomPasswordArgs.builder()\n            .length(16)\n            .special(false)\n            .build());\n\n        var exampleCubeServer = new CubeServer(\"exampleCubeServer\", CubeServerArgs.builder()\n            .availabilityZone(\"ZONE_2\")\n            .imageName(\"ubuntu:latest\")\n            .templateUuid(exampleTemplate.applyValue(getTemplateResult -\u003e getTemplateResult.id()))\n            .imagePassword(serverImagePassword.result())\n            .datacenterId(exampleDatacenter.id())\n            .volume(CubeServerVolumeArgs.builder()\n                .name(\"Volume Example\")\n                .licenceType(\"LINUX\")\n                .diskType(\"DAS\")\n                .build())\n            .nic(CubeServerNicArgs.builder()\n                .lan(exampleLan.id())\n                .name(\"Nic Example\")\n                .dhcp(true)\n                .firewallActive(true)\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleDatacenter:\n    type: ionoscloud:compute:Datacenter\n    properties:\n      location: de/txl\n  exampleLan:\n    type: ionoscloud:compute:Lan\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      public: true\n  exampleCubeServer:\n    type: ionoscloud:compute:CubeServer\n    properties:\n      availabilityZone: ZONE_2\n      imageName: ubuntu:latest\n      templateUuid: ${exampleTemplate.id}\n      imagePassword: ${serverImagePassword.result}\n      datacenterId: ${exampleDatacenter.id}\n      volume:\n        name: Volume Example\n        licenceType: LINUX\n        diskType: DAS\n      nic:\n        lan: ${exampleLan.id}\n        name: Nic Example\n        dhcp: true\n        firewallActive: true\n  serverImagePassword:\n    type: random:RandomPassword\n    properties:\n      length: 16\n      special: false\nvariables:\n  exampleTemplate:\n    fn::invoke:\n      function: ionoscloud:compute:getTemplate\n      arguments:\n        name: CUBES XS\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nResource Server can be imported using the `resource id` and the `datacenter id`, e.g.\n\n```sh\n$ pulumi import ionoscloud:compute/cubeServer:CubeServer myserver {datacenter uuid}/{server uuid}\n```\n\n",
            "properties": {
                "availabilityZone": {
                    "type": "string",
                    "description": "[string] The availability zone in which the server should exist. This property is immutable.\n"
                },
                "bootCdrom": {
                    "type": "string",
                    "description": "***DEPRECATED*** Please refer to ionoscloud.compute.BootDeviceSelection (Optional)[string] The associated boot drive, if any. Must be the UUID of a bootable CDROM image that can be retrieved using the ionoscloud.compute.getImage data source.\n",
                    "deprecationMessage": "Please use the 'ionoscloud_server_boot_device_selection' resource for managing the boot device of the server."
                },
                "bootImage": {
                    "type": "string",
                    "description": "[string] The image or snapshot UUID / name. May also be an image alias. It is required if `licence_type` is not provided.\n"
                },
                "bootVolume": {
                    "type": "string",
                    "description": "The associated boot volume.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "[string] The ID of a Virtual Data Center.\n"
                },
                "firewallruleId": {
                    "type": "string",
                    "description": "The associated firewall rule.\n"
                },
                "imageName": {
                    "type": "string",
                    "description": "[string] The name, ID or alias of the image. May also be a snapshot ID. It is required if `licence_type` is not provided. Attribute is immutable.\n"
                },
                "imagePassword": {
                    "type": "string",
                    "description": "[string] Required if `ssh_key_path` is not provided.\n\n\u003e **⚠ WARNING**\n\u003e\n\u003e Image_name under volume level is deprecated, please use image_name under server level\n\n\n\u003e **⚠ WARNING**\n\u003e\n\u003e For creating a **CUBE** server, you can not set `volume.size` argument.\n\u003e\n",
                    "secret": true
                },
                "inlineVolumeIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list that contains the IDs for the volumes defined inside the cube server resource.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the server.\n"
                },
                "nic": {
                    "$ref": "#/types/ionoscloud:compute/CubeServerNic:CubeServerNic",
                    "description": "See the Nic section.\n"
                },
                "primaryIp": {
                    "type": "string",
                    "description": "The associated IP address.\n"
                },
                "primaryNic": {
                    "type": "string",
                    "description": "The associated NIC.\n"
                },
                "sshKeyPaths": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] List of paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images. Required for IonosCloud Linux images. Required if `image_password` is not provided.\n"
                },
                "templateUuid": {
                    "type": "string",
                    "description": "[string] The UUID of the template for creating a CUBE server; the available templates for CUBE servers can be found on the templates resource\n"
                },
                "vmState": {
                    "type": "string",
                    "description": "[string] Sets the power state of the cube server. E.g: `RUNNING` or `SUSPENDED`.\n"
                },
                "volume": {
                    "$ref": "#/types/ionoscloud:compute/CubeServerVolume:CubeServerVolume",
                    "description": "See the Volume section.\n"
                }
            },
            "required": [
                "availabilityZone",
                "bootCdrom",
                "bootImage",
                "bootVolume",
                "datacenterId",
                "firewallruleId",
                "imageName",
                "imagePassword",
                "inlineVolumeIds",
                "name",
                "nic",
                "primaryIp",
                "primaryNic",
                "sshKeyPaths",
                "templateUuid",
                "vmState",
                "volume"
            ],
            "inputProperties": {
                "availabilityZone": {
                    "type": "string",
                    "description": "[string] The availability zone in which the server should exist. This property is immutable.\n"
                },
                "bootCdrom": {
                    "type": "string",
                    "description": "***DEPRECATED*** Please refer to ionoscloud.compute.BootDeviceSelection (Optional)[string] The associated boot drive, if any. Must be the UUID of a bootable CDROM image that can be retrieved using the ionoscloud.compute.getImage data source.\n",
                    "deprecationMessage": "Please use the 'ionoscloud_server_boot_device_selection' resource for managing the boot device of the server."
                },
                "bootImage": {
                    "type": "string",
                    "description": "[string] The image or snapshot UUID / name. May also be an image alias. It is required if `licence_type` is not provided.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "[string] The ID of a Virtual Data Center.\n",
                    "willReplaceOnChanges": true
                },
                "imageName": {
                    "type": "string",
                    "description": "[string] The name, ID or alias of the image. May also be a snapshot ID. It is required if `licence_type` is not provided. Attribute is immutable.\n"
                },
                "imagePassword": {
                    "type": "string",
                    "description": "[string] Required if `ssh_key_path` is not provided.\n\n\u003e **⚠ WARNING**\n\u003e\n\u003e Image_name under volume level is deprecated, please use image_name under server level\n\n\n\u003e **⚠ WARNING**\n\u003e\n\u003e For creating a **CUBE** server, you can not set `volume.size` argument.\n\u003e\n",
                    "secret": true
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the server.\n"
                },
                "nic": {
                    "$ref": "#/types/ionoscloud:compute/CubeServerNic:CubeServerNic",
                    "description": "See the Nic section.\n"
                },
                "sshKeyPaths": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] List of paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images. Required for IonosCloud Linux images. Required if `image_password` is not provided.\n"
                },
                "templateUuid": {
                    "type": "string",
                    "description": "[string] The UUID of the template for creating a CUBE server; the available templates for CUBE servers can be found on the templates resource\n"
                },
                "vmState": {
                    "type": "string",
                    "description": "[string] Sets the power state of the cube server. E.g: `RUNNING` or `SUSPENDED`.\n"
                },
                "volume": {
                    "$ref": "#/types/ionoscloud:compute/CubeServerVolume:CubeServerVolume",
                    "description": "See the Volume section.\n"
                }
            },
            "requiredInputs": [
                "datacenterId",
                "nic",
                "templateUuid",
                "volume"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CubeServer resources.\n",
                "properties": {
                    "availabilityZone": {
                        "type": "string",
                        "description": "[string] The availability zone in which the server should exist. This property is immutable.\n"
                    },
                    "bootCdrom": {
                        "type": "string",
                        "description": "***DEPRECATED*** Please refer to ionoscloud.compute.BootDeviceSelection (Optional)[string] The associated boot drive, if any. Must be the UUID of a bootable CDROM image that can be retrieved using the ionoscloud.compute.getImage data source.\n",
                        "deprecationMessage": "Please use the 'ionoscloud_server_boot_device_selection' resource for managing the boot device of the server."
                    },
                    "bootImage": {
                        "type": "string",
                        "description": "[string] The image or snapshot UUID / name. May also be an image alias. It is required if `licence_type` is not provided.\n"
                    },
                    "bootVolume": {
                        "type": "string",
                        "description": "The associated boot volume.\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "[string] The ID of a Virtual Data Center.\n",
                        "willReplaceOnChanges": true
                    },
                    "firewallruleId": {
                        "type": "string",
                        "description": "The associated firewall rule.\n"
                    },
                    "imageName": {
                        "type": "string",
                        "description": "[string] The name, ID or alias of the image. May also be a snapshot ID. It is required if `licence_type` is not provided. Attribute is immutable.\n"
                    },
                    "imagePassword": {
                        "type": "string",
                        "description": "[string] Required if `ssh_key_path` is not provided.\n\n\u003e **⚠ WARNING**\n\u003e\n\u003e Image_name under volume level is deprecated, please use image_name under server level\n\n\n\u003e **⚠ WARNING**\n\u003e\n\u003e For creating a **CUBE** server, you can not set `volume.size` argument.\n\u003e\n",
                        "secret": true
                    },
                    "inlineVolumeIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list that contains the IDs for the volumes defined inside the cube server resource.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] The name of the server.\n"
                    },
                    "nic": {
                        "$ref": "#/types/ionoscloud:compute/CubeServerNic:CubeServerNic",
                        "description": "See the Nic section.\n"
                    },
                    "primaryIp": {
                        "type": "string",
                        "description": "The associated IP address.\n"
                    },
                    "primaryNic": {
                        "type": "string",
                        "description": "The associated NIC.\n"
                    },
                    "sshKeyPaths": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "[list] List of paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images. Required for IonosCloud Linux images. Required if `image_password` is not provided.\n"
                    },
                    "templateUuid": {
                        "type": "string",
                        "description": "[string] The UUID of the template for creating a CUBE server; the available templates for CUBE servers can be found on the templates resource\n"
                    },
                    "vmState": {
                        "type": "string",
                        "description": "[string] Sets the power state of the cube server. E.g: `RUNNING` or `SUSPENDED`.\n"
                    },
                    "volume": {
                        "$ref": "#/types/ionoscloud:compute/CubeServerVolume:CubeServerVolume",
                        "description": "See the Volume section.\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:compute/datacenter:Datacenter": {
            "description": "Manages a Virtual **Data Center** on IonosCloud.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = new ionoscloud.compute.Datacenter(\"example\", {\n    description: \"datacenter description\",\n    location: \"us/las\",\n    secAuthProtection: false,\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\nexample = ionoscloud.compute.Datacenter(\"example\",\n    description=\"datacenter description\",\n    location=\"us/las\",\n    sec_auth_protection=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Ionoscloud.Compute.Datacenter(\"example\", new()\n    {\n        Description = \"datacenter description\",\n        Location = \"us/las\",\n        SecAuthProtection = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := compute.NewDatacenter(ctx, \"example\", \u0026compute.DatacenterArgs{\n\t\t\tDescription:       pulumi.String(\"datacenter description\"),\n\t\t\tLocation:          pulumi.String(\"us/las\"),\n\t\t\tSecAuthProtection: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.Datacenter;\nimport com.pulumi.ionoscloud.compute.DatacenterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new Datacenter(\"example\", DatacenterArgs.builder()\n            .description(\"datacenter description\")\n            .location(\"us/las\")\n            .secAuthProtection(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: ionoscloud:compute:Datacenter\n    properties:\n      description: datacenter description\n      location: us/las\n      secAuthProtection: false\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nResource Datacenter can be imported using the `resource id`, e.g.\n\n```sh\n$ pulumi import ionoscloud:compute/datacenter:Datacenter mydc {datacenter uuid}\n```\n\n",
            "properties": {
                "cpuArchitectures": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:compute/DatacenterCpuArchitecture:DatacenterCpuArchitecture"
                    },
                    "description": "Array of features and CPU families available in a location\n"
                },
                "description": {
                    "type": "string",
                    "description": "[string] Description for the Virtual Data Center.\n"
                },
                "features": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of features supported by the location this data center is part of\n"
                },
                "ipv6CidrBlock": {
                    "type": "string",
                    "description": "The automatically-assigned /56 IPv6 CIDR block if IPv6 is enabled on this virtual data center\n"
                },
                "location": {
                    "type": "string",
                    "description": "[string] The regional location where the Virtual Data Center will be created. This argument is immutable.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the Virtual Data Center.\n"
                },
                "secAuthProtection": {
                    "type": "boolean",
                    "description": "[bool] Boolean value representing if the data center requires extra protection e.g. two factor protection\n"
                },
                "version": {
                    "type": "integer",
                    "description": "The version of that Data Center. Gets incremented with every change\n"
                }
            },
            "required": [
                "cpuArchitectures",
                "description",
                "features",
                "ipv6CidrBlock",
                "location",
                "name",
                "version"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "[string] Description for the Virtual Data Center.\n"
                },
                "location": {
                    "type": "string",
                    "description": "[string] The regional location where the Virtual Data Center will be created. This argument is immutable.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the Virtual Data Center.\n"
                },
                "secAuthProtection": {
                    "type": "boolean",
                    "description": "[bool] Boolean value representing if the data center requires extra protection e.g. two factor protection\n"
                }
            },
            "requiredInputs": [
                "location"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Datacenter resources.\n",
                "properties": {
                    "cpuArchitectures": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:compute/DatacenterCpuArchitecture:DatacenterCpuArchitecture"
                        },
                        "description": "Array of features and CPU families available in a location\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "[string] Description for the Virtual Data Center.\n"
                    },
                    "features": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of features supported by the location this data center is part of\n"
                    },
                    "ipv6CidrBlock": {
                        "type": "string",
                        "description": "The automatically-assigned /56 IPv6 CIDR block if IPv6 is enabled on this virtual data center\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "[string] The regional location where the Virtual Data Center will be created. This argument is immutable.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] The name of the Virtual Data Center.\n"
                    },
                    "secAuthProtection": {
                        "type": "boolean",
                        "description": "[bool] Boolean value representing if the data center requires extra protection e.g. two factor protection\n"
                    },
                    "version": {
                        "type": "integer",
                        "description": "The version of that Data Center. Gets incremented with every change\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:compute/firewall:Firewall": {
            "description": "Manages a set of **Firewall Rules** on IonosCloud.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\nimport * as random from \"@pulumi/random\";\n\nconst exampleDatacenter = new ionoscloud.compute.Datacenter(\"exampleDatacenter\", {\n    location: \"us/las\",\n    description: \"Datacenter Description\",\n    secAuthProtection: false,\n});\nconst exampleIPBlock = new ionoscloud.compute.IPBlock(\"exampleIPBlock\", {\n    location: exampleDatacenter.location,\n    size: 2,\n});\nconst serverImagePassword = new random.RandomPassword(\"serverImagePassword\", {\n    length: 16,\n    special: false,\n});\nconst exampleServer = new ionoscloud.compute.Server(\"exampleServer\", {\n    datacenterId: exampleDatacenter.id,\n    cores: 1,\n    ram: 1024,\n    availabilityZone: \"ZONE_1\",\n    cpuFamily: \"INTEL_XEON\",\n    imageName: \"Ubuntu-20.04\",\n    imagePassword: serverImagePassword.result,\n    volume: {\n        name: \"system\",\n        size: 14,\n        diskType: \"SSD\",\n    },\n    nic: {\n        lan: 1,\n        dhcp: true,\n        firewallActive: true,\n    },\n});\nconst exampleNic = new ionoscloud.compute.Nic(\"exampleNic\", {\n    datacenterId: exampleDatacenter.id,\n    serverId: exampleServer.id,\n    lan: 2,\n    dhcp: true,\n    firewallActive: true,\n});\nconst exampleFirewall = new ionoscloud.compute.Firewall(\"exampleFirewall\", {\n    datacenterId: exampleDatacenter.id,\n    serverId: exampleServer.id,\n    nicId: exampleNic.id,\n    protocol: \"ICMP\",\n    sourceMac: \"00:0a:95:9d:68:16\",\n    sourceIp: exampleIPBlock.ips[0],\n    targetIp: exampleIPBlock.ips[1],\n    icmpType: \"1\",\n    icmpCode: \"8\",\n    type: \"INGRESS\",\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\nimport pulumi_random as random\n\nexample_datacenter = ionoscloud.compute.Datacenter(\"exampleDatacenter\",\n    location=\"us/las\",\n    description=\"Datacenter Description\",\n    sec_auth_protection=False)\nexample_ip_block = ionoscloud.compute.IPBlock(\"exampleIPBlock\",\n    location=example_datacenter.location,\n    size=2)\nserver_image_password = random.RandomPassword(\"serverImagePassword\",\n    length=16,\n    special=False)\nexample_server = ionoscloud.compute.Server(\"exampleServer\",\n    datacenter_id=example_datacenter.id,\n    cores=1,\n    ram=1024,\n    availability_zone=\"ZONE_1\",\n    cpu_family=\"INTEL_XEON\",\n    image_name=\"Ubuntu-20.04\",\n    image_password=server_image_password.result,\n    volume={\n        \"name\": \"system\",\n        \"size\": 14,\n        \"disk_type\": \"SSD\",\n    },\n    nic={\n        \"lan\": 1,\n        \"dhcp\": True,\n        \"firewall_active\": True,\n    })\nexample_nic = ionoscloud.compute.Nic(\"exampleNic\",\n    datacenter_id=example_datacenter.id,\n    server_id=example_server.id,\n    lan=2,\n    dhcp=True,\n    firewall_active=True)\nexample_firewall = ionoscloud.compute.Firewall(\"exampleFirewall\",\n    datacenter_id=example_datacenter.id,\n    server_id=example_server.id,\n    nic_id=example_nic.id,\n    protocol=\"ICMP\",\n    source_mac=\"00:0a:95:9d:68:16\",\n    source_ip=example_ip_block.ips[0],\n    target_ip=example_ip_block.ips[1],\n    icmp_type=\"1\",\n    icmp_code=\"8\",\n    type=\"INGRESS\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\nusing Random = Pulumi.Random;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleDatacenter = new Ionoscloud.Compute.Datacenter(\"exampleDatacenter\", new()\n    {\n        Location = \"us/las\",\n        Description = \"Datacenter Description\",\n        SecAuthProtection = false,\n    });\n\n    var exampleIPBlock = new Ionoscloud.Compute.IPBlock(\"exampleIPBlock\", new()\n    {\n        Location = exampleDatacenter.Location,\n        Size = 2,\n    });\n\n    var serverImagePassword = new Random.RandomPassword(\"serverImagePassword\", new()\n    {\n        Length = 16,\n        Special = false,\n    });\n\n    var exampleServer = new Ionoscloud.Compute.Server(\"exampleServer\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        Cores = 1,\n        Ram = 1024,\n        AvailabilityZone = \"ZONE_1\",\n        CpuFamily = \"INTEL_XEON\",\n        ImageName = \"Ubuntu-20.04\",\n        ImagePassword = serverImagePassword.Result,\n        Volume = new Ionoscloud.Compute.Inputs.ServerVolumeArgs\n        {\n            Name = \"system\",\n            Size = 14,\n            DiskType = \"SSD\",\n        },\n        Nic = new Ionoscloud.Compute.Inputs.ServerNicArgs\n        {\n            Lan = 1,\n            Dhcp = true,\n            FirewallActive = true,\n        },\n    });\n\n    var exampleNic = new Ionoscloud.Compute.Nic(\"exampleNic\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        ServerId = exampleServer.Id,\n        Lan = 2,\n        Dhcp = true,\n        FirewallActive = true,\n    });\n\n    var exampleFirewall = new Ionoscloud.Compute.Firewall(\"exampleFirewall\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        ServerId = exampleServer.Id,\n        NicId = exampleNic.Id,\n        Protocol = \"ICMP\",\n        SourceMac = \"00:0a:95:9d:68:16\",\n        SourceIp = exampleIPBlock.Ips.Apply(ips =\u003e ips[0]),\n        TargetIp = exampleIPBlock.Ips.Apply(ips =\u003e ips[1]),\n        IcmpType = \"1\",\n        IcmpCode = \"8\",\n        Type = \"INGRESS\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi-random/sdk/v4/go/random\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleDatacenter, err := compute.NewDatacenter(ctx, \"exampleDatacenter\", \u0026compute.DatacenterArgs{\n\t\t\tLocation:          pulumi.String(\"us/las\"),\n\t\t\tDescription:       pulumi.String(\"Datacenter Description\"),\n\t\t\tSecAuthProtection: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleIPBlock, err := compute.NewIPBlock(ctx, \"exampleIPBlock\", \u0026compute.IPBlockArgs{\n\t\t\tLocation: exampleDatacenter.Location,\n\t\t\tSize:     pulumi.Int(2),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tserverImagePassword, err := random.NewRandomPassword(ctx, \"serverImagePassword\", \u0026random.RandomPasswordArgs{\n\t\t\tLength:  pulumi.Int(16),\n\t\t\tSpecial: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleServer, err := compute.NewServer(ctx, \"exampleServer\", \u0026compute.ServerArgs{\n\t\t\tDatacenterId:     exampleDatacenter.ID(),\n\t\t\tCores:            pulumi.Int(1),\n\t\t\tRam:              pulumi.Int(1024),\n\t\t\tAvailabilityZone: pulumi.String(\"ZONE_1\"),\n\t\t\tCpuFamily:        pulumi.String(\"INTEL_XEON\"),\n\t\t\tImageName:        pulumi.String(\"Ubuntu-20.04\"),\n\t\t\tImagePassword:    serverImagePassword.Result,\n\t\t\tVolume: \u0026compute.ServerVolumeArgs{\n\t\t\t\tName:     pulumi.String(\"system\"),\n\t\t\t\tSize:     pulumi.Int(14),\n\t\t\t\tDiskType: pulumi.String(\"SSD\"),\n\t\t\t},\n\t\t\tNic: \u0026compute.ServerNicArgs{\n\t\t\t\tLan:            pulumi.Int(1),\n\t\t\t\tDhcp:           pulumi.Bool(true),\n\t\t\t\tFirewallActive: pulumi.Bool(true),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleNic, err := compute.NewNic(ctx, \"exampleNic\", \u0026compute.NicArgs{\n\t\t\tDatacenterId:   exampleDatacenter.ID(),\n\t\t\tServerId:       exampleServer.ID(),\n\t\t\tLan:            pulumi.Int(2),\n\t\t\tDhcp:           pulumi.Bool(true),\n\t\t\tFirewallActive: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = compute.NewFirewall(ctx, \"exampleFirewall\", \u0026compute.FirewallArgs{\n\t\t\tDatacenterId: exampleDatacenter.ID(),\n\t\t\tServerId:     exampleServer.ID(),\n\t\t\tNicId:        exampleNic.ID(),\n\t\t\tProtocol:     pulumi.String(\"ICMP\"),\n\t\t\tSourceMac:    pulumi.String(\"00:0a:95:9d:68:16\"),\n\t\t\tSourceIp: exampleIPBlock.Ips.ApplyT(func(ips []string) (string, error) {\n\t\t\t\treturn ips[0], nil\n\t\t\t}).(pulumi.StringOutput),\n\t\t\tTargetIp: exampleIPBlock.Ips.ApplyT(func(ips []string) (string, error) {\n\t\t\t\treturn ips[1], nil\n\t\t\t}).(pulumi.StringOutput),\n\t\t\tIcmpType: pulumi.String(\"1\"),\n\t\t\tIcmpCode: pulumi.String(\"8\"),\n\t\t\tType:     pulumi.String(\"INGRESS\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.Datacenter;\nimport com.pulumi.ionoscloud.compute.DatacenterArgs;\nimport com.pulumi.ionoscloud.compute.IPBlock;\nimport com.pulumi.ionoscloud.compute.IPBlockArgs;\nimport com.pulumi.random.RandomPassword;\nimport com.pulumi.random.RandomPasswordArgs;\nimport com.pulumi.ionoscloud.compute.Server;\nimport com.pulumi.ionoscloud.compute.ServerArgs;\nimport com.pulumi.ionoscloud.compute.inputs.ServerVolumeArgs;\nimport com.pulumi.ionoscloud.compute.inputs.ServerNicArgs;\nimport com.pulumi.ionoscloud.compute.Nic;\nimport com.pulumi.ionoscloud.compute.NicArgs;\nimport com.pulumi.ionoscloud.compute.Firewall;\nimport com.pulumi.ionoscloud.compute.FirewallArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleDatacenter = new Datacenter(\"exampleDatacenter\", DatacenterArgs.builder()\n            .location(\"us/las\")\n            .description(\"Datacenter Description\")\n            .secAuthProtection(false)\n            .build());\n\n        var exampleIPBlock = new IPBlock(\"exampleIPBlock\", IPBlockArgs.builder()\n            .location(exampleDatacenter.location())\n            .size(2)\n            .build());\n\n        var serverImagePassword = new RandomPassword(\"serverImagePassword\", RandomPasswordArgs.builder()\n            .length(16)\n            .special(false)\n            .build());\n\n        var exampleServer = new Server(\"exampleServer\", ServerArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .cores(1)\n            .ram(1024)\n            .availabilityZone(\"ZONE_1\")\n            .cpuFamily(\"INTEL_XEON\")\n            .imageName(\"Ubuntu-20.04\")\n            .imagePassword(serverImagePassword.result())\n            .volume(ServerVolumeArgs.builder()\n                .name(\"system\")\n                .size(14)\n                .diskType(\"SSD\")\n                .build())\n            .nic(ServerNicArgs.builder()\n                .lan(\"1\")\n                .dhcp(true)\n                .firewallActive(true)\n                .build())\n            .build());\n\n        var exampleNic = new Nic(\"exampleNic\", NicArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .serverId(exampleServer.id())\n            .lan(2)\n            .dhcp(true)\n            .firewallActive(true)\n            .build());\n\n        var exampleFirewall = new Firewall(\"exampleFirewall\", FirewallArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .serverId(exampleServer.id())\n            .nicId(exampleNic.id())\n            .protocol(\"ICMP\")\n            .sourceMac(\"00:0a:95:9d:68:16\")\n            .sourceIp(exampleIPBlock.ips().applyValue(ips -\u003e ips[0]))\n            .targetIp(exampleIPBlock.ips().applyValue(ips -\u003e ips[1]))\n            .icmpType(1)\n            .icmpCode(8)\n            .type(\"INGRESS\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleDatacenter:\n    type: ionoscloud:compute:Datacenter\n    properties:\n      location: us/las\n      description: Datacenter Description\n      secAuthProtection: false\n  exampleIPBlock:\n    type: ionoscloud:compute:IPBlock\n    properties:\n      location: ${exampleDatacenter.location}\n      size: 2\n  exampleServer:\n    type: ionoscloud:compute:Server\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      cores: 1\n      ram: 1024\n      availabilityZone: ZONE_1\n      cpuFamily: INTEL_XEON\n      imageName: Ubuntu-20.04\n      imagePassword: ${serverImagePassword.result}\n      volume:\n        name: system\n        size: 14\n        diskType: SSD\n      nic:\n        lan: '1'\n        dhcp: true\n        firewallActive: true\n  exampleNic:\n    type: ionoscloud:compute:Nic\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      serverId: ${exampleServer.id}\n      lan: 2\n      dhcp: true\n      firewallActive: true\n  exampleFirewall:\n    type: ionoscloud:compute:Firewall\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      serverId: ${exampleServer.id}\n      nicId: ${exampleNic.id}\n      protocol: ICMP\n      sourceMac: 00:0a:95:9d:68:16\n      sourceIp: ${exampleIPBlock.ips[0]}\n      targetIp: ${exampleIPBlock.ips[1]}\n      icmpType: 1\n      icmpCode: 8\n      type: INGRESS\n  serverImagePassword:\n    type: random:RandomPassword\n    properties:\n      length: 16\n      special: false\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nResource Firewall can be imported using the `resource id`, e.g.\n\n```sh\n$ pulumi import ionoscloud:compute/firewall:Firewall myfwrule {datacenter uuid}/{server uuid}/{nic uuid}/{firewall uuid}\n```\n\n",
            "properties": {
                "datacenterId": {
                    "type": "string",
                    "description": "[string] The Virtual Data Center ID.\n"
                },
                "icmpCode": {
                    "type": "string",
                    "description": "[int] Defines the allowed code (from 0 to 254) if protocol ICMP is chosen.\n"
                },
                "icmpType": {
                    "type": "string",
                    "description": "[string] Defines the allowed code (from 0 to 254) if protocol ICMP is chosen. Value null allows all codes.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the firewall rule.\n"
                },
                "nicId": {
                    "type": "string",
                    "description": "[string] The NIC ID.\n"
                },
                "portRangeEnd": {
                    "type": "integer",
                    "description": "[int] Defines the end range of the allowed port (from 1 to 65534) if the protocol TCP or UDP is chosen. Leave portRangeStart and portRangeEnd null to allow all ports.\n"
                },
                "portRangeStart": {
                    "type": "integer",
                    "description": "[int] Defines the start range of the allowed port (from 1 to 65534) if protocol TCP or UDP is chosen. Leave portRangeStart and portRangeEnd null to allow all ports.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "[string] The protocol for the rule: TCP, UDP, ICMP, ANY. Property cannot be modified after creation (disallowed in update requests).\n"
                },
                "serverId": {
                    "type": "string",
                    "description": "[string] The Server ID.\n"
                },
                "sourceIp": {
                    "type": "string",
                    "description": "[string] Only traffic originating from the respective IPv4 address is allowed. Value null allows all source IPs.\n"
                },
                "sourceMac": {
                    "type": "string",
                    "description": "[string] Only traffic originating from the respective MAC address is allowed. Valid format: aa:bb:cc:dd:ee:ff. Value null allows all source MAC address. Valid format: aa:bb:cc:dd:ee:ff.\n"
                },
                "targetIp": {
                    "type": "string",
                    "description": "[string] In case the target NIC has multiple IP addresses, only traffic directed to the respective IP address of the NIC is allowed. Value null allows all target IPs.\n"
                },
                "type": {
                    "type": "string",
                    "description": "[string] The type of firewall rule. If is not specified, it will take the default value INGRESS.\n"
                }
            },
            "required": [
                "datacenterId",
                "name",
                "nicId",
                "protocol",
                "serverId",
                "sourceIp",
                "targetIp",
                "type"
            ],
            "inputProperties": {
                "datacenterId": {
                    "type": "string",
                    "description": "[string] The Virtual Data Center ID.\n",
                    "willReplaceOnChanges": true
                },
                "icmpCode": {
                    "type": "string",
                    "description": "[int] Defines the allowed code (from 0 to 254) if protocol ICMP is chosen.\n"
                },
                "icmpType": {
                    "type": "string",
                    "description": "[string] Defines the allowed code (from 0 to 254) if protocol ICMP is chosen. Value null allows all codes.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the firewall rule.\n"
                },
                "nicId": {
                    "type": "string",
                    "description": "[string] The NIC ID.\n",
                    "willReplaceOnChanges": true
                },
                "portRangeEnd": {
                    "type": "integer",
                    "description": "[int] Defines the end range of the allowed port (from 1 to 65534) if the protocol TCP or UDP is chosen. Leave portRangeStart and portRangeEnd null to allow all ports.\n"
                },
                "portRangeStart": {
                    "type": "integer",
                    "description": "[int] Defines the start range of the allowed port (from 1 to 65534) if protocol TCP or UDP is chosen. Leave portRangeStart and portRangeEnd null to allow all ports.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "[string] The protocol for the rule: TCP, UDP, ICMP, ANY. Property cannot be modified after creation (disallowed in update requests).\n"
                },
                "serverId": {
                    "type": "string",
                    "description": "[string] The Server ID.\n",
                    "willReplaceOnChanges": true
                },
                "sourceIp": {
                    "type": "string",
                    "description": "[string] Only traffic originating from the respective IPv4 address is allowed. Value null allows all source IPs.\n"
                },
                "sourceMac": {
                    "type": "string",
                    "description": "[string] Only traffic originating from the respective MAC address is allowed. Valid format: aa:bb:cc:dd:ee:ff. Value null allows all source MAC address. Valid format: aa:bb:cc:dd:ee:ff.\n"
                },
                "targetIp": {
                    "type": "string",
                    "description": "[string] In case the target NIC has multiple IP addresses, only traffic directed to the respective IP address of the NIC is allowed. Value null allows all target IPs.\n"
                },
                "type": {
                    "type": "string",
                    "description": "[string] The type of firewall rule. If is not specified, it will take the default value INGRESS.\n"
                }
            },
            "requiredInputs": [
                "datacenterId",
                "nicId",
                "protocol",
                "serverId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Firewall resources.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "[string] The Virtual Data Center ID.\n",
                        "willReplaceOnChanges": true
                    },
                    "icmpCode": {
                        "type": "string",
                        "description": "[int] Defines the allowed code (from 0 to 254) if protocol ICMP is chosen.\n"
                    },
                    "icmpType": {
                        "type": "string",
                        "description": "[string] Defines the allowed code (from 0 to 254) if protocol ICMP is chosen. Value null allows all codes.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] The name of the firewall rule.\n"
                    },
                    "nicId": {
                        "type": "string",
                        "description": "[string] The NIC ID.\n",
                        "willReplaceOnChanges": true
                    },
                    "portRangeEnd": {
                        "type": "integer",
                        "description": "[int] Defines the end range of the allowed port (from 1 to 65534) if the protocol TCP or UDP is chosen. Leave portRangeStart and portRangeEnd null to allow all ports.\n"
                    },
                    "portRangeStart": {
                        "type": "integer",
                        "description": "[int] Defines the start range of the allowed port (from 1 to 65534) if protocol TCP or UDP is chosen. Leave portRangeStart and portRangeEnd null to allow all ports.\n"
                    },
                    "protocol": {
                        "type": "string",
                        "description": "[string] The protocol for the rule: TCP, UDP, ICMP, ANY. Property cannot be modified after creation (disallowed in update requests).\n"
                    },
                    "serverId": {
                        "type": "string",
                        "description": "[string] The Server ID.\n",
                        "willReplaceOnChanges": true
                    },
                    "sourceIp": {
                        "type": "string",
                        "description": "[string] Only traffic originating from the respective IPv4 address is allowed. Value null allows all source IPs.\n"
                    },
                    "sourceMac": {
                        "type": "string",
                        "description": "[string] Only traffic originating from the respective MAC address is allowed. Valid format: aa:bb:cc:dd:ee:ff. Value null allows all source MAC address. Valid format: aa:bb:cc:dd:ee:ff.\n"
                    },
                    "targetIp": {
                        "type": "string",
                        "description": "[string] In case the target NIC has multiple IP addresses, only traffic directed to the respective IP address of the NIC is allowed. Value null allows all target IPs.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "[string] The type of firewall rule. If is not specified, it will take the default value INGRESS.\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:compute/group:Group": {
            "description": "Manages **Groups** and **Group Privileges** on IonosCloud.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\nimport * as random from \"@pulumi/random\";\n\nconst user1Password = new random.RandomPassword(\"user1Password\", {\n    length: 16,\n    special: true,\n    overrideSpecial: \"!#$%\u0026*()-_=+[]{}\u003c\u003e:?\",\n});\nconst example1 = new ionoscloud.compute.User(\"example1\", {\n    firstName: \"user1\",\n    lastName: \"user1\",\n    email: \"unique_email.com\",\n    password: user1Password.result,\n    administrator: false,\n    forceSecAuth: false,\n});\nconst user2Password = new random.RandomPassword(\"user2Password\", {\n    length: 16,\n    special: true,\n    overrideSpecial: \"!#$%\u0026*()-_=+[]{}\u003c\u003e:?\",\n});\nconst example2 = new ionoscloud.compute.User(\"example2\", {\n    firstName: \"user2\",\n    lastName: \"user2\",\n    email: \"unique_email.com\",\n    password: user2Password.result,\n    administrator: false,\n    forceSecAuth: false,\n});\nconst example = new ionoscloud.compute.Group(\"example\", {\n    createDatacenter: true,\n    createSnapshot: true,\n    reserveIp: true,\n    accessActivityLog: true,\n    createPcc: true,\n    s3Privilege: true,\n    createBackupUnit: true,\n    createInternetAccess: true,\n    createK8sCluster: true,\n    createFlowLog: true,\n    accessAndManageMonitoring: true,\n    accessAndManageCertificates: true,\n    manageDbaas: true,\n    userIds: [\n        example1.id,\n        example2.id,\n    ],\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\nimport pulumi_random as random\n\nuser1_password = random.RandomPassword(\"user1Password\",\n    length=16,\n    special=True,\n    override_special=\"!#$%\u0026*()-_=+[]{}\u003c\u003e:?\")\nexample1 = ionoscloud.compute.User(\"example1\",\n    first_name=\"user1\",\n    last_name=\"user1\",\n    email=\"unique_email.com\",\n    password=user1_password.result,\n    administrator=False,\n    force_sec_auth=False)\nuser2_password = random.RandomPassword(\"user2Password\",\n    length=16,\n    special=True,\n    override_special=\"!#$%\u0026*()-_=+[]{}\u003c\u003e:?\")\nexample2 = ionoscloud.compute.User(\"example2\",\n    first_name=\"user2\",\n    last_name=\"user2\",\n    email=\"unique_email.com\",\n    password=user2_password.result,\n    administrator=False,\n    force_sec_auth=False)\nexample = ionoscloud.compute.Group(\"example\",\n    create_datacenter=True,\n    create_snapshot=True,\n    reserve_ip=True,\n    access_activity_log=True,\n    create_pcc=True,\n    s3_privilege=True,\n    create_backup_unit=True,\n    create_internet_access=True,\n    create_k8s_cluster=True,\n    create_flow_log=True,\n    access_and_manage_monitoring=True,\n    access_and_manage_certificates=True,\n    manage_dbaas=True,\n    user_ids=[\n        example1.id,\n        example2.id,\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\nusing Random = Pulumi.Random;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var user1Password = new Random.RandomPassword(\"user1Password\", new()\n    {\n        Length = 16,\n        Special = true,\n        OverrideSpecial = \"!#$%\u0026*()-_=+[]{}\u003c\u003e:?\",\n    });\n\n    var example1 = new Ionoscloud.Compute.User(\"example1\", new()\n    {\n        FirstName = \"user1\",\n        LastName = \"user1\",\n        Email = \"unique_email.com\",\n        Password = user1Password.Result,\n        Administrator = false,\n        ForceSecAuth = false,\n    });\n\n    var user2Password = new Random.RandomPassword(\"user2Password\", new()\n    {\n        Length = 16,\n        Special = true,\n        OverrideSpecial = \"!#$%\u0026*()-_=+[]{}\u003c\u003e:?\",\n    });\n\n    var example2 = new Ionoscloud.Compute.User(\"example2\", new()\n    {\n        FirstName = \"user2\",\n        LastName = \"user2\",\n        Email = \"unique_email.com\",\n        Password = user2Password.Result,\n        Administrator = false,\n        ForceSecAuth = false,\n    });\n\n    var example = new Ionoscloud.Compute.Group(\"example\", new()\n    {\n        CreateDatacenter = true,\n        CreateSnapshot = true,\n        ReserveIp = true,\n        AccessActivityLog = true,\n        CreatePcc = true,\n        S3Privilege = true,\n        CreateBackupUnit = true,\n        CreateInternetAccess = true,\n        CreateK8sCluster = true,\n        CreateFlowLog = true,\n        AccessAndManageMonitoring = true,\n        AccessAndManageCertificates = true,\n        ManageDbaas = true,\n        UserIds = new[]\n        {\n            example1.Id,\n            example2.Id,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi-random/sdk/v4/go/random\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tuser1Password, err := random.NewRandomPassword(ctx, \"user1Password\", \u0026random.RandomPasswordArgs{\n\t\t\tLength:          pulumi.Int(16),\n\t\t\tSpecial:         pulumi.Bool(true),\n\t\t\tOverrideSpecial: pulumi.String(\"!#$%\u0026*()-_=+[]{}\u003c\u003e:?\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texample1, err := compute.NewUser(ctx, \"example1\", \u0026compute.UserArgs{\n\t\t\tFirstName:     pulumi.String(\"user1\"),\n\t\t\tLastName:      pulumi.String(\"user1\"),\n\t\t\tEmail:         pulumi.String(\"unique_email.com\"),\n\t\t\tPassword:      user1Password.Result,\n\t\t\tAdministrator: pulumi.Bool(false),\n\t\t\tForceSecAuth:  pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tuser2Password, err := random.NewRandomPassword(ctx, \"user2Password\", \u0026random.RandomPasswordArgs{\n\t\t\tLength:          pulumi.Int(16),\n\t\t\tSpecial:         pulumi.Bool(true),\n\t\t\tOverrideSpecial: pulumi.String(\"!#$%\u0026*()-_=+[]{}\u003c\u003e:?\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texample2, err := compute.NewUser(ctx, \"example2\", \u0026compute.UserArgs{\n\t\t\tFirstName:     pulumi.String(\"user2\"),\n\t\t\tLastName:      pulumi.String(\"user2\"),\n\t\t\tEmail:         pulumi.String(\"unique_email.com\"),\n\t\t\tPassword:      user2Password.Result,\n\t\t\tAdministrator: pulumi.Bool(false),\n\t\t\tForceSecAuth:  pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = compute.NewGroup(ctx, \"example\", \u0026compute.GroupArgs{\n\t\t\tCreateDatacenter:            pulumi.Bool(true),\n\t\t\tCreateSnapshot:              pulumi.Bool(true),\n\t\t\tReserveIp:                   pulumi.Bool(true),\n\t\t\tAccessActivityLog:           pulumi.Bool(true),\n\t\t\tCreatePcc:                   pulumi.Bool(true),\n\t\t\tS3Privilege:                 pulumi.Bool(true),\n\t\t\tCreateBackupUnit:            pulumi.Bool(true),\n\t\t\tCreateInternetAccess:        pulumi.Bool(true),\n\t\t\tCreateK8sCluster:            pulumi.Bool(true),\n\t\t\tCreateFlowLog:               pulumi.Bool(true),\n\t\t\tAccessAndManageMonitoring:   pulumi.Bool(true),\n\t\t\tAccessAndManageCertificates: pulumi.Bool(true),\n\t\t\tManageDbaas:                 pulumi.Bool(true),\n\t\t\tUserIds: pulumi.StringArray{\n\t\t\t\texample1.ID(),\n\t\t\t\texample2.ID(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.random.RandomPassword;\nimport com.pulumi.random.RandomPasswordArgs;\nimport com.pulumi.ionoscloud.compute.User;\nimport com.pulumi.ionoscloud.compute.UserArgs;\nimport com.pulumi.ionoscloud.compute.Group;\nimport com.pulumi.ionoscloud.compute.GroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var user1Password = new RandomPassword(\"user1Password\", RandomPasswordArgs.builder()\n            .length(16)\n            .special(true)\n            .overrideSpecial(\"!#$%\u0026*()-_=+[]{}\u003c\u003e:?\")\n            .build());\n\n        var example1 = new User(\"example1\", UserArgs.builder()\n            .firstName(\"user1\")\n            .lastName(\"user1\")\n            .email(\"unique_email.com\")\n            .password(user1Password.result())\n            .administrator(false)\n            .forceSecAuth(false)\n            .build());\n\n        var user2Password = new RandomPassword(\"user2Password\", RandomPasswordArgs.builder()\n            .length(16)\n            .special(true)\n            .overrideSpecial(\"!#$%\u0026*()-_=+[]{}\u003c\u003e:?\")\n            .build());\n\n        var example2 = new User(\"example2\", UserArgs.builder()\n            .firstName(\"user2\")\n            .lastName(\"user2\")\n            .email(\"unique_email.com\")\n            .password(user2Password.result())\n            .administrator(false)\n            .forceSecAuth(false)\n            .build());\n\n        var example = new Group(\"example\", GroupArgs.builder()\n            .createDatacenter(true)\n            .createSnapshot(true)\n            .reserveIp(true)\n            .accessActivityLog(true)\n            .createPcc(true)\n            .s3Privilege(true)\n            .createBackupUnit(true)\n            .createInternetAccess(true)\n            .createK8sCluster(true)\n            .createFlowLog(true)\n            .accessAndManageMonitoring(true)\n            .accessAndManageCertificates(true)\n            .manageDbaas(true)\n            .userIds(            \n                example1.id(),\n                example2.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example1:\n    type: ionoscloud:compute:User\n    properties:\n      firstName: user1\n      lastName: user1\n      email: unique_email.com\n      password: ${user1Password.result}\n      administrator: false\n      forceSecAuth: false\n  example2:\n    type: ionoscloud:compute:User\n    properties:\n      firstName: user2\n      lastName: user2\n      email: unique_email.com\n      password: ${user2Password.result}\n      administrator: false\n      forceSecAuth: false\n  example:\n    type: ionoscloud:compute:Group\n    properties:\n      createDatacenter: true\n      createSnapshot: true\n      reserveIp: true\n      accessActivityLog: true\n      createPcc: true\n      s3Privilege: true\n      createBackupUnit: true\n      createInternetAccess: true\n      createK8sCluster: true\n      createFlowLog: true\n      accessAndManageMonitoring: true\n      accessAndManageCertificates: true\n      manageDbaas: true\n      userIds:\n        - ${example1.id}\n        - ${example2.id}\n  user1Password:\n    type: random:RandomPassword\n    properties:\n      length: 16\n      special: true\n      overrideSpecial: '!#$%\u0026*()-_=+[]{}\u003c\u003e:?'\n  user2Password:\n    type: random:RandomPassword\n    properties:\n      length: 16\n      special: true\n      overrideSpecial: '!#$%\u0026*()-_=+[]{}\u003c\u003e:?'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nResource Group can be imported using the `resource id`, e.g.\n\n```sh\n$ pulumi import ionoscloud:compute/group:Group mygroup {group uuid}\n```\n\n\u003e :warning: **If you are upgrading to v6.2.0**: You have to modify you plan for user_ids to match the new structure, by renaming the field old field, **user_id**, to user_ids and put the old value into an array. This is not backwards compatible.\n\n",
            "properties": {
                "accessActivityLog": {
                    "type": "boolean",
                    "description": "[Boolean] The group will be allowed to access the activity log.\n"
                },
                "accessAndManageCertificates": {
                    "type": "boolean",
                    "description": "[Boolean]  The group will be allowed to access and manage certificates.\n"
                },
                "accessAndManageMonitoring": {
                    "type": "boolean",
                    "description": "[Boolean]  The group will be allowed to access and manage monitoring.\n"
                },
                "createBackupUnit": {
                    "type": "boolean",
                    "description": "[Boolean] The group will be allowed to create backup unit privilege.\n"
                },
                "createDatacenter": {
                    "type": "boolean",
                    "description": "[Boolean] The group will be allowed to create virtual data centers.\n"
                },
                "createFlowLog": {
                    "type": "boolean",
                    "description": "[Boolean]  The group will be allowed to create flow log.\n"
                },
                "createInternetAccess": {
                    "type": "boolean",
                    "description": "[Boolean] The group will be allowed to create internet access privilege.\n"
                },
                "createK8sCluster": {
                    "type": "boolean",
                    "description": "[Boolean]  The group will be allowed to create kubernetes cluster privilege.\n"
                },
                "createPcc": {
                    "type": "boolean",
                    "description": "[Boolean] The group will be allowed to create Cross Connects privilege.\n"
                },
                "createSnapshot": {
                    "type": "boolean",
                    "description": "[Boolean] The group will be allowed to create snapshots.\n"
                },
                "manageDbaas": {
                    "type": "boolean",
                    "description": "[Boolean]  Privilege for a group to manage DBaaS related functionality.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] A name for the group.\n"
                },
                "reserveIp": {
                    "type": "boolean",
                    "description": "[Boolean] The group will be allowed to reserve IP addresses.\n"
                },
                "s3Privilege": {
                    "type": "boolean",
                    "description": "[Boolean] The group will have S3 privilege.\n"
                },
                "userId": {
                    "type": "string",
                    "description": "[string] The ID of the specific user to add to the group. Please use user_ids argument since this is **DEPRECATED**\n",
                    "deprecationMessage": "Please use user_ids for adding users to the group, since user_id will be removed in the future"
                },
                "userIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] A list of users to add to the group.\n"
                },
                "users": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:compute/GroupUser:GroupUser"
                    },
                    "description": "List of users - See the User section\n\n**NOTE:** user_id/user_ids field cannot be used at the same time with group_ids field in user resource. Trying to add the same user to the same group in both ways in the same plan will result in a cyclic dependency error.\n"
                }
            },
            "required": [
                "name",
                "users"
            ],
            "inputProperties": {
                "accessActivityLog": {
                    "type": "boolean",
                    "description": "[Boolean] The group will be allowed to access the activity log.\n"
                },
                "accessAndManageCertificates": {
                    "type": "boolean",
                    "description": "[Boolean]  The group will be allowed to access and manage certificates.\n"
                },
                "accessAndManageMonitoring": {
                    "type": "boolean",
                    "description": "[Boolean]  The group will be allowed to access and manage monitoring.\n"
                },
                "createBackupUnit": {
                    "type": "boolean",
                    "description": "[Boolean] The group will be allowed to create backup unit privilege.\n"
                },
                "createDatacenter": {
                    "type": "boolean",
                    "description": "[Boolean] The group will be allowed to create virtual data centers.\n"
                },
                "createFlowLog": {
                    "type": "boolean",
                    "description": "[Boolean]  The group will be allowed to create flow log.\n"
                },
                "createInternetAccess": {
                    "type": "boolean",
                    "description": "[Boolean] The group will be allowed to create internet access privilege.\n"
                },
                "createK8sCluster": {
                    "type": "boolean",
                    "description": "[Boolean]  The group will be allowed to create kubernetes cluster privilege.\n"
                },
                "createPcc": {
                    "type": "boolean",
                    "description": "[Boolean] The group will be allowed to create Cross Connects privilege.\n"
                },
                "createSnapshot": {
                    "type": "boolean",
                    "description": "[Boolean] The group will be allowed to create snapshots.\n"
                },
                "manageDbaas": {
                    "type": "boolean",
                    "description": "[Boolean]  Privilege for a group to manage DBaaS related functionality.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] A name for the group.\n"
                },
                "reserveIp": {
                    "type": "boolean",
                    "description": "[Boolean] The group will be allowed to reserve IP addresses.\n"
                },
                "s3Privilege": {
                    "type": "boolean",
                    "description": "[Boolean] The group will have S3 privilege.\n"
                },
                "userId": {
                    "type": "string",
                    "description": "[string] The ID of the specific user to add to the group. Please use user_ids argument since this is **DEPRECATED**\n",
                    "deprecationMessage": "Please use user_ids for adding users to the group, since user_id will be removed in the future"
                },
                "userIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] A list of users to add to the group.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Group resources.\n",
                "properties": {
                    "accessActivityLog": {
                        "type": "boolean",
                        "description": "[Boolean] The group will be allowed to access the activity log.\n"
                    },
                    "accessAndManageCertificates": {
                        "type": "boolean",
                        "description": "[Boolean]  The group will be allowed to access and manage certificates.\n"
                    },
                    "accessAndManageMonitoring": {
                        "type": "boolean",
                        "description": "[Boolean]  The group will be allowed to access and manage monitoring.\n"
                    },
                    "createBackupUnit": {
                        "type": "boolean",
                        "description": "[Boolean] The group will be allowed to create backup unit privilege.\n"
                    },
                    "createDatacenter": {
                        "type": "boolean",
                        "description": "[Boolean] The group will be allowed to create virtual data centers.\n"
                    },
                    "createFlowLog": {
                        "type": "boolean",
                        "description": "[Boolean]  The group will be allowed to create flow log.\n"
                    },
                    "createInternetAccess": {
                        "type": "boolean",
                        "description": "[Boolean] The group will be allowed to create internet access privilege.\n"
                    },
                    "createK8sCluster": {
                        "type": "boolean",
                        "description": "[Boolean]  The group will be allowed to create kubernetes cluster privilege.\n"
                    },
                    "createPcc": {
                        "type": "boolean",
                        "description": "[Boolean] The group will be allowed to create Cross Connects privilege.\n"
                    },
                    "createSnapshot": {
                        "type": "boolean",
                        "description": "[Boolean] The group will be allowed to create snapshots.\n"
                    },
                    "manageDbaas": {
                        "type": "boolean",
                        "description": "[Boolean]  Privilege for a group to manage DBaaS related functionality.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] A name for the group.\n"
                    },
                    "reserveIp": {
                        "type": "boolean",
                        "description": "[Boolean] The group will be allowed to reserve IP addresses.\n"
                    },
                    "s3Privilege": {
                        "type": "boolean",
                        "description": "[Boolean] The group will have S3 privilege.\n"
                    },
                    "userId": {
                        "type": "string",
                        "description": "[string] The ID of the specific user to add to the group. Please use user_ids argument since this is **DEPRECATED**\n",
                        "deprecationMessage": "Please use user_ids for adding users to the group, since user_id will be removed in the future"
                    },
                    "userIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "[list] A list of users to add to the group.\n"
                    },
                    "users": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:compute/GroupUser:GroupUser"
                        },
                        "description": "List of users - See the User section\n\n**NOTE:** user_id/user_ids field cannot be used at the same time with group_ids field in user resource. Trying to add the same user to the same group in both ways in the same plan will result in a cyclic dependency error.\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:compute/iPBlock:IPBlock": {
            "description": "Manages **IP Blocks** on IonosCloud. IP Blocks contain reserved public IP addresses that can be assigned servers or other resources.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = new ionoscloud.compute.IPBlock(\"example\", {\n    location: \"us/las\",\n    size: 1,\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\nexample = ionoscloud.compute.IPBlock(\"example\",\n    location=\"us/las\",\n    size=1)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Ionoscloud.Compute.IPBlock(\"example\", new()\n    {\n        Location = \"us/las\",\n        Size = 1,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := compute.NewIPBlock(ctx, \"example\", \u0026compute.IPBlockArgs{\n\t\t\tLocation: pulumi.String(\"us/las\"),\n\t\t\tSize:     pulumi.Int(1),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.IPBlock;\nimport com.pulumi.ionoscloud.compute.IPBlockArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new IPBlock(\"example\", IPBlockArgs.builder()\n            .location(\"us/las\")\n            .size(1)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: ionoscloud:compute:IPBlock\n    properties:\n      location: us/las\n      size: 1\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nResource Ipblock can be imported using the `resource id`, e.g.\n\n```sh\n$ pulumi import ionoscloud:compute/iPBlock:IPBlock myipblock {ipblock uuid}\n```\n\n",
            "properties": {
                "ipConsumers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:compute/IPBlockIpConsumer:IPBlockIpConsumer"
                    },
                    "description": "Read-Only attribute. Lists consumption detail of an individual ip\n"
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[integer] The list of IP addresses associated with this block.\n"
                },
                "location": {
                    "type": "string",
                    "description": "[string] The regional location for this IP Block: us/las, us/ewr, de/fra, de/fkb.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of Ip Block\n"
                },
                "size": {
                    "type": "integer",
                    "description": "[integer] The number of IP addresses to reserve for this block.\n"
                }
            },
            "required": [
                "ipConsumers",
                "ips",
                "location",
                "name",
                "size"
            ],
            "inputProperties": {
                "ipConsumers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:compute/IPBlockIpConsumer:IPBlockIpConsumer"
                    },
                    "description": "Read-Only attribute. Lists consumption detail of an individual ip\n"
                },
                "location": {
                    "type": "string",
                    "description": "[string] The regional location for this IP Block: us/las, us/ewr, de/fra, de/fkb.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of Ip Block\n"
                },
                "size": {
                    "type": "integer",
                    "description": "[integer] The number of IP addresses to reserve for this block.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "location",
                "size"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IPBlock resources.\n",
                "properties": {
                    "ipConsumers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:compute/IPBlockIpConsumer:IPBlockIpConsumer"
                        },
                        "description": "Read-Only attribute. Lists consumption detail of an individual ip\n"
                    },
                    "ips": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "[integer] The list of IP addresses associated with this block.\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "[string] The regional location for this IP Block: us/las, us/ewr, de/fra, de/fkb.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] The name of Ip Block\n"
                    },
                    "size": {
                        "type": "integer",
                        "description": "[integer] The number of IP addresses to reserve for this block.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:compute/iPFailover:IPFailover": {
            "description": "Manages **IP Failover** groups on IonosCloud.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\nimport * as random from \"@pulumi/random\";\n\nconst exampleDatacenter = new ionoscloud.compute.Datacenter(\"exampleDatacenter\", {\n    location: \"us/las\",\n    description: \"Datacenter Description\",\n    secAuthProtection: false,\n});\nconst exampleIPBlock = new ionoscloud.compute.IPBlock(\"exampleIPBlock\", {\n    location: \"us/las\",\n    size: 1,\n});\nconst exampleLan = new ionoscloud.compute.Lan(\"exampleLan\", {\n    datacenterId: exampleDatacenter.id,\n    \"public\": true,\n});\nconst serverImagePassword = new random.RandomPassword(\"serverImagePassword\", {\n    length: 16,\n    special: false,\n});\nconst exampleServer = new ionoscloud.compute.Server(\"exampleServer\", {\n    datacenterId: exampleDatacenter.id,\n    cores: 1,\n    ram: 1024,\n    availabilityZone: \"ZONE_1\",\n    cpuFamily: \"INTEL_XEON\",\n    imageName: \"Ubuntu-20.04\",\n    imagePassword: serverImagePassword.result,\n    volume: {\n        name: \"system\",\n        size: 14,\n        diskType: \"SSD\",\n    },\n    nic: {\n        lan: 1,\n        dhcp: true,\n        firewallActive: true,\n        ips: [exampleIPBlock.ips[0]],\n    },\n});\nconst exampleIPFailover = new ionoscloud.compute.IPFailover(\"exampleIPFailover\", {\n    datacenterId: exampleDatacenter.id,\n    lanId: exampleLan.id,\n    ip: exampleIPBlock.ips[0],\n    nicuuid: exampleServer.primaryNic,\n}, {\n    dependsOn: [exampleLan],\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\nimport pulumi_random as random\n\nexample_datacenter = ionoscloud.compute.Datacenter(\"exampleDatacenter\",\n    location=\"us/las\",\n    description=\"Datacenter Description\",\n    sec_auth_protection=False)\nexample_ip_block = ionoscloud.compute.IPBlock(\"exampleIPBlock\",\n    location=\"us/las\",\n    size=1)\nexample_lan = ionoscloud.compute.Lan(\"exampleLan\",\n    datacenter_id=example_datacenter.id,\n    public=True)\nserver_image_password = random.RandomPassword(\"serverImagePassword\",\n    length=16,\n    special=False)\nexample_server = ionoscloud.compute.Server(\"exampleServer\",\n    datacenter_id=example_datacenter.id,\n    cores=1,\n    ram=1024,\n    availability_zone=\"ZONE_1\",\n    cpu_family=\"INTEL_XEON\",\n    image_name=\"Ubuntu-20.04\",\n    image_password=server_image_password.result,\n    volume={\n        \"name\": \"system\",\n        \"size\": 14,\n        \"disk_type\": \"SSD\",\n    },\n    nic={\n        \"lan\": 1,\n        \"dhcp\": True,\n        \"firewall_active\": True,\n        \"ips\": [example_ip_block.ips[0]],\n    })\nexample_ip_failover = ionoscloud.compute.IPFailover(\"exampleIPFailover\",\n    datacenter_id=example_datacenter.id,\n    lan_id=example_lan.id,\n    ip=example_ip_block.ips[0],\n    nicuuid=example_server.primary_nic,\n    opts = pulumi.ResourceOptions(depends_on=[example_lan]))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\nusing Random = Pulumi.Random;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleDatacenter = new Ionoscloud.Compute.Datacenter(\"exampleDatacenter\", new()\n    {\n        Location = \"us/las\",\n        Description = \"Datacenter Description\",\n        SecAuthProtection = false,\n    });\n\n    var exampleIPBlock = new Ionoscloud.Compute.IPBlock(\"exampleIPBlock\", new()\n    {\n        Location = \"us/las\",\n        Size = 1,\n    });\n\n    var exampleLan = new Ionoscloud.Compute.Lan(\"exampleLan\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        Public = true,\n    });\n\n    var serverImagePassword = new Random.RandomPassword(\"serverImagePassword\", new()\n    {\n        Length = 16,\n        Special = false,\n    });\n\n    var exampleServer = new Ionoscloud.Compute.Server(\"exampleServer\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        Cores = 1,\n        Ram = 1024,\n        AvailabilityZone = \"ZONE_1\",\n        CpuFamily = \"INTEL_XEON\",\n        ImageName = \"Ubuntu-20.04\",\n        ImagePassword = serverImagePassword.Result,\n        Volume = new Ionoscloud.Compute.Inputs.ServerVolumeArgs\n        {\n            Name = \"system\",\n            Size = 14,\n            DiskType = \"SSD\",\n        },\n        Nic = new Ionoscloud.Compute.Inputs.ServerNicArgs\n        {\n            Lan = 1,\n            Dhcp = true,\n            FirewallActive = true,\n            Ips = new[]\n            {\n                exampleIPBlock.Ips.Apply(ips =\u003e ips[0]),\n            },\n        },\n    });\n\n    var exampleIPFailover = new Ionoscloud.Compute.IPFailover(\"exampleIPFailover\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        LanId = exampleLan.Id,\n        Ip = exampleIPBlock.Ips.Apply(ips =\u003e ips[0]),\n        Nicuuid = exampleServer.PrimaryNic,\n    }, new CustomResourceOptions\n    {\n        DependsOn =\n        {\n            exampleLan,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi-random/sdk/v4/go/random\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleDatacenter, err := compute.NewDatacenter(ctx, \"exampleDatacenter\", \u0026compute.DatacenterArgs{\n\t\t\tLocation:          pulumi.String(\"us/las\"),\n\t\t\tDescription:       pulumi.String(\"Datacenter Description\"),\n\t\t\tSecAuthProtection: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleIPBlock, err := compute.NewIPBlock(ctx, \"exampleIPBlock\", \u0026compute.IPBlockArgs{\n\t\t\tLocation: pulumi.String(\"us/las\"),\n\t\t\tSize:     pulumi.Int(1),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleLan, err := compute.NewLan(ctx, \"exampleLan\", \u0026compute.LanArgs{\n\t\t\tDatacenterId: exampleDatacenter.ID(),\n\t\t\tPublic:       pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tserverImagePassword, err := random.NewRandomPassword(ctx, \"serverImagePassword\", \u0026random.RandomPasswordArgs{\n\t\t\tLength:  pulumi.Int(16),\n\t\t\tSpecial: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleServer, err := compute.NewServer(ctx, \"exampleServer\", \u0026compute.ServerArgs{\n\t\t\tDatacenterId:     exampleDatacenter.ID(),\n\t\t\tCores:            pulumi.Int(1),\n\t\t\tRam:              pulumi.Int(1024),\n\t\t\tAvailabilityZone: pulumi.String(\"ZONE_1\"),\n\t\t\tCpuFamily:        pulumi.String(\"INTEL_XEON\"),\n\t\t\tImageName:        pulumi.String(\"Ubuntu-20.04\"),\n\t\t\tImagePassword:    serverImagePassword.Result,\n\t\t\tVolume: \u0026compute.ServerVolumeArgs{\n\t\t\t\tName:     pulumi.String(\"system\"),\n\t\t\t\tSize:     pulumi.Int(14),\n\t\t\t\tDiskType: pulumi.String(\"SSD\"),\n\t\t\t},\n\t\t\tNic: \u0026compute.ServerNicArgs{\n\t\t\t\tLan:            pulumi.Int(1),\n\t\t\t\tDhcp:           pulumi.Bool(true),\n\t\t\t\tFirewallActive: pulumi.Bool(true),\n\t\t\t\tIps: pulumi.StringArray{\n\t\t\t\t\texampleIPBlock.Ips.ApplyT(func(ips []string) (string, error) {\n\t\t\t\t\t\treturn ips[0], nil\n\t\t\t\t\t}).(pulumi.StringOutput),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = compute.NewIPFailover(ctx, \"exampleIPFailover\", \u0026compute.IPFailoverArgs{\n\t\t\tDatacenterId: exampleDatacenter.ID(),\n\t\t\tLanId:        exampleLan.ID(),\n\t\t\tIp: exampleIPBlock.Ips.ApplyT(func(ips []string) (string, error) {\n\t\t\t\treturn ips[0], nil\n\t\t\t}).(pulumi.StringOutput),\n\t\t\tNicuuid: exampleServer.PrimaryNic,\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\texampleLan,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.Datacenter;\nimport com.pulumi.ionoscloud.compute.DatacenterArgs;\nimport com.pulumi.ionoscloud.compute.IPBlock;\nimport com.pulumi.ionoscloud.compute.IPBlockArgs;\nimport com.pulumi.ionoscloud.compute.Lan;\nimport com.pulumi.ionoscloud.compute.LanArgs;\nimport com.pulumi.random.RandomPassword;\nimport com.pulumi.random.RandomPasswordArgs;\nimport com.pulumi.ionoscloud.compute.Server;\nimport com.pulumi.ionoscloud.compute.ServerArgs;\nimport com.pulumi.ionoscloud.compute.inputs.ServerVolumeArgs;\nimport com.pulumi.ionoscloud.compute.inputs.ServerNicArgs;\nimport com.pulumi.ionoscloud.compute.IPFailover;\nimport com.pulumi.ionoscloud.compute.IPFailoverArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleDatacenter = new Datacenter(\"exampleDatacenter\", DatacenterArgs.builder()\n            .location(\"us/las\")\n            .description(\"Datacenter Description\")\n            .secAuthProtection(false)\n            .build());\n\n        var exampleIPBlock = new IPBlock(\"exampleIPBlock\", IPBlockArgs.builder()\n            .location(\"us/las\")\n            .size(1)\n            .build());\n\n        var exampleLan = new Lan(\"exampleLan\", LanArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .public_(true)\n            .build());\n\n        var serverImagePassword = new RandomPassword(\"serverImagePassword\", RandomPasswordArgs.builder()\n            .length(16)\n            .special(false)\n            .build());\n\n        var exampleServer = new Server(\"exampleServer\", ServerArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .cores(1)\n            .ram(1024)\n            .availabilityZone(\"ZONE_1\")\n            .cpuFamily(\"INTEL_XEON\")\n            .imageName(\"Ubuntu-20.04\")\n            .imagePassword(serverImagePassword.result())\n            .volume(ServerVolumeArgs.builder()\n                .name(\"system\")\n                .size(14)\n                .diskType(\"SSD\")\n                .build())\n            .nic(ServerNicArgs.builder()\n                .lan(\"1\")\n                .dhcp(true)\n                .firewallActive(true)\n                .ips(exampleIPBlock.ips().applyValue(ips -\u003e ips[0]))\n                .build())\n            .build());\n\n        var exampleIPFailover = new IPFailover(\"exampleIPFailover\", IPFailoverArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .lanId(exampleLan.id())\n            .ip(exampleIPBlock.ips().applyValue(ips -\u003e ips[0]))\n            .nicuuid(exampleServer.primaryNic())\n            .build(), CustomResourceOptions.builder()\n                .dependsOn(exampleLan)\n                .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleDatacenter:\n    type: ionoscloud:compute:Datacenter\n    properties:\n      location: us/las\n      description: Datacenter Description\n      secAuthProtection: false\n  exampleIPBlock:\n    type: ionoscloud:compute:IPBlock\n    properties:\n      location: us/las\n      size: 1\n  exampleLan:\n    type: ionoscloud:compute:Lan\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      public: true\n  exampleServer:\n    type: ionoscloud:compute:Server\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      cores: 1\n      ram: 1024\n      availabilityZone: ZONE_1\n      cpuFamily: INTEL_XEON\n      imageName: Ubuntu-20.04\n      imagePassword: ${serverImagePassword.result}\n      volume:\n        name: system\n        size: 14\n        diskType: SSD\n      nic:\n        lan: '1'\n        dhcp: true\n        firewallActive: true\n        ips:\n          - ${exampleIPBlock.ips[0]}\n  exampleIPFailover:\n    type: ionoscloud:compute:IPFailover\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      lanId: ${exampleLan.id}\n      ip: ${exampleIPBlock.ips[0]}\n      nicuuid: ${exampleServer.primaryNic}\n    options:\n      dependsOn:\n        - ${exampleLan}\n  serverImagePassword:\n    type: random:RandomPassword\n    properties:\n      length: 16\n      special: false\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## A note on multiple NICs on an IP Failover\n\nIf you want to add a secondary NIC to an IP Failover, follow these steps:\n1) Creating NIC A with failover IP on LAN 1\n2) Create NIC B unde the same LAN but with a different IP\n3) Create the IP Failover on LAN 1 with NIC A and failover IP of NIC A (A becomes now \"master\", no slaves)\n4) Update NIC B IP to be the failover IP ( B becomes now a slave, A remains master)\n\nAfter this you can create a new NIC C, NIC D and so on, in LAN 1, directly with the failover IP.\n\nPlease check examples for a full example with the above steps.\n\n## Import\n\nResource IpFailover can be imported using the `resource id`, e.g.\n\n```sh\n$ pulumi import ionoscloud:compute/iPFailover:IPFailover myipfailover {datacenter uuid}/{lan uuid}\n```\n\n",
            "properties": {
                "datacenterId": {
                    "type": "string",
                    "description": "[string] The ID of a Virtual Data Center.\n"
                },
                "ip": {
                    "type": "string",
                    "description": "[string] The reserved IP address to be used in the IP failover group.\n"
                },
                "lanId": {
                    "type": "string",
                    "description": "[string] The ID of a LAN.\n"
                },
                "nicuuid": {
                    "type": "string",
                    "description": "The UUID of the master NIC\n"
                }
            },
            "required": [
                "datacenterId",
                "ip",
                "lanId",
                "nicuuid"
            ],
            "inputProperties": {
                "datacenterId": {
                    "type": "string",
                    "description": "[string] The ID of a Virtual Data Center.\n",
                    "willReplaceOnChanges": true
                },
                "ip": {
                    "type": "string",
                    "description": "[string] The reserved IP address to be used in the IP failover group.\n",
                    "willReplaceOnChanges": true
                },
                "lanId": {
                    "type": "string",
                    "description": "[string] The ID of a LAN.\n",
                    "willReplaceOnChanges": true
                },
                "nicuuid": {
                    "type": "string",
                    "description": "The UUID of the master NIC\n"
                }
            },
            "requiredInputs": [
                "datacenterId",
                "ip",
                "lanId",
                "nicuuid"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IPFailover resources.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "[string] The ID of a Virtual Data Center.\n",
                        "willReplaceOnChanges": true
                    },
                    "ip": {
                        "type": "string",
                        "description": "[string] The reserved IP address to be used in the IP failover group.\n",
                        "willReplaceOnChanges": true
                    },
                    "lanId": {
                        "type": "string",
                        "description": "[string] The ID of a LAN.\n",
                        "willReplaceOnChanges": true
                    },
                    "nicuuid": {
                        "type": "string",
                        "description": "The UUID of the master NIC\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:compute/lan:Lan": {
            "description": "Manages a **LAN** on IonosCloud.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst exampleDatacenter = new ionoscloud.compute.Datacenter(\"exampleDatacenter\", {\n    location: \"us/las\",\n    description: \"Datacenter Description\",\n    secAuthProtection: false,\n});\nconst exampleCrossconnect = new ionoscloud.compute.Crossconnect(\"exampleCrossconnect\", {description: \"Cross Connect Description\"});\nconst exampleLan = new ionoscloud.compute.Lan(\"exampleLan\", {\n    datacenterId: exampleDatacenter.id,\n    \"public\": false,\n    pcc: exampleCrossconnect.id,\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\nexample_datacenter = ionoscloud.compute.Datacenter(\"exampleDatacenter\",\n    location=\"us/las\",\n    description=\"Datacenter Description\",\n    sec_auth_protection=False)\nexample_crossconnect = ionoscloud.compute.Crossconnect(\"exampleCrossconnect\", description=\"Cross Connect Description\")\nexample_lan = ionoscloud.compute.Lan(\"exampleLan\",\n    datacenter_id=example_datacenter.id,\n    public=False,\n    pcc=example_crossconnect.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleDatacenter = new Ionoscloud.Compute.Datacenter(\"exampleDatacenter\", new()\n    {\n        Location = \"us/las\",\n        Description = \"Datacenter Description\",\n        SecAuthProtection = false,\n    });\n\n    var exampleCrossconnect = new Ionoscloud.Compute.Crossconnect(\"exampleCrossconnect\", new()\n    {\n        Description = \"Cross Connect Description\",\n    });\n\n    var exampleLan = new Ionoscloud.Compute.Lan(\"exampleLan\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        Public = false,\n        Pcc = exampleCrossconnect.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleDatacenter, err := compute.NewDatacenter(ctx, \"exampleDatacenter\", \u0026compute.DatacenterArgs{\n\t\t\tLocation:          pulumi.String(\"us/las\"),\n\t\t\tDescription:       pulumi.String(\"Datacenter Description\"),\n\t\t\tSecAuthProtection: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleCrossconnect, err := compute.NewCrossconnect(ctx, \"exampleCrossconnect\", \u0026compute.CrossconnectArgs{\n\t\t\tDescription: pulumi.String(\"Cross Connect Description\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = compute.NewLan(ctx, \"exampleLan\", \u0026compute.LanArgs{\n\t\t\tDatacenterId: exampleDatacenter.ID(),\n\t\t\tPublic:       pulumi.Bool(false),\n\t\t\tPcc:          exampleCrossconnect.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.Datacenter;\nimport com.pulumi.ionoscloud.compute.DatacenterArgs;\nimport com.pulumi.ionoscloud.compute.Crossconnect;\nimport com.pulumi.ionoscloud.compute.CrossconnectArgs;\nimport com.pulumi.ionoscloud.compute.Lan;\nimport com.pulumi.ionoscloud.compute.LanArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleDatacenter = new Datacenter(\"exampleDatacenter\", DatacenterArgs.builder()\n            .location(\"us/las\")\n            .description(\"Datacenter Description\")\n            .secAuthProtection(false)\n            .build());\n\n        var exampleCrossconnect = new Crossconnect(\"exampleCrossconnect\", CrossconnectArgs.builder()\n            .description(\"Cross Connect Description\")\n            .build());\n\n        var exampleLan = new Lan(\"exampleLan\", LanArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .public_(false)\n            .pcc(exampleCrossconnect.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleDatacenter:\n    type: ionoscloud:compute:Datacenter\n    properties:\n      location: us/las\n      description: Datacenter Description\n      secAuthProtection: false\n  exampleCrossconnect:\n    type: ionoscloud:compute:Crossconnect\n    properties:\n      description: Cross Connect Description\n  exampleLan:\n    type: ionoscloud:compute:Lan\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      public: false\n      pcc: ${exampleCrossconnect.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### With IPv6 Enabled\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst exampleDatacenter = new ionoscloud.compute.Datacenter(\"exampleDatacenter\", {\n    location: \"de/txl\",\n    description: \"Datacenter Description\",\n    secAuthProtection: false,\n});\nconst exampleLan = new ionoscloud.compute.Lan(\"exampleLan\", {\n    datacenterId: exampleDatacenter.id,\n    \"public\": true,\n    ipv6CidrBlock: \"AUTO\",\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\nexample_datacenter = ionoscloud.compute.Datacenter(\"exampleDatacenter\",\n    location=\"de/txl\",\n    description=\"Datacenter Description\",\n    sec_auth_protection=False)\nexample_lan = ionoscloud.compute.Lan(\"exampleLan\",\n    datacenter_id=example_datacenter.id,\n    public=True,\n    ipv6_cidr_block=\"AUTO\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleDatacenter = new Ionoscloud.Compute.Datacenter(\"exampleDatacenter\", new()\n    {\n        Location = \"de/txl\",\n        Description = \"Datacenter Description\",\n        SecAuthProtection = false,\n    });\n\n    var exampleLan = new Ionoscloud.Compute.Lan(\"exampleLan\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        Public = true,\n        Ipv6CidrBlock = \"AUTO\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleDatacenter, err := compute.NewDatacenter(ctx, \"exampleDatacenter\", \u0026compute.DatacenterArgs{\n\t\t\tLocation:          pulumi.String(\"de/txl\"),\n\t\t\tDescription:       pulumi.String(\"Datacenter Description\"),\n\t\t\tSecAuthProtection: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = compute.NewLan(ctx, \"exampleLan\", \u0026compute.LanArgs{\n\t\t\tDatacenterId:  exampleDatacenter.ID(),\n\t\t\tPublic:        pulumi.Bool(true),\n\t\t\tIpv6CidrBlock: pulumi.String(\"AUTO\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.Datacenter;\nimport com.pulumi.ionoscloud.compute.DatacenterArgs;\nimport com.pulumi.ionoscloud.compute.Lan;\nimport com.pulumi.ionoscloud.compute.LanArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleDatacenter = new Datacenter(\"exampleDatacenter\", DatacenterArgs.builder()\n            .location(\"de/txl\")\n            .description(\"Datacenter Description\")\n            .secAuthProtection(false)\n            .build());\n\n        var exampleLan = new Lan(\"exampleLan\", LanArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .public_(true)\n            .ipv6CidrBlock(\"AUTO\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleDatacenter:\n    type: ionoscloud:compute:Datacenter\n    properties:\n      location: de/txl\n      description: Datacenter Description\n      secAuthProtection: false\n  exampleLan:\n    type: ionoscloud:compute:Lan\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      public: true\n      ipv6CidrBlock: AUTO\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Important Notes\n\n- Please note that only LANs datacenters found in the same physical location can be connected through a Cross-connect\n- A LAN cannot be a part of two Cross-connects\n\n## Import\n\nResource Lan can be imported using the `resource id`, e.g.\n\n```sh\n$ pulumi import ionoscloud:compute/lan:Lan mylan {datacenter uuid}/{lan id}\n```\n\n",
            "properties": {
                "datacenterId": {
                    "type": "string",
                    "description": "[string] The ID of a Virtual Data Center.\n"
                },
                "ipFailovers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:compute/LanIpFailover:LanIpFailover"
                    },
                    "description": "IP failover configurations for lan\n"
                },
                "ipv6CidrBlock": {
                    "type": "string",
                    "description": "Contains the LAN's /64 IPv6 CIDR block if this LAN is IPv6 enabled. 'AUTO' will result in enabling this LAN for IPv6 and automatically assign a /64 IPv6 CIDR block to this LAN. If you specify your own IPv6 CIDR block then you must provide a unique /64 block, which is inside the IPv6 CIDR block of the virtual datacenter and unique inside all LANs from this virtual datacenter.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the LAN.\n"
                },
                "pcc": {
                    "type": "string",
                    "description": "[String] The unique id of a `ionoscloud.compute.Crossconnect` resource, in order. It needs to be ensured that IP addresses of the NICs of all LANs connected to a given Cross Connect is not duplicated and belongs to the same subnet range\n"
                },
                "public": {
                    "type": "boolean",
                    "description": "[Boolean] Indicates if the LAN faces the public Internet (true) or not (false).\n"
                }
            },
            "required": [
                "datacenterId",
                "ipFailovers",
                "ipv6CidrBlock",
                "name"
            ],
            "inputProperties": {
                "datacenterId": {
                    "type": "string",
                    "description": "[string] The ID of a Virtual Data Center.\n",
                    "willReplaceOnChanges": true
                },
                "ipFailovers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:compute/LanIpFailover:LanIpFailover"
                    },
                    "description": "IP failover configurations for lan\n"
                },
                "ipv6CidrBlock": {
                    "type": "string",
                    "description": "Contains the LAN's /64 IPv6 CIDR block if this LAN is IPv6 enabled. 'AUTO' will result in enabling this LAN for IPv6 and automatically assign a /64 IPv6 CIDR block to this LAN. If you specify your own IPv6 CIDR block then you must provide a unique /64 block, which is inside the IPv6 CIDR block of the virtual datacenter and unique inside all LANs from this virtual datacenter.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the LAN.\n"
                },
                "pcc": {
                    "type": "string",
                    "description": "[String] The unique id of a `ionoscloud.compute.Crossconnect` resource, in order. It needs to be ensured that IP addresses of the NICs of all LANs connected to a given Cross Connect is not duplicated and belongs to the same subnet range\n"
                },
                "public": {
                    "type": "boolean",
                    "description": "[Boolean] Indicates if the LAN faces the public Internet (true) or not (false).\n"
                }
            },
            "requiredInputs": [
                "datacenterId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Lan resources.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "[string] The ID of a Virtual Data Center.\n",
                        "willReplaceOnChanges": true
                    },
                    "ipFailovers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:compute/LanIpFailover:LanIpFailover"
                        },
                        "description": "IP failover configurations for lan\n"
                    },
                    "ipv6CidrBlock": {
                        "type": "string",
                        "description": "Contains the LAN's /64 IPv6 CIDR block if this LAN is IPv6 enabled. 'AUTO' will result in enabling this LAN for IPv6 and automatically assign a /64 IPv6 CIDR block to this LAN. If you specify your own IPv6 CIDR block then you must provide a unique /64 block, which is inside the IPv6 CIDR block of the virtual datacenter and unique inside all LANs from this virtual datacenter.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] The name of the LAN.\n"
                    },
                    "pcc": {
                        "type": "string",
                        "description": "[String] The unique id of a `ionoscloud.compute.Crossconnect` resource, in order. It needs to be ensured that IP addresses of the NICs of all LANs connected to a given Cross Connect is not duplicated and belongs to the same subnet range\n"
                    },
                    "public": {
                        "type": "boolean",
                        "description": "[Boolean] Indicates if the LAN faces the public Internet (true) or not (false).\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:compute/natGateway:NatGateway": {
            "description": "Manages a **Nat Gateway** on IonosCloud.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst exampleDatacenter = new ionoscloud.compute.Datacenter(\"exampleDatacenter\", {\n    location: \"us/las\",\n    description: \"Datacenter Description\",\n    secAuthProtection: false,\n});\nconst exampleIPBlock = new ionoscloud.compute.IPBlock(\"exampleIPBlock\", {\n    location: \"us/las\",\n    size: 2,\n});\nconst exampleLan = new ionoscloud.compute.Lan(\"exampleLan\", {\n    datacenterId: exampleDatacenter.id,\n    \"public\": true,\n});\nconst exampleNatGateway = new ionoscloud.compute.NatGateway(\"exampleNatGateway\", {\n    datacenterId: exampleDatacenter.id,\n    publicIps: [\n        exampleIPBlock.ips[0],\n        exampleIPBlock.ips[1],\n    ],\n    lans: [{\n        id: exampleLan.id,\n        gatewayIps: [\"10.11.2.5\"],\n    }],\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\nexample_datacenter = ionoscloud.compute.Datacenter(\"exampleDatacenter\",\n    location=\"us/las\",\n    description=\"Datacenter Description\",\n    sec_auth_protection=False)\nexample_ip_block = ionoscloud.compute.IPBlock(\"exampleIPBlock\",\n    location=\"us/las\",\n    size=2)\nexample_lan = ionoscloud.compute.Lan(\"exampleLan\",\n    datacenter_id=example_datacenter.id,\n    public=True)\nexample_nat_gateway = ionoscloud.compute.NatGateway(\"exampleNatGateway\",\n    datacenter_id=example_datacenter.id,\n    public_ips=[\n        example_ip_block.ips[0],\n        example_ip_block.ips[1],\n    ],\n    lans=[{\n        \"id\": example_lan.id,\n        \"gateway_ips\": [\"10.11.2.5\"],\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleDatacenter = new Ionoscloud.Compute.Datacenter(\"exampleDatacenter\", new()\n    {\n        Location = \"us/las\",\n        Description = \"Datacenter Description\",\n        SecAuthProtection = false,\n    });\n\n    var exampleIPBlock = new Ionoscloud.Compute.IPBlock(\"exampleIPBlock\", new()\n    {\n        Location = \"us/las\",\n        Size = 2,\n    });\n\n    var exampleLan = new Ionoscloud.Compute.Lan(\"exampleLan\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        Public = true,\n    });\n\n    var exampleNatGateway = new Ionoscloud.Compute.NatGateway(\"exampleNatGateway\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        PublicIps = new[]\n        {\n            exampleIPBlock.Ips.Apply(ips =\u003e ips[0]),\n            exampleIPBlock.Ips.Apply(ips =\u003e ips[1]),\n        },\n        Lans = new[]\n        {\n            new Ionoscloud.Compute.Inputs.NatGatewayLanArgs\n            {\n                Id = exampleLan.Id,\n                GatewayIps = new[]\n                {\n                    \"10.11.2.5\",\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleDatacenter, err := compute.NewDatacenter(ctx, \"exampleDatacenter\", \u0026compute.DatacenterArgs{\n\t\t\tLocation:          pulumi.String(\"us/las\"),\n\t\t\tDescription:       pulumi.String(\"Datacenter Description\"),\n\t\t\tSecAuthProtection: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleIPBlock, err := compute.NewIPBlock(ctx, \"exampleIPBlock\", \u0026compute.IPBlockArgs{\n\t\t\tLocation: pulumi.String(\"us/las\"),\n\t\t\tSize:     pulumi.Int(2),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleLan, err := compute.NewLan(ctx, \"exampleLan\", \u0026compute.LanArgs{\n\t\t\tDatacenterId: exampleDatacenter.ID(),\n\t\t\tPublic:       pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = compute.NewNatGateway(ctx, \"exampleNatGateway\", \u0026compute.NatGatewayArgs{\n\t\t\tDatacenterId: exampleDatacenter.ID(),\n\t\t\tPublicIps: pulumi.StringArray{\n\t\t\t\texampleIPBlock.Ips.ApplyT(func(ips []string) (string, error) {\n\t\t\t\t\treturn ips[0], nil\n\t\t\t\t}).(pulumi.StringOutput),\n\t\t\t\texampleIPBlock.Ips.ApplyT(func(ips []string) (string, error) {\n\t\t\t\t\treturn ips[1], nil\n\t\t\t\t}).(pulumi.StringOutput),\n\t\t\t},\n\t\t\tLans: compute.NatGatewayLanArray{\n\t\t\t\t\u0026compute.NatGatewayLanArgs{\n\t\t\t\t\tId: exampleLan.ID(),\n\t\t\t\t\tGatewayIps: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"10.11.2.5\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.Datacenter;\nimport com.pulumi.ionoscloud.compute.DatacenterArgs;\nimport com.pulumi.ionoscloud.compute.IPBlock;\nimport com.pulumi.ionoscloud.compute.IPBlockArgs;\nimport com.pulumi.ionoscloud.compute.Lan;\nimport com.pulumi.ionoscloud.compute.LanArgs;\nimport com.pulumi.ionoscloud.compute.NatGateway;\nimport com.pulumi.ionoscloud.compute.NatGatewayArgs;\nimport com.pulumi.ionoscloud.compute.inputs.NatGatewayLanArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleDatacenter = new Datacenter(\"exampleDatacenter\", DatacenterArgs.builder()\n            .location(\"us/las\")\n            .description(\"Datacenter Description\")\n            .secAuthProtection(false)\n            .build());\n\n        var exampleIPBlock = new IPBlock(\"exampleIPBlock\", IPBlockArgs.builder()\n            .location(\"us/las\")\n            .size(2)\n            .build());\n\n        var exampleLan = new Lan(\"exampleLan\", LanArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .public_(true)\n            .build());\n\n        var exampleNatGateway = new NatGateway(\"exampleNatGateway\", NatGatewayArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .publicIps(            \n                exampleIPBlock.ips().applyValue(ips -\u003e ips[0]),\n                exampleIPBlock.ips().applyValue(ips -\u003e ips[1]))\n            .lans(NatGatewayLanArgs.builder()\n                .id(exampleLan.id())\n                .gatewayIps(\"10.11.2.5\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleDatacenter:\n    type: ionoscloud:compute:Datacenter\n    properties:\n      location: us/las\n      description: Datacenter Description\n      secAuthProtection: false\n  exampleIPBlock:\n    type: ionoscloud:compute:IPBlock\n    properties:\n      location: us/las\n      size: 2\n  exampleLan:\n    type: ionoscloud:compute:Lan\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      public: true\n  exampleNatGateway:\n    type: ionoscloud:compute:NatGateway\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      publicIps:\n        - ${exampleIPBlock.ips[0]}\n        - ${exampleIPBlock.ips[1]}\n      lans:\n        - id: ${exampleLan.id}\n          gatewayIps:\n            - 10.11.2.5\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nA Nat Gateway resource can be imported using its `resource id` and the `datacenter id`, e.g.\n\n```sh\n$ pulumi import ionoscloud:compute/natGateway:NatGateway my_natgateway {datacenter uuid}/{nat gateway uuid}\n```\n\n",
            "properties": {
                "datacenterId": {
                    "type": "string",
                    "description": "[string] A Datacenter's UUID.\n"
                },
                "lans": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:compute/NatGatewayLan:NatGatewayLan"
                    },
                    "description": "[list] A list of Local Area Networks the node pool should be part of.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] Name of the NAT gateway.\n"
                },
                "publicIps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list]Collection of public IP addresses of the NAT gateway. Should be customer reserved IP addresses in that location.\n"
                }
            },
            "required": [
                "datacenterId",
                "lans",
                "name",
                "publicIps"
            ],
            "inputProperties": {
                "datacenterId": {
                    "type": "string",
                    "description": "[string] A Datacenter's UUID.\n",
                    "willReplaceOnChanges": true
                },
                "lans": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:compute/NatGatewayLan:NatGatewayLan"
                    },
                    "description": "[list] A list of Local Area Networks the node pool should be part of.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] Name of the NAT gateway.\n"
                },
                "publicIps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list]Collection of public IP addresses of the NAT gateway. Should be customer reserved IP addresses in that location.\n"
                }
            },
            "requiredInputs": [
                "datacenterId",
                "lans",
                "publicIps"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NatGateway resources.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "[string] A Datacenter's UUID.\n",
                        "willReplaceOnChanges": true
                    },
                    "lans": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:compute/NatGatewayLan:NatGatewayLan"
                        },
                        "description": "[list] A list of Local Area Networks the node pool should be part of.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] Name of the NAT gateway.\n"
                    },
                    "publicIps": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "[list]Collection of public IP addresses of the NAT gateway. Should be customer reserved IP addresses in that location.\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:compute/natGatewayRule:NatGatewayRule": {
            "description": "Manages a **Nat Gateway Rule** on IonosCloud.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst exampleDatacenter = new ionoscloud.compute.Datacenter(\"exampleDatacenter\", {\n    location: \"us/las\",\n    description: \"Datacenter Description\",\n    secAuthProtection: false,\n});\nconst exampleIPBlock = new ionoscloud.compute.IPBlock(\"exampleIPBlock\", {\n    location: \"us/las\",\n    size: 2,\n});\nconst exampleLan = new ionoscloud.compute.Lan(\"exampleLan\", {\n    datacenterId: exampleDatacenter.id,\n    \"public\": true,\n});\nconst exampleNatGateway = new ionoscloud.compute.NatGateway(\"exampleNatGateway\", {\n    datacenterId: exampleDatacenter.id,\n    publicIps: [\n        exampleIPBlock.ips[0],\n        exampleIPBlock.ips[1],\n    ],\n    lans: [{\n        id: exampleLan.id,\n        gatewayIps: [\"10.11.2.5\"],\n    }],\n});\nconst exampleNatGatewayRule = new ionoscloud.compute.NatGatewayRule(\"exampleNatGatewayRule\", {\n    datacenterId: exampleDatacenter.id,\n    natgatewayId: exampleNatGateway.id,\n    type: \"SNAT\",\n    protocol: \"TCP\",\n    sourceSubnet: \"10.0.1.0/24\",\n    publicIp: exampleIPBlock.ips[0],\n    targetSubnet: \"10.0.1.0/24\",\n    targetPortRange: {\n        start: 500,\n        end: 1000,\n    },\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\nexample_datacenter = ionoscloud.compute.Datacenter(\"exampleDatacenter\",\n    location=\"us/las\",\n    description=\"Datacenter Description\",\n    sec_auth_protection=False)\nexample_ip_block = ionoscloud.compute.IPBlock(\"exampleIPBlock\",\n    location=\"us/las\",\n    size=2)\nexample_lan = ionoscloud.compute.Lan(\"exampleLan\",\n    datacenter_id=example_datacenter.id,\n    public=True)\nexample_nat_gateway = ionoscloud.compute.NatGateway(\"exampleNatGateway\",\n    datacenter_id=example_datacenter.id,\n    public_ips=[\n        example_ip_block.ips[0],\n        example_ip_block.ips[1],\n    ],\n    lans=[{\n        \"id\": example_lan.id,\n        \"gateway_ips\": [\"10.11.2.5\"],\n    }])\nexample_nat_gateway_rule = ionoscloud.compute.NatGatewayRule(\"exampleNatGatewayRule\",\n    datacenter_id=example_datacenter.id,\n    natgateway_id=example_nat_gateway.id,\n    type=\"SNAT\",\n    protocol=\"TCP\",\n    source_subnet=\"10.0.1.0/24\",\n    public_ip=example_ip_block.ips[0],\n    target_subnet=\"10.0.1.0/24\",\n    target_port_range={\n        \"start\": 500,\n        \"end\": 1000,\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleDatacenter = new Ionoscloud.Compute.Datacenter(\"exampleDatacenter\", new()\n    {\n        Location = \"us/las\",\n        Description = \"Datacenter Description\",\n        SecAuthProtection = false,\n    });\n\n    var exampleIPBlock = new Ionoscloud.Compute.IPBlock(\"exampleIPBlock\", new()\n    {\n        Location = \"us/las\",\n        Size = 2,\n    });\n\n    var exampleLan = new Ionoscloud.Compute.Lan(\"exampleLan\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        Public = true,\n    });\n\n    var exampleNatGateway = new Ionoscloud.Compute.NatGateway(\"exampleNatGateway\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        PublicIps = new[]\n        {\n            exampleIPBlock.Ips.Apply(ips =\u003e ips[0]),\n            exampleIPBlock.Ips.Apply(ips =\u003e ips[1]),\n        },\n        Lans = new[]\n        {\n            new Ionoscloud.Compute.Inputs.NatGatewayLanArgs\n            {\n                Id = exampleLan.Id,\n                GatewayIps = new[]\n                {\n                    \"10.11.2.5\",\n                },\n            },\n        },\n    });\n\n    var exampleNatGatewayRule = new Ionoscloud.Compute.NatGatewayRule(\"exampleNatGatewayRule\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        NatgatewayId = exampleNatGateway.Id,\n        Type = \"SNAT\",\n        Protocol = \"TCP\",\n        SourceSubnet = \"10.0.1.0/24\",\n        PublicIp = exampleIPBlock.Ips.Apply(ips =\u003e ips[0]),\n        TargetSubnet = \"10.0.1.0/24\",\n        TargetPortRange = new Ionoscloud.Compute.Inputs.NatGatewayRuleTargetPortRangeArgs\n        {\n            Start = 500,\n            End = 1000,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleDatacenter, err := compute.NewDatacenter(ctx, \"exampleDatacenter\", \u0026compute.DatacenterArgs{\n\t\t\tLocation:          pulumi.String(\"us/las\"),\n\t\t\tDescription:       pulumi.String(\"Datacenter Description\"),\n\t\t\tSecAuthProtection: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleIPBlock, err := compute.NewIPBlock(ctx, \"exampleIPBlock\", \u0026compute.IPBlockArgs{\n\t\t\tLocation: pulumi.String(\"us/las\"),\n\t\t\tSize:     pulumi.Int(2),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleLan, err := compute.NewLan(ctx, \"exampleLan\", \u0026compute.LanArgs{\n\t\t\tDatacenterId: exampleDatacenter.ID(),\n\t\t\tPublic:       pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleNatGateway, err := compute.NewNatGateway(ctx, \"exampleNatGateway\", \u0026compute.NatGatewayArgs{\n\t\t\tDatacenterId: exampleDatacenter.ID(),\n\t\t\tPublicIps: pulumi.StringArray{\n\t\t\t\texampleIPBlock.Ips.ApplyT(func(ips []string) (string, error) {\n\t\t\t\t\treturn ips[0], nil\n\t\t\t\t}).(pulumi.StringOutput),\n\t\t\t\texampleIPBlock.Ips.ApplyT(func(ips []string) (string, error) {\n\t\t\t\t\treturn ips[1], nil\n\t\t\t\t}).(pulumi.StringOutput),\n\t\t\t},\n\t\t\tLans: compute.NatGatewayLanArray{\n\t\t\t\t\u0026compute.NatGatewayLanArgs{\n\t\t\t\t\tId: exampleLan.ID(),\n\t\t\t\t\tGatewayIps: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"10.11.2.5\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = compute.NewNatGatewayRule(ctx, \"exampleNatGatewayRule\", \u0026compute.NatGatewayRuleArgs{\n\t\t\tDatacenterId: exampleDatacenter.ID(),\n\t\t\tNatgatewayId: exampleNatGateway.ID(),\n\t\t\tType:         pulumi.String(\"SNAT\"),\n\t\t\tProtocol:     pulumi.String(\"TCP\"),\n\t\t\tSourceSubnet: pulumi.String(\"10.0.1.0/24\"),\n\t\t\tPublicIp: exampleIPBlock.Ips.ApplyT(func(ips []string) (string, error) {\n\t\t\t\treturn ips[0], nil\n\t\t\t}).(pulumi.StringOutput),\n\t\t\tTargetSubnet: pulumi.String(\"10.0.1.0/24\"),\n\t\t\tTargetPortRange: \u0026compute.NatGatewayRuleTargetPortRangeArgs{\n\t\t\t\tStart: pulumi.Int(500),\n\t\t\t\tEnd:   pulumi.Int(1000),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.Datacenter;\nimport com.pulumi.ionoscloud.compute.DatacenterArgs;\nimport com.pulumi.ionoscloud.compute.IPBlock;\nimport com.pulumi.ionoscloud.compute.IPBlockArgs;\nimport com.pulumi.ionoscloud.compute.Lan;\nimport com.pulumi.ionoscloud.compute.LanArgs;\nimport com.pulumi.ionoscloud.compute.NatGateway;\nimport com.pulumi.ionoscloud.compute.NatGatewayArgs;\nimport com.pulumi.ionoscloud.compute.inputs.NatGatewayLanArgs;\nimport com.pulumi.ionoscloud.compute.NatGatewayRule;\nimport com.pulumi.ionoscloud.compute.NatGatewayRuleArgs;\nimport com.pulumi.ionoscloud.compute.inputs.NatGatewayRuleTargetPortRangeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleDatacenter = new Datacenter(\"exampleDatacenter\", DatacenterArgs.builder()\n            .location(\"us/las\")\n            .description(\"Datacenter Description\")\n            .secAuthProtection(false)\n            .build());\n\n        var exampleIPBlock = new IPBlock(\"exampleIPBlock\", IPBlockArgs.builder()\n            .location(\"us/las\")\n            .size(2)\n            .build());\n\n        var exampleLan = new Lan(\"exampleLan\", LanArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .public_(true)\n            .build());\n\n        var exampleNatGateway = new NatGateway(\"exampleNatGateway\", NatGatewayArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .publicIps(            \n                exampleIPBlock.ips().applyValue(ips -\u003e ips[0]),\n                exampleIPBlock.ips().applyValue(ips -\u003e ips[1]))\n            .lans(NatGatewayLanArgs.builder()\n                .id(exampleLan.id())\n                .gatewayIps(\"10.11.2.5\")\n                .build())\n            .build());\n\n        var exampleNatGatewayRule = new NatGatewayRule(\"exampleNatGatewayRule\", NatGatewayRuleArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .natgatewayId(exampleNatGateway.id())\n            .type(\"SNAT\")\n            .protocol(\"TCP\")\n            .sourceSubnet(\"10.0.1.0/24\")\n            .publicIp(exampleIPBlock.ips().applyValue(ips -\u003e ips[0]))\n            .targetSubnet(\"10.0.1.0/24\")\n            .targetPortRange(NatGatewayRuleTargetPortRangeArgs.builder()\n                .start(500)\n                .end(1000)\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleDatacenter:\n    type: ionoscloud:compute:Datacenter\n    properties:\n      location: us/las\n      description: Datacenter Description\n      secAuthProtection: false\n  exampleIPBlock:\n    type: ionoscloud:compute:IPBlock\n    properties:\n      location: us/las\n      size: 2\n  exampleLan:\n    type: ionoscloud:compute:Lan\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      public: true\n  exampleNatGateway:\n    type: ionoscloud:compute:NatGateway\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      publicIps:\n        - ${exampleIPBlock.ips[0]}\n        - ${exampleIPBlock.ips[1]}\n      lans:\n        - id: ${exampleLan.id}\n          gatewayIps:\n            - 10.11.2.5\n  exampleNatGatewayRule:\n    type: ionoscloud:compute:NatGatewayRule\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      natgatewayId: ${exampleNatGateway.id}\n      type: SNAT\n      protocol: TCP\n      sourceSubnet: 10.0.1.0/24\n      publicIp: ${exampleIPBlock.ips[0]}\n      targetSubnet: 10.0.1.0/24\n      targetPortRange:\n        start: 500\n        end: 1000\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nA Nat Gateway Rule resource can be imported using its `resource id`, the `datacenter id` and the `natgateway id , e.g.\n\n```sh\n$ pulumi import ionoscloud:compute/natGatewayRule:NatGatewayRule my_natgateway_rule {datacenter uuid}/{nat gateway uuid}/{nat gateway rule uuid}\n```\n\n",
            "properties": {
                "datacenterId": {
                    "type": "string",
                    "description": "[string] A Datacenter's UUID.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] Name of the NAT gateway rule.\n"
                },
                "natgatewayId": {
                    "type": "string",
                    "description": "[string] Nat Gateway's UUID.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "[string] Protocol of the NAT gateway rule. Defaults to ALL. If protocol is 'ICMP' then targetPortRange start and end cannot be set.\n"
                },
                "publicIp": {
                    "type": "string",
                    "description": "[string] Public IP address of the NAT gateway rule. Specifies the address used for masking outgoing packets source address field. Should be one of the customer reserved IP address already configured on the NAT gateway resource.\n"
                },
                "sourceSubnet": {
                    "type": "string",
                    "description": "[string] Source subnet of the NAT gateway rule. For SNAT rules it specifies which packets this translation rule applies to based on the packets source IP address.\n"
                },
                "targetPortRange": {
                    "$ref": "#/types/ionoscloud:compute/NatGatewayRuleTargetPortRange:NatGatewayRuleTargetPortRange",
                    "description": "Target port range of the NAT gateway rule. For SNAT rules it specifies which packets this translation rule applies to based on destination port. If none is provided, rule will match any port.\n"
                },
                "targetSubnet": {
                    "type": "string",
                    "description": "[string] Target or destination subnet of the NAT gateway rule. For SNAT rules it specifies which packets this translation rule applies to based on the packets destination IP address. If none is provided, rule will match any address.\n"
                },
                "type": {
                    "type": "string",
                    "description": "[string] Type of the NAT gateway rule.\n"
                }
            },
            "required": [
                "datacenterId",
                "name",
                "natgatewayId",
                "protocol",
                "publicIp",
                "sourceSubnet",
                "targetPortRange",
                "targetSubnet",
                "type"
            ],
            "inputProperties": {
                "datacenterId": {
                    "type": "string",
                    "description": "[string] A Datacenter's UUID.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "[string] Name of the NAT gateway rule.\n"
                },
                "natgatewayId": {
                    "type": "string",
                    "description": "[string] Nat Gateway's UUID.\n",
                    "willReplaceOnChanges": true
                },
                "protocol": {
                    "type": "string",
                    "description": "[string] Protocol of the NAT gateway rule. Defaults to ALL. If protocol is 'ICMP' then targetPortRange start and end cannot be set.\n"
                },
                "publicIp": {
                    "type": "string",
                    "description": "[string] Public IP address of the NAT gateway rule. Specifies the address used for masking outgoing packets source address field. Should be one of the customer reserved IP address already configured on the NAT gateway resource.\n"
                },
                "sourceSubnet": {
                    "type": "string",
                    "description": "[string] Source subnet of the NAT gateway rule. For SNAT rules it specifies which packets this translation rule applies to based on the packets source IP address.\n"
                },
                "targetPortRange": {
                    "$ref": "#/types/ionoscloud:compute/NatGatewayRuleTargetPortRange:NatGatewayRuleTargetPortRange",
                    "description": "Target port range of the NAT gateway rule. For SNAT rules it specifies which packets this translation rule applies to based on destination port. If none is provided, rule will match any port.\n"
                },
                "targetSubnet": {
                    "type": "string",
                    "description": "[string] Target or destination subnet of the NAT gateway rule. For SNAT rules it specifies which packets this translation rule applies to based on the packets destination IP address. If none is provided, rule will match any address.\n"
                },
                "type": {
                    "type": "string",
                    "description": "[string] Type of the NAT gateway rule.\n"
                }
            },
            "requiredInputs": [
                "datacenterId",
                "natgatewayId",
                "publicIp",
                "sourceSubnet"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NatGatewayRule resources.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "[string] A Datacenter's UUID.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] Name of the NAT gateway rule.\n"
                    },
                    "natgatewayId": {
                        "type": "string",
                        "description": "[string] Nat Gateway's UUID.\n",
                        "willReplaceOnChanges": true
                    },
                    "protocol": {
                        "type": "string",
                        "description": "[string] Protocol of the NAT gateway rule. Defaults to ALL. If protocol is 'ICMP' then targetPortRange start and end cannot be set.\n"
                    },
                    "publicIp": {
                        "type": "string",
                        "description": "[string] Public IP address of the NAT gateway rule. Specifies the address used for masking outgoing packets source address field. Should be one of the customer reserved IP address already configured on the NAT gateway resource.\n"
                    },
                    "sourceSubnet": {
                        "type": "string",
                        "description": "[string] Source subnet of the NAT gateway rule. For SNAT rules it specifies which packets this translation rule applies to based on the packets source IP address.\n"
                    },
                    "targetPortRange": {
                        "$ref": "#/types/ionoscloud:compute/NatGatewayRuleTargetPortRange:NatGatewayRuleTargetPortRange",
                        "description": "Target port range of the NAT gateway rule. For SNAT rules it specifies which packets this translation rule applies to based on destination port. If none is provided, rule will match any port.\n"
                    },
                    "targetSubnet": {
                        "type": "string",
                        "description": "[string] Target or destination subnet of the NAT gateway rule. For SNAT rules it specifies which packets this translation rule applies to based on the packets destination IP address. If none is provided, rule will match any address.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "[string] Type of the NAT gateway rule.\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:compute/nic:Nic": {
            "description": "\n\n## Import\n\nResource **Nic** can be imported using the `resource id`, e.g.\n\n```sh\n$ pulumi import ionoscloud:compute/nic:Nic mynic {datacenter uuid}/{server uuid}/{nic uuid}\n```\n\n",
            "properties": {
                "datacenterId": {
                    "type": "string",
                    "description": "[string] The ID of a Virtual Data Center.\n"
                },
                "deviceNumber": {
                    "type": "integer",
                    "description": "The Logical Unit Number (LUN) of the storage volume. Null if this NIC was created from CloudAPI and no DCD changes were done on the Datacenter.\n"
                },
                "dhcp": {
                    "type": "boolean",
                    "description": "[Boolean] Indicates if the NIC should get an IP address using DHCP (true) or not (false).\n"
                },
                "dhcpv6": {
                    "type": "boolean",
                    "description": "[Boolean] Indicates if the NIC should get an IPv6 address using DHCP (true) or not (false).\n"
                },
                "firewallActive": {
                    "type": "boolean",
                    "description": "[Boolean] If this resource is set to true and is nested under a server resource firewall, with open SSH port, resource must be nested under the NIC.\n"
                },
                "firewallType": {
                    "type": "string",
                    "description": "[String] The type of firewall rules that will be allowed on the NIC. If it is not specified it will take the default value INGRESS\n"
                },
                "flowlog": {
                    "$ref": "#/types/ionoscloud:compute/NicFlowlog:NicFlowlog",
                    "description": "Only 1 flow log can be configured. Only the name field can change as part of an update. Flow logs holistically capture network information such as source and destination IP addresses, source and destination ports, number of packets, amount of bytes, the start and end time of the recording, and the type of protocol – and log the extent to which your instances are being accessed.\n"
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] Collection of IP addresses assigned to a NIC. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.\n"
                },
                "ipv6CidrBlock": {
                    "type": "string",
                    "description": "Automatically assigned /80 IPv6 CIDR block if the NIC is connected to an IPv6 enabled LAN. You can also specify an /80 IPv6 CIDR block for the NIC on your own, which must be inside the /64 IPv6 CIDR block of the LAN and unique.\n"
                },
                "ipv6Ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] Collection of IPv6 addresses assigned to a NIC. Explicitly assigned public IPs need to come from the NIC's Ipv6 CIDR block, Passing value null or empty array will assign an IPv6 address automatically from the NIC's CIDR block.\n"
                },
                "lan": {
                    "type": "integer",
                    "description": "[integer] The LAN ID the NIC will sit on.\n"
                },
                "mac": {
                    "type": "string",
                    "description": "The MAC address of the NIC.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the LAN.\n"
                },
                "pciSlot": {
                    "type": "integer",
                    "description": "The PCI slot number of the Nic.\n"
                },
                "serverId": {
                    "type": "string",
                    "description": "[string] The ID of a server.\n"
                }
            },
            "required": [
                "datacenterId",
                "deviceNumber",
                "firewallType",
                "ips",
                "ipv6CidrBlock",
                "ipv6Ips",
                "lan",
                "mac",
                "name",
                "pciSlot",
                "serverId"
            ],
            "inputProperties": {
                "datacenterId": {
                    "type": "string",
                    "description": "[string] The ID of a Virtual Data Center.\n",
                    "willReplaceOnChanges": true
                },
                "dhcp": {
                    "type": "boolean",
                    "description": "[Boolean] Indicates if the NIC should get an IP address using DHCP (true) or not (false).\n"
                },
                "dhcpv6": {
                    "type": "boolean",
                    "description": "[Boolean] Indicates if the NIC should get an IPv6 address using DHCP (true) or not (false).\n"
                },
                "firewallActive": {
                    "type": "boolean",
                    "description": "[Boolean] If this resource is set to true and is nested under a server resource firewall, with open SSH port, resource must be nested under the NIC.\n"
                },
                "firewallType": {
                    "type": "string",
                    "description": "[String] The type of firewall rules that will be allowed on the NIC. If it is not specified it will take the default value INGRESS\n"
                },
                "flowlog": {
                    "$ref": "#/types/ionoscloud:compute/NicFlowlog:NicFlowlog",
                    "description": "Only 1 flow log can be configured. Only the name field can change as part of an update. Flow logs holistically capture network information such as source and destination IP addresses, source and destination ports, number of packets, amount of bytes, the start and end time of the recording, and the type of protocol – and log the extent to which your instances are being accessed.\n"
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] Collection of IP addresses assigned to a NIC. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.\n"
                },
                "ipv6CidrBlock": {
                    "type": "string",
                    "description": "Automatically assigned /80 IPv6 CIDR block if the NIC is connected to an IPv6 enabled LAN. You can also specify an /80 IPv6 CIDR block for the NIC on your own, which must be inside the /64 IPv6 CIDR block of the LAN and unique.\n"
                },
                "ipv6Ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] Collection of IPv6 addresses assigned to a NIC. Explicitly assigned public IPs need to come from the NIC's Ipv6 CIDR block, Passing value null or empty array will assign an IPv6 address automatically from the NIC's CIDR block.\n"
                },
                "lan": {
                    "type": "integer",
                    "description": "[integer] The LAN ID the NIC will sit on.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the LAN.\n"
                },
                "serverId": {
                    "type": "string",
                    "description": "[string] The ID of a server.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "datacenterId",
                "lan",
                "serverId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Nic resources.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "[string] The ID of a Virtual Data Center.\n",
                        "willReplaceOnChanges": true
                    },
                    "deviceNumber": {
                        "type": "integer",
                        "description": "The Logical Unit Number (LUN) of the storage volume. Null if this NIC was created from CloudAPI and no DCD changes were done on the Datacenter.\n"
                    },
                    "dhcp": {
                        "type": "boolean",
                        "description": "[Boolean] Indicates if the NIC should get an IP address using DHCP (true) or not (false).\n"
                    },
                    "dhcpv6": {
                        "type": "boolean",
                        "description": "[Boolean] Indicates if the NIC should get an IPv6 address using DHCP (true) or not (false).\n"
                    },
                    "firewallActive": {
                        "type": "boolean",
                        "description": "[Boolean] If this resource is set to true and is nested under a server resource firewall, with open SSH port, resource must be nested under the NIC.\n"
                    },
                    "firewallType": {
                        "type": "string",
                        "description": "[String] The type of firewall rules that will be allowed on the NIC. If it is not specified it will take the default value INGRESS\n"
                    },
                    "flowlog": {
                        "$ref": "#/types/ionoscloud:compute/NicFlowlog:NicFlowlog",
                        "description": "Only 1 flow log can be configured. Only the name field can change as part of an update. Flow logs holistically capture network information such as source and destination IP addresses, source and destination ports, number of packets, amount of bytes, the start and end time of the recording, and the type of protocol – and log the extent to which your instances are being accessed.\n"
                    },
                    "ips": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "[list] Collection of IP addresses assigned to a NIC. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.\n"
                    },
                    "ipv6CidrBlock": {
                        "type": "string",
                        "description": "Automatically assigned /80 IPv6 CIDR block if the NIC is connected to an IPv6 enabled LAN. You can also specify an /80 IPv6 CIDR block for the NIC on your own, which must be inside the /64 IPv6 CIDR block of the LAN and unique.\n"
                    },
                    "ipv6Ips": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "[list] Collection of IPv6 addresses assigned to a NIC. Explicitly assigned public IPs need to come from the NIC's Ipv6 CIDR block, Passing value null or empty array will assign an IPv6 address automatically from the NIC's CIDR block.\n"
                    },
                    "lan": {
                        "type": "integer",
                        "description": "[integer] The LAN ID the NIC will sit on.\n"
                    },
                    "mac": {
                        "type": "string",
                        "description": "The MAC address of the NIC.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] The name of the LAN.\n"
                    },
                    "pciSlot": {
                        "type": "integer",
                        "description": "The PCI slot number of the Nic.\n"
                    },
                    "serverId": {
                        "type": "string",
                        "description": "[string] The ID of a server.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:compute/s3Key:S3Key": {
            "description": "Manages an **IONOS Object Storage Key** on IonosCloud.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst exampleUser = new ionoscloud.compute.User(\"exampleUser\", {\n    firstName: \"example\",\n    lastName: \"example\",\n    email: \"unique@email.com\",\n    password: \"abc123-321CBA\",\n    administrator: false,\n    forceSecAuth: false,\n});\nconst exampleS3Key = new ionoscloud.compute.S3Key(\"exampleS3Key\", {\n    userId: exampleUser.id,\n    active: true,\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\nexample_user = ionoscloud.compute.User(\"exampleUser\",\n    first_name=\"example\",\n    last_name=\"example\",\n    email=\"unique@email.com\",\n    password=\"abc123-321CBA\",\n    administrator=False,\n    force_sec_auth=False)\nexample_s3_key = ionoscloud.compute.S3Key(\"exampleS3Key\",\n    user_id=example_user.id,\n    active=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleUser = new Ionoscloud.Compute.User(\"exampleUser\", new()\n    {\n        FirstName = \"example\",\n        LastName = \"example\",\n        Email = \"unique@email.com\",\n        Password = \"abc123-321CBA\",\n        Administrator = false,\n        ForceSecAuth = false,\n    });\n\n    var exampleS3Key = new Ionoscloud.Compute.S3Key(\"exampleS3Key\", new()\n    {\n        UserId = exampleUser.Id,\n        Active = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleUser, err := compute.NewUser(ctx, \"exampleUser\", \u0026compute.UserArgs{\n\t\t\tFirstName:     pulumi.String(\"example\"),\n\t\t\tLastName:      pulumi.String(\"example\"),\n\t\t\tEmail:         pulumi.String(\"unique@email.com\"),\n\t\t\tPassword:      pulumi.String(\"abc123-321CBA\"),\n\t\t\tAdministrator: pulumi.Bool(false),\n\t\t\tForceSecAuth:  pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = compute.NewS3Key(ctx, \"exampleS3Key\", \u0026compute.S3KeyArgs{\n\t\t\tUserId: exampleUser.ID(),\n\t\t\tActive: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.User;\nimport com.pulumi.ionoscloud.compute.UserArgs;\nimport com.pulumi.ionoscloud.compute.S3Key;\nimport com.pulumi.ionoscloud.compute.S3KeyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleUser = new User(\"exampleUser\", UserArgs.builder()\n            .firstName(\"example\")\n            .lastName(\"example\")\n            .email(\"unique@email.com\")\n            .password(\"abc123-321CBA\")\n            .administrator(false)\n            .forceSecAuth(false)\n            .build());\n\n        var exampleS3Key = new S3Key(\"exampleS3Key\", S3KeyArgs.builder()\n            .userId(exampleUser.id())\n            .active(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleUser:\n    type: ionoscloud:compute:User\n    properties:\n      firstName: example\n      lastName: example\n      email: unique@email.com\n      password: abc123-321CBA\n      administrator: false\n      forceSecAuth: false\n  exampleS3Key:\n    type: ionoscloud:compute:S3Key\n    properties:\n      userId: ${exampleUser.id}\n      active: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nAn IONOS Object Storage Unit resource can be imported using its user id as well as its `resource id`, e.g.\n\n```sh\n$ pulumi import ionoscloud:compute/s3Key:S3Key demo {userId}/{s3KeyId}\n```\n\nThis can be helpful when you want to import IONOS Object Storage Keys which you have already created manually or using other means, outside of terraform.\n\n",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "[boolean] Whether the IONOS Object Storage is active / enabled or not - Please keep in mind this is only required on create. Default value in true\n"
                },
                "secretKey": {
                    "type": "string",
                    "description": "The IONOS Object Storage Secret key.\n"
                },
                "userId": {
                    "type": "string",
                    "description": "[string] The UUID of the user owning the IONOS Object Storage Key.\n"
                }
            },
            "required": [
                "secretKey",
                "userId"
            ],
            "inputProperties": {
                "active": {
                    "type": "boolean",
                    "description": "[boolean] Whether the IONOS Object Storage is active / enabled or not - Please keep in mind this is only required on create. Default value in true\n"
                },
                "userId": {
                    "type": "string",
                    "description": "[string] The UUID of the user owning the IONOS Object Storage Key.\n"
                }
            },
            "requiredInputs": [
                "userId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering S3Key resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "[boolean] Whether the IONOS Object Storage is active / enabled or not - Please keep in mind this is only required on create. Default value in true\n"
                    },
                    "secretKey": {
                        "type": "string",
                        "description": "The IONOS Object Storage Secret key.\n"
                    },
                    "userId": {
                        "type": "string",
                        "description": "[string] The UUID of the user owning the IONOS Object Storage Key.\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:compute/server:Server": {
            "description": "\n\n## Import\n\nResource Server can be imported using the `resource id` and the `datacenter id`, e.g.. Passing only resource id and datacenter id means that the first nic found linked to the server will be attached to it.\n\n```sh\n$ pulumi import ionoscloud:compute/server:Server myserver {datacenter uuid}/{server uuid}\n```\n\nOptionally, you can pass `primary_nic` and `firewallrule_id` so terraform will know to import also the first nic and firewall rule (if it exists on the server):\n\n```sh\n$ pulumi import ionoscloud:compute/server:Server myserver {datacenter uuid}/{server uuid}/{primary nic id}/{firewall rule id}\n```\n\n",
            "properties": {
                "availabilityZone": {
                    "type": "string",
                    "description": "[string] The availability zone in which the server should exist. E.g: `AUTO`, `ZONE_1`, `ZONE_2`. This property is immutable.\n"
                },
                "bootCdrom": {
                    "type": "string",
                    "description": "***DEPRECATED*** Please refer to ionoscloud.compute.BootDeviceSelection (Optional)(Computed)[string] The associated boot drive, if any. Must be the UUID of a bootable CDROM image that can be retrieved using the ionoscloud.compute.getImage data source.\n",
                    "deprecationMessage": "Please use the 'ionoscloud_server_boot_device_selection' resource for managing the boot device of the server."
                },
                "bootImage": {
                    "type": "string",
                    "description": "[string] The image or snapshot UUID / name. May also be an image alias. It is required if `licence_type` is not provided.\n"
                },
                "bootVolume": {
                    "type": "string",
                    "description": "The associated boot volume.\n"
                },
                "cores": {
                    "type": "integer",
                    "description": "(Computed)[integer] Number of server CPU cores.\n"
                },
                "cpuFamily": {
                    "type": "string",
                    "description": "[string] CPU architecture on which server gets provisioned; not all CPU architectures are available in all datacenter regions; available CPU architectures can be retrieved from the datacenter resource. E.g.: \"INTEL_SKYLAKE\" or \"INTEL_XEON\".\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "[string] The ID of a Virtual Data Center.\n"
                },
                "firewallruleId": {
                    "type": "string",
                    "description": "The associated firewall rule.\n"
                },
                "firewallruleIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The associated firewall rules.\n"
                },
                "imageName": {
                    "type": "string",
                    "description": "[string] The name, ID or alias of the image. May also be a snapshot ID. It is required if `licence_type` is not provided. Attribute is immutable.\n"
                },
                "imagePassword": {
                    "type": "string",
                    "description": "[string] Required if `ssh_key_path` is not provided.\n",
                    "secret": true
                },
                "inlineVolumeIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list with the IDs for the volumes that are defined inside the server resource.\n\n\u003e **⚠ WARNING**\n\u003e\n\u003e Image_name under volume level is deprecated, please use image_name under server level\n\u003e ssh_key_path and ssh_keys fields are immutable.\n\n\n\u003e **⚠ WARNING**\n\u003e\n\u003e If you want to create a **CUBE** server, you have to provide the `template_uuid`. In this case you can not set `cores`, `ram` and `volume.size` arguments, these being mutually exclusive with `template_uuid`.\n\u003e\n\u003e In all the other cases (**ENTERPRISE** servers) you have to provide values for `cores`, `ram` and `volume size`.\n"
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:compute/ServerLabel:ServerLabel"
                    },
                    "description": "[set] A label can be seen as an object with only two required fields: `key` and `value`, both of the `string` type. Please check the example presented above to see how a `label` can be used in the plan. A server can have multiple labels.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the server.\n"
                },
                "nic": {
                    "$ref": "#/types/ionoscloud:compute/ServerNic:ServerNic",
                    "description": "See the Nic section.\n"
                },
                "primaryIp": {
                    "type": "string",
                    "description": "The associated IP address.\n"
                },
                "primaryNic": {
                    "type": "string",
                    "description": "The associated NIC.\n"
                },
                "ram": {
                    "type": "integer",
                    "description": "(Computed)[integer] The amount of memory for the server in MB.\n"
                },
                "sshKeyPaths": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] List of absolute paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images.  Also accepts ssh keys directly. Required for IonosCloud Linux images. Required if `image_password` is not provided. Does not support `~` expansion to homedir in the given path. This property is immutable.\n",
                    "deprecationMessage": "Will be renamed to ssh_keys in the future, to allow users to set both the ssh key path or directly the ssh key"
                },
                "sshKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] Immutable List of absolute or relative paths to files containing public SSH key that will be injected into IonosCloud provided Linux images. Also accepts ssh keys directly. Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key. This field may only be set in creation requests. When reading, it always returns null. SSH keys are only supported if a public Linux image is used for the volume creation. Does not support `~` expansion to homedir in the given path.\n"
                },
                "templateUuid": {
                    "type": "string",
                    "description": "[string] The UUID of the template for creating a CUBE server; the available templates for CUBE servers can be found on the templates resource\n"
                },
                "type": {
                    "type": "string",
                    "description": "(Computed)[string] Server usages: [ENTERPRISE](https://docs.ionos.com/cloud/compute-engine/virtual-servers/virtual-servers) or [CUBE](https://docs.ionos.com/cloud/compute-engine/virtual-servers/cloud-cubes). This property is immutable.\n"
                },
                "vmState": {
                    "type": "string",
                    "description": "[string] Sets the power state of the server. E.g: `RUNNING`, `SHUTOFF` or `SUSPENDED`. SUSPENDED state is only valid for cube. SHUTOFF state is only valid for enterprise.\n"
                },
                "volume": {
                    "$ref": "#/types/ionoscloud:compute/ServerVolume:ServerVolume",
                    "description": "See the Volume section.\n"
                }
            },
            "required": [
                "availabilityZone",
                "bootCdrom",
                "bootImage",
                "bootVolume",
                "cores",
                "cpuFamily",
                "datacenterId",
                "firewallruleId",
                "firewallruleIds",
                "imageName",
                "imagePassword",
                "inlineVolumeIds",
                "name",
                "primaryIp",
                "primaryNic",
                "ram",
                "type",
                "vmState",
                "volume"
            ],
            "inputProperties": {
                "availabilityZone": {
                    "type": "string",
                    "description": "[string] The availability zone in which the server should exist. E.g: `AUTO`, `ZONE_1`, `ZONE_2`. This property is immutable.\n"
                },
                "bootCdrom": {
                    "type": "string",
                    "description": "***DEPRECATED*** Please refer to ionoscloud.compute.BootDeviceSelection (Optional)(Computed)[string] The associated boot drive, if any. Must be the UUID of a bootable CDROM image that can be retrieved using the ionoscloud.compute.getImage data source.\n",
                    "deprecationMessage": "Please use the 'ionoscloud_server_boot_device_selection' resource for managing the boot device of the server."
                },
                "bootImage": {
                    "type": "string",
                    "description": "[string] The image or snapshot UUID / name. May also be an image alias. It is required if `licence_type` is not provided.\n"
                },
                "cores": {
                    "type": "integer",
                    "description": "(Computed)[integer] Number of server CPU cores.\n"
                },
                "cpuFamily": {
                    "type": "string",
                    "description": "[string] CPU architecture on which server gets provisioned; not all CPU architectures are available in all datacenter regions; available CPU architectures can be retrieved from the datacenter resource. E.g.: \"INTEL_SKYLAKE\" or \"INTEL_XEON\".\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "[string] The ID of a Virtual Data Center.\n",
                    "willReplaceOnChanges": true
                },
                "firewallruleIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The associated firewall rules.\n"
                },
                "imageName": {
                    "type": "string",
                    "description": "[string] The name, ID or alias of the image. May also be a snapshot ID. It is required if `licence_type` is not provided. Attribute is immutable.\n"
                },
                "imagePassword": {
                    "type": "string",
                    "description": "[string] Required if `ssh_key_path` is not provided.\n",
                    "secret": true
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:compute/ServerLabel:ServerLabel"
                    },
                    "description": "[set] A label can be seen as an object with only two required fields: `key` and `value`, both of the `string` type. Please check the example presented above to see how a `label` can be used in the plan. A server can have multiple labels.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the server.\n"
                },
                "nic": {
                    "$ref": "#/types/ionoscloud:compute/ServerNic:ServerNic",
                    "description": "See the Nic section.\n"
                },
                "ram": {
                    "type": "integer",
                    "description": "(Computed)[integer] The amount of memory for the server in MB.\n"
                },
                "sshKeyPaths": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] List of absolute paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images.  Also accepts ssh keys directly. Required for IonosCloud Linux images. Required if `image_password` is not provided. Does not support `~` expansion to homedir in the given path. This property is immutable.\n",
                    "deprecationMessage": "Will be renamed to ssh_keys in the future, to allow users to set both the ssh key path or directly the ssh key"
                },
                "sshKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] Immutable List of absolute or relative paths to files containing public SSH key that will be injected into IonosCloud provided Linux images. Also accepts ssh keys directly. Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key. This field may only be set in creation requests. When reading, it always returns null. SSH keys are only supported if a public Linux image is used for the volume creation. Does not support `~` expansion to homedir in the given path.\n"
                },
                "templateUuid": {
                    "type": "string",
                    "description": "[string] The UUID of the template for creating a CUBE server; the available templates for CUBE servers can be found on the templates resource\n"
                },
                "type": {
                    "type": "string",
                    "description": "(Computed)[string] Server usages: [ENTERPRISE](https://docs.ionos.com/cloud/compute-engine/virtual-servers/virtual-servers) or [CUBE](https://docs.ionos.com/cloud/compute-engine/virtual-servers/cloud-cubes). This property is immutable.\n"
                },
                "vmState": {
                    "type": "string",
                    "description": "[string] Sets the power state of the server. E.g: `RUNNING`, `SHUTOFF` or `SUSPENDED`. SUSPENDED state is only valid for cube. SHUTOFF state is only valid for enterprise.\n"
                },
                "volume": {
                    "$ref": "#/types/ionoscloud:compute/ServerVolume:ServerVolume",
                    "description": "See the Volume section.\n"
                }
            },
            "requiredInputs": [
                "datacenterId",
                "volume"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Server resources.\n",
                "properties": {
                    "availabilityZone": {
                        "type": "string",
                        "description": "[string] The availability zone in which the server should exist. E.g: `AUTO`, `ZONE_1`, `ZONE_2`. This property is immutable.\n"
                    },
                    "bootCdrom": {
                        "type": "string",
                        "description": "***DEPRECATED*** Please refer to ionoscloud.compute.BootDeviceSelection (Optional)(Computed)[string] The associated boot drive, if any. Must be the UUID of a bootable CDROM image that can be retrieved using the ionoscloud.compute.getImage data source.\n",
                        "deprecationMessage": "Please use the 'ionoscloud_server_boot_device_selection' resource for managing the boot device of the server."
                    },
                    "bootImage": {
                        "type": "string",
                        "description": "[string] The image or snapshot UUID / name. May also be an image alias. It is required if `licence_type` is not provided.\n"
                    },
                    "bootVolume": {
                        "type": "string",
                        "description": "The associated boot volume.\n"
                    },
                    "cores": {
                        "type": "integer",
                        "description": "(Computed)[integer] Number of server CPU cores.\n"
                    },
                    "cpuFamily": {
                        "type": "string",
                        "description": "[string] CPU architecture on which server gets provisioned; not all CPU architectures are available in all datacenter regions; available CPU architectures can be retrieved from the datacenter resource. E.g.: \"INTEL_SKYLAKE\" or \"INTEL_XEON\".\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "[string] The ID of a Virtual Data Center.\n",
                        "willReplaceOnChanges": true
                    },
                    "firewallruleId": {
                        "type": "string",
                        "description": "The associated firewall rule.\n"
                    },
                    "firewallruleIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The associated firewall rules.\n"
                    },
                    "imageName": {
                        "type": "string",
                        "description": "[string] The name, ID or alias of the image. May also be a snapshot ID. It is required if `licence_type` is not provided. Attribute is immutable.\n"
                    },
                    "imagePassword": {
                        "type": "string",
                        "description": "[string] Required if `ssh_key_path` is not provided.\n",
                        "secret": true
                    },
                    "inlineVolumeIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list with the IDs for the volumes that are defined inside the server resource.\n\n\u003e **⚠ WARNING**\n\u003e\n\u003e Image_name under volume level is deprecated, please use image_name under server level\n\u003e ssh_key_path and ssh_keys fields are immutable.\n\n\n\u003e **⚠ WARNING**\n\u003e\n\u003e If you want to create a **CUBE** server, you have to provide the `template_uuid`. In this case you can not set `cores`, `ram` and `volume.size` arguments, these being mutually exclusive with `template_uuid`.\n\u003e\n\u003e In all the other cases (**ENTERPRISE** servers) you have to provide values for `cores`, `ram` and `volume size`.\n"
                    },
                    "labels": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:compute/ServerLabel:ServerLabel"
                        },
                        "description": "[set] A label can be seen as an object with only two required fields: `key` and `value`, both of the `string` type. Please check the example presented above to see how a `label` can be used in the plan. A server can have multiple labels.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] The name of the server.\n"
                    },
                    "nic": {
                        "$ref": "#/types/ionoscloud:compute/ServerNic:ServerNic",
                        "description": "See the Nic section.\n"
                    },
                    "primaryIp": {
                        "type": "string",
                        "description": "The associated IP address.\n"
                    },
                    "primaryNic": {
                        "type": "string",
                        "description": "The associated NIC.\n"
                    },
                    "ram": {
                        "type": "integer",
                        "description": "(Computed)[integer] The amount of memory for the server in MB.\n"
                    },
                    "sshKeyPaths": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "[list] List of absolute paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images.  Also accepts ssh keys directly. Required for IonosCloud Linux images. Required if `image_password` is not provided. Does not support `~` expansion to homedir in the given path. This property is immutable.\n",
                        "deprecationMessage": "Will be renamed to ssh_keys in the future, to allow users to set both the ssh key path or directly the ssh key"
                    },
                    "sshKeys": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "[list] Immutable List of absolute or relative paths to files containing public SSH key that will be injected into IonosCloud provided Linux images. Also accepts ssh keys directly. Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key. This field may only be set in creation requests. When reading, it always returns null. SSH keys are only supported if a public Linux image is used for the volume creation. Does not support `~` expansion to homedir in the given path.\n"
                    },
                    "templateUuid": {
                        "type": "string",
                        "description": "[string] The UUID of the template for creating a CUBE server; the available templates for CUBE servers can be found on the templates resource\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "(Computed)[string] Server usages: [ENTERPRISE](https://docs.ionos.com/cloud/compute-engine/virtual-servers/virtual-servers) or [CUBE](https://docs.ionos.com/cloud/compute-engine/virtual-servers/cloud-cubes). This property is immutable.\n"
                    },
                    "vmState": {
                        "type": "string",
                        "description": "[string] Sets the power state of the server. E.g: `RUNNING`, `SHUTOFF` or `SUSPENDED`. SUSPENDED state is only valid for cube. SHUTOFF state is only valid for enterprise.\n"
                    },
                    "volume": {
                        "$ref": "#/types/ionoscloud:compute/ServerVolume:ServerVolume",
                        "description": "See the Volume section.\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:compute/share:Share": {
            "description": "Manages **Shares** and list shares permissions granted to the group members for each shared resource.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst exampleDatacenter = new ionoscloud.compute.Datacenter(\"exampleDatacenter\", {\n    location: \"us/las\",\n    description: \"Datacenter Description\",\n    secAuthProtection: false,\n});\nconst exampleGroup = new ionoscloud.compute.Group(\"exampleGroup\", {\n    createDatacenter: true,\n    createSnapshot: true,\n    reserveIp: true,\n    accessActivityLog: true,\n    createPcc: true,\n    s3Privilege: true,\n    createBackupUnit: true,\n    createInternetAccess: true,\n    createK8sCluster: true,\n});\nconst exampleShare = new ionoscloud.compute.Share(\"exampleShare\", {\n    groupId: exampleGroup.id,\n    resourceId: exampleDatacenter.id,\n    editPrivilege: true,\n    sharePrivilege: false,\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\nexample_datacenter = ionoscloud.compute.Datacenter(\"exampleDatacenter\",\n    location=\"us/las\",\n    description=\"Datacenter Description\",\n    sec_auth_protection=False)\nexample_group = ionoscloud.compute.Group(\"exampleGroup\",\n    create_datacenter=True,\n    create_snapshot=True,\n    reserve_ip=True,\n    access_activity_log=True,\n    create_pcc=True,\n    s3_privilege=True,\n    create_backup_unit=True,\n    create_internet_access=True,\n    create_k8s_cluster=True)\nexample_share = ionoscloud.compute.Share(\"exampleShare\",\n    group_id=example_group.id,\n    resource_id=example_datacenter.id,\n    edit_privilege=True,\n    share_privilege=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleDatacenter = new Ionoscloud.Compute.Datacenter(\"exampleDatacenter\", new()\n    {\n        Location = \"us/las\",\n        Description = \"Datacenter Description\",\n        SecAuthProtection = false,\n    });\n\n    var exampleGroup = new Ionoscloud.Compute.Group(\"exampleGroup\", new()\n    {\n        CreateDatacenter = true,\n        CreateSnapshot = true,\n        ReserveIp = true,\n        AccessActivityLog = true,\n        CreatePcc = true,\n        S3Privilege = true,\n        CreateBackupUnit = true,\n        CreateInternetAccess = true,\n        CreateK8sCluster = true,\n    });\n\n    var exampleShare = new Ionoscloud.Compute.Share(\"exampleShare\", new()\n    {\n        GroupId = exampleGroup.Id,\n        ResourceId = exampleDatacenter.Id,\n        EditPrivilege = true,\n        SharePrivilege = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleDatacenter, err := compute.NewDatacenter(ctx, \"exampleDatacenter\", \u0026compute.DatacenterArgs{\n\t\t\tLocation:          pulumi.String(\"us/las\"),\n\t\t\tDescription:       pulumi.String(\"Datacenter Description\"),\n\t\t\tSecAuthProtection: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleGroup, err := compute.NewGroup(ctx, \"exampleGroup\", \u0026compute.GroupArgs{\n\t\t\tCreateDatacenter:     pulumi.Bool(true),\n\t\t\tCreateSnapshot:       pulumi.Bool(true),\n\t\t\tReserveIp:            pulumi.Bool(true),\n\t\t\tAccessActivityLog:    pulumi.Bool(true),\n\t\t\tCreatePcc:            pulumi.Bool(true),\n\t\t\tS3Privilege:          pulumi.Bool(true),\n\t\t\tCreateBackupUnit:     pulumi.Bool(true),\n\t\t\tCreateInternetAccess: pulumi.Bool(true),\n\t\t\tCreateK8sCluster:     pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = compute.NewShare(ctx, \"exampleShare\", \u0026compute.ShareArgs{\n\t\t\tGroupId:        exampleGroup.ID(),\n\t\t\tResourceId:     exampleDatacenter.ID(),\n\t\t\tEditPrivilege:  pulumi.Bool(true),\n\t\t\tSharePrivilege: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.Datacenter;\nimport com.pulumi.ionoscloud.compute.DatacenterArgs;\nimport com.pulumi.ionoscloud.compute.Group;\nimport com.pulumi.ionoscloud.compute.GroupArgs;\nimport com.pulumi.ionoscloud.compute.Share;\nimport com.pulumi.ionoscloud.compute.ShareArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleDatacenter = new Datacenter(\"exampleDatacenter\", DatacenterArgs.builder()\n            .location(\"us/las\")\n            .description(\"Datacenter Description\")\n            .secAuthProtection(false)\n            .build());\n\n        var exampleGroup = new Group(\"exampleGroup\", GroupArgs.builder()\n            .createDatacenter(true)\n            .createSnapshot(true)\n            .reserveIp(true)\n            .accessActivityLog(true)\n            .createPcc(true)\n            .s3Privilege(true)\n            .createBackupUnit(true)\n            .createInternetAccess(true)\n            .createK8sCluster(true)\n            .build());\n\n        var exampleShare = new Share(\"exampleShare\", ShareArgs.builder()\n            .groupId(exampleGroup.id())\n            .resourceId(exampleDatacenter.id())\n            .editPrivilege(true)\n            .sharePrivilege(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleDatacenter:\n    type: ionoscloud:compute:Datacenter\n    properties:\n      location: us/las\n      description: Datacenter Description\n      secAuthProtection: false\n  exampleGroup:\n    type: ionoscloud:compute:Group\n    properties:\n      createDatacenter: true\n      createSnapshot: true\n      reserveIp: true\n      accessActivityLog: true\n      createPcc: true\n      s3Privilege: true\n      createBackupUnit: true\n      createInternetAccess: true\n      createK8sCluster: true\n  exampleShare:\n    type: ionoscloud:compute:Share\n    properties:\n      groupId: ${exampleGroup.id}\n      resourceId: ${exampleDatacenter.id}\n      editPrivilege: true\n      sharePrivilege: false\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nResource Share can be imported using the `resource id`, e.g.\n\n```sh\n$ pulumi import ionoscloud:compute/share:Share myshare {group uuid}/{resource uuid}\n```\n\n",
            "properties": {
                "editPrivilege": {
                    "type": "boolean",
                    "description": "[Boolean] The group has permission to edit privileges on this resource.\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "[string] The ID of the specific group containing the resource to update.\n"
                },
                "resourceId": {
                    "type": "string",
                    "description": "[string] The ID of the specific resource to update.\n"
                },
                "sharePrivilege": {
                    "type": "boolean",
                    "description": "[Boolean] The group has permission to share this resource.\n\n⚠️ **Note:** There is a limitation due to which the creation of several shares at the same time leads\nto an error. To avoid this, `parallelism=1` can be used when running `pulumi up` command in order\nto create the resources in a sequential manner. Another solution involves the usage of `depends_on`\nattributes inside the `ionoscloud.compute.Share` resource to enforce the sequential creation of the shares.\n"
                }
            },
            "required": [
                "groupId",
                "resourceId"
            ],
            "inputProperties": {
                "editPrivilege": {
                    "type": "boolean",
                    "description": "[Boolean] The group has permission to edit privileges on this resource.\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "[string] The ID of the specific group containing the resource to update.\n"
                },
                "resourceId": {
                    "type": "string",
                    "description": "[string] The ID of the specific resource to update.\n"
                },
                "sharePrivilege": {
                    "type": "boolean",
                    "description": "[Boolean] The group has permission to share this resource.\n\n⚠️ **Note:** There is a limitation due to which the creation of several shares at the same time leads\nto an error. To avoid this, `parallelism=1` can be used when running `pulumi up` command in order\nto create the resources in a sequential manner. Another solution involves the usage of `depends_on`\nattributes inside the `ionoscloud.compute.Share` resource to enforce the sequential creation of the shares.\n"
                }
            },
            "requiredInputs": [
                "groupId",
                "resourceId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Share resources.\n",
                "properties": {
                    "editPrivilege": {
                        "type": "boolean",
                        "description": "[Boolean] The group has permission to edit privileges on this resource.\n"
                    },
                    "groupId": {
                        "type": "string",
                        "description": "[string] The ID of the specific group containing the resource to update.\n"
                    },
                    "resourceId": {
                        "type": "string",
                        "description": "[string] The ID of the specific resource to update.\n"
                    },
                    "sharePrivilege": {
                        "type": "boolean",
                        "description": "[Boolean] The group has permission to share this resource.\n\n⚠️ **Note:** There is a limitation due to which the creation of several shares at the same time leads\nto an error. To avoid this, `parallelism=1` can be used when running `pulumi up` command in order\nto create the resources in a sequential manner. Another solution involves the usage of `depends_on`\nattributes inside the `ionoscloud.compute.Share` resource to enforce the sequential creation of the shares.\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:compute/snapshot:Snapshot": {
            "description": "Manages **Snapshots** on IonosCloud.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\nimport * as random from \"@pulumi/random\";\n\nconst exampleImage = ionoscloud.compute.getImage({\n    type: \"HDD\",\n    imageAlias: \"ubuntu:latest\",\n    location: \"us/las\",\n});\nconst exampleDatacenter = new ionoscloud.compute.Datacenter(\"exampleDatacenter\", {\n    location: \"us/las\",\n    description: \"Datacenter Description\",\n    secAuthProtection: false,\n});\nconst exampleLan = new ionoscloud.compute.Lan(\"exampleLan\", {\n    datacenterId: exampleDatacenter.id,\n    \"public\": true,\n});\nconst serverImagePassword = new random.RandomPassword(\"serverImagePassword\", {\n    length: 16,\n    special: false,\n});\nconst exampleServer = new ionoscloud.compute.Server(\"exampleServer\", {\n    datacenterId: exampleDatacenter.id,\n    cores: 1,\n    ram: 1024,\n    availabilityZone: \"ZONE_1\",\n    cpuFamily: \"INTEL_XEON\",\n    imageName: exampleImage.then(exampleImage =\u003e exampleImage.id),\n    imagePassword: serverImagePassword.result,\n    type: \"ENTERPRISE\",\n    volume: {\n        name: \"system\",\n        size: 5,\n        diskType: \"SSD Standard\",\n        userData: \"foo\",\n        bus: \"VIRTIO\",\n        availabilityZone: \"ZONE_1\",\n    },\n});\nconst testSnapshot = new ionoscloud.compute.Snapshot(\"testSnapshot\", {\n    datacenterId: exampleDatacenter.id,\n    volumeId: exampleServer.bootVolume,\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\nimport pulumi_ionoscloud as ionoscloud\nimport pulumi_random as random\n\nexample_image = ionoscloud.compute.get_image(type=\"HDD\",\n    image_alias=\"ubuntu:latest\",\n    location=\"us/las\")\nexample_datacenter = ionoscloud.compute.Datacenter(\"exampleDatacenter\",\n    location=\"us/las\",\n    description=\"Datacenter Description\",\n    sec_auth_protection=False)\nexample_lan = ionoscloud.compute.Lan(\"exampleLan\",\n    datacenter_id=example_datacenter.id,\n    public=True)\nserver_image_password = random.RandomPassword(\"serverImagePassword\",\n    length=16,\n    special=False)\nexample_server = ionoscloud.compute.Server(\"exampleServer\",\n    datacenter_id=example_datacenter.id,\n    cores=1,\n    ram=1024,\n    availability_zone=\"ZONE_1\",\n    cpu_family=\"INTEL_XEON\",\n    image_name=example_image.id,\n    image_password=server_image_password.result,\n    type=\"ENTERPRISE\",\n    volume={\n        \"name\": \"system\",\n        \"size\": 5,\n        \"disk_type\": \"SSD Standard\",\n        \"user_data\": \"foo\",\n        \"bus\": \"VIRTIO\",\n        \"availability_zone\": \"ZONE_1\",\n    })\ntest_snapshot = ionoscloud.compute.Snapshot(\"testSnapshot\",\n    datacenter_id=example_datacenter.id,\n    volume_id=example_server.boot_volume)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\nusing Random = Pulumi.Random;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleImage = Ionoscloud.Compute.GetImage.Invoke(new()\n    {\n        Type = \"HDD\",\n        ImageAlias = \"ubuntu:latest\",\n        Location = \"us/las\",\n    });\n\n    var exampleDatacenter = new Ionoscloud.Compute.Datacenter(\"exampleDatacenter\", new()\n    {\n        Location = \"us/las\",\n        Description = \"Datacenter Description\",\n        SecAuthProtection = false,\n    });\n\n    var exampleLan = new Ionoscloud.Compute.Lan(\"exampleLan\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        Public = true,\n    });\n\n    var serverImagePassword = new Random.RandomPassword(\"serverImagePassword\", new()\n    {\n        Length = 16,\n        Special = false,\n    });\n\n    var exampleServer = new Ionoscloud.Compute.Server(\"exampleServer\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        Cores = 1,\n        Ram = 1024,\n        AvailabilityZone = \"ZONE_1\",\n        CpuFamily = \"INTEL_XEON\",\n        ImageName = exampleImage.Apply(getImageResult =\u003e getImageResult.Id),\n        ImagePassword = serverImagePassword.Result,\n        Type = \"ENTERPRISE\",\n        Volume = new Ionoscloud.Compute.Inputs.ServerVolumeArgs\n        {\n            Name = \"system\",\n            Size = 5,\n            DiskType = \"SSD Standard\",\n            UserData = \"foo\",\n            Bus = \"VIRTIO\",\n            AvailabilityZone = \"ZONE_1\",\n        },\n    });\n\n    var testSnapshot = new Ionoscloud.Compute.Snapshot(\"testSnapshot\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        VolumeId = exampleServer.BootVolume,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi-random/sdk/v4/go/random\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleImage, err := compute.GetImage(ctx, \u0026compute.GetImageArgs{\n\t\t\tType:       pulumi.StringRef(\"HDD\"),\n\t\t\tImageAlias: pulumi.StringRef(\"ubuntu:latest\"),\n\t\t\tLocation:   pulumi.StringRef(\"us/las\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleDatacenter, err := compute.NewDatacenter(ctx, \"exampleDatacenter\", \u0026compute.DatacenterArgs{\n\t\t\tLocation:          pulumi.String(\"us/las\"),\n\t\t\tDescription:       pulumi.String(\"Datacenter Description\"),\n\t\t\tSecAuthProtection: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = compute.NewLan(ctx, \"exampleLan\", \u0026compute.LanArgs{\n\t\t\tDatacenterId: exampleDatacenter.ID(),\n\t\t\tPublic:       pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tserverImagePassword, err := random.NewRandomPassword(ctx, \"serverImagePassword\", \u0026random.RandomPasswordArgs{\n\t\t\tLength:  pulumi.Int(16),\n\t\t\tSpecial: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleServer, err := compute.NewServer(ctx, \"exampleServer\", \u0026compute.ServerArgs{\n\t\t\tDatacenterId:     exampleDatacenter.ID(),\n\t\t\tCores:            pulumi.Int(1),\n\t\t\tRam:              pulumi.Int(1024),\n\t\t\tAvailabilityZone: pulumi.String(\"ZONE_1\"),\n\t\t\tCpuFamily:        pulumi.String(\"INTEL_XEON\"),\n\t\t\tImageName:        pulumi.String(exampleImage.Id),\n\t\t\tImagePassword:    serverImagePassword.Result,\n\t\t\tType:             pulumi.String(\"ENTERPRISE\"),\n\t\t\tVolume: \u0026compute.ServerVolumeArgs{\n\t\t\t\tName:             pulumi.String(\"system\"),\n\t\t\t\tSize:             pulumi.Int(5),\n\t\t\t\tDiskType:         pulumi.String(\"SSD Standard\"),\n\t\t\t\tUserData:         pulumi.String(\"foo\"),\n\t\t\t\tBus:              pulumi.String(\"VIRTIO\"),\n\t\t\t\tAvailabilityZone: pulumi.String(\"ZONE_1\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = compute.NewSnapshot(ctx, \"testSnapshot\", \u0026compute.SnapshotArgs{\n\t\t\tDatacenterId: exampleDatacenter.ID(),\n\t\t\tVolumeId:     exampleServer.BootVolume,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.ComputeFunctions;\nimport com.pulumi.ionoscloud.compute.inputs.GetImageArgs;\nimport com.pulumi.ionoscloud.compute.Datacenter;\nimport com.pulumi.ionoscloud.compute.DatacenterArgs;\nimport com.pulumi.ionoscloud.compute.Lan;\nimport com.pulumi.ionoscloud.compute.LanArgs;\nimport com.pulumi.random.RandomPassword;\nimport com.pulumi.random.RandomPasswordArgs;\nimport com.pulumi.ionoscloud.compute.Server;\nimport com.pulumi.ionoscloud.compute.ServerArgs;\nimport com.pulumi.ionoscloud.compute.inputs.ServerVolumeArgs;\nimport com.pulumi.ionoscloud.compute.Snapshot;\nimport com.pulumi.ionoscloud.compute.SnapshotArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var exampleImage = ComputeFunctions.getImage(GetImageArgs.builder()\n            .type(\"HDD\")\n            .imageAlias(\"ubuntu:latest\")\n            .location(\"us/las\")\n            .build());\n\n        var exampleDatacenter = new Datacenter(\"exampleDatacenter\", DatacenterArgs.builder()\n            .location(\"us/las\")\n            .description(\"Datacenter Description\")\n            .secAuthProtection(false)\n            .build());\n\n        var exampleLan = new Lan(\"exampleLan\", LanArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .public_(true)\n            .build());\n\n        var serverImagePassword = new RandomPassword(\"serverImagePassword\", RandomPasswordArgs.builder()\n            .length(16)\n            .special(false)\n            .build());\n\n        var exampleServer = new Server(\"exampleServer\", ServerArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .cores(1)\n            .ram(1024)\n            .availabilityZone(\"ZONE_1\")\n            .cpuFamily(\"INTEL_XEON\")\n            .imageName(exampleImage.applyValue(getImageResult -\u003e getImageResult.id()))\n            .imagePassword(serverImagePassword.result())\n            .type(\"ENTERPRISE\")\n            .volume(ServerVolumeArgs.builder()\n                .name(\"system\")\n                .size(5)\n                .diskType(\"SSD Standard\")\n                .userData(\"foo\")\n                .bus(\"VIRTIO\")\n                .availabilityZone(\"ZONE_1\")\n                .build())\n            .build());\n\n        var testSnapshot = new Snapshot(\"testSnapshot\", SnapshotArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .volumeId(exampleServer.bootVolume())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleDatacenter:\n    type: ionoscloud:compute:Datacenter\n    properties:\n      location: us/las\n      description: Datacenter Description\n      secAuthProtection: false\n  exampleLan:\n    type: ionoscloud:compute:Lan\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      public: true\n  exampleServer:\n    type: ionoscloud:compute:Server\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      cores: 1\n      ram: 1024\n      availabilityZone: ZONE_1\n      cpuFamily: INTEL_XEON\n      imageName: ${exampleImage.id}\n      imagePassword: ${serverImagePassword.result}\n      type: ENTERPRISE\n      volume:\n        name: system\n        size: 5\n        diskType: SSD Standard\n        userData: foo\n        bus: VIRTIO\n        availabilityZone: ZONE_1\n  testSnapshot:\n    type: ionoscloud:compute:Snapshot\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      volumeId: ${exampleServer.bootVolume}\n  serverImagePassword:\n    type: random:RandomPassword\n    properties:\n      length: 16\n      special: false\nvariables:\n  exampleImage:\n    fn::invoke:\n      function: ionoscloud:compute:getImage\n      arguments:\n        type: HDD\n        imageAlias: ubuntu:latest\n        location: us/las\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nResource Snapshot can be imported using the `snapshot id`, e.g.\n\n```sh\n$ pulumi import ionoscloud:compute/snapshot:Snapshot mysnapshot {snapshot uuid}\n```\n\n",
            "properties": {
                "cpuHotPlug": {
                    "type": "boolean",
                    "description": "(Computed)[string] Is capable of CPU hot plug (no reboot required). Can only be updated.\n"
                },
                "cpuHotUnplug": {
                    "type": "boolean",
                    "description": "Is capable of CPU hot unplug (no reboot required)\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "[string] The ID of the Virtual Data Center.\n"
                },
                "description": {
                    "type": "string",
                    "description": "(Computed)[string] Human readable description\n"
                },
                "discScsiHotPlug": {
                    "type": "boolean",
                    "description": "Is capable of SCSI drive hot plug (no reboot required)\n"
                },
                "discScsiHotUnplug": {
                    "type": "boolean",
                    "description": "Is capable of SCSI drive hot unplug (no reboot required). This works only for non-Windows virtual Machines.\n"
                },
                "discVirtioHotPlug": {
                    "type": "boolean",
                    "description": "(Computed)[string] Is capable of Virt-IO drive hot plug (no reboot required). Can only be updated.\n"
                },
                "discVirtioHotUnplug": {
                    "type": "boolean",
                    "description": "(Computed)[string] Is capable of Virt-IO drive hot unplug (no reboot required). This works only for non-Windows virtual Machines. Can only be updated.\n"
                },
                "licenceType": {
                    "type": "string",
                    "description": "(Computed)[string] OS type of this Snapshot\n"
                },
                "location": {
                    "type": "string",
                    "description": "Location of that image/snapshot\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the snapshot.\n"
                },
                "nicHotPlug": {
                    "type": "boolean",
                    "description": "(Computed)[string] Is capable of nic hot plug (no reboot required). Can only be updated.\n"
                },
                "nicHotUnplug": {
                    "type": "boolean",
                    "description": "(Computed)[string] Is capable of nic hot unplug (no reboot required). Can only be updated.\n"
                },
                "ramHotPlug": {
                    "type": "boolean",
                    "description": "(Computed)[string] Is capable of memory hot plug (no reboot required). Can only be updated.\n"
                },
                "ramHotUnplug": {
                    "type": "boolean",
                    "description": "Is capable of memory hot unplug (no reboot required)\n"
                },
                "secAuthProtection": {
                    "type": "boolean",
                    "description": "Boolean value representing if the snapshot requires extra protection e.g. two factor protection\n"
                },
                "size": {
                    "type": "integer",
                    "description": "The size of the image in GB\n"
                },
                "volumeId": {
                    "type": "string",
                    "description": "[string] The ID of the specific volume to take the snapshot from.\n"
                }
            },
            "required": [
                "cpuHotPlug",
                "cpuHotUnplug",
                "datacenterId",
                "description",
                "discScsiHotPlug",
                "discScsiHotUnplug",
                "discVirtioHotPlug",
                "discVirtioHotUnplug",
                "licenceType",
                "location",
                "name",
                "nicHotPlug",
                "nicHotUnplug",
                "ramHotPlug",
                "ramHotUnplug",
                "secAuthProtection",
                "size",
                "volumeId"
            ],
            "inputProperties": {
                "cpuHotPlug": {
                    "type": "boolean",
                    "description": "(Computed)[string] Is capable of CPU hot plug (no reboot required). Can only be updated.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "[string] The ID of the Virtual Data Center.\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "description": "(Computed)[string] Human readable description\n"
                },
                "discVirtioHotPlug": {
                    "type": "boolean",
                    "description": "(Computed)[string] Is capable of Virt-IO drive hot plug (no reboot required). Can only be updated.\n"
                },
                "discVirtioHotUnplug": {
                    "type": "boolean",
                    "description": "(Computed)[string] Is capable of Virt-IO drive hot unplug (no reboot required). This works only for non-Windows virtual Machines. Can only be updated.\n"
                },
                "licenceType": {
                    "type": "string",
                    "description": "(Computed)[string] OS type of this Snapshot\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the snapshot.\n"
                },
                "nicHotPlug": {
                    "type": "boolean",
                    "description": "(Computed)[string] Is capable of nic hot plug (no reboot required). Can only be updated.\n"
                },
                "nicHotUnplug": {
                    "type": "boolean",
                    "description": "(Computed)[string] Is capable of nic hot unplug (no reboot required). Can only be updated.\n"
                },
                "ramHotPlug": {
                    "type": "boolean",
                    "description": "(Computed)[string] Is capable of memory hot plug (no reboot required). Can only be updated.\n"
                },
                "secAuthProtection": {
                    "type": "boolean",
                    "description": "Boolean value representing if the snapshot requires extra protection e.g. two factor protection\n"
                },
                "volumeId": {
                    "type": "string",
                    "description": "[string] The ID of the specific volume to take the snapshot from.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "datacenterId",
                "volumeId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Snapshot resources.\n",
                "properties": {
                    "cpuHotPlug": {
                        "type": "boolean",
                        "description": "(Computed)[string] Is capable of CPU hot plug (no reboot required). Can only be updated.\n"
                    },
                    "cpuHotUnplug": {
                        "type": "boolean",
                        "description": "Is capable of CPU hot unplug (no reboot required)\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "[string] The ID of the Virtual Data Center.\n",
                        "willReplaceOnChanges": true
                    },
                    "description": {
                        "type": "string",
                        "description": "(Computed)[string] Human readable description\n"
                    },
                    "discScsiHotPlug": {
                        "type": "boolean",
                        "description": "Is capable of SCSI drive hot plug (no reboot required)\n"
                    },
                    "discScsiHotUnplug": {
                        "type": "boolean",
                        "description": "Is capable of SCSI drive hot unplug (no reboot required). This works only for non-Windows virtual Machines.\n"
                    },
                    "discVirtioHotPlug": {
                        "type": "boolean",
                        "description": "(Computed)[string] Is capable of Virt-IO drive hot plug (no reboot required). Can only be updated.\n"
                    },
                    "discVirtioHotUnplug": {
                        "type": "boolean",
                        "description": "(Computed)[string] Is capable of Virt-IO drive hot unplug (no reboot required). This works only for non-Windows virtual Machines. Can only be updated.\n"
                    },
                    "licenceType": {
                        "type": "string",
                        "description": "(Computed)[string] OS type of this Snapshot\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "Location of that image/snapshot\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] The name of the snapshot.\n"
                    },
                    "nicHotPlug": {
                        "type": "boolean",
                        "description": "(Computed)[string] Is capable of nic hot plug (no reboot required). Can only be updated.\n"
                    },
                    "nicHotUnplug": {
                        "type": "boolean",
                        "description": "(Computed)[string] Is capable of nic hot unplug (no reboot required). Can only be updated.\n"
                    },
                    "ramHotPlug": {
                        "type": "boolean",
                        "description": "(Computed)[string] Is capable of memory hot plug (no reboot required). Can only be updated.\n"
                    },
                    "ramHotUnplug": {
                        "type": "boolean",
                        "description": "Is capable of memory hot unplug (no reboot required)\n"
                    },
                    "secAuthProtection": {
                        "type": "boolean",
                        "description": "Boolean value representing if the snapshot requires extra protection e.g. two factor protection\n"
                    },
                    "size": {
                        "type": "integer",
                        "description": "The size of the image in GB\n"
                    },
                    "volumeId": {
                        "type": "string",
                        "description": "[string] The ID of the specific volume to take the snapshot from.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:compute/targetGroup:TargetGroup": {
            "description": "Manages a **Target Group** on IonosCloud.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = new ionoscloud.compute.TargetGroup(\"example\", {\n    algorithm: \"ROUND_ROBIN\",\n    healthCheck: {\n        checkInterval: 50000,\n        checkTimeout: 5000,\n        retries: 2,\n    },\n    httpHealthCheck: {\n        matchType: \"STATUS_CODE\",\n        method: \"GET\",\n        negate: true,\n        path: \"/.\",\n        regex: true,\n        response: \"200\",\n    },\n    protocol: \"HTTP\",\n    protocolVersion: \"HTTP1\",\n    targets: [\n        {\n            healthCheckEnabled: true,\n            ip: \"22.231.2.2\",\n            maintenanceEnabled: false,\n            port: 8080,\n            proxyProtocol: \"v2ssl\",\n            weight: 1,\n        },\n        {\n            healthCheckEnabled: false,\n            ip: \"22.231.2.3\",\n            maintenanceEnabled: false,\n            port: 8081,\n            proxyProtocol: \"v2\",\n            weight: 124,\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\nexample = ionoscloud.compute.TargetGroup(\"example\",\n    algorithm=\"ROUND_ROBIN\",\n    health_check={\n        \"check_interval\": 50000,\n        \"check_timeout\": 5000,\n        \"retries\": 2,\n    },\n    http_health_check={\n        \"match_type\": \"STATUS_CODE\",\n        \"method\": \"GET\",\n        \"negate\": True,\n        \"path\": \"/.\",\n        \"regex\": True,\n        \"response\": \"200\",\n    },\n    protocol=\"HTTP\",\n    protocol_version=\"HTTP1\",\n    targets=[\n        {\n            \"health_check_enabled\": True,\n            \"ip\": \"22.231.2.2\",\n            \"maintenance_enabled\": False,\n            \"port\": 8080,\n            \"proxy_protocol\": \"v2ssl\",\n            \"weight\": 1,\n        },\n        {\n            \"health_check_enabled\": False,\n            \"ip\": \"22.231.2.3\",\n            \"maintenance_enabled\": False,\n            \"port\": 8081,\n            \"proxy_protocol\": \"v2\",\n            \"weight\": 124,\n        },\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Ionoscloud.Compute.TargetGroup(\"example\", new()\n    {\n        Algorithm = \"ROUND_ROBIN\",\n        HealthCheck = new Ionoscloud.Compute.Inputs.TargetGroupHealthCheckArgs\n        {\n            CheckInterval = 50000,\n            CheckTimeout = 5000,\n            Retries = 2,\n        },\n        HttpHealthCheck = new Ionoscloud.Compute.Inputs.TargetGroupHttpHealthCheckArgs\n        {\n            MatchType = \"STATUS_CODE\",\n            Method = \"GET\",\n            Negate = true,\n            Path = \"/.\",\n            Regex = true,\n            Response = \"200\",\n        },\n        Protocol = \"HTTP\",\n        ProtocolVersion = \"HTTP1\",\n        Targets = new[]\n        {\n            new Ionoscloud.Compute.Inputs.TargetGroupTargetArgs\n            {\n                HealthCheckEnabled = true,\n                Ip = \"22.231.2.2\",\n                MaintenanceEnabled = false,\n                Port = 8080,\n                ProxyProtocol = \"v2ssl\",\n                Weight = 1,\n            },\n            new Ionoscloud.Compute.Inputs.TargetGroupTargetArgs\n            {\n                HealthCheckEnabled = false,\n                Ip = \"22.231.2.3\",\n                MaintenanceEnabled = false,\n                Port = 8081,\n                ProxyProtocol = \"v2\",\n                Weight = 124,\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := compute.NewTargetGroup(ctx, \"example\", \u0026compute.TargetGroupArgs{\n\t\t\tAlgorithm: pulumi.String(\"ROUND_ROBIN\"),\n\t\t\tHealthCheck: \u0026compute.TargetGroupHealthCheckArgs{\n\t\t\t\tCheckInterval: pulumi.Int(50000),\n\t\t\t\tCheckTimeout:  pulumi.Int(5000),\n\t\t\t\tRetries:       pulumi.Int(2),\n\t\t\t},\n\t\t\tHttpHealthCheck: \u0026compute.TargetGroupHttpHealthCheckArgs{\n\t\t\t\tMatchType: pulumi.String(\"STATUS_CODE\"),\n\t\t\t\tMethod:    pulumi.String(\"GET\"),\n\t\t\t\tNegate:    pulumi.Bool(true),\n\t\t\t\tPath:      pulumi.String(\"/.\"),\n\t\t\t\tRegex:     pulumi.Bool(true),\n\t\t\t\tResponse:  pulumi.String(\"200\"),\n\t\t\t},\n\t\t\tProtocol:        pulumi.String(\"HTTP\"),\n\t\t\tProtocolVersion: pulumi.String(\"HTTP1\"),\n\t\t\tTargets: compute.TargetGroupTargetArray{\n\t\t\t\t\u0026compute.TargetGroupTargetArgs{\n\t\t\t\t\tHealthCheckEnabled: pulumi.Bool(true),\n\t\t\t\t\tIp:                 pulumi.String(\"22.231.2.2\"),\n\t\t\t\t\tMaintenanceEnabled: pulumi.Bool(false),\n\t\t\t\t\tPort:               pulumi.Int(8080),\n\t\t\t\t\tProxyProtocol:      pulumi.String(\"v2ssl\"),\n\t\t\t\t\tWeight:             pulumi.Int(1),\n\t\t\t\t},\n\t\t\t\t\u0026compute.TargetGroupTargetArgs{\n\t\t\t\t\tHealthCheckEnabled: pulumi.Bool(false),\n\t\t\t\t\tIp:                 pulumi.String(\"22.231.2.3\"),\n\t\t\t\t\tMaintenanceEnabled: pulumi.Bool(false),\n\t\t\t\t\tPort:               pulumi.Int(8081),\n\t\t\t\t\tProxyProtocol:      pulumi.String(\"v2\"),\n\t\t\t\t\tWeight:             pulumi.Int(124),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.TargetGroup;\nimport com.pulumi.ionoscloud.compute.TargetGroupArgs;\nimport com.pulumi.ionoscloud.compute.inputs.TargetGroupHealthCheckArgs;\nimport com.pulumi.ionoscloud.compute.inputs.TargetGroupHttpHealthCheckArgs;\nimport com.pulumi.ionoscloud.compute.inputs.TargetGroupTargetArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new TargetGroup(\"example\", TargetGroupArgs.builder()\n            .algorithm(\"ROUND_ROBIN\")\n            .healthCheck(TargetGroupHealthCheckArgs.builder()\n                .checkInterval(50000)\n                .checkTimeout(5000)\n                .retries(2)\n                .build())\n            .httpHealthCheck(TargetGroupHttpHealthCheckArgs.builder()\n                .matchType(\"STATUS_CODE\")\n                .method(\"GET\")\n                .negate(true)\n                .path(\"/.\")\n                .regex(true)\n                .response(\"200\")\n                .build())\n            .protocol(\"HTTP\")\n            .protocolVersion(\"HTTP1\")\n            .targets(            \n                TargetGroupTargetArgs.builder()\n                    .healthCheckEnabled(true)\n                    .ip(\"22.231.2.2\")\n                    .maintenanceEnabled(false)\n                    .port(\"8080\")\n                    .proxyProtocol(\"v2ssl\")\n                    .weight(\"1\")\n                    .build(),\n                TargetGroupTargetArgs.builder()\n                    .healthCheckEnabled(false)\n                    .ip(\"22.231.2.3\")\n                    .maintenanceEnabled(false)\n                    .port(\"8081\")\n                    .proxyProtocol(\"v2\")\n                    .weight(\"124\")\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: ionoscloud:compute:TargetGroup\n    properties:\n      algorithm: ROUND_ROBIN\n      healthCheck:\n        checkInterval: 50000\n        checkTimeout: 5000\n        retries: 2\n      httpHealthCheck:\n        matchType: STATUS_CODE\n        method: GET\n        negate: true\n        path: /.\n        regex: true\n        response: '200'\n      protocol: HTTP\n      protocolVersion: HTTP1\n      targets:\n        - healthCheckEnabled: true\n          ip: 22.231.2.2\n          maintenanceEnabled: false\n          port: '8080'\n          proxyProtocol: v2ssl\n          weight: '1'\n        - healthCheckEnabled: false\n          ip: 22.231.2.3\n          maintenanceEnabled: false\n          port: '8081'\n          proxyProtocol: v2\n          weight: '124'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nResource Target Group can be imported using the `resource id`, e.g.\n\n```sh\n$ pulumi import ionoscloud:compute/targetGroup:TargetGroup myTargetGroup {target group uuid}\n```\n\n",
            "properties": {
                "algorithm": {
                    "type": "string",
                    "description": "[string] Balancing algorithm.\n"
                },
                "healthCheck": {
                    "$ref": "#/types/ionoscloud:compute/TargetGroupHealthCheck:TargetGroupHealthCheck",
                    "description": "Health check attributes for Target Group.\n"
                },
                "httpHealthCheck": {
                    "$ref": "#/types/ionoscloud:compute/TargetGroupHttpHealthCheck:TargetGroupHttpHealthCheck",
                    "description": "Http health check attributes for Target Group\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the target group.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "[string] Balancing protocol.\n"
                },
                "protocolVersion": {
                    "type": "string",
                    "description": "[string] The forwarding protocol version. Value is ignored when protocol is not 'HTTP'.\n"
                },
                "targets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:compute/TargetGroupTarget:TargetGroupTarget"
                    },
                    "description": "[list] Array of items in the collection\n"
                }
            },
            "required": [
                "algorithm",
                "healthCheck",
                "httpHealthCheck",
                "name",
                "protocol",
                "protocolVersion",
                "targets"
            ],
            "inputProperties": {
                "algorithm": {
                    "type": "string",
                    "description": "[string] Balancing algorithm.\n"
                },
                "healthCheck": {
                    "$ref": "#/types/ionoscloud:compute/TargetGroupHealthCheck:TargetGroupHealthCheck",
                    "description": "Health check attributes for Target Group.\n"
                },
                "httpHealthCheck": {
                    "$ref": "#/types/ionoscloud:compute/TargetGroupHttpHealthCheck:TargetGroupHttpHealthCheck",
                    "description": "Http health check attributes for Target Group\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the target group.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "[string] Balancing protocol.\n"
                },
                "protocolVersion": {
                    "type": "string",
                    "description": "[string] The forwarding protocol version. Value is ignored when protocol is not 'HTTP'.\n"
                },
                "targets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:compute/TargetGroupTarget:TargetGroupTarget"
                    },
                    "description": "[list] Array of items in the collection\n"
                }
            },
            "requiredInputs": [
                "algorithm",
                "protocol",
                "protocolVersion"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TargetGroup resources.\n",
                "properties": {
                    "algorithm": {
                        "type": "string",
                        "description": "[string] Balancing algorithm.\n"
                    },
                    "healthCheck": {
                        "$ref": "#/types/ionoscloud:compute/TargetGroupHealthCheck:TargetGroupHealthCheck",
                        "description": "Health check attributes for Target Group.\n"
                    },
                    "httpHealthCheck": {
                        "$ref": "#/types/ionoscloud:compute/TargetGroupHttpHealthCheck:TargetGroupHttpHealthCheck",
                        "description": "Http health check attributes for Target Group\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] The name of the target group.\n"
                    },
                    "protocol": {
                        "type": "string",
                        "description": "[string] Balancing protocol.\n"
                    },
                    "protocolVersion": {
                        "type": "string",
                        "description": "[string] The forwarding protocol version. Value is ignored when protocol is not 'HTTP'.\n"
                    },
                    "targets": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:compute/TargetGroupTarget:TargetGroupTarget"
                        },
                        "description": "[list] Array of items in the collection\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:compute/user:User": {
            "description": "Manages **Users** and list users and groups associated with that user.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\nimport * as random from \"@pulumi/random\";\n\nconst group1 = new ionoscloud.compute.Group(\"group1\", {\n    createDatacenter: true,\n    createSnapshot: true,\n    reserveIp: true,\n    accessActivityLog: false,\n    createK8sCluster: true,\n});\nconst group2 = new ionoscloud.compute.Group(\"group2\", {\n    createDatacenter: true,\n    createSnapshot: true,\n    reserveIp: true,\n    accessActivityLog: false,\n    createK8sCluster: true,\n});\nconst group3 = new ionoscloud.compute.Group(\"group3\", {\n    createDatacenter: true,\n    createSnapshot: true,\n    reserveIp: true,\n    accessActivityLog: false,\n});\nconst userPassword = new random.RandomPassword(\"userPassword\", {\n    length: 16,\n    special: true,\n    overrideSpecial: \"!#$%\u0026*()-_=+[]{}\u003c\u003e:?\",\n});\nconst example = new ionoscloud.compute.User(\"example\", {\n    firstName: \"example\",\n    lastName: \"example\",\n    email: \"unique@email.com\",\n    password: userPassword.result,\n    administrator: false,\n    forceSecAuth: false,\n    active: true,\n    groupIds: [\n        group1.id,\n        group2.id,\n        group3.id,\n    ],\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\nimport pulumi_random as random\n\ngroup1 = ionoscloud.compute.Group(\"group1\",\n    create_datacenter=True,\n    create_snapshot=True,\n    reserve_ip=True,\n    access_activity_log=False,\n    create_k8s_cluster=True)\ngroup2 = ionoscloud.compute.Group(\"group2\",\n    create_datacenter=True,\n    create_snapshot=True,\n    reserve_ip=True,\n    access_activity_log=False,\n    create_k8s_cluster=True)\ngroup3 = ionoscloud.compute.Group(\"group3\",\n    create_datacenter=True,\n    create_snapshot=True,\n    reserve_ip=True,\n    access_activity_log=False)\nuser_password = random.RandomPassword(\"userPassword\",\n    length=16,\n    special=True,\n    override_special=\"!#$%\u0026*()-_=+[]{}\u003c\u003e:?\")\nexample = ionoscloud.compute.User(\"example\",\n    first_name=\"example\",\n    last_name=\"example\",\n    email=\"unique@email.com\",\n    password=user_password.result,\n    administrator=False,\n    force_sec_auth=False,\n    active=True,\n    group_ids=[\n        group1.id,\n        group2.id,\n        group3.id,\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\nusing Random = Pulumi.Random;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var group1 = new Ionoscloud.Compute.Group(\"group1\", new()\n    {\n        CreateDatacenter = true,\n        CreateSnapshot = true,\n        ReserveIp = true,\n        AccessActivityLog = false,\n        CreateK8sCluster = true,\n    });\n\n    var group2 = new Ionoscloud.Compute.Group(\"group2\", new()\n    {\n        CreateDatacenter = true,\n        CreateSnapshot = true,\n        ReserveIp = true,\n        AccessActivityLog = false,\n        CreateK8sCluster = true,\n    });\n\n    var group3 = new Ionoscloud.Compute.Group(\"group3\", new()\n    {\n        CreateDatacenter = true,\n        CreateSnapshot = true,\n        ReserveIp = true,\n        AccessActivityLog = false,\n    });\n\n    var userPassword = new Random.RandomPassword(\"userPassword\", new()\n    {\n        Length = 16,\n        Special = true,\n        OverrideSpecial = \"!#$%\u0026*()-_=+[]{}\u003c\u003e:?\",\n    });\n\n    var example = new Ionoscloud.Compute.User(\"example\", new()\n    {\n        FirstName = \"example\",\n        LastName = \"example\",\n        Email = \"unique@email.com\",\n        Password = userPassword.Result,\n        Administrator = false,\n        ForceSecAuth = false,\n        Active = true,\n        GroupIds = new[]\n        {\n            group1.Id,\n            group2.Id,\n            group3.Id,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi-random/sdk/v4/go/random\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tgroup1, err := compute.NewGroup(ctx, \"group1\", \u0026compute.GroupArgs{\n\t\t\tCreateDatacenter:  pulumi.Bool(true),\n\t\t\tCreateSnapshot:    pulumi.Bool(true),\n\t\t\tReserveIp:         pulumi.Bool(true),\n\t\t\tAccessActivityLog: pulumi.Bool(false),\n\t\t\tCreateK8sCluster:  pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tgroup2, err := compute.NewGroup(ctx, \"group2\", \u0026compute.GroupArgs{\n\t\t\tCreateDatacenter:  pulumi.Bool(true),\n\t\t\tCreateSnapshot:    pulumi.Bool(true),\n\t\t\tReserveIp:         pulumi.Bool(true),\n\t\t\tAccessActivityLog: pulumi.Bool(false),\n\t\t\tCreateK8sCluster:  pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tgroup3, err := compute.NewGroup(ctx, \"group3\", \u0026compute.GroupArgs{\n\t\t\tCreateDatacenter:  pulumi.Bool(true),\n\t\t\tCreateSnapshot:    pulumi.Bool(true),\n\t\t\tReserveIp:         pulumi.Bool(true),\n\t\t\tAccessActivityLog: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tuserPassword, err := random.NewRandomPassword(ctx, \"userPassword\", \u0026random.RandomPasswordArgs{\n\t\t\tLength:          pulumi.Int(16),\n\t\t\tSpecial:         pulumi.Bool(true),\n\t\t\tOverrideSpecial: pulumi.String(\"!#$%\u0026*()-_=+[]{}\u003c\u003e:?\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = compute.NewUser(ctx, \"example\", \u0026compute.UserArgs{\n\t\t\tFirstName:     pulumi.String(\"example\"),\n\t\t\tLastName:      pulumi.String(\"example\"),\n\t\t\tEmail:         pulumi.String(\"unique@email.com\"),\n\t\t\tPassword:      userPassword.Result,\n\t\t\tAdministrator: pulumi.Bool(false),\n\t\t\tForceSecAuth:  pulumi.Bool(false),\n\t\t\tActive:        pulumi.Bool(true),\n\t\t\tGroupIds: pulumi.StringArray{\n\t\t\t\tgroup1.ID(),\n\t\t\t\tgroup2.ID(),\n\t\t\t\tgroup3.ID(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.Group;\nimport com.pulumi.ionoscloud.compute.GroupArgs;\nimport com.pulumi.random.RandomPassword;\nimport com.pulumi.random.RandomPasswordArgs;\nimport com.pulumi.ionoscloud.compute.User;\nimport com.pulumi.ionoscloud.compute.UserArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var group1 = new Group(\"group1\", GroupArgs.builder()\n            .createDatacenter(true)\n            .createSnapshot(true)\n            .reserveIp(true)\n            .accessActivityLog(false)\n            .createK8sCluster(true)\n            .build());\n\n        var group2 = new Group(\"group2\", GroupArgs.builder()\n            .createDatacenter(true)\n            .createSnapshot(true)\n            .reserveIp(true)\n            .accessActivityLog(false)\n            .createK8sCluster(true)\n            .build());\n\n        var group3 = new Group(\"group3\", GroupArgs.builder()\n            .createDatacenter(true)\n            .createSnapshot(true)\n            .reserveIp(true)\n            .accessActivityLog(false)\n            .build());\n\n        var userPassword = new RandomPassword(\"userPassword\", RandomPasswordArgs.builder()\n            .length(16)\n            .special(true)\n            .overrideSpecial(\"!#$%\u0026*()-_=+[]{}\u003c\u003e:?\")\n            .build());\n\n        var example = new User(\"example\", UserArgs.builder()\n            .firstName(\"example\")\n            .lastName(\"example\")\n            .email(\"unique@email.com\")\n            .password(userPassword.result())\n            .administrator(false)\n            .forceSecAuth(false)\n            .active(true)\n            .groupIds(            \n                group1.id(),\n                group2.id(),\n                group3.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: ionoscloud:compute:User\n    properties:\n      firstName: example\n      lastName: example\n      email: unique@email.com\n      password: ${userPassword.result}\n      administrator: false\n      forceSecAuth: false\n      active: true\n      groupIds:\n        - ${group1.id}\n        - ${group2.id}\n        - ${group3.id}\n  group1:\n    type: ionoscloud:compute:Group\n    properties:\n      createDatacenter: true\n      createSnapshot: true\n      reserveIp: true\n      accessActivityLog: false\n      createK8sCluster: true\n  group2:\n    type: ionoscloud:compute:Group\n    properties:\n      createDatacenter: true\n      createSnapshot: true\n      reserveIp: true\n      accessActivityLog: false\n      createK8sCluster: true\n  group3:\n    type: ionoscloud:compute:Group\n    properties:\n      createDatacenter: true\n      createSnapshot: true\n      reserveIp: true\n      accessActivityLog: false\n  userPassword:\n    type: random:RandomPassword\n    properties:\n      length: 16\n      special: true\n      overrideSpecial: '!#$%\u0026*()-_=+[]{}\u003c\u003e:?'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nResource User can be imported using the `resource id`, e.g.\n\n```sh\n$ pulumi import ionoscloud:compute/user:User myuser {user uuid}\n```\n\n",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "[Boolean] Indicates if the user is active\n"
                },
                "administrator": {
                    "type": "boolean",
                    "description": "[Boolean] Indicates if the user has administrative rights. Administrators do not need to be managed in groups, as they automatically have access to all resources associated with the contract.\n"
                },
                "email": {
                    "type": "string",
                    "description": "[string] An e-mail address for the user.\n"
                },
                "firstName": {
                    "type": "string",
                    "description": "[string] A first name for the user.\n"
                },
                "forceSecAuth": {
                    "type": "boolean",
                    "description": "[Boolean] Indicates if secure (two-factor) authentication should be forced for the user (true) or not (false).\n"
                },
                "groupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[Set] The groups that this user will be a member of\n\n**NOTE:** Group_ids field cannot be used at the same time with user_ids field in group resource. Trying to add the same user to the same group in both ways in the same plan will result in a cyclic dependency error.\n"
                },
                "lastName": {
                    "type": "string",
                    "description": "[string] A last name for the user.\n"
                },
                "password": {
                    "type": "string",
                    "description": "[string] A password for the user.\n",
                    "secret": true
                },
                "s3CanonicalUserId": {
                    "type": "string",
                    "description": "Canonical (IONOS Object Storage) id of the user for a given identity\n"
                },
                "secAuthActive": {
                    "type": "boolean",
                    "description": "[Boolean] Indicates if secure authentication is active for the user or not. *it can not be used in create requests - can be used in update*\n"
                }
            },
            "required": [
                "email",
                "firstName",
                "lastName",
                "password",
                "s3CanonicalUserId",
                "secAuthActive"
            ],
            "inputProperties": {
                "active": {
                    "type": "boolean",
                    "description": "[Boolean] Indicates if the user is active\n"
                },
                "administrator": {
                    "type": "boolean",
                    "description": "[Boolean] Indicates if the user has administrative rights. Administrators do not need to be managed in groups, as they automatically have access to all resources associated with the contract.\n"
                },
                "email": {
                    "type": "string",
                    "description": "[string] An e-mail address for the user.\n"
                },
                "firstName": {
                    "type": "string",
                    "description": "[string] A first name for the user.\n"
                },
                "forceSecAuth": {
                    "type": "boolean",
                    "description": "[Boolean] Indicates if secure (two-factor) authentication should be forced for the user (true) or not (false).\n"
                },
                "groupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[Set] The groups that this user will be a member of\n\n**NOTE:** Group_ids field cannot be used at the same time with user_ids field in group resource. Trying to add the same user to the same group in both ways in the same plan will result in a cyclic dependency error.\n"
                },
                "lastName": {
                    "type": "string",
                    "description": "[string] A last name for the user.\n"
                },
                "password": {
                    "type": "string",
                    "description": "[string] A password for the user.\n",
                    "secret": true
                }
            },
            "requiredInputs": [
                "email",
                "firstName",
                "lastName",
                "password"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering User resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "[Boolean] Indicates if the user is active\n"
                    },
                    "administrator": {
                        "type": "boolean",
                        "description": "[Boolean] Indicates if the user has administrative rights. Administrators do not need to be managed in groups, as they automatically have access to all resources associated with the contract.\n"
                    },
                    "email": {
                        "type": "string",
                        "description": "[string] An e-mail address for the user.\n"
                    },
                    "firstName": {
                        "type": "string",
                        "description": "[string] A first name for the user.\n"
                    },
                    "forceSecAuth": {
                        "type": "boolean",
                        "description": "[Boolean] Indicates if secure (two-factor) authentication should be forced for the user (true) or not (false).\n"
                    },
                    "groupIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "[Set] The groups that this user will be a member of\n\n**NOTE:** Group_ids field cannot be used at the same time with user_ids field in group resource. Trying to add the same user to the same group in both ways in the same plan will result in a cyclic dependency error.\n"
                    },
                    "lastName": {
                        "type": "string",
                        "description": "[string] A last name for the user.\n"
                    },
                    "password": {
                        "type": "string",
                        "description": "[string] A password for the user.\n",
                        "secret": true
                    },
                    "s3CanonicalUserId": {
                        "type": "string",
                        "description": "Canonical (IONOS Object Storage) id of the user for a given identity\n"
                    },
                    "secAuthActive": {
                        "type": "boolean",
                        "description": "[Boolean] Indicates if secure authentication is active for the user or not. *it can not be used in create requests - can be used in update*\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:compute/vCPUServer:VCPUServer": {
            "description": "\n\n## Import\n\nResource VCPU Server can be imported using the `resource id` and the `datacenter id`, for example, passing only resource id and datacenter id means that the first nic found linked to the server will be attached to it.\n\n```sh\n$ pulumi import ionoscloud:compute/vCPUServer:VCPUServer myserver {datacenter uuid}/{server uuid}\n```\n\nOptionally, you can pass `primary_nic` and `firewallrule_id` so terraform will know to import also the first nic and firewall rule (if it exists on the server):\n\n```sh\n$ pulumi import ionoscloud:compute/vCPUServer:VCPUServer myserver {datacenter uuid}/{server uuid}/{primary nic id}/{firewall rule id}\n```\n\n",
            "properties": {
                "availabilityZone": {
                    "type": "string",
                    "description": "[string] The availability zone in which the server should exist. E.g: `AUTO`, `ZONE_1`, `ZONE_2`. This property is immutable.\n"
                },
                "bootCdrom": {
                    "type": "string",
                    "description": "***DEPRECATED*** Please refer to ionoscloud.compute.BootDeviceSelection (Optional)[string] The associated boot drive, if any. Must be the UUID of a bootable CDROM image that can be retrieved using the ionoscloud.compute.getImage data source.\n",
                    "deprecationMessage": "Please use the 'ionoscloud_server_boot_device_selection' resource for managing the boot device of the server."
                },
                "bootImage": {
                    "type": "string",
                    "description": "[string] The image or snapshot UUID / name. May also be an image alias. It is required if `licence_type` is not provided.\n"
                },
                "bootVolume": {
                    "type": "string",
                    "description": "The associated boot volume.\n"
                },
                "cores": {
                    "type": "integer",
                    "description": "[integer] Number of server CPU cores.\n"
                },
                "cpuFamily": {
                    "type": "string"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "[string] The ID of a Virtual Data Center.\n"
                },
                "firewallruleId": {
                    "type": "string",
                    "description": "The associated firewall rule.\n"
                },
                "firewallruleIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The associated firewall rules.\n"
                },
                "imageName": {
                    "type": "string",
                    "description": "[string] The name, ID or alias of the image. May also be a snapshot ID. It is required if `licence_type` is not provided. Attribute is immutable.\n"
                },
                "imagePassword": {
                    "type": "string",
                    "description": "[string] The password for the image.\n",
                    "secret": true
                },
                "inlineVolumeIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list with the IDs for the volumes that are defined inside the server resource.\n\n\u003e **⚠ WARNING**\n\u003e\n\u003e ssh_keys field is immutable.\n"
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:compute/VCPUServerLabel:VCPUServerLabel"
                    },
                    "description": "A label can be seen as an object with only two required fields: `key` and `value`, both of the `string` type. Please check the example presented above to see how a `label` can be used in the plan. A server can have multiple labels.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the server.\n"
                },
                "nic": {
                    "$ref": "#/types/ionoscloud:compute/VCPUServerNic:VCPUServerNic",
                    "description": "See the Nic section.\n"
                },
                "primaryIp": {
                    "type": "string",
                    "description": "The associated IP address.\n"
                },
                "primaryNic": {
                    "type": "string",
                    "description": "The associated NIC.\n"
                },
                "ram": {
                    "type": "integer",
                    "description": "[integer] The amount of memory for the server in MB.\n"
                },
                "sshKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] Immutable List of absolute or relative paths to files containing public SSH key that will be injected into IonosCloud provided Linux images. Also accepts ssh keys directly. Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key. This field may only be set in creation requests. When reading, it always returns null. SSH keys are only supported if a public Linux image is used for the volume creation. Does not support `~` expansion to homedir in the given path.\n"
                },
                "type": {
                    "type": "string"
                },
                "vmState": {
                    "type": "string",
                    "description": "Sets the power state of the vcpu server. Possible values: `RUNNING` or `SHUTOFF`.\n"
                },
                "volume": {
                    "$ref": "#/types/ionoscloud:compute/VCPUServerVolume:VCPUServerVolume",
                    "description": "See the Volume section.\n"
                }
            },
            "required": [
                "availabilityZone",
                "bootCdrom",
                "bootImage",
                "bootVolume",
                "cores",
                "cpuFamily",
                "datacenterId",
                "firewallruleId",
                "firewallruleIds",
                "imageName",
                "imagePassword",
                "inlineVolumeIds",
                "name",
                "primaryIp",
                "primaryNic",
                "ram",
                "type",
                "vmState",
                "volume"
            ],
            "inputProperties": {
                "availabilityZone": {
                    "type": "string",
                    "description": "[string] The availability zone in which the server should exist. E.g: `AUTO`, `ZONE_1`, `ZONE_2`. This property is immutable.\n",
                    "willReplaceOnChanges": true
                },
                "bootCdrom": {
                    "type": "string",
                    "description": "***DEPRECATED*** Please refer to ionoscloud.compute.BootDeviceSelection (Optional)[string] The associated boot drive, if any. Must be the UUID of a bootable CDROM image that can be retrieved using the ionoscloud.compute.getImage data source.\n",
                    "deprecationMessage": "Please use the 'ionoscloud_server_boot_device_selection' resource for managing the boot device of the server."
                },
                "bootImage": {
                    "type": "string",
                    "description": "[string] The image or snapshot UUID / name. May also be an image alias. It is required if `licence_type` is not provided.\n"
                },
                "cores": {
                    "type": "integer",
                    "description": "[integer] Number of server CPU cores.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "[string] The ID of a Virtual Data Center.\n",
                    "willReplaceOnChanges": true
                },
                "firewallruleIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The associated firewall rules.\n"
                },
                "imageName": {
                    "type": "string",
                    "description": "[string] The name, ID or alias of the image. May also be a snapshot ID. It is required if `licence_type` is not provided. Attribute is immutable.\n",
                    "willReplaceOnChanges": true
                },
                "imagePassword": {
                    "type": "string",
                    "description": "[string] The password for the image.\n",
                    "secret": true
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:compute/VCPUServerLabel:VCPUServerLabel"
                    },
                    "description": "A label can be seen as an object with only two required fields: `key` and `value`, both of the `string` type. Please check the example presented above to see how a `label` can be used in the plan. A server can have multiple labels.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the server.\n"
                },
                "nic": {
                    "$ref": "#/types/ionoscloud:compute/VCPUServerNic:VCPUServerNic",
                    "description": "See the Nic section.\n"
                },
                "ram": {
                    "type": "integer",
                    "description": "[integer] The amount of memory for the server in MB.\n"
                },
                "sshKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] Immutable List of absolute or relative paths to files containing public SSH key that will be injected into IonosCloud provided Linux images. Also accepts ssh keys directly. Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key. This field may only be set in creation requests. When reading, it always returns null. SSH keys are only supported if a public Linux image is used for the volume creation. Does not support `~` expansion to homedir in the given path.\n",
                    "willReplaceOnChanges": true
                },
                "vmState": {
                    "type": "string",
                    "description": "Sets the power state of the vcpu server. Possible values: `RUNNING` or `SHUTOFF`.\n"
                },
                "volume": {
                    "$ref": "#/types/ionoscloud:compute/VCPUServerVolume:VCPUServerVolume",
                    "description": "See the Volume section.\n"
                }
            },
            "requiredInputs": [
                "cores",
                "datacenterId",
                "ram",
                "volume"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VCPUServer resources.\n",
                "properties": {
                    "availabilityZone": {
                        "type": "string",
                        "description": "[string] The availability zone in which the server should exist. E.g: `AUTO`, `ZONE_1`, `ZONE_2`. This property is immutable.\n",
                        "willReplaceOnChanges": true
                    },
                    "bootCdrom": {
                        "type": "string",
                        "description": "***DEPRECATED*** Please refer to ionoscloud.compute.BootDeviceSelection (Optional)[string] The associated boot drive, if any. Must be the UUID of a bootable CDROM image that can be retrieved using the ionoscloud.compute.getImage data source.\n",
                        "deprecationMessage": "Please use the 'ionoscloud_server_boot_device_selection' resource for managing the boot device of the server."
                    },
                    "bootImage": {
                        "type": "string",
                        "description": "[string] The image or snapshot UUID / name. May also be an image alias. It is required if `licence_type` is not provided.\n"
                    },
                    "bootVolume": {
                        "type": "string",
                        "description": "The associated boot volume.\n"
                    },
                    "cores": {
                        "type": "integer",
                        "description": "[integer] Number of server CPU cores.\n"
                    },
                    "cpuFamily": {
                        "type": "string"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "[string] The ID of a Virtual Data Center.\n",
                        "willReplaceOnChanges": true
                    },
                    "firewallruleId": {
                        "type": "string",
                        "description": "The associated firewall rule.\n"
                    },
                    "firewallruleIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The associated firewall rules.\n"
                    },
                    "imageName": {
                        "type": "string",
                        "description": "[string] The name, ID or alias of the image. May also be a snapshot ID. It is required if `licence_type` is not provided. Attribute is immutable.\n",
                        "willReplaceOnChanges": true
                    },
                    "imagePassword": {
                        "type": "string",
                        "description": "[string] The password for the image.\n",
                        "secret": true
                    },
                    "inlineVolumeIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list with the IDs for the volumes that are defined inside the server resource.\n\n\u003e **⚠ WARNING**\n\u003e\n\u003e ssh_keys field is immutable.\n"
                    },
                    "labels": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:compute/VCPUServerLabel:VCPUServerLabel"
                        },
                        "description": "A label can be seen as an object with only two required fields: `key` and `value`, both of the `string` type. Please check the example presented above to see how a `label` can be used in the plan. A server can have multiple labels.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] The name of the server.\n"
                    },
                    "nic": {
                        "$ref": "#/types/ionoscloud:compute/VCPUServerNic:VCPUServerNic",
                        "description": "See the Nic section.\n"
                    },
                    "primaryIp": {
                        "type": "string",
                        "description": "The associated IP address.\n"
                    },
                    "primaryNic": {
                        "type": "string",
                        "description": "The associated NIC.\n"
                    },
                    "ram": {
                        "type": "integer",
                        "description": "[integer] The amount of memory for the server in MB.\n"
                    },
                    "sshKeys": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "[list] Immutable List of absolute or relative paths to files containing public SSH key that will be injected into IonosCloud provided Linux images. Also accepts ssh keys directly. Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key. This field may only be set in creation requests. When reading, it always returns null. SSH keys are only supported if a public Linux image is used for the volume creation. Does not support `~` expansion to homedir in the given path.\n",
                        "willReplaceOnChanges": true
                    },
                    "type": {
                        "type": "string"
                    },
                    "vmState": {
                        "type": "string",
                        "description": "Sets the power state of the vcpu server. Possible values: `RUNNING` or `SHUTOFF`.\n"
                    },
                    "volume": {
                        "$ref": "#/types/ionoscloud:compute/VCPUServerVolume:VCPUServerVolume",
                        "description": "See the Volume section.\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:compute/volume:Volume": {
            "description": "Manages a **Volume** on IonosCloud.\n\n## Example Usage\n\nA primary volume will be created with the server. If there is a need for additional volumes, this resource handles it.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\nimport * as random from \"@pulumi/random\";\n\nconst exampleImage = ionoscloud.compute.getImage({\n    type: \"HDD\",\n    cloudInit: \"V1\",\n    imageAlias: \"ubuntu:latest\",\n    location: \"us/las\",\n});\nconst exampleDatacenter = new ionoscloud.compute.Datacenter(\"exampleDatacenter\", {\n    location: \"us/las\",\n    description: \"Datacenter Description\",\n    secAuthProtection: false,\n});\nconst exampleLan = new ionoscloud.compute.Lan(\"exampleLan\", {\n    datacenterId: exampleDatacenter.id,\n    \"public\": true,\n});\nconst exampleIPBlock = new ionoscloud.compute.IPBlock(\"exampleIPBlock\", {\n    location: exampleDatacenter.location,\n    size: 4,\n});\nconst serverImagePassword = new random.RandomPassword(\"serverImagePassword\", {\n    length: 16,\n    special: false,\n});\nconst exampleServer = new ionoscloud.compute.Server(\"exampleServer\", {\n    datacenterId: exampleDatacenter.id,\n    cores: 1,\n    ram: 1024,\n    availabilityZone: \"ZONE_1\",\n    cpuFamily: \"INTEL_XEON\",\n    imageName: exampleImage.then(exampleImage =\u003e exampleImage.name),\n    imagePassword: serverImagePassword.result,\n    type: \"ENTERPRISE\",\n    volume: {\n        name: \"system\",\n        size: 5,\n        diskType: \"SSD Standard\",\n        userData: \"foo\",\n        bus: \"VIRTIO\",\n        availabilityZone: \"ZONE_1\",\n    },\n    nic: {\n        lan: exampleLan.id,\n        name: \"system\",\n        dhcp: true,\n        firewallActive: true,\n        firewallType: \"BIDIRECTIONAL\",\n        ips: [\n            exampleIPBlock.ips[0],\n            exampleIPBlock.ips[1],\n        ],\n        firewalls: [{\n            protocol: \"TCP\",\n            name: \"SSH\",\n            portRangeStart: 22,\n            portRangeEnd: 22,\n            sourceMac: \"00:0a:95:9d:68:17\",\n            sourceIp: exampleIPBlock.ips[2],\n            targetIp: exampleIPBlock.ips[3],\n            type: \"EGRESS\",\n        }],\n    },\n});\nconst volumeImagePassword = new random.RandomPassword(\"volumeImagePassword\", {\n    length: 16,\n    special: false,\n});\nconst exampleVolume = new ionoscloud.compute.Volume(\"exampleVolume\", {\n    datacenterId: exampleDatacenter.id,\n    serverId: exampleServer.id,\n    availabilityZone: \"ZONE_1\",\n    size: 5,\n    diskType: \"SSD Standard\",\n    bus: \"VIRTIO\",\n    imageName: exampleImage.then(exampleImage =\u003e exampleImage.name),\n    imagePassword: volumeImagePassword.result,\n    userData: \"foo\",\n});\nconst exampleCompute_volumeVolume = new ionoscloud.compute.Volume(\"exampleCompute/volumeVolume\", {\n    datacenterId: exampleDatacenter.id,\n    serverId: exampleServer.id,\n    availabilityZone: \"ZONE_1\",\n    size: 5,\n    diskType: \"SSD Standard\",\n    bus: \"VIRTIO\",\n    licenceType: \"OTHER\",\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\nimport pulumi_ionoscloud as ionoscloud\nimport pulumi_random as random\n\nexample_image = ionoscloud.compute.get_image(type=\"HDD\",\n    cloud_init=\"V1\",\n    image_alias=\"ubuntu:latest\",\n    location=\"us/las\")\nexample_datacenter = ionoscloud.compute.Datacenter(\"exampleDatacenter\",\n    location=\"us/las\",\n    description=\"Datacenter Description\",\n    sec_auth_protection=False)\nexample_lan = ionoscloud.compute.Lan(\"exampleLan\",\n    datacenter_id=example_datacenter.id,\n    public=True)\nexample_ip_block = ionoscloud.compute.IPBlock(\"exampleIPBlock\",\n    location=example_datacenter.location,\n    size=4)\nserver_image_password = random.RandomPassword(\"serverImagePassword\",\n    length=16,\n    special=False)\nexample_server = ionoscloud.compute.Server(\"exampleServer\",\n    datacenter_id=example_datacenter.id,\n    cores=1,\n    ram=1024,\n    availability_zone=\"ZONE_1\",\n    cpu_family=\"INTEL_XEON\",\n    image_name=example_image.name,\n    image_password=server_image_password.result,\n    type=\"ENTERPRISE\",\n    volume={\n        \"name\": \"system\",\n        \"size\": 5,\n        \"disk_type\": \"SSD Standard\",\n        \"user_data\": \"foo\",\n        \"bus\": \"VIRTIO\",\n        \"availability_zone\": \"ZONE_1\",\n    },\n    nic={\n        \"lan\": example_lan.id,\n        \"name\": \"system\",\n        \"dhcp\": True,\n        \"firewall_active\": True,\n        \"firewall_type\": \"BIDIRECTIONAL\",\n        \"ips\": [\n            example_ip_block.ips[0],\n            example_ip_block.ips[1],\n        ],\n        \"firewalls\": [{\n            \"protocol\": \"TCP\",\n            \"name\": \"SSH\",\n            \"port_range_start\": 22,\n            \"port_range_end\": 22,\n            \"source_mac\": \"00:0a:95:9d:68:17\",\n            \"source_ip\": example_ip_block.ips[2],\n            \"target_ip\": example_ip_block.ips[3],\n            \"type\": \"EGRESS\",\n        }],\n    })\nvolume_image_password = random.RandomPassword(\"volumeImagePassword\",\n    length=16,\n    special=False)\nexample_volume = ionoscloud.compute.Volume(\"exampleVolume\",\n    datacenter_id=example_datacenter.id,\n    server_id=example_server.id,\n    availability_zone=\"ZONE_1\",\n    size=5,\n    disk_type=\"SSD Standard\",\n    bus=\"VIRTIO\",\n    image_name=example_image.name,\n    image_password=volume_image_password.result,\n    user_data=\"foo\")\nexample_compute_volume_volume = ionoscloud.compute.Volume(\"exampleCompute/volumeVolume\",\n    datacenter_id=example_datacenter.id,\n    server_id=example_server.id,\n    availability_zone=\"ZONE_1\",\n    size=5,\n    disk_type=\"SSD Standard\",\n    bus=\"VIRTIO\",\n    licence_type=\"OTHER\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\nusing Random = Pulumi.Random;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleImage = Ionoscloud.Compute.GetImage.Invoke(new()\n    {\n        Type = \"HDD\",\n        CloudInit = \"V1\",\n        ImageAlias = \"ubuntu:latest\",\n        Location = \"us/las\",\n    });\n\n    var exampleDatacenter = new Ionoscloud.Compute.Datacenter(\"exampleDatacenter\", new()\n    {\n        Location = \"us/las\",\n        Description = \"Datacenter Description\",\n        SecAuthProtection = false,\n    });\n\n    var exampleLan = new Ionoscloud.Compute.Lan(\"exampleLan\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        Public = true,\n    });\n\n    var exampleIPBlock = new Ionoscloud.Compute.IPBlock(\"exampleIPBlock\", new()\n    {\n        Location = exampleDatacenter.Location,\n        Size = 4,\n    });\n\n    var serverImagePassword = new Random.RandomPassword(\"serverImagePassword\", new()\n    {\n        Length = 16,\n        Special = false,\n    });\n\n    var exampleServer = new Ionoscloud.Compute.Server(\"exampleServer\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        Cores = 1,\n        Ram = 1024,\n        AvailabilityZone = \"ZONE_1\",\n        CpuFamily = \"INTEL_XEON\",\n        ImageName = exampleImage.Apply(getImageResult =\u003e getImageResult.Name),\n        ImagePassword = serverImagePassword.Result,\n        Type = \"ENTERPRISE\",\n        Volume = new Ionoscloud.Compute.Inputs.ServerVolumeArgs\n        {\n            Name = \"system\",\n            Size = 5,\n            DiskType = \"SSD Standard\",\n            UserData = \"foo\",\n            Bus = \"VIRTIO\",\n            AvailabilityZone = \"ZONE_1\",\n        },\n        Nic = new Ionoscloud.Compute.Inputs.ServerNicArgs\n        {\n            Lan = exampleLan.Id,\n            Name = \"system\",\n            Dhcp = true,\n            FirewallActive = true,\n            FirewallType = \"BIDIRECTIONAL\",\n            Ips = new[]\n            {\n                exampleIPBlock.Ips.Apply(ips =\u003e ips[0]),\n                exampleIPBlock.Ips.Apply(ips =\u003e ips[1]),\n            },\n            Firewalls = new[]\n            {\n                new Ionoscloud.Compute.Inputs.ServerNicFirewallArgs\n                {\n                    Protocol = \"TCP\",\n                    Name = \"SSH\",\n                    PortRangeStart = 22,\n                    PortRangeEnd = 22,\n                    SourceMac = \"00:0a:95:9d:68:17\",\n                    SourceIp = exampleIPBlock.Ips.Apply(ips =\u003e ips[2]),\n                    TargetIp = exampleIPBlock.Ips.Apply(ips =\u003e ips[3]),\n                    Type = \"EGRESS\",\n                },\n            },\n        },\n    });\n\n    var volumeImagePassword = new Random.RandomPassword(\"volumeImagePassword\", new()\n    {\n        Length = 16,\n        Special = false,\n    });\n\n    var exampleVolume = new Ionoscloud.Compute.Volume(\"exampleVolume\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        ServerId = exampleServer.Id,\n        AvailabilityZone = \"ZONE_1\",\n        Size = 5,\n        DiskType = \"SSD Standard\",\n        Bus = \"VIRTIO\",\n        ImageName = exampleImage.Apply(getImageResult =\u003e getImageResult.Name),\n        ImagePassword = volumeImagePassword.Result,\n        UserData = \"foo\",\n    });\n\n    var exampleCompute_volumeVolume = new Ionoscloud.Compute.Volume(\"exampleCompute/volumeVolume\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        ServerId = exampleServer.Id,\n        AvailabilityZone = \"ZONE_1\",\n        Size = 5,\n        DiskType = \"SSD Standard\",\n        Bus = \"VIRTIO\",\n        LicenceType = \"OTHER\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi-random/sdk/v4/go/random\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleImage, err := compute.GetImage(ctx, \u0026compute.GetImageArgs{\n\t\t\tType:       pulumi.StringRef(\"HDD\"),\n\t\t\tCloudInit:  pulumi.StringRef(\"V1\"),\n\t\t\tImageAlias: pulumi.StringRef(\"ubuntu:latest\"),\n\t\t\tLocation:   pulumi.StringRef(\"us/las\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleDatacenter, err := compute.NewDatacenter(ctx, \"exampleDatacenter\", \u0026compute.DatacenterArgs{\n\t\t\tLocation:          pulumi.String(\"us/las\"),\n\t\t\tDescription:       pulumi.String(\"Datacenter Description\"),\n\t\t\tSecAuthProtection: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleLan, err := compute.NewLan(ctx, \"exampleLan\", \u0026compute.LanArgs{\n\t\t\tDatacenterId: exampleDatacenter.ID(),\n\t\t\tPublic:       pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleIPBlock, err := compute.NewIPBlock(ctx, \"exampleIPBlock\", \u0026compute.IPBlockArgs{\n\t\t\tLocation: exampleDatacenter.Location,\n\t\t\tSize:     pulumi.Int(4),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tserverImagePassword, err := random.NewRandomPassword(ctx, \"serverImagePassword\", \u0026random.RandomPasswordArgs{\n\t\t\tLength:  pulumi.Int(16),\n\t\t\tSpecial: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleServer, err := compute.NewServer(ctx, \"exampleServer\", \u0026compute.ServerArgs{\n\t\t\tDatacenterId:     exampleDatacenter.ID(),\n\t\t\tCores:            pulumi.Int(1),\n\t\t\tRam:              pulumi.Int(1024),\n\t\t\tAvailabilityZone: pulumi.String(\"ZONE_1\"),\n\t\t\tCpuFamily:        pulumi.String(\"INTEL_XEON\"),\n\t\t\tImageName:        pulumi.String(exampleImage.Name),\n\t\t\tImagePassword:    serverImagePassword.Result,\n\t\t\tType:             pulumi.String(\"ENTERPRISE\"),\n\t\t\tVolume: \u0026compute.ServerVolumeArgs{\n\t\t\t\tName:             pulumi.String(\"system\"),\n\t\t\t\tSize:             pulumi.Int(5),\n\t\t\t\tDiskType:         pulumi.String(\"SSD Standard\"),\n\t\t\t\tUserData:         pulumi.String(\"foo\"),\n\t\t\t\tBus:              pulumi.String(\"VIRTIO\"),\n\t\t\t\tAvailabilityZone: pulumi.String(\"ZONE_1\"),\n\t\t\t},\n\t\t\tNic: \u0026compute.ServerNicArgs{\n\t\t\t\tLan:            exampleLan.ID(),\n\t\t\t\tName:           pulumi.String(\"system\"),\n\t\t\t\tDhcp:           pulumi.Bool(true),\n\t\t\t\tFirewallActive: pulumi.Bool(true),\n\t\t\t\tFirewallType:   pulumi.String(\"BIDIRECTIONAL\"),\n\t\t\t\tIps: pulumi.StringArray{\n\t\t\t\t\texampleIPBlock.Ips.ApplyT(func(ips []string) (string, error) {\n\t\t\t\t\t\treturn ips[0], nil\n\t\t\t\t\t}).(pulumi.StringOutput),\n\t\t\t\t\texampleIPBlock.Ips.ApplyT(func(ips []string) (string, error) {\n\t\t\t\t\t\treturn ips[1], nil\n\t\t\t\t\t}).(pulumi.StringOutput),\n\t\t\t\t},\n\t\t\t\tFirewalls: compute.ServerNicFirewallArray{\n\t\t\t\t\t\u0026compute.ServerNicFirewallArgs{\n\t\t\t\t\t\tProtocol:       pulumi.String(\"TCP\"),\n\t\t\t\t\t\tName:           pulumi.String(\"SSH\"),\n\t\t\t\t\t\tPortRangeStart: pulumi.Int(22),\n\t\t\t\t\t\tPortRangeEnd:   pulumi.Int(22),\n\t\t\t\t\t\tSourceMac:      pulumi.String(\"00:0a:95:9d:68:17\"),\n\t\t\t\t\t\tSourceIp: exampleIPBlock.Ips.ApplyT(func(ips []string) (string, error) {\n\t\t\t\t\t\t\treturn ips[2], nil\n\t\t\t\t\t\t}).(pulumi.StringOutput),\n\t\t\t\t\t\tTargetIp: exampleIPBlock.Ips.ApplyT(func(ips []string) (string, error) {\n\t\t\t\t\t\t\treturn ips[3], nil\n\t\t\t\t\t\t}).(pulumi.StringOutput),\n\t\t\t\t\t\tType: pulumi.String(\"EGRESS\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvolumeImagePassword, err := random.NewRandomPassword(ctx, \"volumeImagePassword\", \u0026random.RandomPasswordArgs{\n\t\t\tLength:  pulumi.Int(16),\n\t\t\tSpecial: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = compute.NewVolume(ctx, \"exampleVolume\", \u0026compute.VolumeArgs{\n\t\t\tDatacenterId:     exampleDatacenter.ID(),\n\t\t\tServerId:         exampleServer.ID(),\n\t\t\tAvailabilityZone: pulumi.String(\"ZONE_1\"),\n\t\t\tSize:             pulumi.Int(5),\n\t\t\tDiskType:         pulumi.String(\"SSD Standard\"),\n\t\t\tBus:              pulumi.String(\"VIRTIO\"),\n\t\t\tImageName:        pulumi.String(exampleImage.Name),\n\t\t\tImagePassword:    volumeImagePassword.Result,\n\t\t\tUserData:         pulumi.String(\"foo\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = compute.NewVolume(ctx, \"exampleCompute/volumeVolume\", \u0026compute.VolumeArgs{\n\t\t\tDatacenterId:     exampleDatacenter.ID(),\n\t\t\tServerId:         exampleServer.ID(),\n\t\t\tAvailabilityZone: pulumi.String(\"ZONE_1\"),\n\t\t\tSize:             pulumi.Int(5),\n\t\t\tDiskType:         pulumi.String(\"SSD Standard\"),\n\t\t\tBus:              pulumi.String(\"VIRTIO\"),\n\t\t\tLicenceType:      pulumi.String(\"OTHER\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.ComputeFunctions;\nimport com.pulumi.ionoscloud.compute.inputs.GetImageArgs;\nimport com.pulumi.ionoscloud.compute.Datacenter;\nimport com.pulumi.ionoscloud.compute.DatacenterArgs;\nimport com.pulumi.ionoscloud.compute.Lan;\nimport com.pulumi.ionoscloud.compute.LanArgs;\nimport com.pulumi.ionoscloud.compute.IPBlock;\nimport com.pulumi.ionoscloud.compute.IPBlockArgs;\nimport com.pulumi.random.RandomPassword;\nimport com.pulumi.random.RandomPasswordArgs;\nimport com.pulumi.ionoscloud.compute.Server;\nimport com.pulumi.ionoscloud.compute.ServerArgs;\nimport com.pulumi.ionoscloud.compute.inputs.ServerVolumeArgs;\nimport com.pulumi.ionoscloud.compute.inputs.ServerNicArgs;\nimport com.pulumi.ionoscloud.compute.Volume;\nimport com.pulumi.ionoscloud.compute.VolumeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var exampleImage = ComputeFunctions.getImage(GetImageArgs.builder()\n            .type(\"HDD\")\n            .cloudInit(\"V1\")\n            .imageAlias(\"ubuntu:latest\")\n            .location(\"us/las\")\n            .build());\n\n        var exampleDatacenter = new Datacenter(\"exampleDatacenter\", DatacenterArgs.builder()\n            .location(\"us/las\")\n            .description(\"Datacenter Description\")\n            .secAuthProtection(false)\n            .build());\n\n        var exampleLan = new Lan(\"exampleLan\", LanArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .public_(true)\n            .build());\n\n        var exampleIPBlock = new IPBlock(\"exampleIPBlock\", IPBlockArgs.builder()\n            .location(exampleDatacenter.location())\n            .size(4)\n            .build());\n\n        var serverImagePassword = new RandomPassword(\"serverImagePassword\", RandomPasswordArgs.builder()\n            .length(16)\n            .special(false)\n            .build());\n\n        var exampleServer = new Server(\"exampleServer\", ServerArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .cores(1)\n            .ram(1024)\n            .availabilityZone(\"ZONE_1\")\n            .cpuFamily(\"INTEL_XEON\")\n            .imageName(exampleImage.applyValue(getImageResult -\u003e getImageResult.name()))\n            .imagePassword(serverImagePassword.result())\n            .type(\"ENTERPRISE\")\n            .volume(ServerVolumeArgs.builder()\n                .name(\"system\")\n                .size(5)\n                .diskType(\"SSD Standard\")\n                .userData(\"foo\")\n                .bus(\"VIRTIO\")\n                .availabilityZone(\"ZONE_1\")\n                .build())\n            .nic(ServerNicArgs.builder()\n                .lan(exampleLan.id())\n                .name(\"system\")\n                .dhcp(true)\n                .firewallActive(true)\n                .firewallType(\"BIDIRECTIONAL\")\n                .ips(                \n                    exampleIPBlock.ips().applyValue(ips -\u003e ips[0]),\n                    exampleIPBlock.ips().applyValue(ips -\u003e ips[1]))\n                .firewalls(ServerNicFirewallArgs.builder()\n                    .protocol(\"TCP\")\n                    .name(\"SSH\")\n                    .portRangeStart(22)\n                    .portRangeEnd(22)\n                    .sourceMac(\"00:0a:95:9d:68:17\")\n                    .sourceIp(exampleIPBlock.ips().applyValue(ips -\u003e ips[2]))\n                    .targetIp(exampleIPBlock.ips().applyValue(ips -\u003e ips[3]))\n                    .type(\"EGRESS\")\n                    .build())\n                .build())\n            .build());\n\n        var volumeImagePassword = new RandomPassword(\"volumeImagePassword\", RandomPasswordArgs.builder()\n            .length(16)\n            .special(false)\n            .build());\n\n        var exampleVolume = new Volume(\"exampleVolume\", VolumeArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .serverId(exampleServer.id())\n            .availabilityZone(\"ZONE_1\")\n            .size(5)\n            .diskType(\"SSD Standard\")\n            .bus(\"VIRTIO\")\n            .imageName(exampleImage.applyValue(getImageResult -\u003e getImageResult.name()))\n            .imagePassword(volumeImagePassword.result())\n            .userData(\"foo\")\n            .build());\n\n        var exampleCompute_volumeVolume = new Volume(\"exampleCompute/volumeVolume\", VolumeArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .serverId(exampleServer.id())\n            .availabilityZone(\"ZONE_1\")\n            .size(5)\n            .diskType(\"SSD Standard\")\n            .bus(\"VIRTIO\")\n            .licenceType(\"OTHER\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleDatacenter:\n    type: ionoscloud:compute:Datacenter\n    properties:\n      location: us/las\n      description: Datacenter Description\n      secAuthProtection: false\n  exampleLan:\n    type: ionoscloud:compute:Lan\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      public: true\n  exampleIPBlock:\n    type: ionoscloud:compute:IPBlock\n    properties:\n      location: ${exampleDatacenter.location}\n      size: 4\n  exampleServer:\n    type: ionoscloud:compute:Server\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      cores: 1\n      ram: 1024\n      availabilityZone: ZONE_1\n      cpuFamily: INTEL_XEON\n      imageName: ${exampleImage.name}\n      imagePassword: ${serverImagePassword.result}\n      type: ENTERPRISE\n      volume:\n        name: system\n        size: 5\n        diskType: SSD Standard\n        userData: foo\n        bus: VIRTIO\n        availabilityZone: ZONE_1\n      nic:\n        lan: ${exampleLan.id}\n        name: system\n        dhcp: true\n        firewallActive: true\n        firewallType: BIDIRECTIONAL\n        ips:\n          - ${exampleIPBlock.ips[0]}\n          - ${exampleIPBlock.ips[1]}\n        firewalls:\n          - protocol: TCP\n            name: SSH\n            portRangeStart: 22\n            portRangeEnd: 22\n            sourceMac: 00:0a:95:9d:68:17\n            sourceIp: ${exampleIPBlock.ips[2]}\n            targetIp: ${exampleIPBlock.ips[3]}\n            type: EGRESS\n  exampleVolume:\n    type: ionoscloud:compute:Volume\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      serverId: ${exampleServer.id}\n      availabilityZone: ZONE_1\n      size: 5\n      diskType: SSD Standard\n      bus: VIRTIO\n      imageName: ${exampleImage.name}\n      imagePassword: ${volumeImagePassword.result}\n      userData: foo\n  exampleCompute/volumeVolume:\n    type: ionoscloud:compute:Volume\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      serverId: ${exampleServer.id}\n      availabilityZone: ZONE_1\n      size: 5\n      diskType: SSD Standard\n      bus: VIRTIO\n      licenceType: OTHER\n  serverImagePassword:\n    type: random:RandomPassword\n    properties:\n      length: 16\n      special: false\n  volumeImagePassword:\n    type: random:RandomPassword\n    properties:\n      length: 16\n      special: false\nvariables:\n  exampleImage:\n    fn::invoke:\n      function: ionoscloud:compute:getImage\n      arguments:\n        type: HDD\n        cloudInit: V1\n        imageAlias: ubuntu:latest\n        location: us/las\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nResource Volume can be imported using the `resource id`, e.g.\n\n```sh\n$ pulumi import ionoscloud:compute/volume:Volume myvolume {datacenter uuid}/{server uuid}/{volume uuid}\n```\n\n",
            "properties": {
                "availabilityZone": {
                    "type": "string",
                    "description": "[string] The storage availability zone assigned to the volume: AUTO, ZONE_1, ZONE_2, or ZONE_3. This property is immutable\n"
                },
                "backupUnitId": {
                    "type": "string",
                    "description": "[string] The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.\n"
                },
                "bootServer": {
                    "type": "string",
                    "description": "[string] The UUID of the attached server.\n\u003e **⚠ WARNING**\n\u003e\n\u003e ssh_key_path and ssh_keys fields are immutable.\n\u003e If you want to create a **CUBE** server, the type of the inline volume must be set to **DAS**. In this case, you can not set the `size` argument since it is taken from the `template_uuid` you set in the server.\n"
                },
                "bus": {
                    "type": "string",
                    "description": "[Boolean] The bus type of the volume: VIRTIO or IDE.\n"
                },
                "cpuHotPlug": {
                    "type": "boolean",
                    "description": "[string] Is capable of CPU hot plug (no reboot required)\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "[string] The ID of a Virtual Data Center.\n"
                },
                "deviceNumber": {
                    "type": "integer",
                    "description": "The Logical Unit Number of the storage volume. Null for volumes not mounted to any VM.\n"
                },
                "discVirtioHotPlug": {
                    "type": "boolean",
                    "description": "[string] Is capable of Virt-IO drive hot plug (no reboot required)\n"
                },
                "discVirtioHotUnplug": {
                    "type": "boolean",
                    "description": "[string] Is capable of Virt-IO drive hot unplug (no reboot required). This works only for non-Windows virtual Machines.\n"
                },
                "diskType": {
                    "type": "string",
                    "description": "[string] The volume type: HDD or SSD. This property is immutable.\n"
                },
                "image": {
                    "type": "string",
                    "description": "The image or snapshot UUID.\n"
                },
                "imageId": {
                    "type": "string"
                },
                "imageName": {
                    "type": "string",
                    "description": "[string] The name, ID or alias of the image. May also be a snapshot ID. It is required if `licence_type` is not provided. Attribute is immutable.\n"
                },
                "imagePassword": {
                    "type": "string",
                    "description": "[string] Required if `sshkey_path` is not provided.\n"
                },
                "licenceType": {
                    "type": "string",
                    "description": "[string] Required if `image_name` is not provided.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the volume.\n"
                },
                "nicHotPlug": {
                    "type": "boolean",
                    "description": "[string] Is capable of nic hot plug (no reboot required)\n"
                },
                "nicHotUnplug": {
                    "type": "boolean",
                    "description": "[string] Is capable of nic hot unplug (no reboot required)\n"
                },
                "pciSlot": {
                    "type": "integer",
                    "description": "The PCI slot number of the storage volume. Null for volumes not mounted to any VM.\n"
                },
                "ramHotPlug": {
                    "type": "boolean",
                    "description": "[string] Is capable of memory hot plug (no reboot required)\n"
                },
                "serverId": {
                    "type": "string",
                    "description": "[string] The ID of a server.\n"
                },
                "size": {
                    "type": "integer",
                    "description": "[integer] The size of the volume in GB.\n"
                },
                "sshKeyPaths": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] List of absolute paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images. Also accepts ssh keys directly. Required for IonosCloud Linux images. Required if `image_password` is not provided. This property is immutable.\n"
                },
                "sshKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] List of absolute paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images. Also accepts ssh keys directly. Required for IonosCloud Linux images. Required if `image_password` is not provided. This property is immutable.\n"
                },
                "sshkey": {
                    "type": "string",
                    "description": "The associated public SSH key.\n"
                },
                "userData": {
                    "type": "string",
                    "description": "[string] The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. This option will work only with cloud-init compatible images.\n"
                }
            },
            "required": [
                "availabilityZone",
                "backupUnitId",
                "bootServer",
                "bus",
                "cpuHotPlug",
                "datacenterId",
                "deviceNumber",
                "discVirtioHotPlug",
                "discVirtioHotUnplug",
                "diskType",
                "image",
                "imageId",
                "licenceType",
                "name",
                "nicHotPlug",
                "nicHotUnplug",
                "pciSlot",
                "ramHotPlug",
                "serverId",
                "size",
                "sshkey",
                "userData"
            ],
            "inputProperties": {
                "availabilityZone": {
                    "type": "string",
                    "description": "[string] The storage availability zone assigned to the volume: AUTO, ZONE_1, ZONE_2, or ZONE_3. This property is immutable\n"
                },
                "backupUnitId": {
                    "type": "string",
                    "description": "[string] The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.\n"
                },
                "bus": {
                    "type": "string",
                    "description": "[Boolean] The bus type of the volume: VIRTIO or IDE.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "[string] The ID of a Virtual Data Center.\n",
                    "willReplaceOnChanges": true
                },
                "diskType": {
                    "type": "string",
                    "description": "[string] The volume type: HDD or SSD. This property is immutable.\n"
                },
                "imageName": {
                    "type": "string",
                    "description": "[string] The name, ID or alias of the image. May also be a snapshot ID. It is required if `licence_type` is not provided. Attribute is immutable.\n"
                },
                "imagePassword": {
                    "type": "string",
                    "description": "[string] Required if `sshkey_path` is not provided.\n"
                },
                "licenceType": {
                    "type": "string",
                    "description": "[string] Required if `image_name` is not provided.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the volume.\n"
                },
                "serverId": {
                    "type": "string",
                    "description": "[string] The ID of a server.\n"
                },
                "size": {
                    "type": "integer",
                    "description": "[integer] The size of the volume in GB.\n"
                },
                "sshKeyPaths": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] List of absolute paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images. Also accepts ssh keys directly. Required for IonosCloud Linux images. Required if `image_password` is not provided. This property is immutable.\n"
                },
                "sshKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] List of absolute paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images. Also accepts ssh keys directly. Required for IonosCloud Linux images. Required if `image_password` is not provided. This property is immutable.\n"
                },
                "userData": {
                    "type": "string",
                    "description": "[string] The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. This option will work only with cloud-init compatible images.\n"
                }
            },
            "requiredInputs": [
                "datacenterId",
                "diskType",
                "serverId",
                "size"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Volume resources.\n",
                "properties": {
                    "availabilityZone": {
                        "type": "string",
                        "description": "[string] The storage availability zone assigned to the volume: AUTO, ZONE_1, ZONE_2, or ZONE_3. This property is immutable\n"
                    },
                    "backupUnitId": {
                        "type": "string",
                        "description": "[string] The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.\n"
                    },
                    "bootServer": {
                        "type": "string",
                        "description": "[string] The UUID of the attached server.\n\u003e **⚠ WARNING**\n\u003e\n\u003e ssh_key_path and ssh_keys fields are immutable.\n\u003e If you want to create a **CUBE** server, the type of the inline volume must be set to **DAS**. In this case, you can not set the `size` argument since it is taken from the `template_uuid` you set in the server.\n"
                    },
                    "bus": {
                        "type": "string",
                        "description": "[Boolean] The bus type of the volume: VIRTIO or IDE.\n"
                    },
                    "cpuHotPlug": {
                        "type": "boolean",
                        "description": "[string] Is capable of CPU hot plug (no reboot required)\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "[string] The ID of a Virtual Data Center.\n",
                        "willReplaceOnChanges": true
                    },
                    "deviceNumber": {
                        "type": "integer",
                        "description": "The Logical Unit Number of the storage volume. Null for volumes not mounted to any VM.\n"
                    },
                    "discVirtioHotPlug": {
                        "type": "boolean",
                        "description": "[string] Is capable of Virt-IO drive hot plug (no reboot required)\n"
                    },
                    "discVirtioHotUnplug": {
                        "type": "boolean",
                        "description": "[string] Is capable of Virt-IO drive hot unplug (no reboot required). This works only for non-Windows virtual Machines.\n"
                    },
                    "diskType": {
                        "type": "string",
                        "description": "[string] The volume type: HDD or SSD. This property is immutable.\n"
                    },
                    "image": {
                        "type": "string",
                        "description": "The image or snapshot UUID.\n"
                    },
                    "imageId": {
                        "type": "string"
                    },
                    "imageName": {
                        "type": "string",
                        "description": "[string] The name, ID or alias of the image. May also be a snapshot ID. It is required if `licence_type` is not provided. Attribute is immutable.\n"
                    },
                    "imagePassword": {
                        "type": "string",
                        "description": "[string] Required if `sshkey_path` is not provided.\n"
                    },
                    "licenceType": {
                        "type": "string",
                        "description": "[string] Required if `image_name` is not provided.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] The name of the volume.\n"
                    },
                    "nicHotPlug": {
                        "type": "boolean",
                        "description": "[string] Is capable of nic hot plug (no reboot required)\n"
                    },
                    "nicHotUnplug": {
                        "type": "boolean",
                        "description": "[string] Is capable of nic hot unplug (no reboot required)\n"
                    },
                    "pciSlot": {
                        "type": "integer",
                        "description": "The PCI slot number of the storage volume. Null for volumes not mounted to any VM.\n"
                    },
                    "ramHotPlug": {
                        "type": "boolean",
                        "description": "[string] Is capable of memory hot plug (no reboot required)\n"
                    },
                    "serverId": {
                        "type": "string",
                        "description": "[string] The ID of a server.\n"
                    },
                    "size": {
                        "type": "integer",
                        "description": "[integer] The size of the volume in GB.\n"
                    },
                    "sshKeyPaths": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "[list] List of absolute paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images. Also accepts ssh keys directly. Required for IonosCloud Linux images. Required if `image_password` is not provided. This property is immutable.\n"
                    },
                    "sshKeys": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "[list] List of absolute paths to files containing a public SSH key that will be injected into IonosCloud provided Linux images. Also accepts ssh keys directly. Required for IonosCloud Linux images. Required if `image_password` is not provided. This property is immutable.\n"
                    },
                    "sshkey": {
                        "type": "string",
                        "description": "The associated public SSH key.\n"
                    },
                    "userData": {
                        "type": "string",
                        "description": "[string] The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. This option will work only with cloud-init compatible images.\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:creg/registry:Registry": {
            "description": "Manages an **Container Registry** on IonosCloud.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = new ionoscloud.creg.Registry(\"example\", {\n    apiSubnetAllowLists: [\"1.2.3.4/32\"],\n    garbageCollectionSchedule: {\n        days: [\n            \"Monday\",\n            \"Tuesday\",\n        ],\n        time: \"05:19:00+00:00\",\n    },\n    location: \"de/fra\",\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\nexample = ionoscloud.creg.Registry(\"example\",\n    api_subnet_allow_lists=[\"1.2.3.4/32\"],\n    garbage_collection_schedule={\n        \"days\": [\n            \"Monday\",\n            \"Tuesday\",\n        ],\n        \"time\": \"05:19:00+00:00\",\n    },\n    location=\"de/fra\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Ionoscloud.Creg.Registry(\"example\", new()\n    {\n        ApiSubnetAllowLists = new[]\n        {\n            \"1.2.3.4/32\",\n        },\n        GarbageCollectionSchedule = new Ionoscloud.Creg.Inputs.RegistryGarbageCollectionScheduleArgs\n        {\n            Days = new[]\n            {\n                \"Monday\",\n                \"Tuesday\",\n            },\n            Time = \"05:19:00+00:00\",\n        },\n        Location = \"de/fra\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/creg\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := creg.NewRegistry(ctx, \"example\", \u0026creg.RegistryArgs{\n\t\t\tApiSubnetAllowLists: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"1.2.3.4/32\"),\n\t\t\t},\n\t\t\tGarbageCollectionSchedule: \u0026creg.RegistryGarbageCollectionScheduleArgs{\n\t\t\t\tDays: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"Monday\"),\n\t\t\t\t\tpulumi.String(\"Tuesday\"),\n\t\t\t\t},\n\t\t\t\tTime: pulumi.String(\"05:19:00+00:00\"),\n\t\t\t},\n\t\t\tLocation: pulumi.String(\"de/fra\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.creg.Registry;\nimport com.pulumi.ionoscloud.creg.RegistryArgs;\nimport com.pulumi.ionoscloud.creg.inputs.RegistryGarbageCollectionScheduleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new Registry(\"example\", RegistryArgs.builder()\n            .apiSubnetAllowLists(\"1.2.3.4/32\")\n            .garbageCollectionSchedule(RegistryGarbageCollectionScheduleArgs.builder()\n                .days(                \n                    \"Monday\",\n                    \"Tuesday\")\n                .time(\"05:19:00+00:00\")\n                .build())\n            .location(\"de/fra\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: ionoscloud:creg:Registry\n    properties:\n      apiSubnetAllowLists:\n        - 1.2.3.4/32\n      garbageCollectionSchedule:\n        days:\n          - Monday\n          - Tuesday\n        time: 05:19:00+00:00\n      location: de/fra\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nResource Container Registry can be imported using the `resource id`, e.g.\n\n```sh\n$ pulumi import ionoscloud:creg/registry:Registry mycr {container_registry uuid}\n```\n\n",
            "properties": {
                "apiSubnetAllowLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] The subnet CIDRs that are allowed to connect to the registry.  Specify \"a.b.c.d/32\" for an individual IP address. __Note__: If this list is empty or not set, there are no restrictions.\n"
                },
                "features": {
                    "$ref": "#/types/ionoscloud:creg/RegistryFeatures:RegistryFeatures",
                    "description": "[Map]\n"
                },
                "garbageCollectionSchedule": {
                    "$ref": "#/types/ionoscloud:creg/RegistryGarbageCollectionSchedule:RegistryGarbageCollectionSchedule",
                    "description": "[Map]\n"
                },
                "hostname": {
                    "type": "string"
                },
                "location": {
                    "type": "string",
                    "description": "[string] Immutable, update forces re-creation of the resource.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the container registry. Immutable, update forces re-creation of the resource.\n"
                },
                "storageUsages": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:creg/RegistryStorageUsage:RegistryStorageUsage"
                    }
                }
            },
            "required": [
                "features",
                "garbageCollectionSchedule",
                "hostname",
                "location",
                "name",
                "storageUsages"
            ],
            "inputProperties": {
                "apiSubnetAllowLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] The subnet CIDRs that are allowed to connect to the registry.  Specify \"a.b.c.d/32\" for an individual IP address. __Note__: If this list is empty or not set, there are no restrictions.\n"
                },
                "features": {
                    "$ref": "#/types/ionoscloud:creg/RegistryFeatures:RegistryFeatures",
                    "description": "[Map]\n"
                },
                "garbageCollectionSchedule": {
                    "$ref": "#/types/ionoscloud:creg/RegistryGarbageCollectionSchedule:RegistryGarbageCollectionSchedule",
                    "description": "[Map]\n"
                },
                "location": {
                    "type": "string",
                    "description": "[string] Immutable, update forces re-creation of the resource.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name of the container registry. Immutable, update forces re-creation of the resource.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "location"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Registry resources.\n",
                "properties": {
                    "apiSubnetAllowLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "[list] The subnet CIDRs that are allowed to connect to the registry.  Specify \"a.b.c.d/32\" for an individual IP address. __Note__: If this list is empty or not set, there are no restrictions.\n"
                    },
                    "features": {
                        "$ref": "#/types/ionoscloud:creg/RegistryFeatures:RegistryFeatures",
                        "description": "[Map]\n"
                    },
                    "garbageCollectionSchedule": {
                        "$ref": "#/types/ionoscloud:creg/RegistryGarbageCollectionSchedule:RegistryGarbageCollectionSchedule",
                        "description": "[Map]\n"
                    },
                    "hostname": {
                        "type": "string"
                    },
                    "location": {
                        "type": "string",
                        "description": "[string] Immutable, update forces re-creation of the resource.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the container registry. Immutable, update forces re-creation of the resource.\n",
                        "willReplaceOnChanges": true
                    },
                    "storageUsages": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:creg/RegistryStorageUsage:RegistryStorageUsage"
                        }
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:creg/registryToken:RegistryToken": {
            "description": "Manages an **Container Registry Token** on IonosCloud.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst exampleRegistry = new ionoscloud.creg.Registry(\"exampleRegistry\", {\n    garbageCollectionSchedule: {\n        days: [\n            \"Monday\",\n            \"Tuesday\",\n        ],\n        time: \"05:19:00+00:00\",\n    },\n    location: \"de/fra\",\n});\nconst exampleRegistryToken = new ionoscloud.creg.RegistryToken(\"exampleRegistryToken\", {\n    expiryDate: \"2023-01-13 16:27:42Z\",\n    scopes: [{\n        actions: [\"push\"],\n        name: \"Scope1\",\n        type: \"repository\",\n    }],\n    status: \"enabled\",\n    registryId: exampleRegistry.id,\n    savePasswordToFile: \"pass.txt\",\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\nexample_registry = ionoscloud.creg.Registry(\"exampleRegistry\",\n    garbage_collection_schedule={\n        \"days\": [\n            \"Monday\",\n            \"Tuesday\",\n        ],\n        \"time\": \"05:19:00+00:00\",\n    },\n    location=\"de/fra\")\nexample_registry_token = ionoscloud.creg.RegistryToken(\"exampleRegistryToken\",\n    expiry_date=\"2023-01-13 16:27:42Z\",\n    scopes=[{\n        \"actions\": [\"push\"],\n        \"name\": \"Scope1\",\n        \"type\": \"repository\",\n    }],\n    status=\"enabled\",\n    registry_id=example_registry.id,\n    save_password_to_file=\"pass.txt\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleRegistry = new Ionoscloud.Creg.Registry(\"exampleRegistry\", new()\n    {\n        GarbageCollectionSchedule = new Ionoscloud.Creg.Inputs.RegistryGarbageCollectionScheduleArgs\n        {\n            Days = new[]\n            {\n                \"Monday\",\n                \"Tuesday\",\n            },\n            Time = \"05:19:00+00:00\",\n        },\n        Location = \"de/fra\",\n    });\n\n    var exampleRegistryToken = new Ionoscloud.Creg.RegistryToken(\"exampleRegistryToken\", new()\n    {\n        ExpiryDate = \"2023-01-13 16:27:42Z\",\n        Scopes = new[]\n        {\n            new Ionoscloud.Creg.Inputs.RegistryTokenScopeArgs\n            {\n                Actions = new[]\n                {\n                    \"push\",\n                },\n                Name = \"Scope1\",\n                Type = \"repository\",\n            },\n        },\n        Status = \"enabled\",\n        RegistryId = exampleRegistry.Id,\n        SavePasswordToFile = \"pass.txt\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/creg\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleRegistry, err := creg.NewRegistry(ctx, \"exampleRegistry\", \u0026creg.RegistryArgs{\n\t\t\tGarbageCollectionSchedule: \u0026creg.RegistryGarbageCollectionScheduleArgs{\n\t\t\t\tDays: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"Monday\"),\n\t\t\t\t\tpulumi.String(\"Tuesday\"),\n\t\t\t\t},\n\t\t\t\tTime: pulumi.String(\"05:19:00+00:00\"),\n\t\t\t},\n\t\t\tLocation: pulumi.String(\"de/fra\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = creg.NewRegistryToken(ctx, \"exampleRegistryToken\", \u0026creg.RegistryTokenArgs{\n\t\t\tExpiryDate: pulumi.String(\"2023-01-13 16:27:42Z\"),\n\t\t\tScopes: creg.RegistryTokenScopeArray{\n\t\t\t\t\u0026creg.RegistryTokenScopeArgs{\n\t\t\t\t\tActions: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"push\"),\n\t\t\t\t\t},\n\t\t\t\t\tName: pulumi.String(\"Scope1\"),\n\t\t\t\t\tType: pulumi.String(\"repository\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tStatus:             pulumi.String(\"enabled\"),\n\t\t\tRegistryId:         exampleRegistry.ID(),\n\t\t\tSavePasswordToFile: pulumi.String(\"pass.txt\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.creg.Registry;\nimport com.pulumi.ionoscloud.creg.RegistryArgs;\nimport com.pulumi.ionoscloud.creg.inputs.RegistryGarbageCollectionScheduleArgs;\nimport com.pulumi.ionoscloud.creg.RegistryToken;\nimport com.pulumi.ionoscloud.creg.RegistryTokenArgs;\nimport com.pulumi.ionoscloud.creg.inputs.RegistryTokenScopeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleRegistry = new Registry(\"exampleRegistry\", RegistryArgs.builder()\n            .garbageCollectionSchedule(RegistryGarbageCollectionScheduleArgs.builder()\n                .days(                \n                    \"Monday\",\n                    \"Tuesday\")\n                .time(\"05:19:00+00:00\")\n                .build())\n            .location(\"de/fra\")\n            .build());\n\n        var exampleRegistryToken = new RegistryToken(\"exampleRegistryToken\", RegistryTokenArgs.builder()\n            .expiryDate(\"2023-01-13 16:27:42Z\")\n            .scopes(RegistryTokenScopeArgs.builder()\n                .actions(\"push\")\n                .name(\"Scope1\")\n                .type(\"repository\")\n                .build())\n            .status(\"enabled\")\n            .registryId(exampleRegistry.id())\n            .savePasswordToFile(\"pass.txt\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleRegistry:\n    type: ionoscloud:creg:Registry\n    properties:\n      garbageCollectionSchedule:\n        days:\n          - Monday\n          - Tuesday\n        time: 05:19:00+00:00\n      location: de/fra\n  exampleRegistryToken:\n    type: ionoscloud:creg:RegistryToken\n    properties:\n      expiryDate: 2023-01-13 16:27:42Z\n      scopes:\n        - actions:\n            - push\n          name: Scope1\n          type: repository\n      status: enabled\n      registryId: ${exampleRegistry.id}\n      savePasswordToFile: pass.txt\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nResource Container Registry Token can be imported using the `container registry id` and `resource id`, e.g.\n\n```sh\n$ pulumi import ionoscloud:creg/registryToken:RegistryToken mycrtoken {container_registry uuid}/{container_registry_token uuid}\n```\n\n",
            "properties": {
                "credentials": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:creg/RegistryTokenCredential:RegistryTokenCredential"
                    }
                },
                "expiryDate": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the container registry token. Immutable, update forces re-creation of the resource.\n* `expiry-date`           - (Optional)[string] The value must be supplied as ISO 8601 timestamp\n"
                },
                "registryId": {
                    "type": "string"
                },
                "savePasswordToFile": {
                    "type": "string",
                    "description": "[string] Saves token password to file. Only works on create. Takes as argument a file name, or a file path\n\n\u003e **⚠ WARNING** `save_password_to_file` must be used with caution.\n\u003e It will save the password(token) returned on create to a file. This is the only way to get the token.\n"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:creg/RegistryTokenScope:RegistryTokenScope"
                    },
                    "description": "[map]\n"
                },
                "status": {
                    "type": "string",
                    "description": "[string] Must have on of the values: `enabled`, `disabled`\n"
                }
            },
            "required": [
                "credentials",
                "name",
                "registryId",
                "scopes",
                "status"
            ],
            "inputProperties": {
                "expiryDate": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the container registry token. Immutable, update forces re-creation of the resource.\n* `expiry-date`           - (Optional)[string] The value must be supplied as ISO 8601 timestamp\n",
                    "willReplaceOnChanges": true
                },
                "registryId": {
                    "type": "string"
                },
                "savePasswordToFile": {
                    "type": "string",
                    "description": "[string] Saves token password to file. Only works on create. Takes as argument a file name, or a file path\n\n\u003e **⚠ WARNING** `save_password_to_file` must be used with caution.\n\u003e It will save the password(token) returned on create to a file. This is the only way to get the token.\n"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:creg/RegistryTokenScope:RegistryTokenScope"
                    },
                    "description": "[map]\n"
                },
                "status": {
                    "type": "string",
                    "description": "[string] Must have on of the values: `enabled`, `disabled`\n"
                }
            },
            "requiredInputs": [
                "registryId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RegistryToken resources.\n",
                "properties": {
                    "credentials": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:creg/RegistryTokenCredential:RegistryTokenCredential"
                        }
                    },
                    "expiryDate": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] The name of the container registry token. Immutable, update forces re-creation of the resource.\n* `expiry-date`           - (Optional)[string] The value must be supplied as ISO 8601 timestamp\n",
                        "willReplaceOnChanges": true
                    },
                    "registryId": {
                        "type": "string"
                    },
                    "savePasswordToFile": {
                        "type": "string",
                        "description": "[string] Saves token password to file. Only works on create. Takes as argument a file name, or a file path\n\n\u003e **⚠ WARNING** `save_password_to_file` must be used with caution.\n\u003e It will save the password(token) returned on create to a file. This is the only way to get the token.\n"
                    },
                    "scopes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:creg/RegistryTokenScope:RegistryTokenScope"
                        },
                        "description": "[map]\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "[string] Must have on of the values: `enabled`, `disabled`\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:dbaas/inMemoryDBReplicaSet:InMemoryDBReplicaSet": {
            "description": "Manages a **DBaaS InMemoryDB Replica Set**.\n\n## Import\n\nResource DBaaS InMemoryDB Replica Set can be imported using the `replicaset_id` and the `location`, separated by `:`, e.g:\n\n```sh\n$ pulumi import ionoscloud:dbaas/inMemoryDBReplicaSet:InMemoryDBReplicaSet example {location}:{replicaSet UUID}\n```\n\n",
            "properties": {
                "connections": {
                    "$ref": "#/types/ionoscloud:dbaas/InMemoryDBReplicaSetConnections:InMemoryDBReplicaSetConnections",
                    "description": "[object] The network connection for your replica set. Only one connection is allowed. Updates to the value of the fields force the replica set to be re-created.\n"
                },
                "credentials": {
                    "$ref": "#/types/ionoscloud:dbaas/InMemoryDBReplicaSetCredentials:InMemoryDBReplicaSetCredentials",
                    "description": "[object] Credentials for the InMemoryDB replicaset, only one type of password can be used since they are mutually exclusive. These values are used to create the initial InMemoryDB user, updating any of these will force recreation of the replica set resource.\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "[string] The human-readable name of your replica set.\n"
                },
                "dnsName": {
                    "type": "string",
                    "description": "[string] The DNS name pointing to your replica set. Will be used to connect to the active/standalone instance.\n"
                },
                "evictionPolicy": {
                    "type": "string",
                    "description": "[string] The eviction policy for the replica set, possible values are:\n"
                },
                "initialSnapshotId": {
                    "type": "string",
                    "description": "[string] The ID of a snapshot to restore the replica set from. If set, the replica set will be created from the snapshot.\n"
                },
                "location": {
                    "type": "string",
                    "description": "[string] The location of your replica set. Updates to the value of the field force the replica set to be re-created.\n"
                },
                "maintenanceWindow": {
                    "$ref": "#/types/ionoscloud:dbaas/InMemoryDBReplicaSetMaintenanceWindow:InMemoryDBReplicaSetMaintenanceWindow",
                    "description": "(Computed) A weekly 4 hour-long window, during which maintenance might occur.\n"
                },
                "persistenceMode": {
                    "type": "string",
                    "description": "[string] Specifies How and If data is persisted, possible values are:\n* `None` - Data is inMemory only and will not be persisted. Useful for cache only applications.\n* `AOF` - (Append Only File) AOF persistence logs every write operation received by the server. These operations can then be replayed again at server startup, reconstructing the original dataset. Commands are logged using the same format as the InMemoryDB protocol itself.\n* `RDB` - RDB persistence performs snapshots of the current in memory state.\n* `RDB_AOF` - Both RDB and AOF persistence are enabled.\n"
                },
                "replicas": {
                    "type": "integer",
                    "description": "[int] The total number of replicas in the replica set (one active and n-1 passive). In case of a standalone instance, the value is 1. In all other cases, the value is \u003e 1. The replicas will not be available as read replicas, they are only standby for a failure of the active instance.\n"
                },
                "resources": {
                    "$ref": "#/types/ionoscloud:dbaas/InMemoryDBReplicaSetResources:InMemoryDBReplicaSetResources",
                    "description": "[object] The resources of the individual replicas.\n"
                },
                "version": {
                    "type": "string",
                    "description": "[string] The InMemoryDB version of your replica set.\n"
                }
            },
            "required": [
                "connections",
                "credentials",
                "displayName",
                "dnsName",
                "evictionPolicy",
                "location",
                "maintenanceWindow",
                "persistenceMode",
                "replicas",
                "resources",
                "version"
            ],
            "inputProperties": {
                "connections": {
                    "$ref": "#/types/ionoscloud:dbaas/InMemoryDBReplicaSetConnections:InMemoryDBReplicaSetConnections",
                    "description": "[object] The network connection for your replica set. Only one connection is allowed. Updates to the value of the fields force the replica set to be re-created.\n"
                },
                "credentials": {
                    "$ref": "#/types/ionoscloud:dbaas/InMemoryDBReplicaSetCredentials:InMemoryDBReplicaSetCredentials",
                    "description": "[object] Credentials for the InMemoryDB replicaset, only one type of password can be used since they are mutually exclusive. These values are used to create the initial InMemoryDB user, updating any of these will force recreation of the replica set resource.\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "[string] The human-readable name of your replica set.\n"
                },
                "evictionPolicy": {
                    "type": "string",
                    "description": "[string] The eviction policy for the replica set, possible values are:\n"
                },
                "initialSnapshotId": {
                    "type": "string",
                    "description": "[string] The ID of a snapshot to restore the replica set from. If set, the replica set will be created from the snapshot.\n",
                    "willReplaceOnChanges": true
                },
                "location": {
                    "type": "string",
                    "description": "[string] The location of your replica set. Updates to the value of the field force the replica set to be re-created.\n",
                    "willReplaceOnChanges": true
                },
                "maintenanceWindow": {
                    "$ref": "#/types/ionoscloud:dbaas/InMemoryDBReplicaSetMaintenanceWindow:InMemoryDBReplicaSetMaintenanceWindow",
                    "description": "(Computed) A weekly 4 hour-long window, during which maintenance might occur.\n"
                },
                "persistenceMode": {
                    "type": "string",
                    "description": "[string] Specifies How and If data is persisted, possible values are:\n* `None` - Data is inMemory only and will not be persisted. Useful for cache only applications.\n* `AOF` - (Append Only File) AOF persistence logs every write operation received by the server. These operations can then be replayed again at server startup, reconstructing the original dataset. Commands are logged using the same format as the InMemoryDB protocol itself.\n* `RDB` - RDB persistence performs snapshots of the current in memory state.\n* `RDB_AOF` - Both RDB and AOF persistence are enabled.\n"
                },
                "replicas": {
                    "type": "integer",
                    "description": "[int] The total number of replicas in the replica set (one active and n-1 passive). In case of a standalone instance, the value is 1. In all other cases, the value is \u003e 1. The replicas will not be available as read replicas, they are only standby for a failure of the active instance.\n"
                },
                "resources": {
                    "$ref": "#/types/ionoscloud:dbaas/InMemoryDBReplicaSetResources:InMemoryDBReplicaSetResources",
                    "description": "[object] The resources of the individual replicas.\n"
                },
                "version": {
                    "type": "string",
                    "description": "[string] The InMemoryDB version of your replica set.\n"
                }
            },
            "requiredInputs": [
                "connections",
                "credentials",
                "displayName",
                "evictionPolicy",
                "location",
                "persistenceMode",
                "replicas",
                "resources",
                "version"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering InMemoryDBReplicaSet resources.\n",
                "properties": {
                    "connections": {
                        "$ref": "#/types/ionoscloud:dbaas/InMemoryDBReplicaSetConnections:InMemoryDBReplicaSetConnections",
                        "description": "[object] The network connection for your replica set. Only one connection is allowed. Updates to the value of the fields force the replica set to be re-created.\n"
                    },
                    "credentials": {
                        "$ref": "#/types/ionoscloud:dbaas/InMemoryDBReplicaSetCredentials:InMemoryDBReplicaSetCredentials",
                        "description": "[object] Credentials for the InMemoryDB replicaset, only one type of password can be used since they are mutually exclusive. These values are used to create the initial InMemoryDB user, updating any of these will force recreation of the replica set resource.\n"
                    },
                    "displayName": {
                        "type": "string",
                        "description": "[string] The human-readable name of your replica set.\n"
                    },
                    "dnsName": {
                        "type": "string",
                        "description": "[string] The DNS name pointing to your replica set. Will be used to connect to the active/standalone instance.\n"
                    },
                    "evictionPolicy": {
                        "type": "string",
                        "description": "[string] The eviction policy for the replica set, possible values are:\n"
                    },
                    "initialSnapshotId": {
                        "type": "string",
                        "description": "[string] The ID of a snapshot to restore the replica set from. If set, the replica set will be created from the snapshot.\n",
                        "willReplaceOnChanges": true
                    },
                    "location": {
                        "type": "string",
                        "description": "[string] The location of your replica set. Updates to the value of the field force the replica set to be re-created.\n",
                        "willReplaceOnChanges": true
                    },
                    "maintenanceWindow": {
                        "$ref": "#/types/ionoscloud:dbaas/InMemoryDBReplicaSetMaintenanceWindow:InMemoryDBReplicaSetMaintenanceWindow",
                        "description": "(Computed) A weekly 4 hour-long window, during which maintenance might occur.\n"
                    },
                    "persistenceMode": {
                        "type": "string",
                        "description": "[string] Specifies How and If data is persisted, possible values are:\n* `None` - Data is inMemory only and will not be persisted. Useful for cache only applications.\n* `AOF` - (Append Only File) AOF persistence logs every write operation received by the server. These operations can then be replayed again at server startup, reconstructing the original dataset. Commands are logged using the same format as the InMemoryDB protocol itself.\n* `RDB` - RDB persistence performs snapshots of the current in memory state.\n* `RDB_AOF` - Both RDB and AOF persistence are enabled.\n"
                    },
                    "replicas": {
                        "type": "integer",
                        "description": "[int] The total number of replicas in the replica set (one active and n-1 passive). In case of a standalone instance, the value is 1. In all other cases, the value is \u003e 1. The replicas will not be available as read replicas, they are only standby for a failure of the active instance.\n"
                    },
                    "resources": {
                        "$ref": "#/types/ionoscloud:dbaas/InMemoryDBReplicaSetResources:InMemoryDBReplicaSetResources",
                        "description": "[object] The resources of the individual replicas.\n"
                    },
                    "version": {
                        "type": "string",
                        "description": "[string] The InMemoryDB version of your replica set.\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:dbaas/mariaDBCluster:MariaDBCluster": {
            "properties": {
                "connections": {
                    "$ref": "#/types/ionoscloud:dbaas/MariaDBClusterConnections:MariaDBClusterConnections",
                    "description": "The network connection for your cluster. Only one connection is allowed.\n"
                },
                "cores": {
                    "type": "integer",
                    "description": "The number of CPU cores per instance.\n"
                },
                "credentials": {
                    "$ref": "#/types/ionoscloud:dbaas/MariaDBClusterCredentials:MariaDBClusterCredentials",
                    "description": "Credentials for the database user to be created.\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "The friendly name of your cluster.\n"
                },
                "dnsName": {
                    "type": "string",
                    "description": "The DNS name pointing to your cluster.\n"
                },
                "instances": {
                    "type": "integer",
                    "description": "The total number of instances in the cluster (one primary and n-1 secondary).\n"
                },
                "location": {
                    "type": "string",
                    "description": "The cluster location\n"
                },
                "maintenanceWindow": {
                    "$ref": "#/types/ionoscloud:dbaas/MariaDBClusterMaintenanceWindow:MariaDBClusterMaintenanceWindow",
                    "description": "A weekly 4 hour-long window, during which maintenance might occur.\n"
                },
                "mariadbVersion": {
                    "type": "string",
                    "description": "The MariaDB version of your cluster.\n"
                },
                "ram": {
                    "type": "integer",
                    "description": "The amount of memory per instance in gigabytes (GB).\n"
                },
                "storageSize": {
                    "type": "integer",
                    "description": "The amount of storage per instance in gigabytes (GB).\n"
                }
            },
            "required": [
                "connections",
                "cores",
                "credentials",
                "displayName",
                "dnsName",
                "instances",
                "maintenanceWindow",
                "mariadbVersion",
                "ram",
                "storageSize"
            ],
            "inputProperties": {
                "connections": {
                    "$ref": "#/types/ionoscloud:dbaas/MariaDBClusterConnections:MariaDBClusterConnections",
                    "description": "The network connection for your cluster. Only one connection is allowed.\n"
                },
                "cores": {
                    "type": "integer",
                    "description": "The number of CPU cores per instance.\n"
                },
                "credentials": {
                    "$ref": "#/types/ionoscloud:dbaas/MariaDBClusterCredentials:MariaDBClusterCredentials",
                    "description": "Credentials for the database user to be created.\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "The friendly name of your cluster.\n"
                },
                "instances": {
                    "type": "integer",
                    "description": "The total number of instances in the cluster (one primary and n-1 secondary).\n"
                },
                "location": {
                    "type": "string",
                    "description": "The cluster location\n",
                    "willReplaceOnChanges": true
                },
                "maintenanceWindow": {
                    "$ref": "#/types/ionoscloud:dbaas/MariaDBClusterMaintenanceWindow:MariaDBClusterMaintenanceWindow",
                    "description": "A weekly 4 hour-long window, during which maintenance might occur.\n"
                },
                "mariadbVersion": {
                    "type": "string",
                    "description": "The MariaDB version of your cluster.\n"
                },
                "ram": {
                    "type": "integer",
                    "description": "The amount of memory per instance in gigabytes (GB).\n"
                },
                "storageSize": {
                    "type": "integer",
                    "description": "The amount of storage per instance in gigabytes (GB).\n"
                }
            },
            "requiredInputs": [
                "connections",
                "cores",
                "credentials",
                "displayName",
                "instances",
                "mariadbVersion",
                "ram",
                "storageSize"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MariaDBCluster resources.\n",
                "properties": {
                    "connections": {
                        "$ref": "#/types/ionoscloud:dbaas/MariaDBClusterConnections:MariaDBClusterConnections",
                        "description": "The network connection for your cluster. Only one connection is allowed.\n"
                    },
                    "cores": {
                        "type": "integer",
                        "description": "The number of CPU cores per instance.\n"
                    },
                    "credentials": {
                        "$ref": "#/types/ionoscloud:dbaas/MariaDBClusterCredentials:MariaDBClusterCredentials",
                        "description": "Credentials for the database user to be created.\n"
                    },
                    "displayName": {
                        "type": "string",
                        "description": "The friendly name of your cluster.\n"
                    },
                    "dnsName": {
                        "type": "string",
                        "description": "The DNS name pointing to your cluster.\n"
                    },
                    "instances": {
                        "type": "integer",
                        "description": "The total number of instances in the cluster (one primary and n-1 secondary).\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "The cluster location\n",
                        "willReplaceOnChanges": true
                    },
                    "maintenanceWindow": {
                        "$ref": "#/types/ionoscloud:dbaas/MariaDBClusterMaintenanceWindow:MariaDBClusterMaintenanceWindow",
                        "description": "A weekly 4 hour-long window, during which maintenance might occur.\n"
                    },
                    "mariadbVersion": {
                        "type": "string",
                        "description": "The MariaDB version of your cluster.\n"
                    },
                    "ram": {
                        "type": "integer",
                        "description": "The amount of memory per instance in gigabytes (GB).\n"
                    },
                    "storageSize": {
                        "type": "integer",
                        "description": "The amount of storage per instance in gigabytes (GB).\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:dbaas/mongoCluster:MongoCluster": {
            "description": "Manages a **DbaaS Mongo Cluster**.\n\n## Example Usage\n\n### Playground Or Business Editions. They Require Template_id Defined.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\nimport * as random from \"@pulumi/random\";\n\nconst datacenterExample = new ionoscloud.compute.Datacenter(\"datacenterExample\", {\n    location: \"de/txl\",\n    description: \"Datacenter for testing dbaas cluster\",\n});\nconst lanExample = new ionoscloud.compute.Lan(\"lanExample\", {\n    datacenterId: datacenterExample.id,\n    \"public\": false,\n});\nconst exampleMongoCluster = new ionoscloud.dbaas.MongoCluster(\"exampleMongoCluster\", {\n    maintenanceWindow: {\n        dayOfTheWeek: \"Sunday\",\n        time: \"09:00:00\",\n    },\n    mongodbVersion: \"5.0\",\n    instances: 1,\n    displayName: \"example_mongo_cluster\",\n    location: datacenterExample.location,\n    connections: {\n        datacenterId: datacenterExample.id,\n        lanId: lanExample.id,\n        cidrLists: [\"192.168.1.108/24\"],\n    },\n    templateId: \"6b78ea06-ee0e-4689-998c-fc9c46e781f6\",\n});\nconst clusterPassword = new random.RandomPassword(\"clusterPassword\", {\n    length: 16,\n    special: true,\n    overrideSpecial: \"!#$%\u0026*()-_=+[]{}\u003c\u003e:?\",\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\nimport pulumi_random as random\n\ndatacenter_example = ionoscloud.compute.Datacenter(\"datacenterExample\",\n    location=\"de/txl\",\n    description=\"Datacenter for testing dbaas cluster\")\nlan_example = ionoscloud.compute.Lan(\"lanExample\",\n    datacenter_id=datacenter_example.id,\n    public=False)\nexample_mongo_cluster = ionoscloud.dbaas.MongoCluster(\"exampleMongoCluster\",\n    maintenance_window={\n        \"day_of_the_week\": \"Sunday\",\n        \"time\": \"09:00:00\",\n    },\n    mongodb_version=\"5.0\",\n    instances=1,\n    display_name=\"example_mongo_cluster\",\n    location=datacenter_example.location,\n    connections={\n        \"datacenter_id\": datacenter_example.id,\n        \"lan_id\": lan_example.id,\n        \"cidr_lists\": [\"192.168.1.108/24\"],\n    },\n    template_id=\"6b78ea06-ee0e-4689-998c-fc9c46e781f6\")\ncluster_password = random.RandomPassword(\"clusterPassword\",\n    length=16,\n    special=True,\n    override_special=\"!#$%\u0026*()-_=+[]{}\u003c\u003e:?\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\nusing Random = Pulumi.Random;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenterExample = new Ionoscloud.Compute.Datacenter(\"datacenterExample\", new()\n    {\n        Location = \"de/txl\",\n        Description = \"Datacenter for testing dbaas cluster\",\n    });\n\n    var lanExample = new Ionoscloud.Compute.Lan(\"lanExample\", new()\n    {\n        DatacenterId = datacenterExample.Id,\n        Public = false,\n    });\n\n    var exampleMongoCluster = new Ionoscloud.Dbaas.MongoCluster(\"exampleMongoCluster\", new()\n    {\n        MaintenanceWindow = new Ionoscloud.Dbaas.Inputs.MongoClusterMaintenanceWindowArgs\n        {\n            DayOfTheWeek = \"Sunday\",\n            Time = \"09:00:00\",\n        },\n        MongodbVersion = \"5.0\",\n        Instances = 1,\n        DisplayName = \"example_mongo_cluster\",\n        Location = datacenterExample.Location,\n        Connections = new Ionoscloud.Dbaas.Inputs.MongoClusterConnectionsArgs\n        {\n            DatacenterId = datacenterExample.Id,\n            LanId = lanExample.Id,\n            CidrLists = new[]\n            {\n                \"192.168.1.108/24\",\n            },\n        },\n        TemplateId = \"6b78ea06-ee0e-4689-998c-fc9c46e781f6\",\n    });\n\n    var clusterPassword = new Random.RandomPassword(\"clusterPassword\", new()\n    {\n        Length = 16,\n        Special = true,\n        OverrideSpecial = \"!#$%\u0026*()-_=+[]{}\u003c\u003e:?\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/dbaas\"\n\t\"github.com/pulumi/pulumi-random/sdk/v4/go/random\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenterExample, err := compute.NewDatacenter(ctx, \"datacenterExample\", \u0026compute.DatacenterArgs{\n\t\t\tLocation:    pulumi.String(\"de/txl\"),\n\t\t\tDescription: pulumi.String(\"Datacenter for testing dbaas cluster\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tlanExample, err := compute.NewLan(ctx, \"lanExample\", \u0026compute.LanArgs{\n\t\t\tDatacenterId: datacenterExample.ID(),\n\t\t\tPublic:       pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = dbaas.NewMongoCluster(ctx, \"exampleMongoCluster\", \u0026dbaas.MongoClusterArgs{\n\t\t\tMaintenanceWindow: \u0026dbaas.MongoClusterMaintenanceWindowArgs{\n\t\t\t\tDayOfTheWeek: pulumi.String(\"Sunday\"),\n\t\t\t\tTime:         pulumi.String(\"09:00:00\"),\n\t\t\t},\n\t\t\tMongodbVersion: pulumi.String(\"5.0\"),\n\t\t\tInstances:      pulumi.Int(1),\n\t\t\tDisplayName:    pulumi.String(\"example_mongo_cluster\"),\n\t\t\tLocation:       datacenterExample.Location,\n\t\t\tConnections: \u0026dbaas.MongoClusterConnectionsArgs{\n\t\t\t\tDatacenterId: datacenterExample.ID(),\n\t\t\t\tLanId:        lanExample.ID(),\n\t\t\t\tCidrLists: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"192.168.1.108/24\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tTemplateId: pulumi.String(\"6b78ea06-ee0e-4689-998c-fc9c46e781f6\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = random.NewRandomPassword(ctx, \"clusterPassword\", \u0026random.RandomPasswordArgs{\n\t\t\tLength:          pulumi.Int(16),\n\t\t\tSpecial:         pulumi.Bool(true),\n\t\t\tOverrideSpecial: pulumi.String(\"!#$%\u0026*()-_=+[]{}\u003c\u003e:?\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.Datacenter;\nimport com.pulumi.ionoscloud.compute.DatacenterArgs;\nimport com.pulumi.ionoscloud.compute.Lan;\nimport com.pulumi.ionoscloud.compute.LanArgs;\nimport com.pulumi.ionoscloud.dbaas.MongoCluster;\nimport com.pulumi.ionoscloud.dbaas.MongoClusterArgs;\nimport com.pulumi.ionoscloud.dbaas.inputs.MongoClusterMaintenanceWindowArgs;\nimport com.pulumi.ionoscloud.dbaas.inputs.MongoClusterConnectionsArgs;\nimport com.pulumi.random.RandomPassword;\nimport com.pulumi.random.RandomPasswordArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var datacenterExample = new Datacenter(\"datacenterExample\", DatacenterArgs.builder()\n            .location(\"de/txl\")\n            .description(\"Datacenter for testing dbaas cluster\")\n            .build());\n\n        var lanExample = new Lan(\"lanExample\", LanArgs.builder()\n            .datacenterId(datacenterExample.id())\n            .public_(false)\n            .build());\n\n        var exampleMongoCluster = new MongoCluster(\"exampleMongoCluster\", MongoClusterArgs.builder()\n            .maintenanceWindow(MongoClusterMaintenanceWindowArgs.builder()\n                .dayOfTheWeek(\"Sunday\")\n                .time(\"09:00:00\")\n                .build())\n            .mongodbVersion(\"5.0\")\n            .instances(1)\n            .displayName(\"example_mongo_cluster\")\n            .location(datacenterExample.location())\n            .connections(MongoClusterConnectionsArgs.builder()\n                .datacenterId(datacenterExample.id())\n                .lanId(lanExample.id())\n                .cidrLists(\"192.168.1.108/24\")\n                .build())\n            .templateId(\"6b78ea06-ee0e-4689-998c-fc9c46e781f6\")\n            .build());\n\n        var clusterPassword = new RandomPassword(\"clusterPassword\", RandomPasswordArgs.builder()\n            .length(16)\n            .special(true)\n            .overrideSpecial(\"!#$%\u0026*()-_=+[]{}\u003c\u003e:?\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  datacenterExample:\n    type: ionoscloud:compute:Datacenter\n    properties:\n      location: de/txl\n      description: Datacenter for testing dbaas cluster\n  lanExample:\n    type: ionoscloud:compute:Lan\n    properties:\n      datacenterId: ${datacenterExample.id}\n      public: false\n  exampleMongoCluster:\n    type: ionoscloud:dbaas:MongoCluster\n    properties:\n      maintenanceWindow:\n        dayOfTheWeek: Sunday\n        time: 09:00:00\n      mongodbVersion: '5.0'\n      instances: 1\n      displayName: example_mongo_cluster\n      location: ${datacenterExample.location}\n      connections:\n        datacenterId: ${datacenterExample.id}\n        lanId: ${lanExample.id}\n        cidrLists:\n          - 192.168.1.108/24\n      templateId: 6b78ea06-ee0e-4689-998c-fc9c46e781f6\n  clusterPassword:\n    type: random:RandomPassword\n    properties:\n      length: 16\n      special: true\n      overrideSpecial: '!#$%\u0026*()-_=+[]{}\u003c\u003e:?'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Enterprise Edition\n\n**Enterprise Support: With MongoDB Enterprise, you gain access to professional support from the MongoDB team ensuring that you receive timely assistance and expert guidance when needed. IONOS offers enterprise-grade Service Level Agreements (SLAs), guaranteeing rapid response times and 24/7 support to address any critical issues that may arise.**\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\nimport * as random from \"@pulumi/random\";\n\nconst datacenterExample = new ionoscloud.compute.Datacenter(\"datacenterExample\", {\n    location: \"de/txl\",\n    description: \"Datacenter for testing dbaas cluster\",\n});\nconst lanExample = new ionoscloud.compute.Lan(\"lanExample\", {\n    datacenterId: datacenterExample.id,\n    \"public\": false,\n});\nconst exampleMongoCluster = new ionoscloud.dbaas.MongoCluster(\"exampleMongoCluster\", {\n    maintenanceWindow: {\n        dayOfTheWeek: \"Sunday\",\n        time: \"09:00:00\",\n    },\n    mongodbVersion: \"5.0\",\n    instances: 3,\n    displayName: \"example_mongo_cluster\",\n    location: datacenterExample.location,\n    connections: {\n        datacenterId: datacenterExample.id,\n        lanId: lanExample.id,\n        cidrLists: [\n            \"192.168.1.108/24\",\n            \"192.168.1.109/24\",\n            \"192.168.1.110/24\",\n        ],\n    },\n    type: \"sharded-cluster\",\n    shards: 2,\n    edition: \"enterprise\",\n    ram: 2048,\n    cores: 1,\n    storageSize: 5120,\n    storageType: \"HDD\",\n});\nconst clusterPassword = new random.RandomPassword(\"clusterPassword\", {\n    length: 16,\n    special: true,\n    overrideSpecial: \"!#$%\u0026*()-_=+[]{}\u003c\u003e:?\",\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\nimport pulumi_random as random\n\ndatacenter_example = ionoscloud.compute.Datacenter(\"datacenterExample\",\n    location=\"de/txl\",\n    description=\"Datacenter for testing dbaas cluster\")\nlan_example = ionoscloud.compute.Lan(\"lanExample\",\n    datacenter_id=datacenter_example.id,\n    public=False)\nexample_mongo_cluster = ionoscloud.dbaas.MongoCluster(\"exampleMongoCluster\",\n    maintenance_window={\n        \"day_of_the_week\": \"Sunday\",\n        \"time\": \"09:00:00\",\n    },\n    mongodb_version=\"5.0\",\n    instances=3,\n    display_name=\"example_mongo_cluster\",\n    location=datacenter_example.location,\n    connections={\n        \"datacenter_id\": datacenter_example.id,\n        \"lan_id\": lan_example.id,\n        \"cidr_lists\": [\n            \"192.168.1.108/24\",\n            \"192.168.1.109/24\",\n            \"192.168.1.110/24\",\n        ],\n    },\n    type=\"sharded-cluster\",\n    shards=2,\n    edition=\"enterprise\",\n    ram=2048,\n    cores=1,\n    storage_size=5120,\n    storage_type=\"HDD\")\ncluster_password = random.RandomPassword(\"clusterPassword\",\n    length=16,\n    special=True,\n    override_special=\"!#$%\u0026*()-_=+[]{}\u003c\u003e:?\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\nusing Random = Pulumi.Random;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenterExample = new Ionoscloud.Compute.Datacenter(\"datacenterExample\", new()\n    {\n        Location = \"de/txl\",\n        Description = \"Datacenter for testing dbaas cluster\",\n    });\n\n    var lanExample = new Ionoscloud.Compute.Lan(\"lanExample\", new()\n    {\n        DatacenterId = datacenterExample.Id,\n        Public = false,\n    });\n\n    var exampleMongoCluster = new Ionoscloud.Dbaas.MongoCluster(\"exampleMongoCluster\", new()\n    {\n        MaintenanceWindow = new Ionoscloud.Dbaas.Inputs.MongoClusterMaintenanceWindowArgs\n        {\n            DayOfTheWeek = \"Sunday\",\n            Time = \"09:00:00\",\n        },\n        MongodbVersion = \"5.0\",\n        Instances = 3,\n        DisplayName = \"example_mongo_cluster\",\n        Location = datacenterExample.Location,\n        Connections = new Ionoscloud.Dbaas.Inputs.MongoClusterConnectionsArgs\n        {\n            DatacenterId = datacenterExample.Id,\n            LanId = lanExample.Id,\n            CidrLists = new[]\n            {\n                \"192.168.1.108/24\",\n                \"192.168.1.109/24\",\n                \"192.168.1.110/24\",\n            },\n        },\n        Type = \"sharded-cluster\",\n        Shards = 2,\n        Edition = \"enterprise\",\n        Ram = 2048,\n        Cores = 1,\n        StorageSize = 5120,\n        StorageType = \"HDD\",\n    });\n\n    var clusterPassword = new Random.RandomPassword(\"clusterPassword\", new()\n    {\n        Length = 16,\n        Special = true,\n        OverrideSpecial = \"!#$%\u0026*()-_=+[]{}\u003c\u003e:?\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/dbaas\"\n\t\"github.com/pulumi/pulumi-random/sdk/v4/go/random\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenterExample, err := compute.NewDatacenter(ctx, \"datacenterExample\", \u0026compute.DatacenterArgs{\n\t\t\tLocation:    pulumi.String(\"de/txl\"),\n\t\t\tDescription: pulumi.String(\"Datacenter for testing dbaas cluster\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tlanExample, err := compute.NewLan(ctx, \"lanExample\", \u0026compute.LanArgs{\n\t\t\tDatacenterId: datacenterExample.ID(),\n\t\t\tPublic:       pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = dbaas.NewMongoCluster(ctx, \"exampleMongoCluster\", \u0026dbaas.MongoClusterArgs{\n\t\t\tMaintenanceWindow: \u0026dbaas.MongoClusterMaintenanceWindowArgs{\n\t\t\t\tDayOfTheWeek: pulumi.String(\"Sunday\"),\n\t\t\t\tTime:         pulumi.String(\"09:00:00\"),\n\t\t\t},\n\t\t\tMongodbVersion: pulumi.String(\"5.0\"),\n\t\t\tInstances:      pulumi.Int(3),\n\t\t\tDisplayName:    pulumi.String(\"example_mongo_cluster\"),\n\t\t\tLocation:       datacenterExample.Location,\n\t\t\tConnections: \u0026dbaas.MongoClusterConnectionsArgs{\n\t\t\t\tDatacenterId: datacenterExample.ID(),\n\t\t\t\tLanId:        lanExample.ID(),\n\t\t\t\tCidrLists: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"192.168.1.108/24\"),\n\t\t\t\t\tpulumi.String(\"192.168.1.109/24\"),\n\t\t\t\t\tpulumi.String(\"192.168.1.110/24\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tType:        pulumi.String(\"sharded-cluster\"),\n\t\t\tShards:      pulumi.Int(2),\n\t\t\tEdition:     pulumi.String(\"enterprise\"),\n\t\t\tRam:         pulumi.Int(2048),\n\t\t\tCores:       pulumi.Int(1),\n\t\t\tStorageSize: pulumi.Int(5120),\n\t\t\tStorageType: pulumi.String(\"HDD\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = random.NewRandomPassword(ctx, \"clusterPassword\", \u0026random.RandomPasswordArgs{\n\t\t\tLength:          pulumi.Int(16),\n\t\t\tSpecial:         pulumi.Bool(true),\n\t\t\tOverrideSpecial: pulumi.String(\"!#$%\u0026*()-_=+[]{}\u003c\u003e:?\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.Datacenter;\nimport com.pulumi.ionoscloud.compute.DatacenterArgs;\nimport com.pulumi.ionoscloud.compute.Lan;\nimport com.pulumi.ionoscloud.compute.LanArgs;\nimport com.pulumi.ionoscloud.dbaas.MongoCluster;\nimport com.pulumi.ionoscloud.dbaas.MongoClusterArgs;\nimport com.pulumi.ionoscloud.dbaas.inputs.MongoClusterMaintenanceWindowArgs;\nimport com.pulumi.ionoscloud.dbaas.inputs.MongoClusterConnectionsArgs;\nimport com.pulumi.random.RandomPassword;\nimport com.pulumi.random.RandomPasswordArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var datacenterExample = new Datacenter(\"datacenterExample\", DatacenterArgs.builder()\n            .location(\"de/txl\")\n            .description(\"Datacenter for testing dbaas cluster\")\n            .build());\n\n        var lanExample = new Lan(\"lanExample\", LanArgs.builder()\n            .datacenterId(datacenterExample.id())\n            .public_(false)\n            .build());\n\n        var exampleMongoCluster = new MongoCluster(\"exampleMongoCluster\", MongoClusterArgs.builder()\n            .maintenanceWindow(MongoClusterMaintenanceWindowArgs.builder()\n                .dayOfTheWeek(\"Sunday\")\n                .time(\"09:00:00\")\n                .build())\n            .mongodbVersion(\"5.0\")\n            .instances(3)\n            .displayName(\"example_mongo_cluster\")\n            .location(datacenterExample.location())\n            .connections(MongoClusterConnectionsArgs.builder()\n                .datacenterId(datacenterExample.id())\n                .lanId(lanExample.id())\n                .cidrLists(                \n                    \"192.168.1.108/24\",\n                    \"192.168.1.109/24\",\n                    \"192.168.1.110/24\")\n                .build())\n            .type(\"sharded-cluster\")\n            .shards(2)\n            .edition(\"enterprise\")\n            .ram(2048)\n            .cores(1)\n            .storageSize(5120)\n            .storageType(\"HDD\")\n            .build());\n\n        var clusterPassword = new RandomPassword(\"clusterPassword\", RandomPasswordArgs.builder()\n            .length(16)\n            .special(true)\n            .overrideSpecial(\"!#$%\u0026*()-_=+[]{}\u003c\u003e:?\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  datacenterExample:\n    type: ionoscloud:compute:Datacenter\n    properties:\n      location: de/txl\n      description: Datacenter for testing dbaas cluster\n  lanExample:\n    type: ionoscloud:compute:Lan\n    properties:\n      datacenterId: ${datacenterExample.id}\n      public: false\n  exampleMongoCluster:\n    type: ionoscloud:dbaas:MongoCluster\n    properties:\n      maintenanceWindow:\n        dayOfTheWeek: Sunday\n        time: 09:00:00\n      mongodbVersion: '5.0'\n      instances: 3\n      displayName: example_mongo_cluster\n      location: ${datacenterExample.location}\n      connections:\n        datacenterId: ${datacenterExample.id}\n        lanId: ${lanExample.id}\n        cidrLists:\n          - 192.168.1.108/24\n          - 192.168.1.109/24\n          - 192.168.1.110/24\n      type: sharded-cluster\n      shards: 2\n      edition: enterprise\n      ram: 2048\n      cores: 1\n      storageSize: 5120\n      storageType: HDD\n  clusterPassword:\n    type: random:RandomPassword\n    properties:\n      length: 16\n      special: true\n      overrideSpecial: '!#$%\u0026*()-_=+[]{}\u003c\u003e:?'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nResource DbaaS MongoDb Cluster can be imported using the `cluster_id`, e.g.\n\n```sh\n$ pulumi import ionoscloud:dbaas/mongoCluster:MongoCluster mycluser {cluster uuid}\n```\n\n",
            "properties": {
                "backup": {
                    "$ref": "#/types/ionoscloud:dbaas/MongoClusterBackup:MongoClusterBackup",
                    "description": "[list]\n"
                },
                "biConnector": {
                    "$ref": "#/types/ionoscloud:dbaas/MongoClusterBiConnector:MongoClusterBiConnector",
                    "description": "(Computed)The MongoDB Connector for Business Intelligence allows you to query a MongoDB database using SQL commands to aid in data analysis.\n"
                },
                "connectionString": {
                    "type": "string",
                    "description": "[string] The physical location where the cluster will be created. This will be where all of your instances live. Updates to the value of the field force the cluster to be re-created. Available locations: de/txl, gb/lhr, es/vit\n"
                },
                "connections": {
                    "$ref": "#/types/ionoscloud:dbaas/MongoClusterConnections:MongoClusterConnections",
                    "description": "[List] Details about the network connection for your cluster. Updates to the value of the field force the cluster to be re-created.\n"
                },
                "cores": {
                    "type": "integer",
                    "description": "(Computed)[int] The number of CPU cores per replica. Required for enterprise edition.\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "[string] The name of your cluster. Updates to the value of the field force the cluster to be re-created.\n"
                },
                "edition": {
                    "type": "string",
                    "description": "(Computed)[string] Cluster edition. Playground, business or enterprise.\n"
                },
                "instances": {
                    "type": "integer",
                    "description": "[int] The total number of instances in the cluster (one master and n-1 standbys). Example: 1, 3, 5, 7. Updates to the value of the field force the cluster to be re-created.\n"
                },
                "location": {
                    "type": "string",
                    "description": "[string] The physical location where the cluster will be created. Property cannot be modified after datacenter creation (disallowed in update requests). Available locations: de/txl, gb/lhr, es/vit. Update forces cluster re-creation.\n"
                },
                "maintenanceWindow": {
                    "$ref": "#/types/ionoscloud:dbaas/MongoClusterMaintenanceWindow:MongoClusterMaintenanceWindow",
                    "description": "(Computed)[string] A weekly 4 hour-long window, during which maintenance might occur.  Updates to the value of the field force the cluster to be re-created.\n"
                },
                "mongodbVersion": {
                    "type": "string",
                    "description": "[string] The MongoDB version of your cluster. Updates to the value of the field force the cluster to be re-created.\n"
                },
                "ram": {
                    "type": "integer",
                    "description": "(Computed)[int]The amount of memory per instance in megabytes. Required for enterprise edition.\n"
                },
                "shards": {
                    "type": "integer",
                    "description": "[int]The total number of shards in the cluster.\n"
                },
                "storageSize": {
                    "type": "integer",
                    "description": "(Computed)[int] The amount of storage per instance in MB. Required for enterprise edition.\n"
                },
                "storageType": {
                    "type": "string",
                    "description": "(Computed)[String] The storage type used in your cluster. Required for enterprise edition.\n"
                },
                "templateId": {
                    "type": "string",
                    "description": "[string] The unique ID of the template, which specifies the number of cores, storage size, and memory. Updates to the value of the field force the cluster to be re-created. Required for playground and business editions. Must not be provided for enterprise edition.\n"
                },
                "type": {
                    "type": "string",
                    "description": "(Computed)[string]The cluster type, either `replicaset` or `sharded-cluster`.\n"
                }
            },
            "required": [
                "biConnector",
                "connectionString",
                "connections",
                "cores",
                "displayName",
                "edition",
                "instances",
                "location",
                "maintenanceWindow",
                "mongodbVersion",
                "ram",
                "storageSize",
                "storageType",
                "type"
            ],
            "inputProperties": {
                "backup": {
                    "$ref": "#/types/ionoscloud:dbaas/MongoClusterBackup:MongoClusterBackup",
                    "description": "[list]\n"
                },
                "biConnector": {
                    "$ref": "#/types/ionoscloud:dbaas/MongoClusterBiConnector:MongoClusterBiConnector",
                    "description": "(Computed)The MongoDB Connector for Business Intelligence allows you to query a MongoDB database using SQL commands to aid in data analysis.\n"
                },
                "connections": {
                    "$ref": "#/types/ionoscloud:dbaas/MongoClusterConnections:MongoClusterConnections",
                    "description": "[List] Details about the network connection for your cluster. Updates to the value of the field force the cluster to be re-created.\n"
                },
                "cores": {
                    "type": "integer",
                    "description": "(Computed)[int] The number of CPU cores per replica. Required for enterprise edition.\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "[string] The name of your cluster. Updates to the value of the field force the cluster to be re-created.\n"
                },
                "edition": {
                    "type": "string",
                    "description": "(Computed)[string] Cluster edition. Playground, business or enterprise.\n"
                },
                "instances": {
                    "type": "integer",
                    "description": "[int] The total number of instances in the cluster (one master and n-1 standbys). Example: 1, 3, 5, 7. Updates to the value of the field force the cluster to be re-created.\n"
                },
                "location": {
                    "type": "string",
                    "description": "[string] The physical location where the cluster will be created. Property cannot be modified after datacenter creation (disallowed in update requests). Available locations: de/txl, gb/lhr, es/vit. Update forces cluster re-creation.\n",
                    "willReplaceOnChanges": true
                },
                "maintenanceWindow": {
                    "$ref": "#/types/ionoscloud:dbaas/MongoClusterMaintenanceWindow:MongoClusterMaintenanceWindow",
                    "description": "(Computed)[string] A weekly 4 hour-long window, during which maintenance might occur.  Updates to the value of the field force the cluster to be re-created.\n"
                },
                "mongodbVersion": {
                    "type": "string",
                    "description": "[string] The MongoDB version of your cluster. Updates to the value of the field force the cluster to be re-created.\n",
                    "willReplaceOnChanges": true
                },
                "ram": {
                    "type": "integer",
                    "description": "(Computed)[int]The amount of memory per instance in megabytes. Required for enterprise edition.\n"
                },
                "shards": {
                    "type": "integer",
                    "description": "[int]The total number of shards in the cluster.\n"
                },
                "storageSize": {
                    "type": "integer",
                    "description": "(Computed)[int] The amount of storage per instance in MB. Required for enterprise edition.\n",
                    "willReplaceOnChanges": true
                },
                "storageType": {
                    "type": "string",
                    "description": "(Computed)[String] The storage type used in your cluster. Required for enterprise edition.\n"
                },
                "templateId": {
                    "type": "string",
                    "description": "[string] The unique ID of the template, which specifies the number of cores, storage size, and memory. Updates to the value of the field force the cluster to be re-created. Required for playground and business editions. Must not be provided for enterprise edition.\n"
                },
                "type": {
                    "type": "string",
                    "description": "(Computed)[string]The cluster type, either `replicaset` or `sharded-cluster`.\n"
                }
            },
            "requiredInputs": [
                "connections",
                "displayName",
                "instances",
                "location",
                "mongodbVersion"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MongoCluster resources.\n",
                "properties": {
                    "backup": {
                        "$ref": "#/types/ionoscloud:dbaas/MongoClusterBackup:MongoClusterBackup",
                        "description": "[list]\n"
                    },
                    "biConnector": {
                        "$ref": "#/types/ionoscloud:dbaas/MongoClusterBiConnector:MongoClusterBiConnector",
                        "description": "(Computed)The MongoDB Connector for Business Intelligence allows you to query a MongoDB database using SQL commands to aid in data analysis.\n"
                    },
                    "connectionString": {
                        "type": "string",
                        "description": "[string] The physical location where the cluster will be created. This will be where all of your instances live. Updates to the value of the field force the cluster to be re-created. Available locations: de/txl, gb/lhr, es/vit\n"
                    },
                    "connections": {
                        "$ref": "#/types/ionoscloud:dbaas/MongoClusterConnections:MongoClusterConnections",
                        "description": "[List] Details about the network connection for your cluster. Updates to the value of the field force the cluster to be re-created.\n"
                    },
                    "cores": {
                        "type": "integer",
                        "description": "(Computed)[int] The number of CPU cores per replica. Required for enterprise edition.\n"
                    },
                    "displayName": {
                        "type": "string",
                        "description": "[string] The name of your cluster. Updates to the value of the field force the cluster to be re-created.\n"
                    },
                    "edition": {
                        "type": "string",
                        "description": "(Computed)[string] Cluster edition. Playground, business or enterprise.\n"
                    },
                    "instances": {
                        "type": "integer",
                        "description": "[int] The total number of instances in the cluster (one master and n-1 standbys). Example: 1, 3, 5, 7. Updates to the value of the field force the cluster to be re-created.\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "[string] The physical location where the cluster will be created. Property cannot be modified after datacenter creation (disallowed in update requests). Available locations: de/txl, gb/lhr, es/vit. Update forces cluster re-creation.\n",
                        "willReplaceOnChanges": true
                    },
                    "maintenanceWindow": {
                        "$ref": "#/types/ionoscloud:dbaas/MongoClusterMaintenanceWindow:MongoClusterMaintenanceWindow",
                        "description": "(Computed)[string] A weekly 4 hour-long window, during which maintenance might occur.  Updates to the value of the field force the cluster to be re-created.\n"
                    },
                    "mongodbVersion": {
                        "type": "string",
                        "description": "[string] The MongoDB version of your cluster. Updates to the value of the field force the cluster to be re-created.\n",
                        "willReplaceOnChanges": true
                    },
                    "ram": {
                        "type": "integer",
                        "description": "(Computed)[int]The amount of memory per instance in megabytes. Required for enterprise edition.\n"
                    },
                    "shards": {
                        "type": "integer",
                        "description": "[int]The total number of shards in the cluster.\n"
                    },
                    "storageSize": {
                        "type": "integer",
                        "description": "(Computed)[int] The amount of storage per instance in MB. Required for enterprise edition.\n",
                        "willReplaceOnChanges": true
                    },
                    "storageType": {
                        "type": "string",
                        "description": "(Computed)[String] The storage type used in your cluster. Required for enterprise edition.\n"
                    },
                    "templateId": {
                        "type": "string",
                        "description": "[string] The unique ID of the template, which specifies the number of cores, storage size, and memory. Updates to the value of the field force the cluster to be re-created. Required for playground and business editions. Must not be provided for enterprise edition.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "(Computed)[string]The cluster type, either `replicaset` or `sharded-cluster`.\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:dbaas/mongoUser:MongoUser": {
            "description": "Manages a **DbaaS Mongo User**. .\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\n// Basic example\nconst datacenterExample = new ionoscloud.compute.Datacenter(\"datacenterExample\", {\n    location: \"de/txl\",\n    description: \"Datacenter for testing dbaas cluster\",\n});\nconst lanExample = new ionoscloud.compute.Lan(\"lanExample\", {\n    datacenterId: datacenterExample.id,\n    \"public\": false,\n});\nconst exampleMongoCluster = new ionoscloud.dbaas.MongoCluster(\"exampleMongoCluster\", {\n    maintenanceWindow: {\n        dayOfTheWeek: \"Sunday\",\n        time: \"09:00:00\",\n    },\n    mongodbVersion: \"5.0\",\n    instances: 1,\n    displayName: \"example_mongo_cluster\",\n    location: datacenterExample.location,\n    connections: {\n        datacenterId: datacenterExample.id,\n        lanId: lanExample.id,\n        cidrLists: [\"192.168.1.108/24\"],\n    },\n    templateId: \"6b78ea06-ee0e-4689-998c-fc9c46e781f6\",\n});\nconst exampleMongoUser = new ionoscloud.dbaas.MongoUser(\"exampleMongoUser\", {\n    clusterId: exampleMongoCluster.id,\n    username: \"myUser\",\n    password: \"strongPassword\",\n    roles: [\n        {\n            role: \"read\",\n            database: \"db1\",\n        },\n        {\n            role: \"readWrite\",\n            database: \"db2\",\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\n# Basic example\ndatacenter_example = ionoscloud.compute.Datacenter(\"datacenterExample\",\n    location=\"de/txl\",\n    description=\"Datacenter for testing dbaas cluster\")\nlan_example = ionoscloud.compute.Lan(\"lanExample\",\n    datacenter_id=datacenter_example.id,\n    public=False)\nexample_mongo_cluster = ionoscloud.dbaas.MongoCluster(\"exampleMongoCluster\",\n    maintenance_window={\n        \"day_of_the_week\": \"Sunday\",\n        \"time\": \"09:00:00\",\n    },\n    mongodb_version=\"5.0\",\n    instances=1,\n    display_name=\"example_mongo_cluster\",\n    location=datacenter_example.location,\n    connections={\n        \"datacenter_id\": datacenter_example.id,\n        \"lan_id\": lan_example.id,\n        \"cidr_lists\": [\"192.168.1.108/24\"],\n    },\n    template_id=\"6b78ea06-ee0e-4689-998c-fc9c46e781f6\")\nexample_mongo_user = ionoscloud.dbaas.MongoUser(\"exampleMongoUser\",\n    cluster_id=example_mongo_cluster.id,\n    username=\"myUser\",\n    password=\"strongPassword\",\n    roles=[\n        {\n            \"role\": \"read\",\n            \"database\": \"db1\",\n        },\n        {\n            \"role\": \"readWrite\",\n            \"database\": \"db2\",\n        },\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Basic example\n    var datacenterExample = new Ionoscloud.Compute.Datacenter(\"datacenterExample\", new()\n    {\n        Location = \"de/txl\",\n        Description = \"Datacenter for testing dbaas cluster\",\n    });\n\n    var lanExample = new Ionoscloud.Compute.Lan(\"lanExample\", new()\n    {\n        DatacenterId = datacenterExample.Id,\n        Public = false,\n    });\n\n    var exampleMongoCluster = new Ionoscloud.Dbaas.MongoCluster(\"exampleMongoCluster\", new()\n    {\n        MaintenanceWindow = new Ionoscloud.Dbaas.Inputs.MongoClusterMaintenanceWindowArgs\n        {\n            DayOfTheWeek = \"Sunday\",\n            Time = \"09:00:00\",\n        },\n        MongodbVersion = \"5.0\",\n        Instances = 1,\n        DisplayName = \"example_mongo_cluster\",\n        Location = datacenterExample.Location,\n        Connections = new Ionoscloud.Dbaas.Inputs.MongoClusterConnectionsArgs\n        {\n            DatacenterId = datacenterExample.Id,\n            LanId = lanExample.Id,\n            CidrLists = new[]\n            {\n                \"192.168.1.108/24\",\n            },\n        },\n        TemplateId = \"6b78ea06-ee0e-4689-998c-fc9c46e781f6\",\n    });\n\n    var exampleMongoUser = new Ionoscloud.Dbaas.MongoUser(\"exampleMongoUser\", new()\n    {\n        ClusterId = exampleMongoCluster.Id,\n        Username = \"myUser\",\n        Password = \"strongPassword\",\n        Roles = new[]\n        {\n            new Ionoscloud.Dbaas.Inputs.MongoUserRoleArgs\n            {\n                Role = \"read\",\n                Database = \"db1\",\n            },\n            new Ionoscloud.Dbaas.Inputs.MongoUserRoleArgs\n            {\n                Role = \"readWrite\",\n                Database = \"db2\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/dbaas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Basic example\n\t\tdatacenterExample, err := compute.NewDatacenter(ctx, \"datacenterExample\", \u0026compute.DatacenterArgs{\n\t\t\tLocation:    pulumi.String(\"de/txl\"),\n\t\t\tDescription: pulumi.String(\"Datacenter for testing dbaas cluster\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tlanExample, err := compute.NewLan(ctx, \"lanExample\", \u0026compute.LanArgs{\n\t\t\tDatacenterId: datacenterExample.ID(),\n\t\t\tPublic:       pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleMongoCluster, err := dbaas.NewMongoCluster(ctx, \"exampleMongoCluster\", \u0026dbaas.MongoClusterArgs{\n\t\t\tMaintenanceWindow: \u0026dbaas.MongoClusterMaintenanceWindowArgs{\n\t\t\t\tDayOfTheWeek: pulumi.String(\"Sunday\"),\n\t\t\t\tTime:         pulumi.String(\"09:00:00\"),\n\t\t\t},\n\t\t\tMongodbVersion: pulumi.String(\"5.0\"),\n\t\t\tInstances:      pulumi.Int(1),\n\t\t\tDisplayName:    pulumi.String(\"example_mongo_cluster\"),\n\t\t\tLocation:       datacenterExample.Location,\n\t\t\tConnections: \u0026dbaas.MongoClusterConnectionsArgs{\n\t\t\t\tDatacenterId: datacenterExample.ID(),\n\t\t\t\tLanId:        lanExample.ID(),\n\t\t\t\tCidrLists: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"192.168.1.108/24\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tTemplateId: pulumi.String(\"6b78ea06-ee0e-4689-998c-fc9c46e781f6\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = dbaas.NewMongoUser(ctx, \"exampleMongoUser\", \u0026dbaas.MongoUserArgs{\n\t\t\tClusterId: exampleMongoCluster.ID(),\n\t\t\tUsername:  pulumi.String(\"myUser\"),\n\t\t\tPassword:  pulumi.String(\"strongPassword\"),\n\t\t\tRoles: dbaas.MongoUserRoleArray{\n\t\t\t\t\u0026dbaas.MongoUserRoleArgs{\n\t\t\t\t\tRole:     pulumi.String(\"read\"),\n\t\t\t\t\tDatabase: pulumi.String(\"db1\"),\n\t\t\t\t},\n\t\t\t\t\u0026dbaas.MongoUserRoleArgs{\n\t\t\t\t\tRole:     pulumi.String(\"readWrite\"),\n\t\t\t\t\tDatabase: pulumi.String(\"db2\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.Datacenter;\nimport com.pulumi.ionoscloud.compute.DatacenterArgs;\nimport com.pulumi.ionoscloud.compute.Lan;\nimport com.pulumi.ionoscloud.compute.LanArgs;\nimport com.pulumi.ionoscloud.dbaas.MongoCluster;\nimport com.pulumi.ionoscloud.dbaas.MongoClusterArgs;\nimport com.pulumi.ionoscloud.dbaas.inputs.MongoClusterMaintenanceWindowArgs;\nimport com.pulumi.ionoscloud.dbaas.inputs.MongoClusterConnectionsArgs;\nimport com.pulumi.ionoscloud.dbaas.MongoUser;\nimport com.pulumi.ionoscloud.dbaas.MongoUserArgs;\nimport com.pulumi.ionoscloud.dbaas.inputs.MongoUserRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Basic example\n        var datacenterExample = new Datacenter(\"datacenterExample\", DatacenterArgs.builder()\n            .location(\"de/txl\")\n            .description(\"Datacenter for testing dbaas cluster\")\n            .build());\n\n        var lanExample = new Lan(\"lanExample\", LanArgs.builder()\n            .datacenterId(datacenterExample.id())\n            .public_(false)\n            .build());\n\n        var exampleMongoCluster = new MongoCluster(\"exampleMongoCluster\", MongoClusterArgs.builder()\n            .maintenanceWindow(MongoClusterMaintenanceWindowArgs.builder()\n                .dayOfTheWeek(\"Sunday\")\n                .time(\"09:00:00\")\n                .build())\n            .mongodbVersion(\"5.0\")\n            .instances(1)\n            .displayName(\"example_mongo_cluster\")\n            .location(datacenterExample.location())\n            .connections(MongoClusterConnectionsArgs.builder()\n                .datacenterId(datacenterExample.id())\n                .lanId(lanExample.id())\n                .cidrLists(\"192.168.1.108/24\")\n                .build())\n            .templateId(\"6b78ea06-ee0e-4689-998c-fc9c46e781f6\")\n            .build());\n\n        var exampleMongoUser = new MongoUser(\"exampleMongoUser\", MongoUserArgs.builder()\n            .clusterId(exampleMongoCluster.id())\n            .username(\"myUser\")\n            .password(\"strongPassword\")\n            .roles(            \n                MongoUserRoleArgs.builder()\n                    .role(\"read\")\n                    .database(\"db1\")\n                    .build(),\n                MongoUserRoleArgs.builder()\n                    .role(\"readWrite\")\n                    .database(\"db2\")\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Basic example\n  datacenterExample:\n    type: ionoscloud:compute:Datacenter\n    properties:\n      location: de/txl\n      description: Datacenter for testing dbaas cluster\n  lanExample:\n    type: ionoscloud:compute:Lan\n    properties:\n      datacenterId: ${datacenterExample.id}\n      public: false\n  exampleMongoCluster:\n    type: ionoscloud:dbaas:MongoCluster\n    properties:\n      maintenanceWindow:\n        dayOfTheWeek: Sunday\n        time: 09:00:00\n      mongodbVersion: '5.0'\n      instances: 1\n      displayName: example_mongo_cluster\n      location: ${datacenterExample.location}\n      connections:\n        datacenterId: ${datacenterExample.id}\n        lanId: ${lanExample.id}\n        cidrLists:\n          - 192.168.1.108/24\n      templateId: 6b78ea06-ee0e-4689-998c-fc9c46e781f6\n  exampleMongoUser:\n    type: ionoscloud:dbaas:MongoUser\n    properties:\n      clusterId: ${exampleMongoCluster.id}\n      username: myUser\n      password: strongPassword\n      roles:\n        - role: read\n          database: db1\n        - role: readWrite\n          database: db2\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\nimport * as random from \"@pulumi/random\";\n\n// Complete example\nconst datacenterExample = new ionoscloud.compute.Datacenter(\"datacenterExample\", {\n    location: \"de/txl\",\n    description: \"Datacenter for testing dbaas cluster\",\n});\nconst lanExample = new ionoscloud.compute.Lan(\"lanExample\", {\n    datacenterId: datacenterExample.id,\n    \"public\": false,\n});\nconst exampleMongoCluster = new ionoscloud.dbaas.MongoCluster(\"exampleMongoCluster\", {\n    maintenanceWindow: {\n        dayOfTheWeek: \"Sunday\",\n        time: \"09:00:00\",\n    },\n    mongodbVersion: \"5.0\",\n    instances: 1,\n    displayName: \"example_mongo_cluster\",\n    location: datacenterExample.location,\n    connections: {\n        datacenterId: datacenterExample.id,\n        lanId: lanExample.id,\n        cidrLists: [\"192.168.1.108/24\"],\n    },\n    templateId: \"6b78ea06-ee0e-4689-998c-fc9c46e781f6\",\n});\nconst clusterPassword = new random.RandomPassword(\"clusterPassword\", {\n    length: 16,\n    special: true,\n    overrideSpecial: \"!#$%\u0026*()-_=+[]{}\u003c\u003e:?\",\n});\nconst userPassword = new random.RandomPassword(\"userPassword\", {\n    length: 16,\n    special: true,\n    overrideSpecial: \"!#$%\u0026*()-_=+[]{}\u003c\u003e:?\",\n});\nconst exampleMongoUser = new ionoscloud.dbaas.MongoUser(\"exampleMongoUser\", {\n    clusterId: exampleMongoCluster.id,\n    username: \"myUser\",\n    password: userPassword.result,\n    roles: [\n        {\n            role: \"read\",\n            database: \"db1\",\n        },\n        {\n            role: \"readWrite\",\n            database: \"db2\",\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\nimport pulumi_random as random\n\n# Complete example\ndatacenter_example = ionoscloud.compute.Datacenter(\"datacenterExample\",\n    location=\"de/txl\",\n    description=\"Datacenter for testing dbaas cluster\")\nlan_example = ionoscloud.compute.Lan(\"lanExample\",\n    datacenter_id=datacenter_example.id,\n    public=False)\nexample_mongo_cluster = ionoscloud.dbaas.MongoCluster(\"exampleMongoCluster\",\n    maintenance_window={\n        \"day_of_the_week\": \"Sunday\",\n        \"time\": \"09:00:00\",\n    },\n    mongodb_version=\"5.0\",\n    instances=1,\n    display_name=\"example_mongo_cluster\",\n    location=datacenter_example.location,\n    connections={\n        \"datacenter_id\": datacenter_example.id,\n        \"lan_id\": lan_example.id,\n        \"cidr_lists\": [\"192.168.1.108/24\"],\n    },\n    template_id=\"6b78ea06-ee0e-4689-998c-fc9c46e781f6\")\ncluster_password = random.RandomPassword(\"clusterPassword\",\n    length=16,\n    special=True,\n    override_special=\"!#$%\u0026*()-_=+[]{}\u003c\u003e:?\")\nuser_password = random.RandomPassword(\"userPassword\",\n    length=16,\n    special=True,\n    override_special=\"!#$%\u0026*()-_=+[]{}\u003c\u003e:?\")\nexample_mongo_user = ionoscloud.dbaas.MongoUser(\"exampleMongoUser\",\n    cluster_id=example_mongo_cluster.id,\n    username=\"myUser\",\n    password=user_password.result,\n    roles=[\n        {\n            \"role\": \"read\",\n            \"database\": \"db1\",\n        },\n        {\n            \"role\": \"readWrite\",\n            \"database\": \"db2\",\n        },\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\nusing Random = Pulumi.Random;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Complete example\n    var datacenterExample = new Ionoscloud.Compute.Datacenter(\"datacenterExample\", new()\n    {\n        Location = \"de/txl\",\n        Description = \"Datacenter for testing dbaas cluster\",\n    });\n\n    var lanExample = new Ionoscloud.Compute.Lan(\"lanExample\", new()\n    {\n        DatacenterId = datacenterExample.Id,\n        Public = false,\n    });\n\n    var exampleMongoCluster = new Ionoscloud.Dbaas.MongoCluster(\"exampleMongoCluster\", new()\n    {\n        MaintenanceWindow = new Ionoscloud.Dbaas.Inputs.MongoClusterMaintenanceWindowArgs\n        {\n            DayOfTheWeek = \"Sunday\",\n            Time = \"09:00:00\",\n        },\n        MongodbVersion = \"5.0\",\n        Instances = 1,\n        DisplayName = \"example_mongo_cluster\",\n        Location = datacenterExample.Location,\n        Connections = new Ionoscloud.Dbaas.Inputs.MongoClusterConnectionsArgs\n        {\n            DatacenterId = datacenterExample.Id,\n            LanId = lanExample.Id,\n            CidrLists = new[]\n            {\n                \"192.168.1.108/24\",\n            },\n        },\n        TemplateId = \"6b78ea06-ee0e-4689-998c-fc9c46e781f6\",\n    });\n\n    var clusterPassword = new Random.RandomPassword(\"clusterPassword\", new()\n    {\n        Length = 16,\n        Special = true,\n        OverrideSpecial = \"!#$%\u0026*()-_=+[]{}\u003c\u003e:?\",\n    });\n\n    var userPassword = new Random.RandomPassword(\"userPassword\", new()\n    {\n        Length = 16,\n        Special = true,\n        OverrideSpecial = \"!#$%\u0026*()-_=+[]{}\u003c\u003e:?\",\n    });\n\n    var exampleMongoUser = new Ionoscloud.Dbaas.MongoUser(\"exampleMongoUser\", new()\n    {\n        ClusterId = exampleMongoCluster.Id,\n        Username = \"myUser\",\n        Password = userPassword.Result,\n        Roles = new[]\n        {\n            new Ionoscloud.Dbaas.Inputs.MongoUserRoleArgs\n            {\n                Role = \"read\",\n                Database = \"db1\",\n            },\n            new Ionoscloud.Dbaas.Inputs.MongoUserRoleArgs\n            {\n                Role = \"readWrite\",\n                Database = \"db2\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/dbaas\"\n\t\"github.com/pulumi/pulumi-random/sdk/v4/go/random\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Complete example\n\t\tdatacenterExample, err := compute.NewDatacenter(ctx, \"datacenterExample\", \u0026compute.DatacenterArgs{\n\t\t\tLocation:    pulumi.String(\"de/txl\"),\n\t\t\tDescription: pulumi.String(\"Datacenter for testing dbaas cluster\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tlanExample, err := compute.NewLan(ctx, \"lanExample\", \u0026compute.LanArgs{\n\t\t\tDatacenterId: datacenterExample.ID(),\n\t\t\tPublic:       pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleMongoCluster, err := dbaas.NewMongoCluster(ctx, \"exampleMongoCluster\", \u0026dbaas.MongoClusterArgs{\n\t\t\tMaintenanceWindow: \u0026dbaas.MongoClusterMaintenanceWindowArgs{\n\t\t\t\tDayOfTheWeek: pulumi.String(\"Sunday\"),\n\t\t\t\tTime:         pulumi.String(\"09:00:00\"),\n\t\t\t},\n\t\t\tMongodbVersion: pulumi.String(\"5.0\"),\n\t\t\tInstances:      pulumi.Int(1),\n\t\t\tDisplayName:    pulumi.String(\"example_mongo_cluster\"),\n\t\t\tLocation:       datacenterExample.Location,\n\t\t\tConnections: \u0026dbaas.MongoClusterConnectionsArgs{\n\t\t\t\tDatacenterId: datacenterExample.ID(),\n\t\t\t\tLanId:        lanExample.ID(),\n\t\t\t\tCidrLists: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"192.168.1.108/24\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tTemplateId: pulumi.String(\"6b78ea06-ee0e-4689-998c-fc9c46e781f6\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = random.NewRandomPassword(ctx, \"clusterPassword\", \u0026random.RandomPasswordArgs{\n\t\t\tLength:          pulumi.Int(16),\n\t\t\tSpecial:         pulumi.Bool(true),\n\t\t\tOverrideSpecial: pulumi.String(\"!#$%\u0026*()-_=+[]{}\u003c\u003e:?\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tuserPassword, err := random.NewRandomPassword(ctx, \"userPassword\", \u0026random.RandomPasswordArgs{\n\t\t\tLength:          pulumi.Int(16),\n\t\t\tSpecial:         pulumi.Bool(true),\n\t\t\tOverrideSpecial: pulumi.String(\"!#$%\u0026*()-_=+[]{}\u003c\u003e:?\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = dbaas.NewMongoUser(ctx, \"exampleMongoUser\", \u0026dbaas.MongoUserArgs{\n\t\t\tClusterId: exampleMongoCluster.ID(),\n\t\t\tUsername:  pulumi.String(\"myUser\"),\n\t\t\tPassword:  userPassword.Result,\n\t\t\tRoles: dbaas.MongoUserRoleArray{\n\t\t\t\t\u0026dbaas.MongoUserRoleArgs{\n\t\t\t\t\tRole:     pulumi.String(\"read\"),\n\t\t\t\t\tDatabase: pulumi.String(\"db1\"),\n\t\t\t\t},\n\t\t\t\t\u0026dbaas.MongoUserRoleArgs{\n\t\t\t\t\tRole:     pulumi.String(\"readWrite\"),\n\t\t\t\t\tDatabase: pulumi.String(\"db2\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.Datacenter;\nimport com.pulumi.ionoscloud.compute.DatacenterArgs;\nimport com.pulumi.ionoscloud.compute.Lan;\nimport com.pulumi.ionoscloud.compute.LanArgs;\nimport com.pulumi.ionoscloud.dbaas.MongoCluster;\nimport com.pulumi.ionoscloud.dbaas.MongoClusterArgs;\nimport com.pulumi.ionoscloud.dbaas.inputs.MongoClusterMaintenanceWindowArgs;\nimport com.pulumi.ionoscloud.dbaas.inputs.MongoClusterConnectionsArgs;\nimport com.pulumi.random.RandomPassword;\nimport com.pulumi.random.RandomPasswordArgs;\nimport com.pulumi.ionoscloud.dbaas.MongoUser;\nimport com.pulumi.ionoscloud.dbaas.MongoUserArgs;\nimport com.pulumi.ionoscloud.dbaas.inputs.MongoUserRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Complete example\n        var datacenterExample = new Datacenter(\"datacenterExample\", DatacenterArgs.builder()\n            .location(\"de/txl\")\n            .description(\"Datacenter for testing dbaas cluster\")\n            .build());\n\n        var lanExample = new Lan(\"lanExample\", LanArgs.builder()\n            .datacenterId(datacenterExample.id())\n            .public_(false)\n            .build());\n\n        var exampleMongoCluster = new MongoCluster(\"exampleMongoCluster\", MongoClusterArgs.builder()\n            .maintenanceWindow(MongoClusterMaintenanceWindowArgs.builder()\n                .dayOfTheWeek(\"Sunday\")\n                .time(\"09:00:00\")\n                .build())\n            .mongodbVersion(\"5.0\")\n            .instances(1)\n            .displayName(\"example_mongo_cluster\")\n            .location(datacenterExample.location())\n            .connections(MongoClusterConnectionsArgs.builder()\n                .datacenterId(datacenterExample.id())\n                .lanId(lanExample.id())\n                .cidrLists(\"192.168.1.108/24\")\n                .build())\n            .templateId(\"6b78ea06-ee0e-4689-998c-fc9c46e781f6\")\n            .build());\n\n        var clusterPassword = new RandomPassword(\"clusterPassword\", RandomPasswordArgs.builder()\n            .length(16)\n            .special(true)\n            .overrideSpecial(\"!#$%\u0026*()-_=+[]{}\u003c\u003e:?\")\n            .build());\n\n        var userPassword = new RandomPassword(\"userPassword\", RandomPasswordArgs.builder()\n            .length(16)\n            .special(true)\n            .overrideSpecial(\"!#$%\u0026*()-_=+[]{}\u003c\u003e:?\")\n            .build());\n\n        var exampleMongoUser = new MongoUser(\"exampleMongoUser\", MongoUserArgs.builder()\n            .clusterId(exampleMongoCluster.id())\n            .username(\"myUser\")\n            .password(userPassword.result())\n            .roles(            \n                MongoUserRoleArgs.builder()\n                    .role(\"read\")\n                    .database(\"db1\")\n                    .build(),\n                MongoUserRoleArgs.builder()\n                    .role(\"readWrite\")\n                    .database(\"db2\")\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Complete example\n  datacenterExample:\n    type: ionoscloud:compute:Datacenter\n    properties:\n      location: de/txl\n      description: Datacenter for testing dbaas cluster\n  lanExample:\n    type: ionoscloud:compute:Lan\n    properties:\n      datacenterId: ${datacenterExample.id}\n      public: false\n  exampleMongoCluster:\n    type: ionoscloud:dbaas:MongoCluster\n    properties:\n      maintenanceWindow:\n        dayOfTheWeek: Sunday\n        time: 09:00:00\n      mongodbVersion: '5.0'\n      instances: 1\n      displayName: example_mongo_cluster\n      location: ${datacenterExample.location}\n      connections:\n        datacenterId: ${datacenterExample.id}\n        lanId: ${lanExample.id}\n        cidrLists:\n          - 192.168.1.108/24\n      templateId: 6b78ea06-ee0e-4689-998c-fc9c46e781f6\n  clusterPassword:\n    type: random:RandomPassword\n    properties:\n      length: 16\n      special: true\n      overrideSpecial: '!#$%\u0026*()-_=+[]{}\u003c\u003e:?'\n  userPassword:\n    type: random:RandomPassword\n    properties:\n      length: 16\n      special: true\n      overrideSpecial: '!#$%\u0026*()-_=+[]{}\u003c\u003e:?'\n  exampleMongoUser:\n    type: ionoscloud:dbaas:MongoUser\n    properties:\n      clusterId: ${exampleMongoCluster.id}\n      username: myUser\n      password: ${userPassword.result}\n      roles:\n        - role: read\n          database: db1\n        - role: readWrite\n          database: db2\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nResource DBaaS MongoDB User can be imported using the `clusterID` and the `username`.\n\nFirst, define an empty resource in the plan:\n\nhcl\n\nresource \"ionoscloud_mongo_user\" \"importeduser\" {\n\n}\n\nThen you can import the user using the following command:\n\n```sh\n$ pulumi import ionoscloud:dbaas/mongoUser:MongoUser mycluser {clusterId}/{username}\n```\n\n",
            "properties": {
                "clusterId": {
                    "type": "string",
                    "description": "[string] The unique ID of the cluster. Updates to the value of the field force the cluster to be re-created.\n"
                },
                "password": {
                    "type": "string",
                    "description": "[string] User password. Updates to the value of the field force the cluster to be re-created.\n",
                    "secret": true
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:dbaas/MongoUserRole:MongoUserRole"
                    },
                    "description": "[string] a list of mongodb user roles. Updates to the value of the field force the cluster to be re-created.\n"
                },
                "username": {
                    "type": "string",
                    "description": "[string] Used for authentication. Updates to the value of the field force the cluster to be re-created.\n"
                }
            },
            "required": [
                "clusterId",
                "password",
                "username"
            ],
            "inputProperties": {
                "clusterId": {
                    "type": "string",
                    "description": "[string] The unique ID of the cluster. Updates to the value of the field force the cluster to be re-created.\n",
                    "willReplaceOnChanges": true
                },
                "password": {
                    "type": "string",
                    "description": "[string] User password. Updates to the value of the field force the cluster to be re-created.\n",
                    "secret": true
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:dbaas/MongoUserRole:MongoUserRole"
                    },
                    "description": "[string] a list of mongodb user roles. Updates to the value of the field force the cluster to be re-created.\n"
                },
                "username": {
                    "type": "string",
                    "description": "[string] Used for authentication. Updates to the value of the field force the cluster to be re-created.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "clusterId",
                "password",
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MongoUser resources.\n",
                "properties": {
                    "clusterId": {
                        "type": "string",
                        "description": "[string] The unique ID of the cluster. Updates to the value of the field force the cluster to be re-created.\n",
                        "willReplaceOnChanges": true
                    },
                    "password": {
                        "type": "string",
                        "description": "[string] User password. Updates to the value of the field force the cluster to be re-created.\n",
                        "secret": true
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:dbaas/MongoUserRole:MongoUserRole"
                        },
                        "description": "[string] a list of mongodb user roles. Updates to the value of the field force the cluster to be re-created.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "[string] Used for authentication. Updates to the value of the field force the cluster to be re-created.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:dbaas/pSQLCluster:PSQLCluster": {
            "description": "Manages a **DbaaS PgSql Cluster**.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\n// Basic example\nconst exampleDatacenter = new ionoscloud.compute.Datacenter(\"exampleDatacenter\", {\n    location: \"de/txl\",\n    description: \"Datacenter for testing dbaas cluster\",\n});\nconst exampleLan = new ionoscloud.compute.Lan(\"exampleLan\", {\n    datacenterId: exampleDatacenter.id,\n    \"public\": false,\n});\nconst examplePSQLCluster = new ionoscloud.dbaas.PSQLCluster(\"examplePSQLCluster\", {\n    postgresVersion: \"12\",\n    instances: 1,\n    cores: 4,\n    ram: 2048,\n    storageSize: 2048,\n    storageType: \"HDD\",\n    connectionPooler: {\n        enabled: true,\n        poolMode: \"session\",\n    },\n    connections: {\n        datacenterId: exampleDatacenter.id,\n        lanId: exampleLan.id,\n        cidr: \"192.168.100.1/24\",\n    },\n    location: exampleDatacenter.location,\n    displayName: \"PostgreSQL_cluster\",\n    maintenanceWindow: {\n        dayOfTheWeek: \"Sunday\",\n        time: \"09:00:00\",\n    },\n    credentials: {\n        username: \"username\",\n        password: \"strongPassword\",\n    },\n    synchronizationMode: \"ASYNCHRONOUS\",\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\n# Basic example\nexample_datacenter = ionoscloud.compute.Datacenter(\"exampleDatacenter\",\n    location=\"de/txl\",\n    description=\"Datacenter for testing dbaas cluster\")\nexample_lan = ionoscloud.compute.Lan(\"exampleLan\",\n    datacenter_id=example_datacenter.id,\n    public=False)\nexample_psql_cluster = ionoscloud.dbaas.PSQLCluster(\"examplePSQLCluster\",\n    postgres_version=\"12\",\n    instances=1,\n    cores=4,\n    ram=2048,\n    storage_size=2048,\n    storage_type=\"HDD\",\n    connection_pooler={\n        \"enabled\": True,\n        \"pool_mode\": \"session\",\n    },\n    connections={\n        \"datacenter_id\": example_datacenter.id,\n        \"lan_id\": example_lan.id,\n        \"cidr\": \"192.168.100.1/24\",\n    },\n    location=example_datacenter.location,\n    display_name=\"PostgreSQL_cluster\",\n    maintenance_window={\n        \"day_of_the_week\": \"Sunday\",\n        \"time\": \"09:00:00\",\n    },\n    credentials={\n        \"username\": \"username\",\n        \"password\": \"strongPassword\",\n    },\n    synchronization_mode=\"ASYNCHRONOUS\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Basic example\n    var exampleDatacenter = new Ionoscloud.Compute.Datacenter(\"exampleDatacenter\", new()\n    {\n        Location = \"de/txl\",\n        Description = \"Datacenter for testing dbaas cluster\",\n    });\n\n    var exampleLan = new Ionoscloud.Compute.Lan(\"exampleLan\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        Public = false,\n    });\n\n    var examplePSQLCluster = new Ionoscloud.Dbaas.PSQLCluster(\"examplePSQLCluster\", new()\n    {\n        PostgresVersion = \"12\",\n        Instances = 1,\n        Cores = 4,\n        Ram = 2048,\n        StorageSize = 2048,\n        StorageType = \"HDD\",\n        ConnectionPooler = new Ionoscloud.Dbaas.Inputs.PSQLClusterConnectionPoolerArgs\n        {\n            Enabled = true,\n            PoolMode = \"session\",\n        },\n        Connections = new Ionoscloud.Dbaas.Inputs.PSQLClusterConnectionsArgs\n        {\n            DatacenterId = exampleDatacenter.Id,\n            LanId = exampleLan.Id,\n            Cidr = \"192.168.100.1/24\",\n        },\n        Location = exampleDatacenter.Location,\n        DisplayName = \"PostgreSQL_cluster\",\n        MaintenanceWindow = new Ionoscloud.Dbaas.Inputs.PSQLClusterMaintenanceWindowArgs\n        {\n            DayOfTheWeek = \"Sunday\",\n            Time = \"09:00:00\",\n        },\n        Credentials = new Ionoscloud.Dbaas.Inputs.PSQLClusterCredentialsArgs\n        {\n            Username = \"username\",\n            Password = \"strongPassword\",\n        },\n        SynchronizationMode = \"ASYNCHRONOUS\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/dbaas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Basic example\n\t\texampleDatacenter, err := compute.NewDatacenter(ctx, \"exampleDatacenter\", \u0026compute.DatacenterArgs{\n\t\t\tLocation:    pulumi.String(\"de/txl\"),\n\t\t\tDescription: pulumi.String(\"Datacenter for testing dbaas cluster\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleLan, err := compute.NewLan(ctx, \"exampleLan\", \u0026compute.LanArgs{\n\t\t\tDatacenterId: exampleDatacenter.ID(),\n\t\t\tPublic:       pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = dbaas.NewPSQLCluster(ctx, \"examplePSQLCluster\", \u0026dbaas.PSQLClusterArgs{\n\t\t\tPostgresVersion: pulumi.String(\"12\"),\n\t\t\tInstances:       pulumi.Int(1),\n\t\t\tCores:           pulumi.Int(4),\n\t\t\tRam:             pulumi.Int(2048),\n\t\t\tStorageSize:     pulumi.Int(2048),\n\t\t\tStorageType:     pulumi.String(\"HDD\"),\n\t\t\tConnectionPooler: \u0026dbaas.PSQLClusterConnectionPoolerArgs{\n\t\t\t\tEnabled:  pulumi.Bool(true),\n\t\t\t\tPoolMode: pulumi.String(\"session\"),\n\t\t\t},\n\t\t\tConnections: \u0026dbaas.PSQLClusterConnectionsArgs{\n\t\t\t\tDatacenterId: exampleDatacenter.ID(),\n\t\t\t\tLanId:        exampleLan.ID(),\n\t\t\t\tCidr:         pulumi.String(\"192.168.100.1/24\"),\n\t\t\t},\n\t\t\tLocation:    exampleDatacenter.Location,\n\t\t\tDisplayName: pulumi.String(\"PostgreSQL_cluster\"),\n\t\t\tMaintenanceWindow: \u0026dbaas.PSQLClusterMaintenanceWindowArgs{\n\t\t\t\tDayOfTheWeek: pulumi.String(\"Sunday\"),\n\t\t\t\tTime:         pulumi.String(\"09:00:00\"),\n\t\t\t},\n\t\t\tCredentials: \u0026dbaas.PSQLClusterCredentialsArgs{\n\t\t\t\tUsername: pulumi.String(\"username\"),\n\t\t\t\tPassword: pulumi.String(\"strongPassword\"),\n\t\t\t},\n\t\t\tSynchronizationMode: pulumi.String(\"ASYNCHRONOUS\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.Datacenter;\nimport com.pulumi.ionoscloud.compute.DatacenterArgs;\nimport com.pulumi.ionoscloud.compute.Lan;\nimport com.pulumi.ionoscloud.compute.LanArgs;\nimport com.pulumi.ionoscloud.dbaas.PSQLCluster;\nimport com.pulumi.ionoscloud.dbaas.PSQLClusterArgs;\nimport com.pulumi.ionoscloud.dbaas.inputs.PSQLClusterConnectionPoolerArgs;\nimport com.pulumi.ionoscloud.dbaas.inputs.PSQLClusterConnectionsArgs;\nimport com.pulumi.ionoscloud.dbaas.inputs.PSQLClusterMaintenanceWindowArgs;\nimport com.pulumi.ionoscloud.dbaas.inputs.PSQLClusterCredentialsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Basic example\n        var exampleDatacenter = new Datacenter(\"exampleDatacenter\", DatacenterArgs.builder()\n            .location(\"de/txl\")\n            .description(\"Datacenter for testing dbaas cluster\")\n            .build());\n\n        var exampleLan = new Lan(\"exampleLan\", LanArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .public_(false)\n            .build());\n\n        var examplePSQLCluster = new PSQLCluster(\"examplePSQLCluster\", PSQLClusterArgs.builder()\n            .postgresVersion(\"12\")\n            .instances(1)\n            .cores(4)\n            .ram(2048)\n            .storageSize(2048)\n            .storageType(\"HDD\")\n            .connectionPooler(PSQLClusterConnectionPoolerArgs.builder()\n                .enabled(true)\n                .poolMode(\"session\")\n                .build())\n            .connections(PSQLClusterConnectionsArgs.builder()\n                .datacenterId(exampleDatacenter.id())\n                .lanId(exampleLan.id())\n                .cidr(\"192.168.100.1/24\")\n                .build())\n            .location(exampleDatacenter.location())\n            .displayName(\"PostgreSQL_cluster\")\n            .maintenanceWindow(PSQLClusterMaintenanceWindowArgs.builder()\n                .dayOfTheWeek(\"Sunday\")\n                .time(\"09:00:00\")\n                .build())\n            .credentials(PSQLClusterCredentialsArgs.builder()\n                .username(\"username\")\n                .password(\"strongPassword\")\n                .build())\n            .synchronizationMode(\"ASYNCHRONOUS\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Basic example\n  exampleDatacenter:\n    type: ionoscloud:compute:Datacenter\n    properties:\n      location: de/txl\n      description: Datacenter for testing dbaas cluster\n  exampleLan:\n    type: ionoscloud:compute:Lan\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      public: false\n  examplePSQLCluster:\n    type: ionoscloud:dbaas:PSQLCluster\n    properties:\n      postgresVersion: '12'\n      instances: 1\n      cores: 4\n      ram: 2048\n      storageSize: 2048\n      storageType: HDD\n      connectionPooler:\n        enabled: true\n        poolMode: session\n      connections:\n        datacenterId: ${exampleDatacenter.id}\n        lanId: ${exampleLan.id}\n        cidr: 192.168.100.1/24\n      location: ${exampleDatacenter.location}\n      displayName: PostgreSQL_cluster\n      maintenanceWindow:\n        dayOfTheWeek: Sunday\n        time: 09:00:00\n      credentials:\n        username: username\n        password: strongPassword\n      synchronizationMode: ASYNCHRONOUS\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nResource DbaaS Postgres Cluster can be imported using the `cluster_id`, e.g.\n\n```sh\n$ pulumi import ionoscloud:dbaas/pSQLCluster:PSQLCluster mycluser {cluster uuid}\n```\n\n",
            "properties": {
                "backupLocation": {
                    "type": "string",
                    "description": "(Computed)[string] The IONOS Object Storage location where the backups will be stored. Possible values are: `de`, `eu-south-2`, `eu-central-2`. This attribute is immutable (disallowed in update requests).\n"
                },
                "connectionPooler": {
                    "$ref": "#/types/ionoscloud:dbaas/PSQLClusterConnectionPooler:PSQLClusterConnectionPooler",
                    "description": "[object]\n"
                },
                "connections": {
                    "$ref": "#/types/ionoscloud:dbaas/PSQLClusterConnections:PSQLClusterConnections",
                    "description": "[string] Details about the network connection for your cluster.\n"
                },
                "cores": {
                    "type": "integer",
                    "description": "[int] The number of CPU cores per replica.\n"
                },
                "credentials": {
                    "$ref": "#/types/ionoscloud:dbaas/PSQLClusterCredentials:PSQLClusterCredentials",
                    "description": "[string] Credentials for the database user to be created. This attribute is immutable(disallowed in update requests).\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "[string] The friendly name of your cluster.\n"
                },
                "dnsName": {
                    "type": "string",
                    "description": "[string] The DNS name pointing to your cluster.\n"
                },
                "fromBackup": {
                    "$ref": "#/types/ionoscloud:dbaas/PSQLClusterFromBackup:PSQLClusterFromBackup",
                    "description": "[string] The unique ID of the backup you want to restore. This attribute is immutable(disallowed in update requests).\n"
                },
                "instances": {
                    "type": "integer",
                    "description": "[int] The total number of instances in the cluster (one master and n-1 standbys)\n"
                },
                "location": {
                    "type": "string",
                    "description": "[string] The physical location where the cluster will be created. This will be where all of your instances live. Property cannot be modified after datacenter creation. Possible values are: `de/fra`, `de/txl`, `gb/lhr`, `es/vit`, `us/ewr`, `us/las`. This attribute is immutable(disallowed in update requests).\n"
                },
                "maintenanceWindow": {
                    "$ref": "#/types/ionoscloud:dbaas/PSQLClusterMaintenanceWindow:PSQLClusterMaintenanceWindow",
                    "description": "(Computed)[string] A weekly 4 hour-long window, during which maintenance might occur\n"
                },
                "postgresVersion": {
                    "type": "string",
                    "description": "[string] The PostgreSQL version of your cluster.\n"
                },
                "ram": {
                    "type": "integer",
                    "description": "[int] The amount of memory per instance in megabytes. Has to be a multiple of 1024.\n"
                },
                "storageSize": {
                    "type": "integer",
                    "description": "[int] The amount of storage per instance in MB. Has to be a multiple of 2048.\n"
                },
                "storageType": {
                    "type": "string",
                    "description": "[string] SSD, SSD Standard, SSD Premium, or HDD. Value \"SSD\" is deprecated, use the equivalent \"SSD Premium\" instead. This attribute is immutable(disallowed in update requests).\n"
                },
                "synchronizationMode": {
                    "type": "string",
                    "description": "[string] Represents different modes of replication. Can have one of the following values: ASYNCHRONOUS, SYNCHRONOUS, STRICTLY_SYNCHRONOUS. This attribute is immutable(disallowed in update requests).\n"
                }
            },
            "required": [
                "backupLocation",
                "connectionPooler",
                "cores",
                "credentials",
                "displayName",
                "dnsName",
                "instances",
                "location",
                "maintenanceWindow",
                "postgresVersion",
                "ram",
                "storageSize",
                "storageType",
                "synchronizationMode"
            ],
            "inputProperties": {
                "backupLocation": {
                    "type": "string",
                    "description": "(Computed)[string] The IONOS Object Storage location where the backups will be stored. Possible values are: `de`, `eu-south-2`, `eu-central-2`. This attribute is immutable (disallowed in update requests).\n"
                },
                "connectionPooler": {
                    "$ref": "#/types/ionoscloud:dbaas/PSQLClusterConnectionPooler:PSQLClusterConnectionPooler",
                    "description": "[object]\n"
                },
                "connections": {
                    "$ref": "#/types/ionoscloud:dbaas/PSQLClusterConnections:PSQLClusterConnections",
                    "description": "[string] Details about the network connection for your cluster.\n"
                },
                "cores": {
                    "type": "integer",
                    "description": "[int] The number of CPU cores per replica.\n"
                },
                "credentials": {
                    "$ref": "#/types/ionoscloud:dbaas/PSQLClusterCredentials:PSQLClusterCredentials",
                    "description": "[string] Credentials for the database user to be created. This attribute is immutable(disallowed in update requests).\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "[string] The friendly name of your cluster.\n"
                },
                "fromBackup": {
                    "$ref": "#/types/ionoscloud:dbaas/PSQLClusterFromBackup:PSQLClusterFromBackup",
                    "description": "[string] The unique ID of the backup you want to restore. This attribute is immutable(disallowed in update requests).\n"
                },
                "instances": {
                    "type": "integer",
                    "description": "[int] The total number of instances in the cluster (one master and n-1 standbys)\n"
                },
                "location": {
                    "type": "string",
                    "description": "[string] The physical location where the cluster will be created. This will be where all of your instances live. Property cannot be modified after datacenter creation. Possible values are: `de/fra`, `de/txl`, `gb/lhr`, `es/vit`, `us/ewr`, `us/las`. This attribute is immutable(disallowed in update requests).\n"
                },
                "maintenanceWindow": {
                    "$ref": "#/types/ionoscloud:dbaas/PSQLClusterMaintenanceWindow:PSQLClusterMaintenanceWindow",
                    "description": "(Computed)[string] A weekly 4 hour-long window, during which maintenance might occur\n"
                },
                "postgresVersion": {
                    "type": "string",
                    "description": "[string] The PostgreSQL version of your cluster.\n"
                },
                "ram": {
                    "type": "integer",
                    "description": "[int] The amount of memory per instance in megabytes. Has to be a multiple of 1024.\n"
                },
                "storageSize": {
                    "type": "integer",
                    "description": "[int] The amount of storage per instance in MB. Has to be a multiple of 2048.\n"
                },
                "storageType": {
                    "type": "string",
                    "description": "[string] SSD, SSD Standard, SSD Premium, or HDD. Value \"SSD\" is deprecated, use the equivalent \"SSD Premium\" instead. This attribute is immutable(disallowed in update requests).\n"
                },
                "synchronizationMode": {
                    "type": "string",
                    "description": "[string] Represents different modes of replication. Can have one of the following values: ASYNCHRONOUS, SYNCHRONOUS, STRICTLY_SYNCHRONOUS. This attribute is immutable(disallowed in update requests).\n"
                }
            },
            "requiredInputs": [
                "cores",
                "credentials",
                "displayName",
                "instances",
                "location",
                "postgresVersion",
                "ram",
                "storageSize",
                "storageType",
                "synchronizationMode"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PSQLCluster resources.\n",
                "properties": {
                    "backupLocation": {
                        "type": "string",
                        "description": "(Computed)[string] The IONOS Object Storage location where the backups will be stored. Possible values are: `de`, `eu-south-2`, `eu-central-2`. This attribute is immutable (disallowed in update requests).\n"
                    },
                    "connectionPooler": {
                        "$ref": "#/types/ionoscloud:dbaas/PSQLClusterConnectionPooler:PSQLClusterConnectionPooler",
                        "description": "[object]\n"
                    },
                    "connections": {
                        "$ref": "#/types/ionoscloud:dbaas/PSQLClusterConnections:PSQLClusterConnections",
                        "description": "[string] Details about the network connection for your cluster.\n"
                    },
                    "cores": {
                        "type": "integer",
                        "description": "[int] The number of CPU cores per replica.\n"
                    },
                    "credentials": {
                        "$ref": "#/types/ionoscloud:dbaas/PSQLClusterCredentials:PSQLClusterCredentials",
                        "description": "[string] Credentials for the database user to be created. This attribute is immutable(disallowed in update requests).\n"
                    },
                    "displayName": {
                        "type": "string",
                        "description": "[string] The friendly name of your cluster.\n"
                    },
                    "dnsName": {
                        "type": "string",
                        "description": "[string] The DNS name pointing to your cluster.\n"
                    },
                    "fromBackup": {
                        "$ref": "#/types/ionoscloud:dbaas/PSQLClusterFromBackup:PSQLClusterFromBackup",
                        "description": "[string] The unique ID of the backup you want to restore. This attribute is immutable(disallowed in update requests).\n"
                    },
                    "instances": {
                        "type": "integer",
                        "description": "[int] The total number of instances in the cluster (one master and n-1 standbys)\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "[string] The physical location where the cluster will be created. This will be where all of your instances live. Property cannot be modified after datacenter creation. Possible values are: `de/fra`, `de/txl`, `gb/lhr`, `es/vit`, `us/ewr`, `us/las`. This attribute is immutable(disallowed in update requests).\n"
                    },
                    "maintenanceWindow": {
                        "$ref": "#/types/ionoscloud:dbaas/PSQLClusterMaintenanceWindow:PSQLClusterMaintenanceWindow",
                        "description": "(Computed)[string] A weekly 4 hour-long window, during which maintenance might occur\n"
                    },
                    "postgresVersion": {
                        "type": "string",
                        "description": "[string] The PostgreSQL version of your cluster.\n"
                    },
                    "ram": {
                        "type": "integer",
                        "description": "[int] The amount of memory per instance in megabytes. Has to be a multiple of 1024.\n"
                    },
                    "storageSize": {
                        "type": "integer",
                        "description": "[int] The amount of storage per instance in MB. Has to be a multiple of 2048.\n"
                    },
                    "storageType": {
                        "type": "string",
                        "description": "[string] SSD, SSD Standard, SSD Premium, or HDD. Value \"SSD\" is deprecated, use the equivalent \"SSD Premium\" instead. This attribute is immutable(disallowed in update requests).\n"
                    },
                    "synchronizationMode": {
                        "type": "string",
                        "description": "[string] Represents different modes of replication. Can have one of the following values: ASYNCHRONOUS, SYNCHRONOUS, STRICTLY_SYNCHRONOUS. This attribute is immutable(disallowed in update requests).\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:dbaas/pSQLDatabase:PSQLDatabase": {
            "description": "Manages a **DbaaS PgSql Database**.\n\n## Example Usage\n\nCreate a `PgSQL` cluster as presented in the documentation for the cluster, then define a database resource\nand link it with the previously created cluster:\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst examplePgDatabase = new ionoscloud.dbaas.PSQLDatabase(\"examplePgDatabase\", {\n    clusterId: ionoscloud_pg_cluster.example.id,\n    owner: \"exampleuser\",\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\nexample_pg_database = ionoscloud.dbaas.PSQLDatabase(\"examplePgDatabase\",\n    cluster_id=ionoscloud_pg_cluster[\"example\"][\"id\"],\n    owner=\"exampleuser\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var examplePgDatabase = new Ionoscloud.Dbaas.PSQLDatabase(\"examplePgDatabase\", new()\n    {\n        ClusterId = ionoscloud_pg_cluster.Example.Id,\n        Owner = \"exampleuser\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/dbaas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dbaas.NewPSQLDatabase(ctx, \"examplePgDatabase\", \u0026dbaas.PSQLDatabaseArgs{\n\t\t\tClusterId: pulumi.Any(ionoscloud_pg_cluster.Example.Id),\n\t\t\tOwner:     pulumi.String(\"exampleuser\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.dbaas.PSQLDatabase;\nimport com.pulumi.ionoscloud.dbaas.PSQLDatabaseArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var examplePgDatabase = new PSQLDatabase(\"examplePgDatabase\", PSQLDatabaseArgs.builder()\n            .clusterId(ionoscloud_pg_cluster.example().id())\n            .owner(\"exampleuser\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  examplePgDatabase:\n    type: ionoscloud:dbaas:PSQLDatabase\n    properties:\n      clusterId: ${ionoscloud_pg_cluster.example.id}\n      owner: exampleuser\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nIn order to import a PgSql database, you can define an empty database resource in the plan:\n\nhcl\n\nresource \"ionoscloud_pg_database\" \"example\" {\n\n}\n\nThe resource can be imported using the `clusterId` and the `name`, for example:\n\n```sh\n$ pulumi import ionoscloud:dbaas/pSQLDatabase:PSQLDatabase example {clusterId}/{name}\n```\n\n",
            "properties": {
                "clusterId": {
                    "type": "string",
                    "description": "[string] The unique ID of the cluster.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the database.\n"
                },
                "owner": {
                    "type": "string",
                    "description": "[string] The owner of the database.\n"
                }
            },
            "required": [
                "clusterId",
                "name",
                "owner"
            ],
            "inputProperties": {
                "clusterId": {
                    "type": "string",
                    "description": "[string] The unique ID of the cluster.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the database.\n"
                },
                "owner": {
                    "type": "string",
                    "description": "[string] The owner of the database.\n"
                }
            },
            "requiredInputs": [
                "clusterId",
                "owner"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PSQLDatabase resources.\n",
                "properties": {
                    "clusterId": {
                        "type": "string",
                        "description": "[string] The unique ID of the cluster.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] The name of the database.\n"
                    },
                    "owner": {
                        "type": "string",
                        "description": "[string] The owner of the database.\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:dbaas/pSQLUser:PSQLUser": {
            "description": "Manages a **DbaaS PgSql User**.\n\n## Example Usage\n\nCreate a `PgSQL` cluster as presented in the documentation for the cluster, then define a user resource\nand link it with the previously created cluster:\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\nimport * as random from \"@pulumi/random\";\n\nconst userPassword = new random.RandomPassword(\"userPassword\", {\n    length: 16,\n    special: true,\n    overrideSpecial: \"!#$%\u0026*()-_=+[]{}\u003c\u003e:?\",\n});\nconst examplePgUser = new ionoscloud.dbaas.PSQLUser(\"examplePgUser\", {\n    clusterId: ionoscloud_pg_cluster.example.id,\n    username: \"exampleuser\",\n    password: userPassword.result,\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\nimport pulumi_random as random\n\nuser_password = random.RandomPassword(\"userPassword\",\n    length=16,\n    special=True,\n    override_special=\"!#$%\u0026*()-_=+[]{}\u003c\u003e:?\")\nexample_pg_user = ionoscloud.dbaas.PSQLUser(\"examplePgUser\",\n    cluster_id=ionoscloud_pg_cluster[\"example\"][\"id\"],\n    username=\"exampleuser\",\n    password=user_password.result)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\nusing Random = Pulumi.Random;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var userPassword = new Random.RandomPassword(\"userPassword\", new()\n    {\n        Length = 16,\n        Special = true,\n        OverrideSpecial = \"!#$%\u0026*()-_=+[]{}\u003c\u003e:?\",\n    });\n\n    var examplePgUser = new Ionoscloud.Dbaas.PSQLUser(\"examplePgUser\", new()\n    {\n        ClusterId = ionoscloud_pg_cluster.Example.Id,\n        Username = \"exampleuser\",\n        Password = userPassword.Result,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/dbaas\"\n\t\"github.com/pulumi/pulumi-random/sdk/v4/go/random\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tuserPassword, err := random.NewRandomPassword(ctx, \"userPassword\", \u0026random.RandomPasswordArgs{\n\t\t\tLength:          pulumi.Int(16),\n\t\t\tSpecial:         pulumi.Bool(true),\n\t\t\tOverrideSpecial: pulumi.String(\"!#$%\u0026*()-_=+[]{}\u003c\u003e:?\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = dbaas.NewPSQLUser(ctx, \"examplePgUser\", \u0026dbaas.PSQLUserArgs{\n\t\t\tClusterId: pulumi.Any(ionoscloud_pg_cluster.Example.Id),\n\t\t\tUsername:  pulumi.String(\"exampleuser\"),\n\t\t\tPassword:  userPassword.Result,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.random.RandomPassword;\nimport com.pulumi.random.RandomPasswordArgs;\nimport com.pulumi.ionoscloud.dbaas.PSQLUser;\nimport com.pulumi.ionoscloud.dbaas.PSQLUserArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var userPassword = new RandomPassword(\"userPassword\", RandomPasswordArgs.builder()\n            .length(16)\n            .special(true)\n            .overrideSpecial(\"!#$%\u0026*()-_=+[]{}\u003c\u003e:?\")\n            .build());\n\n        var examplePgUser = new PSQLUser(\"examplePgUser\", PSQLUserArgs.builder()\n            .clusterId(ionoscloud_pg_cluster.example().id())\n            .username(\"exampleuser\")\n            .password(userPassword.result())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  examplePgUser:\n    type: ionoscloud:dbaas:PSQLUser\n    properties:\n      clusterId: ${ionoscloud_pg_cluster.example.id}\n      username: exampleuser\n      password: ${userPassword.result}\n  userPassword:\n    type: random:RandomPassword\n    properties:\n      length: 16\n      special: true\n      overrideSpecial: '!#$%\u0026*()-_=+[]{}\u003c\u003e:?'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nIn order to import a PgSql user, you can define an empty user resource in the plan:\n\nhcl\n\nresource \"ionoscloud_pg_user\" \"example\" {\n\n}\n\nThe resource can be imported using the `clusterId` and the `username`, for example:\n\n```sh\n$ pulumi import ionoscloud:dbaas/pSQLUser:PSQLUser example {clusterId}/{username}\n```\n\n",
            "properties": {
                "clusterId": {
                    "type": "string",
                    "description": "[string] The unique ID of the cluster. Updates to the value of the field force the cluster to be re-created.\n"
                },
                "isSystemUser": {
                    "type": "boolean",
                    "description": "[bool] Describes whether this user is a system user or not. A system user cannot be updated or deleted.\n"
                },
                "password": {
                    "type": "string",
                    "description": "[string] User password.\n",
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "[string] Used for authentication. Updates to the value of the field force the cluster to be re-created.\n"
                }
            },
            "required": [
                "clusterId",
                "isSystemUser",
                "password",
                "username"
            ],
            "inputProperties": {
                "clusterId": {
                    "type": "string",
                    "description": "[string] The unique ID of the cluster. Updates to the value of the field force the cluster to be re-created.\n",
                    "willReplaceOnChanges": true
                },
                "password": {
                    "type": "string",
                    "description": "[string] User password.\n",
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "[string] Used for authentication. Updates to the value of the field force the cluster to be re-created.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "clusterId",
                "password",
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PSQLUser resources.\n",
                "properties": {
                    "clusterId": {
                        "type": "string",
                        "description": "[string] The unique ID of the cluster. Updates to the value of the field force the cluster to be re-created.\n",
                        "willReplaceOnChanges": true
                    },
                    "isSystemUser": {
                        "type": "boolean",
                        "description": "[bool] Describes whether this user is a system user or not. A system user cannot be updated or deleted.\n"
                    },
                    "password": {
                        "type": "string",
                        "description": "[string] User password.\n",
                        "secret": true
                    },
                    "username": {
                        "type": "string",
                        "description": "[string] Used for authentication. Updates to the value of the field force the cluster to be re-created.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:dns/record:Record": {
            "description": "Manages a **DNS Record**.\n\n\u003e ⚠️  Only tokens are accepted for authorization in the **ionoscloud_dns_record** resource. Please ensure you are using tokens as other methods will not be valid.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = new ionoscloud.dns.Zone(\"example\", {\n    description: \"description\",\n    enabled: false,\n});\nconst recordexample = new ionoscloud.dns.Record(\"recordexample\", {\n    zoneId: example.id,\n    type: \"CNAME\",\n    content: \"1.2.3.4\",\n    ttl: 2000,\n    priority: 1024,\n    enabled: false,\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\nexample = ionoscloud.dns.Zone(\"example\",\n    description=\"description\",\n    enabled=False)\nrecordexample = ionoscloud.dns.Record(\"recordexample\",\n    zone_id=example.id,\n    type=\"CNAME\",\n    content=\"1.2.3.4\",\n    ttl=2000,\n    priority=1024,\n    enabled=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Ionoscloud.Dns.Zone(\"example\", new()\n    {\n        Description = \"description\",\n        Enabled = false,\n    });\n\n    var recordexample = new Ionoscloud.Dns.Record(\"recordexample\", new()\n    {\n        ZoneId = example.Id,\n        Type = \"CNAME\",\n        Content = \"1.2.3.4\",\n        Ttl = 2000,\n        Priority = 1024,\n        Enabled = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/dns\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := dns.NewZone(ctx, \"example\", \u0026dns.ZoneArgs{\n\t\t\tDescription: pulumi.String(\"description\"),\n\t\t\tEnabled:     pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = dns.NewRecord(ctx, \"recordexample\", \u0026dns.RecordArgs{\n\t\t\tZoneId:   example.ID(),\n\t\t\tType:     pulumi.String(\"CNAME\"),\n\t\t\tContent:  pulumi.String(\"1.2.3.4\"),\n\t\t\tTtl:      pulumi.Int(2000),\n\t\t\tPriority: pulumi.Int(1024),\n\t\t\tEnabled:  pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.dns.Zone;\nimport com.pulumi.ionoscloud.dns.ZoneArgs;\nimport com.pulumi.ionoscloud.dns.Record;\nimport com.pulumi.ionoscloud.dns.RecordArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new Zone(\"example\", ZoneArgs.builder()\n            .description(\"description\")\n            .enabled(false)\n            .build());\n\n        var recordexample = new Record(\"recordexample\", RecordArgs.builder()\n            .zoneId(example.id())\n            .type(\"CNAME\")\n            .content(\"1.2.3.4\")\n            .ttl(2000)\n            .priority(1024)\n            .enabled(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: ionoscloud:dns:Zone\n    properties:\n      description: description\n      enabled: false\n  recordexample:\n    type: ionoscloud:dns:Record\n    properties:\n      zoneId: ${example.id}\n      type: CNAME\n      content: 1.2.3.4\n      ttl: 2000\n      priority: 1024\n      enabled: false\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nIn order to import a DNS Record, you can define an empty DNS Record resource in the plan:\n\nhcl\n\nresource \"ionoscloud_dns_record\" \"example\" {\n\n}\n\nThe resource can be imported using the `zone_id` and the `record_id`, for example:\n\n```sh\n$ pulumi import ionoscloud:dns/record:Record example {zone_id}/{record_id}\n```\n\n",
            "properties": {
                "content": {
                    "type": "string",
                    "description": "[string] The content of the DNS Record.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "[bool] Indicates if the DNS Record is active or not. Default is `true`.\n"
                },
                "fqdn": {
                    "type": "string",
                    "description": "Fully qualified domain name\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the DNS Record.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "[int] The priority for the DNS Record.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "[int] Time to live for the DNS Record. Default is `3600`.\n"
                },
                "type": {
                    "type": "string",
                    "description": "[string] The type of the DNS Record, can have one of these values: `A, AAAA, CNAME, ALIAS, MX, NS, SRV, TXT, CAA, SSHFP, TLSA, SMIMEA, DS, HTTPS, SVCB, OPENPGPKEY, CERT, URI, RP, LOC`. More details about types can be found [here](https://docs.ionos.com/dns-as-a-service/readme/api-how-tos/create-a-new-dns-record#create-records-of-other-types).\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "[string] The DNS Zone ID in which the DNS Record will be created.\n"
                }
            },
            "required": [
                "content",
                "enabled",
                "fqdn",
                "name",
                "ttl",
                "type",
                "zoneId"
            ],
            "inputProperties": {
                "content": {
                    "type": "string",
                    "description": "[string] The content of the DNS Record.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "[bool] Indicates if the DNS Record is active or not. Default is `true`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the DNS Record.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "[int] The priority for the DNS Record.\n"
                },
                "ttl": {
                    "type": "integer",
                    "description": "[int] Time to live for the DNS Record. Default is `3600`.\n"
                },
                "type": {
                    "type": "string",
                    "description": "[string] The type of the DNS Record, can have one of these values: `A, AAAA, CNAME, ALIAS, MX, NS, SRV, TXT, CAA, SSHFP, TLSA, SMIMEA, DS, HTTPS, SVCB, OPENPGPKEY, CERT, URI, RP, LOC`. More details about types can be found [here](https://docs.ionos.com/dns-as-a-service/readme/api-how-tos/create-a-new-dns-record#create-records-of-other-types).\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "[string] The DNS Zone ID in which the DNS Record will be created.\n"
                }
            },
            "requiredInputs": [
                "content",
                "type",
                "zoneId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Record resources.\n",
                "properties": {
                    "content": {
                        "type": "string",
                        "description": "[string] The content of the DNS Record.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "[bool] Indicates if the DNS Record is active or not. Default is `true`.\n"
                    },
                    "fqdn": {
                        "type": "string",
                        "description": "Fully qualified domain name\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] The name of the DNS Record.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "[int] The priority for the DNS Record.\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "[int] Time to live for the DNS Record. Default is `3600`.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "[string] The type of the DNS Record, can have one of these values: `A, AAAA, CNAME, ALIAS, MX, NS, SRV, TXT, CAA, SSHFP, TLSA, SMIMEA, DS, HTTPS, SVCB, OPENPGPKEY, CERT, URI, RP, LOC`. More details about types can be found [here](https://docs.ionos.com/dns-as-a-service/readme/api-how-tos/create-a-new-dns-record#create-records-of-other-types).\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "[string] The DNS Zone ID in which the DNS Record will be created.\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:dns/zone:Zone": {
            "description": "Manages a **DNS Zone**.\n\n\u003e ⚠️  Only tokens are accepted for authorization in the **ionoscloud_dns_zone** resource. Please ensure you are using tokens as other methods will not be valid.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = new ionoscloud.dns.Zone(\"example\", {\n    description: \"description\",\n    enabled: false,\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\nexample = ionoscloud.dns.Zone(\"example\",\n    description=\"description\",\n    enabled=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Ionoscloud.Dns.Zone(\"example\", new()\n    {\n        Description = \"description\",\n        Enabled = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/dns\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dns.NewZone(ctx, \"example\", \u0026dns.ZoneArgs{\n\t\t\tDescription: pulumi.String(\"description\"),\n\t\t\tEnabled:     pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.dns.Zone;\nimport com.pulumi.ionoscloud.dns.ZoneArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new Zone(\"example\", ZoneArgs.builder()\n            .description(\"description\")\n            .enabled(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: ionoscloud:dns:Zone\n    properties:\n      description: description\n      enabled: false\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nIn order to import a DNS Zone, you can define an empty DNS Zone resource in the plan:\n\nhcl\n\nresource \"ionoscloud_dns_zone\" \"example\" {\n\n}\n\nThe resource can be imported using the `zone_id`, for example:\n\n```sh\n$ pulumi import ionoscloud:dns/zone:Zone example {zone_id}\n```\n\n",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "[string] The description for the DNS Zone.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "[bool] Indicates if the DNS Zone is active or not. Default is `true`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the DNS Zone.\n"
                },
                "nameservers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of available name servers.\n"
                }
            },
            "required": [
                "enabled",
                "name",
                "nameservers"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "[string] The description for the DNS Zone.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "[bool] Indicates if the DNS Zone is active or not. Default is `true`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the DNS Zone.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Zone resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "[string] The description for the DNS Zone.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "[bool] Indicates if the DNS Zone is active or not. Default is `true`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] The name of the DNS Zone.\n"
                    },
                    "nameservers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of available name servers.\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:dsaas/cluster:Cluster": {
            "description": "Manages a **Dataplatform Cluster**.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst exampleDatacenter = new ionoscloud.compute.Datacenter(\"exampleDatacenter\", {\n    location: \"de/txl\",\n    description: \"Datacenter for testing Dataplatform Cluster\",\n});\nconst exampleLan = new ionoscloud.compute.Lan(\"exampleLan\", {\n    datacenterId: exampleDatacenter.id,\n    \"public\": false,\n});\nconst exampleCluster = new ionoscloud.dsaas.Cluster(\"exampleCluster\", {\n    datacenterId: exampleDatacenter.id,\n    maintenanceWindows: [{\n        dayOfTheWeek: \"Sunday\",\n        time: \"09:00:00\",\n    }],\n    version: \"23.11\",\n    lans: [{\n        lanId: exampleLan.id,\n        dhcp: false,\n        routes: [{\n            network: \"182.168.42.1/24\",\n            gateway: \"192.168.42.1\",\n        }],\n    }],\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\nexample_datacenter = ionoscloud.compute.Datacenter(\"exampleDatacenter\",\n    location=\"de/txl\",\n    description=\"Datacenter for testing Dataplatform Cluster\")\nexample_lan = ionoscloud.compute.Lan(\"exampleLan\",\n    datacenter_id=example_datacenter.id,\n    public=False)\nexample_cluster = ionoscloud.dsaas.Cluster(\"exampleCluster\",\n    datacenter_id=example_datacenter.id,\n    maintenance_windows=[{\n        \"day_of_the_week\": \"Sunday\",\n        \"time\": \"09:00:00\",\n    }],\n    version=\"23.11\",\n    lans=[{\n        \"lan_id\": example_lan.id,\n        \"dhcp\": False,\n        \"routes\": [{\n            \"network\": \"182.168.42.1/24\",\n            \"gateway\": \"192.168.42.1\",\n        }],\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleDatacenter = new Ionoscloud.Compute.Datacenter(\"exampleDatacenter\", new()\n    {\n        Location = \"de/txl\",\n        Description = \"Datacenter for testing Dataplatform Cluster\",\n    });\n\n    var exampleLan = new Ionoscloud.Compute.Lan(\"exampleLan\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        Public = false,\n    });\n\n    var exampleCluster = new Ionoscloud.Dsaas.Cluster(\"exampleCluster\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        MaintenanceWindows = new[]\n        {\n            new Ionoscloud.Dsaas.Inputs.ClusterMaintenanceWindowArgs\n            {\n                DayOfTheWeek = \"Sunday\",\n                Time = \"09:00:00\",\n            },\n        },\n        Version = \"23.11\",\n        Lans = new[]\n        {\n            new Ionoscloud.Dsaas.Inputs.ClusterLanArgs\n            {\n                LanId = exampleLan.Id,\n                Dhcp = false,\n                Routes = new[]\n                {\n                    new Ionoscloud.Dsaas.Inputs.ClusterLanRouteArgs\n                    {\n                        Network = \"182.168.42.1/24\",\n                        Gateway = \"192.168.42.1\",\n                    },\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/dsaas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleDatacenter, err := compute.NewDatacenter(ctx, \"exampleDatacenter\", \u0026compute.DatacenterArgs{\n\t\t\tLocation:    pulumi.String(\"de/txl\"),\n\t\t\tDescription: pulumi.String(\"Datacenter for testing Dataplatform Cluster\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleLan, err := compute.NewLan(ctx, \"exampleLan\", \u0026compute.LanArgs{\n\t\t\tDatacenterId: exampleDatacenter.ID(),\n\t\t\tPublic:       pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = dsaas.NewCluster(ctx, \"exampleCluster\", \u0026dsaas.ClusterArgs{\n\t\t\tDatacenterId: exampleDatacenter.ID(),\n\t\t\tMaintenanceWindows: dsaas.ClusterMaintenanceWindowArray{\n\t\t\t\t\u0026dsaas.ClusterMaintenanceWindowArgs{\n\t\t\t\t\tDayOfTheWeek: pulumi.String(\"Sunday\"),\n\t\t\t\t\tTime:         pulumi.String(\"09:00:00\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tVersion: pulumi.String(\"23.11\"),\n\t\t\tLans: dsaas.ClusterLanArray{\n\t\t\t\t\u0026dsaas.ClusterLanArgs{\n\t\t\t\t\tLanId: exampleLan.ID(),\n\t\t\t\t\tDhcp:  pulumi.Bool(false),\n\t\t\t\t\tRoutes: dsaas.ClusterLanRouteArray{\n\t\t\t\t\t\t\u0026dsaas.ClusterLanRouteArgs{\n\t\t\t\t\t\t\tNetwork: pulumi.String(\"182.168.42.1/24\"),\n\t\t\t\t\t\t\tGateway: pulumi.String(\"192.168.42.1\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.Datacenter;\nimport com.pulumi.ionoscloud.compute.DatacenterArgs;\nimport com.pulumi.ionoscloud.compute.Lan;\nimport com.pulumi.ionoscloud.compute.LanArgs;\nimport com.pulumi.ionoscloud.dsaas.Cluster;\nimport com.pulumi.ionoscloud.dsaas.ClusterArgs;\nimport com.pulumi.ionoscloud.dsaas.inputs.ClusterMaintenanceWindowArgs;\nimport com.pulumi.ionoscloud.dsaas.inputs.ClusterLanArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleDatacenter = new Datacenter(\"exampleDatacenter\", DatacenterArgs.builder()\n            .location(\"de/txl\")\n            .description(\"Datacenter for testing Dataplatform Cluster\")\n            .build());\n\n        var exampleLan = new Lan(\"exampleLan\", LanArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .public_(false)\n            .build());\n\n        var exampleCluster = new Cluster(\"exampleCluster\", ClusterArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .maintenanceWindows(ClusterMaintenanceWindowArgs.builder()\n                .dayOfTheWeek(\"Sunday\")\n                .time(\"09:00:00\")\n                .build())\n            .version(\"23.11\")\n            .lans(ClusterLanArgs.builder()\n                .lanId(exampleLan.id())\n                .dhcp(false)\n                .routes(ClusterLanRouteArgs.builder()\n                    .network(\"182.168.42.1/24\")\n                    .gateway(\"192.168.42.1\")\n                    .build())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleDatacenter:\n    type: ionoscloud:compute:Datacenter\n    properties:\n      location: de/txl\n      description: Datacenter for testing Dataplatform Cluster\n  exampleLan:\n    type: ionoscloud:compute:Lan\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      public: false\n  exampleCluster:\n    type: ionoscloud:dsaas:Cluster\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      maintenanceWindows:\n        - dayOfTheWeek: Sunday\n          time: 09:00:00\n      version: '23.11'\n      lans:\n        - lanId: ${exampleLan.id}\n          dhcp: false\n          routes:\n            - network: 182.168.42.1/24\n              gateway: 192.168.42.1\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nResource Dataplatform Cluster can be imported using the `cluster_id`, e.g.\n\n```sh\n$ pulumi import ionoscloud:dsaas/cluster:Cluster mycluser {cluster uuid}\n```\n\n",
            "properties": {
                "datacenterId": {
                    "type": "string",
                    "description": "[string] The UUID of the virtual data center (VDC) the cluster is provisioned.\n"
                },
                "lans": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:dsaas/ClusterLan:ClusterLan"
                    },
                    "description": "[list] A list of LANs you want this node pool to be part of.\n"
                },
                "maintenanceWindows": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:dsaas/ClusterMaintenanceWindow:ClusterMaintenanceWindow"
                    },
                    "description": "[string] Starting time of a weekly 4 hour-long window, during which maintenance might occur in hh:mm:ss format\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of your cluster. Must be 63 characters or less and must be empty or begin and end with an alphanumeric character ([a-z0-9A-Z]). It can contain dashes (-), underscores (_), dots (.), and alphanumerics in-between.\n"
                },
                "version": {
                    "type": "string",
                    "description": "[int] The version of the Data Platform.\n"
                }
            },
            "required": [
                "datacenterId",
                "maintenanceWindows",
                "name",
                "version"
            ],
            "inputProperties": {
                "datacenterId": {
                    "type": "string",
                    "description": "[string] The UUID of the virtual data center (VDC) the cluster is provisioned.\n",
                    "willReplaceOnChanges": true
                },
                "lans": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:dsaas/ClusterLan:ClusterLan"
                    },
                    "description": "[list] A list of LANs you want this node pool to be part of.\n"
                },
                "maintenanceWindows": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:dsaas/ClusterMaintenanceWindow:ClusterMaintenanceWindow"
                    },
                    "description": "[string] Starting time of a weekly 4 hour-long window, during which maintenance might occur in hh:mm:ss format\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of your cluster. Must be 63 characters or less and must be empty or begin and end with an alphanumeric character ([a-z0-9A-Z]). It can contain dashes (-), underscores (_), dots (.), and alphanumerics in-between.\n"
                },
                "version": {
                    "type": "string",
                    "description": "[int] The version of the Data Platform.\n"
                }
            },
            "requiredInputs": [
                "datacenterId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Cluster resources.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "[string] The UUID of the virtual data center (VDC) the cluster is provisioned.\n",
                        "willReplaceOnChanges": true
                    },
                    "lans": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:dsaas/ClusterLan:ClusterLan"
                        },
                        "description": "[list] A list of LANs you want this node pool to be part of.\n"
                    },
                    "maintenanceWindows": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:dsaas/ClusterMaintenanceWindow:ClusterMaintenanceWindow"
                        },
                        "description": "[string] Starting time of a weekly 4 hour-long window, during which maintenance might occur in hh:mm:ss format\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] The name of your cluster. Must be 63 characters or less and must be empty or begin and end with an alphanumeric character ([a-z0-9A-Z]). It can contain dashes (-), underscores (_), dots (.), and alphanumerics in-between.\n"
                    },
                    "version": {
                        "type": "string",
                        "description": "[int] The version of the Data Platform.\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:dsaas/nodePool:NodePool": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst exampleDatacenter = new ionoscloud.compute.Datacenter(\"exampleDatacenter\", {\n    location: \"de/txl\",\n    description: \"Datacenter for testing Dataplatform Cluster\",\n});\nconst exampleCluster = new ionoscloud.dsaas.Cluster(\"exampleCluster\", {\n    datacenterId: exampleDatacenter.id,\n    maintenanceWindows: [{\n        dayOfTheWeek: \"Sunday\",\n        time: \"09:00:00\",\n    }],\n    version: \"23.7\",\n});\nconst exampleNodePool = new ionoscloud.dsaas.NodePool(\"exampleNodePool\", {\n    clusterId: exampleCluster.id,\n    nodeCount: 1,\n    cpuFamily: \"INTEL_SKYLAKE\",\n    coresCount: 1,\n    ramSize: 2048,\n    availabilityZone: \"AUTO\",\n    storageType: \"HDD\",\n    storageSize: 10,\n    maintenanceWindows: [{\n        dayOfTheWeek: \"Monday\",\n        time: \"09:00:00\",\n    }],\n    labels: {\n        foo: \"bar\",\n        color: \"green\",\n    },\n    annotations: {\n        ann1: \"value1\",\n        ann2: \"value2\",\n    },\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\nexample_datacenter = ionoscloud.compute.Datacenter(\"exampleDatacenter\",\n    location=\"de/txl\",\n    description=\"Datacenter for testing Dataplatform Cluster\")\nexample_cluster = ionoscloud.dsaas.Cluster(\"exampleCluster\",\n    datacenter_id=example_datacenter.id,\n    maintenance_windows=[{\n        \"day_of_the_week\": \"Sunday\",\n        \"time\": \"09:00:00\",\n    }],\n    version=\"23.7\")\nexample_node_pool = ionoscloud.dsaas.NodePool(\"exampleNodePool\",\n    cluster_id=example_cluster.id,\n    node_count=1,\n    cpu_family=\"INTEL_SKYLAKE\",\n    cores_count=1,\n    ram_size=2048,\n    availability_zone=\"AUTO\",\n    storage_type=\"HDD\",\n    storage_size=10,\n    maintenance_windows=[{\n        \"day_of_the_week\": \"Monday\",\n        \"time\": \"09:00:00\",\n    }],\n    labels={\n        \"foo\": \"bar\",\n        \"color\": \"green\",\n    },\n    annotations={\n        \"ann1\": \"value1\",\n        \"ann2\": \"value2\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleDatacenter = new Ionoscloud.Compute.Datacenter(\"exampleDatacenter\", new()\n    {\n        Location = \"de/txl\",\n        Description = \"Datacenter for testing Dataplatform Cluster\",\n    });\n\n    var exampleCluster = new Ionoscloud.Dsaas.Cluster(\"exampleCluster\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        MaintenanceWindows = new[]\n        {\n            new Ionoscloud.Dsaas.Inputs.ClusterMaintenanceWindowArgs\n            {\n                DayOfTheWeek = \"Sunday\",\n                Time = \"09:00:00\",\n            },\n        },\n        Version = \"23.7\",\n    });\n\n    var exampleNodePool = new Ionoscloud.Dsaas.NodePool(\"exampleNodePool\", new()\n    {\n        ClusterId = exampleCluster.Id,\n        NodeCount = 1,\n        CpuFamily = \"INTEL_SKYLAKE\",\n        CoresCount = 1,\n        RamSize = 2048,\n        AvailabilityZone = \"AUTO\",\n        StorageType = \"HDD\",\n        StorageSize = 10,\n        MaintenanceWindows = new[]\n        {\n            new Ionoscloud.Dsaas.Inputs.NodePoolMaintenanceWindowArgs\n            {\n                DayOfTheWeek = \"Monday\",\n                Time = \"09:00:00\",\n            },\n        },\n        Labels = \n        {\n            { \"foo\", \"bar\" },\n            { \"color\", \"green\" },\n        },\n        Annotations = \n        {\n            { \"ann1\", \"value1\" },\n            { \"ann2\", \"value2\" },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/dsaas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleDatacenter, err := compute.NewDatacenter(ctx, \"exampleDatacenter\", \u0026compute.DatacenterArgs{\n\t\t\tLocation:    pulumi.String(\"de/txl\"),\n\t\t\tDescription: pulumi.String(\"Datacenter for testing Dataplatform Cluster\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleCluster, err := dsaas.NewCluster(ctx, \"exampleCluster\", \u0026dsaas.ClusterArgs{\n\t\t\tDatacenterId: exampleDatacenter.ID(),\n\t\t\tMaintenanceWindows: dsaas.ClusterMaintenanceWindowArray{\n\t\t\t\t\u0026dsaas.ClusterMaintenanceWindowArgs{\n\t\t\t\t\tDayOfTheWeek: pulumi.String(\"Sunday\"),\n\t\t\t\t\tTime:         pulumi.String(\"09:00:00\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tVersion: pulumi.String(\"23.7\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = dsaas.NewNodePool(ctx, \"exampleNodePool\", \u0026dsaas.NodePoolArgs{\n\t\t\tClusterId:        exampleCluster.ID(),\n\t\t\tNodeCount:        pulumi.Int(1),\n\t\t\tCpuFamily:        pulumi.String(\"INTEL_SKYLAKE\"),\n\t\t\tCoresCount:       pulumi.Int(1),\n\t\t\tRamSize:          pulumi.Int(2048),\n\t\t\tAvailabilityZone: pulumi.String(\"AUTO\"),\n\t\t\tStorageType:      pulumi.String(\"HDD\"),\n\t\t\tStorageSize:      pulumi.Int(10),\n\t\t\tMaintenanceWindows: dsaas.NodePoolMaintenanceWindowArray{\n\t\t\t\t\u0026dsaas.NodePoolMaintenanceWindowArgs{\n\t\t\t\t\tDayOfTheWeek: pulumi.String(\"Monday\"),\n\t\t\t\t\tTime:         pulumi.String(\"09:00:00\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tLabels: pulumi.StringMap{\n\t\t\t\t\"foo\":   pulumi.String(\"bar\"),\n\t\t\t\t\"color\": pulumi.String(\"green\"),\n\t\t\t},\n\t\t\tAnnotations: pulumi.StringMap{\n\t\t\t\t\"ann1\": pulumi.String(\"value1\"),\n\t\t\t\t\"ann2\": pulumi.String(\"value2\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.Datacenter;\nimport com.pulumi.ionoscloud.compute.DatacenterArgs;\nimport com.pulumi.ionoscloud.dsaas.Cluster;\nimport com.pulumi.ionoscloud.dsaas.ClusterArgs;\nimport com.pulumi.ionoscloud.dsaas.inputs.ClusterMaintenanceWindowArgs;\nimport com.pulumi.ionoscloud.dsaas.NodePool;\nimport com.pulumi.ionoscloud.dsaas.NodePoolArgs;\nimport com.pulumi.ionoscloud.dsaas.inputs.NodePoolMaintenanceWindowArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleDatacenter = new Datacenter(\"exampleDatacenter\", DatacenterArgs.builder()\n            .location(\"de/txl\")\n            .description(\"Datacenter for testing Dataplatform Cluster\")\n            .build());\n\n        var exampleCluster = new Cluster(\"exampleCluster\", ClusterArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .maintenanceWindows(ClusterMaintenanceWindowArgs.builder()\n                .dayOfTheWeek(\"Sunday\")\n                .time(\"09:00:00\")\n                .build())\n            .version(\"23.7\")\n            .build());\n\n        var exampleNodePool = new NodePool(\"exampleNodePool\", NodePoolArgs.builder()\n            .clusterId(exampleCluster.id())\n            .nodeCount(1)\n            .cpuFamily(\"INTEL_SKYLAKE\")\n            .coresCount(1)\n            .ramSize(2048)\n            .availabilityZone(\"AUTO\")\n            .storageType(\"HDD\")\n            .storageSize(10)\n            .maintenanceWindows(NodePoolMaintenanceWindowArgs.builder()\n                .dayOfTheWeek(\"Monday\")\n                .time(\"09:00:00\")\n                .build())\n            .labels(Map.ofEntries(\n                Map.entry(\"foo\", \"bar\"),\n                Map.entry(\"color\", \"green\")\n            ))\n            .annotations(Map.ofEntries(\n                Map.entry(\"ann1\", \"value1\"),\n                Map.entry(\"ann2\", \"value2\")\n            ))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleDatacenter:\n    type: ionoscloud:compute:Datacenter\n    properties:\n      location: de/txl\n      description: Datacenter for testing Dataplatform Cluster\n  exampleCluster:\n    type: ionoscloud:dsaas:Cluster\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      maintenanceWindows:\n        - dayOfTheWeek: Sunday\n          time: 09:00:00\n      version: '23.7'\n  exampleNodePool:\n    type: ionoscloud:dsaas:NodePool\n    properties:\n      clusterId: ${exampleCluster.id}\n      nodeCount: 1\n      cpuFamily: INTEL_SKYLAKE\n      coresCount: 1\n      ramSize: 2048\n      availabilityZone: AUTO\n      storageType: HDD\n      storageSize: 10\n      maintenanceWindows:\n        - dayOfTheWeek: Monday\n          time: 09:00:00\n      labels:\n        foo: bar\n        color: green\n      annotations:\n        ann1: value1\n        ann2: value2\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nA Dataplatform Node Pool resource can be imported using its cluster's UUID as well as its own UUID, e.g.:\n\n```sh\n$ pulumi import ionoscloud:dsaas/nodePool:NodePool mynodepool {dataplatform_cluster_uuid}/{dataplatform_nodepool_id}\n```\n\n",
            "properties": {
                "annotations": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "[map] Key-value pairs attached to node pool resource as [Kubernetes annotations](https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/).\n"
                },
                "availabilityZone": {
                    "type": "string",
                    "description": "[string] The availability zone of the virtual datacenter region where the node pool resources should be provisioned. Must be set with one of the values `AUTO`, `ZONE_1` or `ZONE_2`. The default value is `AUTO`.\n"
                },
                "clusterId": {
                    "type": "string",
                    "description": "[string] The UUID of an existing Dataplatform cluster.\n"
                },
                "coresCount": {
                    "type": "integer",
                    "description": "[int] The number of CPU cores per node. Must be set with a minimum value of 1. The default value is `4`.\n"
                },
                "cpuFamily": {
                    "type": "string",
                    "description": "[string] A valid CPU family name or `AUTO` if the platform shall choose the best fitting option. Available CPU architectures can be retrieved from the datacenter resource. The default value is `AUTO`.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The UUID of the virtual data center (VDC) in which the nodepool is provisioned\n"
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "[map] Key-value pairs attached to the node pool resource as [Kubernetes labels](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/).\n"
                },
                "maintenanceWindows": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:dsaas/NodePoolMaintenanceWindow:NodePoolMaintenanceWindow"
                    },
                    "description": "[string] Starting time of a weekly 4 hour-long window, during which maintenance might occur in hh:mm:ss format\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of your node pool. Must be 63 characters or less and must be empty or begin and end with an alphanumeric character ([a-z0-9A-Z]). It can contain dashes (-), underscores (_), dots (.), and alphanumerics in-between.\n"
                },
                "nodeCount": {
                    "type": "integer",
                    "description": "[int] The number of nodes that make up the node pool. Must be set with a minimum value of 1.\n"
                },
                "ramSize": {
                    "type": "integer",
                    "description": "[int] The RAM size for one node in MB. Must be set in multiples of `1024`MB, with a minimum size is of `2048`MB. The default value is `4096`.\n"
                },
                "storageSize": {
                    "type": "integer",
                    "description": "[int] The size of the volume in GB. The size must be greater than `10`GB. The default value is `20`.\n"
                },
                "storageType": {
                    "type": "string",
                    "description": "[int] The type of hardware for the volume. Must be set with one of the values `HDD` or `SSD`. The default value is `SSD`.\n"
                },
                "version": {
                    "type": "string",
                    "description": "The version of the Data Platform.\n"
                }
            },
            "required": [
                "availabilityZone",
                "clusterId",
                "coresCount",
                "cpuFamily",
                "datacenterId",
                "maintenanceWindows",
                "name",
                "nodeCount",
                "ramSize",
                "storageSize",
                "storageType",
                "version"
            ],
            "inputProperties": {
                "annotations": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "[map] Key-value pairs attached to node pool resource as [Kubernetes annotations](https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/).\n"
                },
                "availabilityZone": {
                    "type": "string",
                    "description": "[string] The availability zone of the virtual datacenter region where the node pool resources should be provisioned. Must be set with one of the values `AUTO`, `ZONE_1` or `ZONE_2`. The default value is `AUTO`.\n",
                    "willReplaceOnChanges": true
                },
                "clusterId": {
                    "type": "string",
                    "description": "[string] The UUID of an existing Dataplatform cluster.\n"
                },
                "coresCount": {
                    "type": "integer",
                    "description": "[int] The number of CPU cores per node. Must be set with a minimum value of 1. The default value is `4`.\n",
                    "willReplaceOnChanges": true
                },
                "cpuFamily": {
                    "type": "string",
                    "description": "[string] A valid CPU family name or `AUTO` if the platform shall choose the best fitting option. Available CPU architectures can be retrieved from the datacenter resource. The default value is `AUTO`.\n",
                    "willReplaceOnChanges": true
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "[map] Key-value pairs attached to the node pool resource as [Kubernetes labels](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/).\n"
                },
                "maintenanceWindows": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:dsaas/NodePoolMaintenanceWindow:NodePoolMaintenanceWindow"
                    },
                    "description": "[string] Starting time of a weekly 4 hour-long window, during which maintenance might occur in hh:mm:ss format\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of your node pool. Must be 63 characters or less and must be empty or begin and end with an alphanumeric character ([a-z0-9A-Z]). It can contain dashes (-), underscores (_), dots (.), and alphanumerics in-between.\n",
                    "willReplaceOnChanges": true
                },
                "nodeCount": {
                    "type": "integer",
                    "description": "[int] The number of nodes that make up the node pool. Must be set with a minimum value of 1.\n"
                },
                "ramSize": {
                    "type": "integer",
                    "description": "[int] The RAM size for one node in MB. Must be set in multiples of `1024`MB, with a minimum size is of `2048`MB. The default value is `4096`.\n",
                    "willReplaceOnChanges": true
                },
                "storageSize": {
                    "type": "integer",
                    "description": "[int] The size of the volume in GB. The size must be greater than `10`GB. The default value is `20`.\n",
                    "willReplaceOnChanges": true
                },
                "storageType": {
                    "type": "string",
                    "description": "[int] The type of hardware for the volume. Must be set with one of the values `HDD` or `SSD`. The default value is `SSD`.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "clusterId",
                "nodeCount"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NodePool resources.\n",
                "properties": {
                    "annotations": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "[map] Key-value pairs attached to node pool resource as [Kubernetes annotations](https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/).\n"
                    },
                    "availabilityZone": {
                        "type": "string",
                        "description": "[string] The availability zone of the virtual datacenter region where the node pool resources should be provisioned. Must be set with one of the values `AUTO`, `ZONE_1` or `ZONE_2`. The default value is `AUTO`.\n",
                        "willReplaceOnChanges": true
                    },
                    "clusterId": {
                        "type": "string",
                        "description": "[string] The UUID of an existing Dataplatform cluster.\n"
                    },
                    "coresCount": {
                        "type": "integer",
                        "description": "[int] The number of CPU cores per node. Must be set with a minimum value of 1. The default value is `4`.\n",
                        "willReplaceOnChanges": true
                    },
                    "cpuFamily": {
                        "type": "string",
                        "description": "[string] A valid CPU family name or `AUTO` if the platform shall choose the best fitting option. Available CPU architectures can be retrieved from the datacenter resource. The default value is `AUTO`.\n",
                        "willReplaceOnChanges": true
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "The UUID of the virtual data center (VDC) in which the nodepool is provisioned\n"
                    },
                    "labels": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "[map] Key-value pairs attached to the node pool resource as [Kubernetes labels](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/).\n"
                    },
                    "maintenanceWindows": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:dsaas/NodePoolMaintenanceWindow:NodePoolMaintenanceWindow"
                        },
                        "description": "[string] Starting time of a weekly 4 hour-long window, during which maintenance might occur in hh:mm:ss format\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] The name of your node pool. Must be 63 characters or less and must be empty or begin and end with an alphanumeric character ([a-z0-9A-Z]). It can contain dashes (-), underscores (_), dots (.), and alphanumerics in-between.\n",
                        "willReplaceOnChanges": true
                    },
                    "nodeCount": {
                        "type": "integer",
                        "description": "[int] The number of nodes that make up the node pool. Must be set with a minimum value of 1.\n"
                    },
                    "ramSize": {
                        "type": "integer",
                        "description": "[int] The RAM size for one node in MB. Must be set in multiples of `1024`MB, with a minimum size is of `2048`MB. The default value is `4096`.\n",
                        "willReplaceOnChanges": true
                    },
                    "storageSize": {
                        "type": "integer",
                        "description": "[int] The size of the volume in GB. The size must be greater than `10`GB. The default value is `20`.\n",
                        "willReplaceOnChanges": true
                    },
                    "storageType": {
                        "type": "string",
                        "description": "[int] The type of hardware for the volume. Must be set with one of the values `HDD` or `SSD`. The default value is `SSD`.\n",
                        "willReplaceOnChanges": true
                    },
                    "version": {
                        "type": "string",
                        "description": "The version of the Data Platform.\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:k8s/cluster:Cluster": {
            "description": "Manages a **Managed Kubernetes Cluster** on IonosCloud.\n\n## Example Usage\n\n### Public cluster\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = new ionoscloud.k8s.Cluster(\"example\", {\n    apiSubnetAllowLists: [\"1.2.3.4/32\"],\n    k8sVersion: \"1.28.6\",\n    maintenanceWindow: {\n        dayOfTheWeek: \"Sunday\",\n        time: \"09:00:00Z\",\n    },\n    s3Buckets: [{\n        name: \"globally_unique_bucket_name\",\n    }],\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\nexample = ionoscloud.k8s.Cluster(\"example\",\n    api_subnet_allow_lists=[\"1.2.3.4/32\"],\n    k8s_version=\"1.28.6\",\n    maintenance_window={\n        \"day_of_the_week\": \"Sunday\",\n        \"time\": \"09:00:00Z\",\n    },\n    s3_buckets=[{\n        \"name\": \"globally_unique_bucket_name\",\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Ionoscloud.K8s.Cluster(\"example\", new()\n    {\n        ApiSubnetAllowLists = new[]\n        {\n            \"1.2.3.4/32\",\n        },\n        K8sVersion = \"1.28.6\",\n        MaintenanceWindow = new Ionoscloud.K8s.Inputs.ClusterMaintenanceWindowArgs\n        {\n            DayOfTheWeek = \"Sunday\",\n            Time = \"09:00:00Z\",\n        },\n        S3Buckets = new[]\n        {\n            new Ionoscloud.K8s.Inputs.ClusterS3BucketArgs\n            {\n                Name = \"globally_unique_bucket_name\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/k8s\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := k8s.NewCluster(ctx, \"example\", \u0026k8s.ClusterArgs{\n\t\t\tApiSubnetAllowLists: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"1.2.3.4/32\"),\n\t\t\t},\n\t\t\tK8sVersion: pulumi.String(\"1.28.6\"),\n\t\t\tMaintenanceWindow: \u0026k8s.ClusterMaintenanceWindowArgs{\n\t\t\t\tDayOfTheWeek: pulumi.String(\"Sunday\"),\n\t\t\t\tTime:         pulumi.String(\"09:00:00Z\"),\n\t\t\t},\n\t\t\tS3Buckets: k8s.ClusterS3BucketArray{\n\t\t\t\t\u0026k8s.ClusterS3BucketArgs{\n\t\t\t\t\tName: pulumi.String(\"globally_unique_bucket_name\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.k8s.Cluster;\nimport com.pulumi.ionoscloud.k8s.ClusterArgs;\nimport com.pulumi.ionoscloud.k8s.inputs.ClusterMaintenanceWindowArgs;\nimport com.pulumi.ionoscloud.k8s.inputs.ClusterS3BucketArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new Cluster(\"example\", ClusterArgs.builder()\n            .apiSubnetAllowLists(\"1.2.3.4/32\")\n            .k8sVersion(\"1.28.6\")\n            .maintenanceWindow(ClusterMaintenanceWindowArgs.builder()\n                .dayOfTheWeek(\"Sunday\")\n                .time(\"09:00:00Z\")\n                .build())\n            .s3Buckets(ClusterS3BucketArgs.builder()\n                .name(\"globally_unique_bucket_name\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: ionoscloud:k8s:Cluster\n    properties:\n      apiSubnetAllowLists:\n        - 1.2.3.4/32\n      k8sVersion: 1.28.6\n      maintenanceWindow:\n        dayOfTheWeek: Sunday\n        time: 09:00:00Z\n      s3Buckets:\n        - name: globally_unique_bucket_name\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Private Cluster\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst testdatacenter = new ionoscloud.compute.Datacenter(\"testdatacenter\", {\n    location: \"de/fra\",\n    description: \"Test datacenter\",\n});\nconst k8sip = new ionoscloud.compute.IPBlock(\"k8sip\", {\n    location: \"de/fra\",\n    size: 1,\n});\nconst example = new ionoscloud.k8s.Cluster(\"example\", {\n    k8sVersion: \"1.28.6\",\n    maintenanceWindow: {\n        dayOfTheWeek: \"Sunday\",\n        time: \"09:00:00Z\",\n    },\n    apiSubnetAllowLists: [\"1.2.3.4/32\"],\n    s3Buckets: [{\n        name: \"globally_unique_bucket_name\",\n    }],\n    location: \"de/fra\",\n    natGatewayIp: k8sip.ips[0],\n    nodeSubnet: \"192.168.0.0/16\",\n    \"public\": false,\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\ntestdatacenter = ionoscloud.compute.Datacenter(\"testdatacenter\",\n    location=\"de/fra\",\n    description=\"Test datacenter\")\nk8sip = ionoscloud.compute.IPBlock(\"k8sip\",\n    location=\"de/fra\",\n    size=1)\nexample = ionoscloud.k8s.Cluster(\"example\",\n    k8s_version=\"1.28.6\",\n    maintenance_window={\n        \"day_of_the_week\": \"Sunday\",\n        \"time\": \"09:00:00Z\",\n    },\n    api_subnet_allow_lists=[\"1.2.3.4/32\"],\n    s3_buckets=[{\n        \"name\": \"globally_unique_bucket_name\",\n    }],\n    location=\"de/fra\",\n    nat_gateway_ip=k8sip.ips[0],\n    node_subnet=\"192.168.0.0/16\",\n    public=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testdatacenter = new Ionoscloud.Compute.Datacenter(\"testdatacenter\", new()\n    {\n        Location = \"de/fra\",\n        Description = \"Test datacenter\",\n    });\n\n    var k8sip = new Ionoscloud.Compute.IPBlock(\"k8sip\", new()\n    {\n        Location = \"de/fra\",\n        Size = 1,\n    });\n\n    var example = new Ionoscloud.K8s.Cluster(\"example\", new()\n    {\n        K8sVersion = \"1.28.6\",\n        MaintenanceWindow = new Ionoscloud.K8s.Inputs.ClusterMaintenanceWindowArgs\n        {\n            DayOfTheWeek = \"Sunday\",\n            Time = \"09:00:00Z\",\n        },\n        ApiSubnetAllowLists = new[]\n        {\n            \"1.2.3.4/32\",\n        },\n        S3Buckets = new[]\n        {\n            new Ionoscloud.K8s.Inputs.ClusterS3BucketArgs\n            {\n                Name = \"globally_unique_bucket_name\",\n            },\n        },\n        Location = \"de/fra\",\n        NatGatewayIp = k8sip.Ips.Apply(ips =\u003e ips[0]),\n        NodeSubnet = \"192.168.0.0/16\",\n        Public = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/k8s\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := compute.NewDatacenter(ctx, \"testdatacenter\", \u0026compute.DatacenterArgs{\n\t\t\tLocation:    pulumi.String(\"de/fra\"),\n\t\t\tDescription: pulumi.String(\"Test datacenter\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tk8sip, err := compute.NewIPBlock(ctx, \"k8sip\", \u0026compute.IPBlockArgs{\n\t\t\tLocation: pulumi.String(\"de/fra\"),\n\t\t\tSize:     pulumi.Int(1),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = k8s.NewCluster(ctx, \"example\", \u0026k8s.ClusterArgs{\n\t\t\tK8sVersion: pulumi.String(\"1.28.6\"),\n\t\t\tMaintenanceWindow: \u0026k8s.ClusterMaintenanceWindowArgs{\n\t\t\t\tDayOfTheWeek: pulumi.String(\"Sunday\"),\n\t\t\t\tTime:         pulumi.String(\"09:00:00Z\"),\n\t\t\t},\n\t\t\tApiSubnetAllowLists: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"1.2.3.4/32\"),\n\t\t\t},\n\t\t\tS3Buckets: k8s.ClusterS3BucketArray{\n\t\t\t\t\u0026k8s.ClusterS3BucketArgs{\n\t\t\t\t\tName: pulumi.String(\"globally_unique_bucket_name\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tLocation: pulumi.String(\"de/fra\"),\n\t\t\tNatGatewayIp: k8sip.Ips.ApplyT(func(ips []string) (string, error) {\n\t\t\t\treturn ips[0], nil\n\t\t\t}).(pulumi.StringOutput),\n\t\t\tNodeSubnet: pulumi.String(\"192.168.0.0/16\"),\n\t\t\tPublic:     pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.Datacenter;\nimport com.pulumi.ionoscloud.compute.DatacenterArgs;\nimport com.pulumi.ionoscloud.compute.IPBlock;\nimport com.pulumi.ionoscloud.compute.IPBlockArgs;\nimport com.pulumi.ionoscloud.k8s.Cluster;\nimport com.pulumi.ionoscloud.k8s.ClusterArgs;\nimport com.pulumi.ionoscloud.k8s.inputs.ClusterMaintenanceWindowArgs;\nimport com.pulumi.ionoscloud.k8s.inputs.ClusterS3BucketArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testdatacenter = new Datacenter(\"testdatacenter\", DatacenterArgs.builder()\n            .location(\"de/fra\")\n            .description(\"Test datacenter\")\n            .build());\n\n        var k8sip = new IPBlock(\"k8sip\", IPBlockArgs.builder()\n            .location(\"de/fra\")\n            .size(1)\n            .build());\n\n        var example = new Cluster(\"example\", ClusterArgs.builder()\n            .k8sVersion(\"1.28.6\")\n            .maintenanceWindow(ClusterMaintenanceWindowArgs.builder()\n                .dayOfTheWeek(\"Sunday\")\n                .time(\"09:00:00Z\")\n                .build())\n            .apiSubnetAllowLists(\"1.2.3.4/32\")\n            .s3Buckets(ClusterS3BucketArgs.builder()\n                .name(\"globally_unique_bucket_name\")\n                .build())\n            .location(\"de/fra\")\n            .natGatewayIp(k8sip.ips().applyValue(ips -\u003e ips[0]))\n            .nodeSubnet(\"192.168.0.0/16\")\n            .public_(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testdatacenter:\n    type: ionoscloud:compute:Datacenter\n    properties:\n      location: de/fra\n      description: Test datacenter\n  k8sip:\n    type: ionoscloud:compute:IPBlock\n    properties:\n      location: de/fra\n      size: 1\n  example:\n    type: ionoscloud:k8s:Cluster\n    properties:\n      k8sVersion: 1.28.6\n      maintenanceWindow:\n        dayOfTheWeek: Sunday\n        time: 09:00:00Z\n      apiSubnetAllowLists:\n        - 1.2.3.4/32\n      s3Buckets:\n        - name: globally_unique_bucket_name\n      location: de/fra\n      natGatewayIp: ${k8sip.ips[0]}\n      nodeSubnet: 192.168.0.0/16\n      public: false\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nA Kubernetes Cluster resource can be imported using its `resource id`, e.g.\n\n```sh\n$ pulumi import ionoscloud:k8s/cluster:Cluster demo {k8s_cluster uuid}\n```\n\nThis can be helpful when you want to import kubernetes clusters which you have already created manually or using other means, outside of terraform.\n\n⚠️ **_Warning: **During a maintenance window, k8s can update your `k8s_version` if the old one reaches end of life. This upgrade will not be shown in the plan, as we prevent\n\nterraform from doing a downgrade, as downgrading `k8s_version` is not supported._**\n\n",
            "properties": {
                "allowReplace": {
                    "type": "boolean",
                    "description": "[bool] When set to true, allows the update of immutable fields by first destroying and then re-creating the cluster.\n\n⚠️ **_Warning: `allow_replace` - lets you update immutable fields, but it first destroys and then re-creates the cluster in order to do it. Set the field to true only if you know what you are doing._**\n"
                },
                "apiSubnetAllowLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] Access to the K8s API server is restricted to these CIDRs. Cluster-internal traffic is not affected by this restriction. If no allowlist is specified, access is not restricted. If an IP without subnet mask is provided, the default value will be used: 32 for IPv4 and 128 for IPv6.\n"
                },
                "k8sVersion": {
                    "type": "string",
                    "description": "[string] The desired Kubernetes Version. For supported values, please check the API documentation. Downgrades are not supported. The provider will ignore downgrades of patch level.\n"
                },
                "location": {
                    "type": "string",
                    "description": "[string] This attribute is mandatory if the cluster is private. The location must be enabled for your contract, or you must have a data center at that location. This property is not adjustable.\n"
                },
                "maintenanceWindow": {
                    "$ref": "#/types/ionoscloud:k8s/ClusterMaintenanceWindow:ClusterMaintenanceWindow",
                    "description": "A maintenance window comprise of a day of the week and a time for maintenance to be allowed\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the Kubernetes Cluster.\n"
                },
                "natGatewayIp": {
                    "type": "string",
                    "description": "[string] The NAT gateway IP of the cluster if the cluster is private. This attribute is immutable. Must be a reserved IP in the same location as the cluster's location. This attribute is mandatory if the cluster is private.\n"
                },
                "nodeSubnet": {
                    "type": "string",
                    "description": "[string] The node subnet of the cluster, if the cluster is private. This attribute is optional and immutable. Must be a valid CIDR notation for an IPv4 network prefix of 16 bits length.\n"
                },
                "public": {
                    "type": "boolean",
                    "description": "[boolean] Indicates if the cluster is public or private. This attribute is immutable.\n"
                },
                "s3Buckets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:k8s/ClusterS3Bucket:ClusterS3Bucket"
                    },
                    "description": "[list] List of IONOS Object Storage buckets configured for K8s usage. For now it contains only an IONOS Object Storage bucket used to store K8s API audit logs.\n"
                },
                "viableNodePoolVersions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] List of versions that may be used for node pools under this cluster\n"
                }
            },
            "required": [
                "k8sVersion",
                "maintenanceWindow",
                "name",
                "nodeSubnet",
                "viableNodePoolVersions"
            ],
            "inputProperties": {
                "allowReplace": {
                    "type": "boolean",
                    "description": "[bool] When set to true, allows the update of immutable fields by first destroying and then re-creating the cluster.\n\n⚠️ **_Warning: `allow_replace` - lets you update immutable fields, but it first destroys and then re-creates the cluster in order to do it. Set the field to true only if you know what you are doing._**\n"
                },
                "apiSubnetAllowLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] Access to the K8s API server is restricted to these CIDRs. Cluster-internal traffic is not affected by this restriction. If no allowlist is specified, access is not restricted. If an IP without subnet mask is provided, the default value will be used: 32 for IPv4 and 128 for IPv6.\n"
                },
                "k8sVersion": {
                    "type": "string",
                    "description": "[string] The desired Kubernetes Version. For supported values, please check the API documentation. Downgrades are not supported. The provider will ignore downgrades of patch level.\n"
                },
                "location": {
                    "type": "string",
                    "description": "[string] This attribute is mandatory if the cluster is private. The location must be enabled for your contract, or you must have a data center at that location. This property is not adjustable.\n",
                    "willReplaceOnChanges": true
                },
                "maintenanceWindow": {
                    "$ref": "#/types/ionoscloud:k8s/ClusterMaintenanceWindow:ClusterMaintenanceWindow",
                    "description": "A maintenance window comprise of a day of the week and a time for maintenance to be allowed\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the Kubernetes Cluster.\n"
                },
                "natGatewayIp": {
                    "type": "string",
                    "description": "[string] The NAT gateway IP of the cluster if the cluster is private. This attribute is immutable. Must be a reserved IP in the same location as the cluster's location. This attribute is mandatory if the cluster is private.\n",
                    "willReplaceOnChanges": true
                },
                "nodeSubnet": {
                    "type": "string",
                    "description": "[string] The node subnet of the cluster, if the cluster is private. This attribute is optional and immutable. Must be a valid CIDR notation for an IPv4 network prefix of 16 bits length.\n",
                    "willReplaceOnChanges": true
                },
                "public": {
                    "type": "boolean",
                    "description": "[boolean] Indicates if the cluster is public or private. This attribute is immutable.\n",
                    "willReplaceOnChanges": true
                },
                "s3Buckets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:k8s/ClusterS3Bucket:ClusterS3Bucket"
                    },
                    "description": "[list] List of IONOS Object Storage buckets configured for K8s usage. For now it contains only an IONOS Object Storage bucket used to store K8s API audit logs.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Cluster resources.\n",
                "properties": {
                    "allowReplace": {
                        "type": "boolean",
                        "description": "[bool] When set to true, allows the update of immutable fields by first destroying and then re-creating the cluster.\n\n⚠️ **_Warning: `allow_replace` - lets you update immutable fields, but it first destroys and then re-creates the cluster in order to do it. Set the field to true only if you know what you are doing._**\n"
                    },
                    "apiSubnetAllowLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "[list] Access to the K8s API server is restricted to these CIDRs. Cluster-internal traffic is not affected by this restriction. If no allowlist is specified, access is not restricted. If an IP without subnet mask is provided, the default value will be used: 32 for IPv4 and 128 for IPv6.\n"
                    },
                    "k8sVersion": {
                        "type": "string",
                        "description": "[string] The desired Kubernetes Version. For supported values, please check the API documentation. Downgrades are not supported. The provider will ignore downgrades of patch level.\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "[string] This attribute is mandatory if the cluster is private. The location must be enabled for your contract, or you must have a data center at that location. This property is not adjustable.\n",
                        "willReplaceOnChanges": true
                    },
                    "maintenanceWindow": {
                        "$ref": "#/types/ionoscloud:k8s/ClusterMaintenanceWindow:ClusterMaintenanceWindow",
                        "description": "A maintenance window comprise of a day of the week and a time for maintenance to be allowed\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] The name of the Kubernetes Cluster.\n"
                    },
                    "natGatewayIp": {
                        "type": "string",
                        "description": "[string] The NAT gateway IP of the cluster if the cluster is private. This attribute is immutable. Must be a reserved IP in the same location as the cluster's location. This attribute is mandatory if the cluster is private.\n",
                        "willReplaceOnChanges": true
                    },
                    "nodeSubnet": {
                        "type": "string",
                        "description": "[string] The node subnet of the cluster, if the cluster is private. This attribute is optional and immutable. Must be a valid CIDR notation for an IPv4 network prefix of 16 bits length.\n",
                        "willReplaceOnChanges": true
                    },
                    "public": {
                        "type": "boolean",
                        "description": "[boolean] Indicates if the cluster is public or private. This attribute is immutable.\n",
                        "willReplaceOnChanges": true
                    },
                    "s3Buckets": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:k8s/ClusterS3Bucket:ClusterS3Bucket"
                        },
                        "description": "[list] List of IONOS Object Storage buckets configured for K8s usage. For now it contains only an IONOS Object Storage bucket used to store K8s API audit logs.\n"
                    },
                    "viableNodePoolVersions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "[list] List of versions that may be used for node pools under this cluster\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:k8s/nodePool:NodePool": {
            "description": "Manages a **Managed Kubernetes Node Pool**, part of a managed Kubernetes cluster on IonosCloud.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst exampleDatacenter = new ionoscloud.compute.Datacenter(\"exampleDatacenter\", {\n    location: \"us/las\",\n    description: \"datacenter description\",\n    secAuthProtection: false,\n});\nconst exampleLan = new ionoscloud.compute.Lan(\"exampleLan\", {\n    datacenterId: exampleDatacenter.id,\n    \"public\": false,\n});\nconst exampleIPBlock = new ionoscloud.compute.IPBlock(\"exampleIPBlock\", {\n    location: \"us/las\",\n    size: 3,\n});\nconst exampleCluster = new ionoscloud.k8s.Cluster(\"exampleCluster\", {\n    k8sVersion: \"1.28.6\",\n    maintenanceWindow: {\n        dayOfTheWeek: \"Sunday\",\n        time: \"09:00:00Z\",\n    },\n    apiSubnetAllowLists: [\"1.2.3.4/32\"],\n    s3Buckets: [{\n        name: \"globally_unique_s3_bucket_name\",\n    }],\n});\nconst exampleNodePool = new ionoscloud.k8s.NodePool(\"exampleNodePool\", {\n    datacenterId: exampleDatacenter.id,\n    k8sClusterId: exampleCluster.id,\n    k8sVersion: exampleCluster.k8sVersion,\n    maintenanceWindow: {\n        dayOfTheWeek: \"Monday\",\n        time: \"09:00:00Z\",\n    },\n    autoScaling: {\n        minNodeCount: 1,\n        maxNodeCount: 2,\n    },\n    cpuFamily: \"INTEL_XEON\",\n    availabilityZone: \"AUTO\",\n    storageType: \"SSD\",\n    nodeCount: 1,\n    coresCount: 2,\n    ramSize: 2048,\n    storageSize: 40,\n    publicIps: [\n        exampleIPBlock.ips[0],\n        exampleIPBlock.ips[1],\n        exampleIPBlock.ips[2],\n    ],\n    lans: [{\n        id: exampleLan.id,\n        dhcp: true,\n        routes: [{\n            network: \"1.2.3.5/24\",\n            gatewayIp: \"10.1.5.17\",\n        }],\n    }],\n    labels: {\n        lab1: \"value1\",\n        lab2: \"value2\",\n    },\n    annotations: {\n        ann1: \"value1\",\n        ann2: \"value2\",\n    },\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\nexample_datacenter = ionoscloud.compute.Datacenter(\"exampleDatacenter\",\n    location=\"us/las\",\n    description=\"datacenter description\",\n    sec_auth_protection=False)\nexample_lan = ionoscloud.compute.Lan(\"exampleLan\",\n    datacenter_id=example_datacenter.id,\n    public=False)\nexample_ip_block = ionoscloud.compute.IPBlock(\"exampleIPBlock\",\n    location=\"us/las\",\n    size=3)\nexample_cluster = ionoscloud.k8s.Cluster(\"exampleCluster\",\n    k8s_version=\"1.28.6\",\n    maintenance_window={\n        \"day_of_the_week\": \"Sunday\",\n        \"time\": \"09:00:00Z\",\n    },\n    api_subnet_allow_lists=[\"1.2.3.4/32\"],\n    s3_buckets=[{\n        \"name\": \"globally_unique_s3_bucket_name\",\n    }])\nexample_node_pool = ionoscloud.k8s.NodePool(\"exampleNodePool\",\n    datacenter_id=example_datacenter.id,\n    k8s_cluster_id=example_cluster.id,\n    k8s_version=example_cluster.k8s_version,\n    maintenance_window={\n        \"day_of_the_week\": \"Monday\",\n        \"time\": \"09:00:00Z\",\n    },\n    auto_scaling={\n        \"min_node_count\": 1,\n        \"max_node_count\": 2,\n    },\n    cpu_family=\"INTEL_XEON\",\n    availability_zone=\"AUTO\",\n    storage_type=\"SSD\",\n    node_count=1,\n    cores_count=2,\n    ram_size=2048,\n    storage_size=40,\n    public_ips=[\n        example_ip_block.ips[0],\n        example_ip_block.ips[1],\n        example_ip_block.ips[2],\n    ],\n    lans=[{\n        \"id\": example_lan.id,\n        \"dhcp\": True,\n        \"routes\": [{\n            \"network\": \"1.2.3.5/24\",\n            \"gateway_ip\": \"10.1.5.17\",\n        }],\n    }],\n    labels={\n        \"lab1\": \"value1\",\n        \"lab2\": \"value2\",\n    },\n    annotations={\n        \"ann1\": \"value1\",\n        \"ann2\": \"value2\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleDatacenter = new Ionoscloud.Compute.Datacenter(\"exampleDatacenter\", new()\n    {\n        Location = \"us/las\",\n        Description = \"datacenter description\",\n        SecAuthProtection = false,\n    });\n\n    var exampleLan = new Ionoscloud.Compute.Lan(\"exampleLan\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        Public = false,\n    });\n\n    var exampleIPBlock = new Ionoscloud.Compute.IPBlock(\"exampleIPBlock\", new()\n    {\n        Location = \"us/las\",\n        Size = 3,\n    });\n\n    var exampleCluster = new Ionoscloud.K8s.Cluster(\"exampleCluster\", new()\n    {\n        K8sVersion = \"1.28.6\",\n        MaintenanceWindow = new Ionoscloud.K8s.Inputs.ClusterMaintenanceWindowArgs\n        {\n            DayOfTheWeek = \"Sunday\",\n            Time = \"09:00:00Z\",\n        },\n        ApiSubnetAllowLists = new[]\n        {\n            \"1.2.3.4/32\",\n        },\n        S3Buckets = new[]\n        {\n            new Ionoscloud.K8s.Inputs.ClusterS3BucketArgs\n            {\n                Name = \"globally_unique_s3_bucket_name\",\n            },\n        },\n    });\n\n    var exampleNodePool = new Ionoscloud.K8s.NodePool(\"exampleNodePool\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        K8sClusterId = exampleCluster.Id,\n        K8sVersion = exampleCluster.K8sVersion,\n        MaintenanceWindow = new Ionoscloud.K8s.Inputs.NodePoolMaintenanceWindowArgs\n        {\n            DayOfTheWeek = \"Monday\",\n            Time = \"09:00:00Z\",\n        },\n        AutoScaling = new Ionoscloud.K8s.Inputs.NodePoolAutoScalingArgs\n        {\n            MinNodeCount = 1,\n            MaxNodeCount = 2,\n        },\n        CpuFamily = \"INTEL_XEON\",\n        AvailabilityZone = \"AUTO\",\n        StorageType = \"SSD\",\n        NodeCount = 1,\n        CoresCount = 2,\n        RamSize = 2048,\n        StorageSize = 40,\n        PublicIps = new[]\n        {\n            exampleIPBlock.Ips.Apply(ips =\u003e ips[0]),\n            exampleIPBlock.Ips.Apply(ips =\u003e ips[1]),\n            exampleIPBlock.Ips.Apply(ips =\u003e ips[2]),\n        },\n        Lans = new[]\n        {\n            new Ionoscloud.K8s.Inputs.NodePoolLanArgs\n            {\n                Id = exampleLan.Id,\n                Dhcp = true,\n                Routes = new[]\n                {\n                    new Ionoscloud.K8s.Inputs.NodePoolLanRouteArgs\n                    {\n                        Network = \"1.2.3.5/24\",\n                        GatewayIp = \"10.1.5.17\",\n                    },\n                },\n            },\n        },\n        Labels = \n        {\n            { \"lab1\", \"value1\" },\n            { \"lab2\", \"value2\" },\n        },\n        Annotations = \n        {\n            { \"ann1\", \"value1\" },\n            { \"ann2\", \"value2\" },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/k8s\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleDatacenter, err := compute.NewDatacenter(ctx, \"exampleDatacenter\", \u0026compute.DatacenterArgs{\n\t\t\tLocation:          pulumi.String(\"us/las\"),\n\t\t\tDescription:       pulumi.String(\"datacenter description\"),\n\t\t\tSecAuthProtection: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleLan, err := compute.NewLan(ctx, \"exampleLan\", \u0026compute.LanArgs{\n\t\t\tDatacenterId: exampleDatacenter.ID(),\n\t\t\tPublic:       pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleIPBlock, err := compute.NewIPBlock(ctx, \"exampleIPBlock\", \u0026compute.IPBlockArgs{\n\t\t\tLocation: pulumi.String(\"us/las\"),\n\t\t\tSize:     pulumi.Int(3),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleCluster, err := k8s.NewCluster(ctx, \"exampleCluster\", \u0026k8s.ClusterArgs{\n\t\t\tK8sVersion: pulumi.String(\"1.28.6\"),\n\t\t\tMaintenanceWindow: \u0026k8s.ClusterMaintenanceWindowArgs{\n\t\t\t\tDayOfTheWeek: pulumi.String(\"Sunday\"),\n\t\t\t\tTime:         pulumi.String(\"09:00:00Z\"),\n\t\t\t},\n\t\t\tApiSubnetAllowLists: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"1.2.3.4/32\"),\n\t\t\t},\n\t\t\tS3Buckets: k8s.ClusterS3BucketArray{\n\t\t\t\t\u0026k8s.ClusterS3BucketArgs{\n\t\t\t\t\tName: pulumi.String(\"globally_unique_s3_bucket_name\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = k8s.NewNodePool(ctx, \"exampleNodePool\", \u0026k8s.NodePoolArgs{\n\t\t\tDatacenterId: exampleDatacenter.ID(),\n\t\t\tK8sClusterId: exampleCluster.ID(),\n\t\t\tK8sVersion:   exampleCluster.K8sVersion,\n\t\t\tMaintenanceWindow: \u0026k8s.NodePoolMaintenanceWindowArgs{\n\t\t\t\tDayOfTheWeek: pulumi.String(\"Monday\"),\n\t\t\t\tTime:         pulumi.String(\"09:00:00Z\"),\n\t\t\t},\n\t\t\tAutoScaling: \u0026k8s.NodePoolAutoScalingArgs{\n\t\t\t\tMinNodeCount: pulumi.Int(1),\n\t\t\t\tMaxNodeCount: pulumi.Int(2),\n\t\t\t},\n\t\t\tCpuFamily:        pulumi.String(\"INTEL_XEON\"),\n\t\t\tAvailabilityZone: pulumi.String(\"AUTO\"),\n\t\t\tStorageType:      pulumi.String(\"SSD\"),\n\t\t\tNodeCount:        pulumi.Int(1),\n\t\t\tCoresCount:       pulumi.Int(2),\n\t\t\tRamSize:          pulumi.Int(2048),\n\t\t\tStorageSize:      pulumi.Int(40),\n\t\t\tPublicIps: pulumi.StringArray{\n\t\t\t\texampleIPBlock.Ips.ApplyT(func(ips []string) (string, error) {\n\t\t\t\t\treturn ips[0], nil\n\t\t\t\t}).(pulumi.StringOutput),\n\t\t\t\texampleIPBlock.Ips.ApplyT(func(ips []string) (string, error) {\n\t\t\t\t\treturn ips[1], nil\n\t\t\t\t}).(pulumi.StringOutput),\n\t\t\t\texampleIPBlock.Ips.ApplyT(func(ips []string) (string, error) {\n\t\t\t\t\treturn ips[2], nil\n\t\t\t\t}).(pulumi.StringOutput),\n\t\t\t},\n\t\t\tLans: k8s.NodePoolLanArray{\n\t\t\t\t\u0026k8s.NodePoolLanArgs{\n\t\t\t\t\tId:   exampleLan.ID(),\n\t\t\t\t\tDhcp: pulumi.Bool(true),\n\t\t\t\t\tRoutes: k8s.NodePoolLanRouteArray{\n\t\t\t\t\t\t\u0026k8s.NodePoolLanRouteArgs{\n\t\t\t\t\t\t\tNetwork:   pulumi.String(\"1.2.3.5/24\"),\n\t\t\t\t\t\t\tGatewayIp: pulumi.String(\"10.1.5.17\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tLabels: pulumi.StringMap{\n\t\t\t\t\"lab1\": pulumi.String(\"value1\"),\n\t\t\t\t\"lab2\": pulumi.String(\"value2\"),\n\t\t\t},\n\t\t\tAnnotations: pulumi.StringMap{\n\t\t\t\t\"ann1\": pulumi.String(\"value1\"),\n\t\t\t\t\"ann2\": pulumi.String(\"value2\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.Datacenter;\nimport com.pulumi.ionoscloud.compute.DatacenterArgs;\nimport com.pulumi.ionoscloud.compute.Lan;\nimport com.pulumi.ionoscloud.compute.LanArgs;\nimport com.pulumi.ionoscloud.compute.IPBlock;\nimport com.pulumi.ionoscloud.compute.IPBlockArgs;\nimport com.pulumi.ionoscloud.k8s.Cluster;\nimport com.pulumi.ionoscloud.k8s.ClusterArgs;\nimport com.pulumi.ionoscloud.k8s.inputs.ClusterMaintenanceWindowArgs;\nimport com.pulumi.ionoscloud.k8s.inputs.ClusterS3BucketArgs;\nimport com.pulumi.ionoscloud.k8s.NodePool;\nimport com.pulumi.ionoscloud.k8s.NodePoolArgs;\nimport com.pulumi.ionoscloud.k8s.inputs.NodePoolMaintenanceWindowArgs;\nimport com.pulumi.ionoscloud.k8s.inputs.NodePoolAutoScalingArgs;\nimport com.pulumi.ionoscloud.k8s.inputs.NodePoolLanArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleDatacenter = new Datacenter(\"exampleDatacenter\", DatacenterArgs.builder()\n            .location(\"us/las\")\n            .description(\"datacenter description\")\n            .secAuthProtection(false)\n            .build());\n\n        var exampleLan = new Lan(\"exampleLan\", LanArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .public_(false)\n            .build());\n\n        var exampleIPBlock = new IPBlock(\"exampleIPBlock\", IPBlockArgs.builder()\n            .location(\"us/las\")\n            .size(3)\n            .build());\n\n        var exampleCluster = new Cluster(\"exampleCluster\", ClusterArgs.builder()\n            .k8sVersion(\"1.28.6\")\n            .maintenanceWindow(ClusterMaintenanceWindowArgs.builder()\n                .dayOfTheWeek(\"Sunday\")\n                .time(\"09:00:00Z\")\n                .build())\n            .apiSubnetAllowLists(\"1.2.3.4/32\")\n            .s3Buckets(ClusterS3BucketArgs.builder()\n                .name(\"globally_unique_s3_bucket_name\")\n                .build())\n            .build());\n\n        var exampleNodePool = new NodePool(\"exampleNodePool\", NodePoolArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .k8sClusterId(exampleCluster.id())\n            .k8sVersion(exampleCluster.k8sVersion())\n            .maintenanceWindow(NodePoolMaintenanceWindowArgs.builder()\n                .dayOfTheWeek(\"Monday\")\n                .time(\"09:00:00Z\")\n                .build())\n            .autoScaling(NodePoolAutoScalingArgs.builder()\n                .minNodeCount(1)\n                .maxNodeCount(2)\n                .build())\n            .cpuFamily(\"INTEL_XEON\")\n            .availabilityZone(\"AUTO\")\n            .storageType(\"SSD\")\n            .nodeCount(1)\n            .coresCount(2)\n            .ramSize(2048)\n            .storageSize(40)\n            .publicIps(            \n                exampleIPBlock.ips().applyValue(ips -\u003e ips[0]),\n                exampleIPBlock.ips().applyValue(ips -\u003e ips[1]),\n                exampleIPBlock.ips().applyValue(ips -\u003e ips[2]))\n            .lans(NodePoolLanArgs.builder()\n                .id(exampleLan.id())\n                .dhcp(true)\n                .routes(NodePoolLanRouteArgs.builder()\n                    .network(\"1.2.3.5/24\")\n                    .gatewayIp(\"10.1.5.17\")\n                    .build())\n                .build())\n            .labels(Map.ofEntries(\n                Map.entry(\"lab1\", \"value1\"),\n                Map.entry(\"lab2\", \"value2\")\n            ))\n            .annotations(Map.ofEntries(\n                Map.entry(\"ann1\", \"value1\"),\n                Map.entry(\"ann2\", \"value2\")\n            ))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleDatacenter:\n    type: ionoscloud:compute:Datacenter\n    properties:\n      location: us/las\n      description: datacenter description\n      secAuthProtection: false\n  exampleLan:\n    type: ionoscloud:compute:Lan\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      public: false\n  exampleIPBlock:\n    type: ionoscloud:compute:IPBlock\n    properties:\n      location: us/las\n      size: 3\n  exampleCluster:\n    type: ionoscloud:k8s:Cluster\n    properties:\n      k8sVersion: 1.28.6\n      maintenanceWindow:\n        dayOfTheWeek: Sunday\n        time: 09:00:00Z\n      apiSubnetAllowLists:\n        - 1.2.3.4/32\n      s3Buckets:\n        - name: globally_unique_s3_bucket_name\n  exampleNodePool:\n    type: ionoscloud:k8s:NodePool\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      k8sClusterId: ${exampleCluster.id}\n      k8sVersion: ${exampleCluster.k8sVersion}\n      maintenanceWindow:\n        dayOfTheWeek: Monday\n        time: 09:00:00Z\n      autoScaling:\n        minNodeCount: 1\n        maxNodeCount: 2\n      cpuFamily: INTEL_XEON\n      availabilityZone: AUTO\n      storageType: SSD\n      nodeCount: 1\n      coresCount: 2\n      ramSize: 2048\n      storageSize: 40\n      publicIps:\n        - ${exampleIPBlock.ips[0]}\n        - ${exampleIPBlock.ips[1]}\n        - ${exampleIPBlock.ips[2]}\n      lans:\n        - id: ${exampleLan.id}\n          dhcp: true\n          routes:\n            - network: 1.2.3.5/24\n              gatewayIp: 10.1.5.17\n      labels:\n        lab1: value1\n        lab2: value2\n      annotations:\n        ann1: value1\n        ann2: value2\n```\n\u003c!--End PulumiCodeChooser --\u003e\n**Note:** Set `create_before_destroy` on the lan resource if you want to remove it from the nodepool during an update. This is to ensure that the nodepool is updated before the lan is destroyed.\n\n## Import\n\nA Kubernetes Node Pool resource can be imported using its Kubernetes cluster's uuid as well as its own UUID, both of which you can retrieve from the cloud API: `resource id`, e.g.:\n\n```sh\n$ pulumi import ionoscloud:k8s/nodePool:NodePool demo {k8s_cluster_uuid}/{k8s_nodepool_id}\n```\n\nThis can be helpful when you want to import kubernetes node pools which you have already created manually or using other means, outside of terraform, towards the goal of managing them via Terraform\n\n⚠️ **_Warning: **During a maintenance window, k8s can update your `k8s_version` if the old one reaches end of life. This upgrade will not be shown in the plan, as we prevent \n\nterraform from doing a downgrade, as downgrading `k8s_version` is not supported._**\n\n⚠️ **_Warning: **If you are upgrading from v5.x.x to v6.x.x**: You have to modify you plan for lans to match the new structure, by putting the ids from the old slice in lans.id fields. This is not backwards compatible._**\n\n",
            "properties": {
                "allowReplace": {
                    "type": "boolean",
                    "description": "When set to true, allows the update of immutable fields by destroying and re-creating the node pool\n"
                },
                "annotations": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "[map] A key/value map of annotations\n"
                },
                "autoScaling": {
                    "$ref": "#/types/ionoscloud:k8s/NodePoolAutoScaling:NodePoolAutoScaling",
                    "description": "[string] Wether the Node Pool should autoscale. For more details, please check the API documentation\n"
                },
                "availabilityZone": {
                    "type": "string",
                    "description": "[string] - The desired Compute availability zone - See the API documentation for more information. *This attribute is immutable*.\n"
                },
                "coresCount": {
                    "type": "integer",
                    "description": "[int] - The CPU cores count for each node of the node pool. *This attribute is immutable*.\n"
                },
                "cpuFamily": {
                    "type": "string",
                    "description": "[string] The desired CPU Family - See the API documentation for more information. *This attribute is immutable*.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "[string] A Datacenter's UUID\n"
                },
                "k8sClusterId": {
                    "type": "string",
                    "description": "[string] A k8s cluster's UUID\n"
                },
                "k8sVersion": {
                    "type": "string",
                    "description": "[string] The desired Kubernetes Version. For supported values, please check the API documentation. Downgrades are not supported. The provider will ignore downgrades of patch level.\n"
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "[map] A key/value map of labels\n"
                },
                "lans": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:k8s/NodePoolLan:NodePoolLan"
                    },
                    "description": "[list] A list of numeric LAN id's you want this node pool to be part of. For more details, please check the API documentation, as well as the example above\n"
                },
                "maintenanceWindow": {
                    "$ref": "#/types/ionoscloud:k8s/NodePoolMaintenanceWindow:NodePoolMaintenanceWindow",
                    "description": "See the **maintenance_window** section in the example above\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the Kubernetes Cluster. *This attribute is immutable*.\n"
                },
                "nodeCount": {
                    "type": "integer",
                    "description": "[int] - The desired number of nodes in the node pool\n"
                },
                "publicIps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] A list of public IPs associated with the node pool; must have at least `node_count + 1` elements\n"
                },
                "ramSize": {
                    "type": "integer",
                    "description": "[int] - The desired amount of RAM, in MB. *This attribute is immutable*.\n"
                },
                "storageSize": {
                    "type": "integer",
                    "description": "[int] - The size of the volume in GB. The size should be greater than 10GB. *This attribute is immutable*.\n"
                },
                "storageType": {
                    "type": "string",
                    "description": "[string] - The desired storage type - SSD/HDD. *This attribute is immutable*.\n"
                }
            },
            "required": [
                "availabilityZone",
                "coresCount",
                "cpuFamily",
                "datacenterId",
                "k8sClusterId",
                "k8sVersion",
                "maintenanceWindow",
                "name",
                "nodeCount",
                "ramSize",
                "storageSize",
                "storageType"
            ],
            "inputProperties": {
                "allowReplace": {
                    "type": "boolean",
                    "description": "When set to true, allows the update of immutable fields by destroying and re-creating the node pool\n"
                },
                "annotations": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "[map] A key/value map of annotations\n"
                },
                "autoScaling": {
                    "$ref": "#/types/ionoscloud:k8s/NodePoolAutoScaling:NodePoolAutoScaling",
                    "description": "[string] Wether the Node Pool should autoscale. For more details, please check the API documentation\n"
                },
                "availabilityZone": {
                    "type": "string",
                    "description": "[string] - The desired Compute availability zone - See the API documentation for more information. *This attribute is immutable*.\n",
                    "willReplaceOnChanges": true
                },
                "coresCount": {
                    "type": "integer",
                    "description": "[int] - The CPU cores count for each node of the node pool. *This attribute is immutable*.\n",
                    "willReplaceOnChanges": true
                },
                "cpuFamily": {
                    "type": "string",
                    "description": "[string] The desired CPU Family - See the API documentation for more information. *This attribute is immutable*.\n",
                    "willReplaceOnChanges": true
                },
                "datacenterId": {
                    "type": "string",
                    "description": "[string] A Datacenter's UUID\n"
                },
                "k8sClusterId": {
                    "type": "string",
                    "description": "[string] A k8s cluster's UUID\n"
                },
                "k8sVersion": {
                    "type": "string",
                    "description": "[string] The desired Kubernetes Version. For supported values, please check the API documentation. Downgrades are not supported. The provider will ignore downgrades of patch level.\n"
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "[map] A key/value map of labels\n"
                },
                "lans": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:k8s/NodePoolLan:NodePoolLan"
                    },
                    "description": "[list] A list of numeric LAN id's you want this node pool to be part of. For more details, please check the API documentation, as well as the example above\n"
                },
                "maintenanceWindow": {
                    "$ref": "#/types/ionoscloud:k8s/NodePoolMaintenanceWindow:NodePoolMaintenanceWindow",
                    "description": "See the **maintenance_window** section in the example above\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the Kubernetes Cluster. *This attribute is immutable*.\n",
                    "willReplaceOnChanges": true
                },
                "nodeCount": {
                    "type": "integer",
                    "description": "[int] - The desired number of nodes in the node pool\n"
                },
                "publicIps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] A list of public IPs associated with the node pool; must have at least `node_count + 1` elements\n"
                },
                "ramSize": {
                    "type": "integer",
                    "description": "[int] - The desired amount of RAM, in MB. *This attribute is immutable*.\n",
                    "willReplaceOnChanges": true
                },
                "storageSize": {
                    "type": "integer",
                    "description": "[int] - The size of the volume in GB. The size should be greater than 10GB. *This attribute is immutable*.\n",
                    "willReplaceOnChanges": true
                },
                "storageType": {
                    "type": "string",
                    "description": "[string] - The desired storage type - SSD/HDD. *This attribute is immutable*.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "availabilityZone",
                "coresCount",
                "cpuFamily",
                "datacenterId",
                "k8sClusterId",
                "k8sVersion",
                "nodeCount",
                "ramSize",
                "storageSize",
                "storageType"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NodePool resources.\n",
                "properties": {
                    "allowReplace": {
                        "type": "boolean",
                        "description": "When set to true, allows the update of immutable fields by destroying and re-creating the node pool\n"
                    },
                    "annotations": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "[map] A key/value map of annotations\n"
                    },
                    "autoScaling": {
                        "$ref": "#/types/ionoscloud:k8s/NodePoolAutoScaling:NodePoolAutoScaling",
                        "description": "[string] Wether the Node Pool should autoscale. For more details, please check the API documentation\n"
                    },
                    "availabilityZone": {
                        "type": "string",
                        "description": "[string] - The desired Compute availability zone - See the API documentation for more information. *This attribute is immutable*.\n",
                        "willReplaceOnChanges": true
                    },
                    "coresCount": {
                        "type": "integer",
                        "description": "[int] - The CPU cores count for each node of the node pool. *This attribute is immutable*.\n",
                        "willReplaceOnChanges": true
                    },
                    "cpuFamily": {
                        "type": "string",
                        "description": "[string] The desired CPU Family - See the API documentation for more information. *This attribute is immutable*.\n",
                        "willReplaceOnChanges": true
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "[string] A Datacenter's UUID\n"
                    },
                    "k8sClusterId": {
                        "type": "string",
                        "description": "[string] A k8s cluster's UUID\n"
                    },
                    "k8sVersion": {
                        "type": "string",
                        "description": "[string] The desired Kubernetes Version. For supported values, please check the API documentation. Downgrades are not supported. The provider will ignore downgrades of patch level.\n"
                    },
                    "labels": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "[map] A key/value map of labels\n"
                    },
                    "lans": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:k8s/NodePoolLan:NodePoolLan"
                        },
                        "description": "[list] A list of numeric LAN id's you want this node pool to be part of. For more details, please check the API documentation, as well as the example above\n"
                    },
                    "maintenanceWindow": {
                        "$ref": "#/types/ionoscloud:k8s/NodePoolMaintenanceWindow:NodePoolMaintenanceWindow",
                        "description": "See the **maintenance_window** section in the example above\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] The name of the Kubernetes Cluster. *This attribute is immutable*.\n",
                        "willReplaceOnChanges": true
                    },
                    "nodeCount": {
                        "type": "integer",
                        "description": "[int] - The desired number of nodes in the node pool\n"
                    },
                    "publicIps": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "[list] A list of public IPs associated with the node pool; must have at least `node_count + 1` elements\n"
                    },
                    "ramSize": {
                        "type": "integer",
                        "description": "[int] - The desired amount of RAM, in MB. *This attribute is immutable*.\n",
                        "willReplaceOnChanges": true
                    },
                    "storageSize": {
                        "type": "integer",
                        "description": "[int] - The size of the volume in GB. The size should be greater than 10GB. *This attribute is immutable*.\n",
                        "willReplaceOnChanges": true
                    },
                    "storageType": {
                        "type": "string",
                        "description": "[string] - The desired storage type - SSD/HDD. *This attribute is immutable*.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:kafka/cluster:Cluster": {
            "description": "Manages a **Kafka Cluster** on IonosCloud.\n\n## Example Usage\n\nThis resource will create an operational Kafka Cluster. After this section completes, the provisioner can be called.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\n// Basic example\nconst exampleDatacenter = new ionoscloud.compute.Datacenter(\"exampleDatacenter\", {location: \"de/fra\"});\nconst exampleLan = new ionoscloud.compute.Lan(\"exampleLan\", {\n    datacenterId: exampleDatacenter.id,\n    \"public\": false,\n});\nconst exampleCluster = new ionoscloud.kafka.Cluster(\"exampleCluster\", {\n    location: \"de/fra\",\n    version: \"3.7.0\",\n    size: \"S\",\n    connections: {\n        datacenterId: exampleDatacenter.id,\n        lanId: exampleLan.id,\n        brokerAddresses: [\n            \"192.168.1.101/24\",\n            \"192.168.1.102/24\",\n            \"192.168.1.103/24\",\n        ],\n    },\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\n# Basic example\nexample_datacenter = ionoscloud.compute.Datacenter(\"exampleDatacenter\", location=\"de/fra\")\nexample_lan = ionoscloud.compute.Lan(\"exampleLan\",\n    datacenter_id=example_datacenter.id,\n    public=False)\nexample_cluster = ionoscloud.kafka.Cluster(\"exampleCluster\",\n    location=\"de/fra\",\n    version=\"3.7.0\",\n    size=\"S\",\n    connections={\n        \"datacenter_id\": example_datacenter.id,\n        \"lan_id\": example_lan.id,\n        \"broker_addresses\": [\n            \"192.168.1.101/24\",\n            \"192.168.1.102/24\",\n            \"192.168.1.103/24\",\n        ],\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Basic example\n    var exampleDatacenter = new Ionoscloud.Compute.Datacenter(\"exampleDatacenter\", new()\n    {\n        Location = \"de/fra\",\n    });\n\n    var exampleLan = new Ionoscloud.Compute.Lan(\"exampleLan\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        Public = false,\n    });\n\n    var exampleCluster = new Ionoscloud.Kafka.Cluster(\"exampleCluster\", new()\n    {\n        Location = \"de/fra\",\n        Version = \"3.7.0\",\n        Size = \"S\",\n        Connections = new Ionoscloud.Kafka.Inputs.ClusterConnectionsArgs\n        {\n            DatacenterId = exampleDatacenter.Id,\n            LanId = exampleLan.Id,\n            BrokerAddresses = new[]\n            {\n                \"192.168.1.101/24\",\n                \"192.168.1.102/24\",\n                \"192.168.1.103/24\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/kafka\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Basic example\n\t\texampleDatacenter, err := compute.NewDatacenter(ctx, \"exampleDatacenter\", \u0026compute.DatacenterArgs{\n\t\t\tLocation: pulumi.String(\"de/fra\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleLan, err := compute.NewLan(ctx, \"exampleLan\", \u0026compute.LanArgs{\n\t\t\tDatacenterId: exampleDatacenter.ID(),\n\t\t\tPublic:       pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = kafka.NewCluster(ctx, \"exampleCluster\", \u0026kafka.ClusterArgs{\n\t\t\tLocation: pulumi.String(\"de/fra\"),\n\t\t\tVersion:  pulumi.String(\"3.7.0\"),\n\t\t\tSize:     pulumi.String(\"S\"),\n\t\t\tConnections: \u0026kafka.ClusterConnectionsArgs{\n\t\t\t\tDatacenterId: exampleDatacenter.ID(),\n\t\t\t\tLanId:        exampleLan.ID(),\n\t\t\t\tBrokerAddresses: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"192.168.1.101/24\"),\n\t\t\t\t\tpulumi.String(\"192.168.1.102/24\"),\n\t\t\t\t\tpulumi.String(\"192.168.1.103/24\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.Datacenter;\nimport com.pulumi.ionoscloud.compute.DatacenterArgs;\nimport com.pulumi.ionoscloud.compute.Lan;\nimport com.pulumi.ionoscloud.compute.LanArgs;\nimport com.pulumi.ionoscloud.kafka.Cluster;\nimport com.pulumi.ionoscloud.kafka.ClusterArgs;\nimport com.pulumi.ionoscloud.kafka.inputs.ClusterConnectionsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Basic example\n        var exampleDatacenter = new Datacenter(\"exampleDatacenter\", DatacenterArgs.builder()\n            .location(\"de/fra\")\n            .build());\n\n        var exampleLan = new Lan(\"exampleLan\", LanArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .public_(false)\n            .build());\n\n        var exampleCluster = new Cluster(\"exampleCluster\", ClusterArgs.builder()\n            .location(\"de/fra\")\n            .version(\"3.7.0\")\n            .size(\"S\")\n            .connections(ClusterConnectionsArgs.builder()\n                .datacenterId(exampleDatacenter.id())\n                .lanId(exampleLan.id())\n                .brokerAddresses(                \n                    \"192.168.1.101/24\",\n                    \"192.168.1.102/24\",\n                    \"192.168.1.103/24\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Basic example\n  exampleDatacenter:\n    type: ionoscloud:compute:Datacenter\n    properties:\n      location: de/fra\n  exampleLan:\n    type: ionoscloud:compute:Lan\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      public: false\n  exampleCluster:\n    type: ionoscloud:kafka:Cluster\n    properties:\n      location: de/fra\n      version: 3.7.0\n      size: S\n      connections:\n        datacenterId: ${exampleDatacenter.id}\n        lanId: ${exampleLan.id}\n        brokerAddresses:\n          - 192.168.1.101/24\n          - 192.168.1.102/24\n          - 192.168.1.103/24\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nKafka Cluster can be imported using the `location` and `kafka cluster id`:\n\n```sh\n$ pulumi import ionoscloud:kafka/cluster:Cluster mycluster {location}:{kafka cluster uuid}\n```\n\n",
            "properties": {
                "brokerAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] IP address and port of cluster brokers.\n"
                },
                "connections": {
                    "$ref": "#/types/ionoscloud:kafka/ClusterConnections:ClusterConnections",
                    "description": "Connection information of the Kafka Cluster. Minimum items: 1, maximum items: 1.\n"
                },
                "location": {
                    "type": "string",
                    "description": "[string] The location of the Kafka Cluster. Possible values: `de/fra`, `de/txl`\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] Name of the Kafka Cluster.\n"
                },
                "size": {
                    "type": "string",
                    "description": "[string] Size of the Kafka Cluster. Possible values: `XS`, `S`\n"
                },
                "version": {
                    "type": "string",
                    "description": "[string] Version of the Kafka Cluster. Possible values: `3.7.0`\n"
                }
            },
            "required": [
                "brokerAddresses",
                "connections",
                "location",
                "name",
                "size",
                "version"
            ],
            "inputProperties": {
                "connections": {
                    "$ref": "#/types/ionoscloud:kafka/ClusterConnections:ClusterConnections",
                    "description": "Connection information of the Kafka Cluster. Minimum items: 1, maximum items: 1.\n",
                    "willReplaceOnChanges": true
                },
                "location": {
                    "type": "string",
                    "description": "[string] The location of the Kafka Cluster. Possible values: `de/fra`, `de/txl`\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "[string] Name of the Kafka Cluster.\n",
                    "willReplaceOnChanges": true
                },
                "size": {
                    "type": "string",
                    "description": "[string] Size of the Kafka Cluster. Possible values: `XS`, `S`\n",
                    "willReplaceOnChanges": true
                },
                "version": {
                    "type": "string",
                    "description": "[string] Version of the Kafka Cluster. Possible values: `3.7.0`\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "connections",
                "location",
                "size",
                "version"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Cluster resources.\n",
                "properties": {
                    "brokerAddresses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "[list] IP address and port of cluster brokers.\n"
                    },
                    "connections": {
                        "$ref": "#/types/ionoscloud:kafka/ClusterConnections:ClusterConnections",
                        "description": "Connection information of the Kafka Cluster. Minimum items: 1, maximum items: 1.\n",
                        "willReplaceOnChanges": true
                    },
                    "location": {
                        "type": "string",
                        "description": "[string] The location of the Kafka Cluster. Possible values: `de/fra`, `de/txl`\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] Name of the Kafka Cluster.\n",
                        "willReplaceOnChanges": true
                    },
                    "size": {
                        "type": "string",
                        "description": "[string] Size of the Kafka Cluster. Possible values: `XS`, `S`\n",
                        "willReplaceOnChanges": true
                    },
                    "version": {
                        "type": "string",
                        "description": "[string] Version of the Kafka Cluster. Possible values: `3.7.0`\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:kafka/topic:Topic": {
            "description": "Manages a **Kafka Cluster Topic** on IonosCloud.\n\n## Example Usage\n\nThis resource will create an operational Kafka Cluster Topic. After this section completes, the provisioner can be\ncalled.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\n// Basic example\nconst exampleDatacenter = new ionoscloud.compute.Datacenter(\"exampleDatacenter\", {location: \"de/fra\"});\nconst exampleLan = new ionoscloud.compute.Lan(\"exampleLan\", {\n    datacenterId: exampleDatacenter.id,\n    \"public\": false,\n});\nconst exampleCluster = new ionoscloud.kafka.Cluster(\"exampleCluster\", {\n    location: exampleDatacenter.location,\n    version: \"3.7.0\",\n    size: \"S\",\n    connections: {\n        datacenterId: exampleDatacenter.id,\n        lanId: exampleLan.id,\n        brokerAddresses: [\n            \"192.168.1.101/24\",\n            \"192.168.1.102/24\",\n            \"192.168.1.103/24\",\n        ],\n    },\n});\nconst exampleTopic = new ionoscloud.kafka.Topic(\"exampleTopic\", {\n    clusterId: exampleCluster.id,\n    location: exampleCluster.location,\n    replicationFactor: 1,\n    numberOfPartitions: 1,\n    retentionTime: 86400000,\n    segmentBytes: 1073741824,\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\n# Basic example\nexample_datacenter = ionoscloud.compute.Datacenter(\"exampleDatacenter\", location=\"de/fra\")\nexample_lan = ionoscloud.compute.Lan(\"exampleLan\",\n    datacenter_id=example_datacenter.id,\n    public=False)\nexample_cluster = ionoscloud.kafka.Cluster(\"exampleCluster\",\n    location=example_datacenter.location,\n    version=\"3.7.0\",\n    size=\"S\",\n    connections={\n        \"datacenter_id\": example_datacenter.id,\n        \"lan_id\": example_lan.id,\n        \"broker_addresses\": [\n            \"192.168.1.101/24\",\n            \"192.168.1.102/24\",\n            \"192.168.1.103/24\",\n        ],\n    })\nexample_topic = ionoscloud.kafka.Topic(\"exampleTopic\",\n    cluster_id=example_cluster.id,\n    location=example_cluster.location,\n    replication_factor=1,\n    number_of_partitions=1,\n    retention_time=86400000,\n    segment_bytes=1073741824)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Basic example\n    var exampleDatacenter = new Ionoscloud.Compute.Datacenter(\"exampleDatacenter\", new()\n    {\n        Location = \"de/fra\",\n    });\n\n    var exampleLan = new Ionoscloud.Compute.Lan(\"exampleLan\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        Public = false,\n    });\n\n    var exampleCluster = new Ionoscloud.Kafka.Cluster(\"exampleCluster\", new()\n    {\n        Location = exampleDatacenter.Location,\n        Version = \"3.7.0\",\n        Size = \"S\",\n        Connections = new Ionoscloud.Kafka.Inputs.ClusterConnectionsArgs\n        {\n            DatacenterId = exampleDatacenter.Id,\n            LanId = exampleLan.Id,\n            BrokerAddresses = new[]\n            {\n                \"192.168.1.101/24\",\n                \"192.168.1.102/24\",\n                \"192.168.1.103/24\",\n            },\n        },\n    });\n\n    var exampleTopic = new Ionoscloud.Kafka.Topic(\"exampleTopic\", new()\n    {\n        ClusterId = exampleCluster.Id,\n        Location = exampleCluster.Location,\n        ReplicationFactor = 1,\n        NumberOfPartitions = 1,\n        RetentionTime = 86400000,\n        SegmentBytes = 1073741824,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/kafka\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Basic example\n\t\texampleDatacenter, err := compute.NewDatacenter(ctx, \"exampleDatacenter\", \u0026compute.DatacenterArgs{\n\t\t\tLocation: pulumi.String(\"de/fra\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleLan, err := compute.NewLan(ctx, \"exampleLan\", \u0026compute.LanArgs{\n\t\t\tDatacenterId: exampleDatacenter.ID(),\n\t\t\tPublic:       pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleCluster, err := kafka.NewCluster(ctx, \"exampleCluster\", \u0026kafka.ClusterArgs{\n\t\t\tLocation: exampleDatacenter.Location,\n\t\t\tVersion:  pulumi.String(\"3.7.0\"),\n\t\t\tSize:     pulumi.String(\"S\"),\n\t\t\tConnections: \u0026kafka.ClusterConnectionsArgs{\n\t\t\t\tDatacenterId: exampleDatacenter.ID(),\n\t\t\t\tLanId:        exampleLan.ID(),\n\t\t\t\tBrokerAddresses: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"192.168.1.101/24\"),\n\t\t\t\t\tpulumi.String(\"192.168.1.102/24\"),\n\t\t\t\t\tpulumi.String(\"192.168.1.103/24\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = kafka.NewTopic(ctx, \"exampleTopic\", \u0026kafka.TopicArgs{\n\t\t\tClusterId:          exampleCluster.ID(),\n\t\t\tLocation:           exampleCluster.Location,\n\t\t\tReplicationFactor:  pulumi.Int(1),\n\t\t\tNumberOfPartitions: pulumi.Int(1),\n\t\t\tRetentionTime:      pulumi.Int(86400000),\n\t\t\tSegmentBytes:       pulumi.Int(1073741824),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.Datacenter;\nimport com.pulumi.ionoscloud.compute.DatacenterArgs;\nimport com.pulumi.ionoscloud.compute.Lan;\nimport com.pulumi.ionoscloud.compute.LanArgs;\nimport com.pulumi.ionoscloud.kafka.Cluster;\nimport com.pulumi.ionoscloud.kafka.ClusterArgs;\nimport com.pulumi.ionoscloud.kafka.inputs.ClusterConnectionsArgs;\nimport com.pulumi.ionoscloud.kafka.Topic;\nimport com.pulumi.ionoscloud.kafka.TopicArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Basic example\n        var exampleDatacenter = new Datacenter(\"exampleDatacenter\", DatacenterArgs.builder()\n            .location(\"de/fra\")\n            .build());\n\n        var exampleLan = new Lan(\"exampleLan\", LanArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .public_(false)\n            .build());\n\n        var exampleCluster = new Cluster(\"exampleCluster\", ClusterArgs.builder()\n            .location(exampleDatacenter.location())\n            .version(\"3.7.0\")\n            .size(\"S\")\n            .connections(ClusterConnectionsArgs.builder()\n                .datacenterId(exampleDatacenter.id())\n                .lanId(exampleLan.id())\n                .brokerAddresses(                \n                    \"192.168.1.101/24\",\n                    \"192.168.1.102/24\",\n                    \"192.168.1.103/24\")\n                .build())\n            .build());\n\n        var exampleTopic = new Topic(\"exampleTopic\", TopicArgs.builder()\n            .clusterId(exampleCluster.id())\n            .location(exampleCluster.location())\n            .replicationFactor(1)\n            .numberOfPartitions(1)\n            .retentionTime(86400000)\n            .segmentBytes(1073741824)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Basic example\n  exampleDatacenter:\n    type: ionoscloud:compute:Datacenter\n    properties:\n      location: de/fra\n  exampleLan:\n    type: ionoscloud:compute:Lan\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      public: false\n  exampleCluster:\n    type: ionoscloud:kafka:Cluster\n    properties:\n      location: ${exampleDatacenter.location}\n      version: 3.7.0\n      size: S\n      connections:\n        datacenterId: ${exampleDatacenter.id}\n        lanId: ${exampleLan.id}\n        brokerAddresses:\n          - 192.168.1.101/24\n          - 192.168.1.102/24\n          - 192.168.1.103/24\n  exampleTopic:\n    type: ionoscloud:kafka:Topic\n    properties:\n      clusterId: ${exampleCluster.id}\n      location: ${exampleCluster.location}\n      replicationFactor: 1\n      numberOfPartitions: 1\n      retentionTime: 8.64e+07\n      segmentBytes: 1.073741824e+09\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nKafka Cluster Topic can be imported using the `location`, `kafka cluster id` and the `kafka cluster topic id`:\n\n```sh\n$ pulumi import ionoscloud:kafka/topic:Topic my_topic {location}:{kafka cluster uuid}:{kafka cluster topic uuid}\n```\n\n",
            "properties": {
                "clusterId": {
                    "type": "string",
                    "description": "[string] ID of the Kafka Cluster that the topic belongs to.\n"
                },
                "location": {
                    "type": "string",
                    "description": "[string] The location of the Kafka Cluster Topic. Possible values: `de/fra`, `de/txl`\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] Name of the Kafka Cluster.\n"
                },
                "numberOfPartitions": {
                    "type": "integer",
                    "description": "[int] The number of partitions of the topic. Partitions allow for parallel\nprocessing of messages. The partition count must be greater than or equal to the replication factor. Minimum value: 1.\nDefault value: 3.\n"
                },
                "replicationFactor": {
                    "type": "integer",
                    "description": "[int] The number of replicas of the topic. The replication factor determines how many\ncopies of the topic are stored on different brokers. The replication factor must be less than or equal to the number\nof brokers in the Kafka Cluster. Minimum value: 1. Default value: 3.\n"
                },
                "retentionTime": {
                    "type": "integer",
                    "description": "[int] This configuration controls the maximum time we will retain a log before we will\ndiscard old log segments to free up space. This represents an SLA on how soon consumers must read their data. If set\nto -1, no time limit is applied. Default value: 604800000.\n"
                },
                "segmentBytes": {
                    "type": "integer",
                    "description": "[int] This configuration controls the segment file size for the log. Retention and\ncleaning is always done a file at a time so a larger segment size means fewer files but less granular control over\nretention. Default value: 1073741824.\n"
                }
            },
            "required": [
                "clusterId",
                "location",
                "name"
            ],
            "inputProperties": {
                "clusterId": {
                    "type": "string",
                    "description": "[string] ID of the Kafka Cluster that the topic belongs to.\n",
                    "willReplaceOnChanges": true
                },
                "location": {
                    "type": "string",
                    "description": "[string] The location of the Kafka Cluster Topic. Possible values: `de/fra`, `de/txl`\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "[string] Name of the Kafka Cluster.\n",
                    "willReplaceOnChanges": true
                },
                "numberOfPartitions": {
                    "type": "integer",
                    "description": "[int] The number of partitions of the topic. Partitions allow for parallel\nprocessing of messages. The partition count must be greater than or equal to the replication factor. Minimum value: 1.\nDefault value: 3.\n",
                    "willReplaceOnChanges": true
                },
                "replicationFactor": {
                    "type": "integer",
                    "description": "[int] The number of replicas of the topic. The replication factor determines how many\ncopies of the topic are stored on different brokers. The replication factor must be less than or equal to the number\nof brokers in the Kafka Cluster. Minimum value: 1. Default value: 3.\n",
                    "willReplaceOnChanges": true
                },
                "retentionTime": {
                    "type": "integer",
                    "description": "[int] This configuration controls the maximum time we will retain a log before we will\ndiscard old log segments to free up space. This represents an SLA on how soon consumers must read their data. If set\nto -1, no time limit is applied. Default value: 604800000.\n",
                    "willReplaceOnChanges": true
                },
                "segmentBytes": {
                    "type": "integer",
                    "description": "[int] This configuration controls the segment file size for the log. Retention and\ncleaning is always done a file at a time so a larger segment size means fewer files but less granular control over\nretention. Default value: 1073741824.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "clusterId",
                "location"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Topic resources.\n",
                "properties": {
                    "clusterId": {
                        "type": "string",
                        "description": "[string] ID of the Kafka Cluster that the topic belongs to.\n",
                        "willReplaceOnChanges": true
                    },
                    "location": {
                        "type": "string",
                        "description": "[string] The location of the Kafka Cluster Topic. Possible values: `de/fra`, `de/txl`\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] Name of the Kafka Cluster.\n",
                        "willReplaceOnChanges": true
                    },
                    "numberOfPartitions": {
                        "type": "integer",
                        "description": "[int] The number of partitions of the topic. Partitions allow for parallel\nprocessing of messages. The partition count must be greater than or equal to the replication factor. Minimum value: 1.\nDefault value: 3.\n",
                        "willReplaceOnChanges": true
                    },
                    "replicationFactor": {
                        "type": "integer",
                        "description": "[int] The number of replicas of the topic. The replication factor determines how many\ncopies of the topic are stored on different brokers. The replication factor must be less than or equal to the number\nof brokers in the Kafka Cluster. Minimum value: 1. Default value: 3.\n",
                        "willReplaceOnChanges": true
                    },
                    "retentionTime": {
                        "type": "integer",
                        "description": "[int] This configuration controls the maximum time we will retain a log before we will\ndiscard old log segments to free up space. This represents an SLA on how soon consumers must read their data. If set\nto -1, no time limit is applied. Default value: 604800000.\n",
                        "willReplaceOnChanges": true
                    },
                    "segmentBytes": {
                        "type": "integer",
                        "description": "[int] This configuration controls the segment file size for the log. Retention and\ncleaning is always done a file at a time so a larger segment size means fewer files but less granular control over\nretention. Default value: 1073741824.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:logging/pipeline:Pipeline": {
            "description": "\n\n## Import\n\nIn order to import a Logging pipeline, you can define an empty Logging pipeline resource in the plan:\n\nhcl\n\nresource \"ionoscloud_logging_pipeline\" \"example\" {\n\n}\n\nThe resource can be imported using the `location` and `pipeline_id`, for example:\n\n```sh\n$ pulumi import ionoscloud:logging/pipeline:Pipeline example {location}:{pipeline_id}\n```\n\n",
            "properties": {
                "grafanaAddress": {
                    "type": "string",
                    "description": "[string] The address of the client's grafana instance.\n"
                },
                "location": {
                    "type": "string",
                    "description": "[string] The location of the Logging pipeline. Default: `de/txl` One of `de/fra`, `de/txl`, `gb/lhr`, `es/vit`, `fr/par`.\n"
                },
                "logs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:logging/PipelineLog:PipelineLog"
                    },
                    "description": "[list] Pipeline logs, a list that contains elements with the following structure:\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the Logging pipeline.\n"
                }
            },
            "required": [
                "grafanaAddress",
                "logs",
                "name"
            ],
            "inputProperties": {
                "location": {
                    "type": "string",
                    "description": "[string] The location of the Logging pipeline. Default: `de/txl` One of `de/fra`, `de/txl`, `gb/lhr`, `es/vit`, `fr/par`.\n",
                    "willReplaceOnChanges": true
                },
                "logs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:logging/PipelineLog:PipelineLog"
                    },
                    "description": "[list] Pipeline logs, a list that contains elements with the following structure:\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the Logging pipeline.\n"
                }
            },
            "requiredInputs": [
                "logs"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Pipeline resources.\n",
                "properties": {
                    "grafanaAddress": {
                        "type": "string",
                        "description": "[string] The address of the client's grafana instance.\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "[string] The location of the Logging pipeline. Default: `de/txl` One of `de/fra`, `de/txl`, `gb/lhr`, `es/vit`, `fr/par`.\n",
                        "willReplaceOnChanges": true
                    },
                    "logs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:logging/PipelineLog:PipelineLog"
                        },
                        "description": "[list] Pipeline logs, a list that contains elements with the following structure:\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] The name of the Logging pipeline.\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:nfs/cluster:Cluster": {
            "description": "Create clusters of Network File Storage (NFS) on IonosCloud.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\n// Basic example\nconst nfsDc = new ionoscloud.compute.Datacenter(\"nfsDc\", {\n    location: \"de/txl\",\n    description: \"Datacenter Description\",\n    secAuthProtection: false,\n});\nconst nfsLan = new ionoscloud.compute.Lan(\"nfsLan\", {\n    datacenterId: nfsDc.id,\n    \"public\": false,\n});\nconst example = new ionoscloud.nfs.Cluster(\"example\", {\n    location: \"de/txl\",\n    size: 2,\n    nfs: {\n        minVersion: \"4.2\",\n    },\n    connections: {\n        datacenterId: nfsDc.id,\n        ipAddress: \"192.168.100.10/24\",\n        lan: nfsLan.id,\n    },\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\n# Basic example\nnfs_dc = ionoscloud.compute.Datacenter(\"nfsDc\",\n    location=\"de/txl\",\n    description=\"Datacenter Description\",\n    sec_auth_protection=False)\nnfs_lan = ionoscloud.compute.Lan(\"nfsLan\",\n    datacenter_id=nfs_dc.id,\n    public=False)\nexample = ionoscloud.nfs.Cluster(\"example\",\n    location=\"de/txl\",\n    size=2,\n    nfs={\n        \"min_version\": \"4.2\",\n    },\n    connections={\n        \"datacenter_id\": nfs_dc.id,\n        \"ip_address\": \"192.168.100.10/24\",\n        \"lan\": nfs_lan.id,\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Basic example\n    var nfsDc = new Ionoscloud.Compute.Datacenter(\"nfsDc\", new()\n    {\n        Location = \"de/txl\",\n        Description = \"Datacenter Description\",\n        SecAuthProtection = false,\n    });\n\n    var nfsLan = new Ionoscloud.Compute.Lan(\"nfsLan\", new()\n    {\n        DatacenterId = nfsDc.Id,\n        Public = false,\n    });\n\n    var example = new Ionoscloud.Nfs.Cluster(\"example\", new()\n    {\n        Location = \"de/txl\",\n        Size = 2,\n        Nfs = new Ionoscloud.Nfs.Inputs.ClusterNfsArgs\n        {\n            MinVersion = \"4.2\",\n        },\n        Connections = new Ionoscloud.Nfs.Inputs.ClusterConnectionsArgs\n        {\n            DatacenterId = nfsDc.Id,\n            IpAddress = \"192.168.100.10/24\",\n            Lan = nfsLan.Id,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/nfs\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Basic example\n\t\tnfsDc, err := compute.NewDatacenter(ctx, \"nfsDc\", \u0026compute.DatacenterArgs{\n\t\t\tLocation:          pulumi.String(\"de/txl\"),\n\t\t\tDescription:       pulumi.String(\"Datacenter Description\"),\n\t\t\tSecAuthProtection: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tnfsLan, err := compute.NewLan(ctx, \"nfsLan\", \u0026compute.LanArgs{\n\t\t\tDatacenterId: nfsDc.ID(),\n\t\t\tPublic:       pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = nfs.NewCluster(ctx, \"example\", \u0026nfs.ClusterArgs{\n\t\t\tLocation: pulumi.String(\"de/txl\"),\n\t\t\tSize:     pulumi.Int(2),\n\t\t\tNfs: \u0026nfs.ClusterNfsArgs{\n\t\t\t\tMinVersion: pulumi.String(\"4.2\"),\n\t\t\t},\n\t\t\tConnections: \u0026nfs.ClusterConnectionsArgs{\n\t\t\t\tDatacenterId: nfsDc.ID(),\n\t\t\t\tIpAddress:    pulumi.String(\"192.168.100.10/24\"),\n\t\t\t\tLan:          nfsLan.ID(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.Datacenter;\nimport com.pulumi.ionoscloud.compute.DatacenterArgs;\nimport com.pulumi.ionoscloud.compute.Lan;\nimport com.pulumi.ionoscloud.compute.LanArgs;\nimport com.pulumi.ionoscloud.nfs.Cluster;\nimport com.pulumi.ionoscloud.nfs.ClusterArgs;\nimport com.pulumi.ionoscloud.nfs.inputs.ClusterNfsArgs;\nimport com.pulumi.ionoscloud.nfs.inputs.ClusterConnectionsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Basic example\n        var nfsDc = new Datacenter(\"nfsDc\", DatacenterArgs.builder()\n            .location(\"de/txl\")\n            .description(\"Datacenter Description\")\n            .secAuthProtection(false)\n            .build());\n\n        var nfsLan = new Lan(\"nfsLan\", LanArgs.builder()\n            .datacenterId(nfsDc.id())\n            .public_(false)\n            .build());\n\n        var example = new Cluster(\"example\", ClusterArgs.builder()\n            .location(\"de/txl\")\n            .size(2)\n            .nfs(ClusterNfsArgs.builder()\n                .minVersion(\"4.2\")\n                .build())\n            .connections(ClusterConnectionsArgs.builder()\n                .datacenterId(nfsDc.id())\n                .ipAddress(\"192.168.100.10/24\")\n                .lan(nfsLan.id())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Basic example\n  nfsDc:\n    type: ionoscloud:compute:Datacenter\n    properties:\n      location: de/txl\n      description: Datacenter Description\n      secAuthProtection: false\n  nfsLan:\n    type: ionoscloud:compute:Lan\n    properties:\n      datacenterId: ${nfsDc.id}\n      public: false\n  example:\n    type: ionoscloud:nfs:Cluster\n    properties:\n      location: de/txl\n      size: 2\n      nfs:\n        minVersion: '4.2'\n      connections:\n        datacenterId: ${nfsDc.id}\n        ipAddress: 192.168.100.10/24\n        lan: ${nfsLan.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nA Network File Storage Cluster resource can be imported using its `location` and `resource id`:\n\n```sh\n$ pulumi import ionoscloud:nfs/cluster:Cluster name {location}:{uuid}\n```\n\n",
            "properties": {
                "connections": {
                    "$ref": "#/types/ionoscloud:nfs/ClusterConnections:ClusterConnections",
                    "description": "The network connections for the Network File Storage Cluster.\n"
                },
                "location": {
                    "type": "string",
                    "description": "The location where the Network File Storage cluster is located.\n- `de/fra` - Frankfurt\n- `de/txl` - Berlin\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Network File Storage cluster.\n"
                },
                "nfs": {
                    "$ref": "#/types/ionoscloud:nfs/ClusterNfs:ClusterNfs"
                },
                "size": {
                    "type": "integer",
                    "description": "The size of the Network File Storage cluster in TiB. Note that the cluster size cannot be reduced after provisioning. This value determines the billing fees. Default is `2`. The minimum value is `2` and the maximum value is `42`.\n"
                }
            },
            "required": [
                "connections",
                "location",
                "name",
                "size"
            ],
            "inputProperties": {
                "connections": {
                    "$ref": "#/types/ionoscloud:nfs/ClusterConnections:ClusterConnections",
                    "description": "The network connections for the Network File Storage Cluster.\n"
                },
                "location": {
                    "type": "string",
                    "description": "The location where the Network File Storage cluster is located.\n- `de/fra` - Frankfurt\n- `de/txl` - Berlin\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Network File Storage cluster.\n"
                },
                "nfs": {
                    "$ref": "#/types/ionoscloud:nfs/ClusterNfs:ClusterNfs"
                },
                "size": {
                    "type": "integer",
                    "description": "The size of the Network File Storage cluster in TiB. Note that the cluster size cannot be reduced after provisioning. This value determines the billing fees. Default is `2`. The minimum value is `2` and the maximum value is `42`.\n"
                }
            },
            "requiredInputs": [
                "connections",
                "location",
                "size"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Cluster resources.\n",
                "properties": {
                    "connections": {
                        "$ref": "#/types/ionoscloud:nfs/ClusterConnections:ClusterConnections",
                        "description": "The network connections for the Network File Storage Cluster.\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "The location where the Network File Storage cluster is located.\n- `de/fra` - Frankfurt\n- `de/txl` - Berlin\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the Network File Storage cluster.\n"
                    },
                    "nfs": {
                        "$ref": "#/types/ionoscloud:nfs/ClusterNfs:ClusterNfs"
                    },
                    "size": {
                        "type": "integer",
                        "description": "The size of the Network File Storage cluster in TiB. Note that the cluster size cannot be reduced after provisioning. This value determines the billing fees. Default is `2`. The minimum value is `2` and the maximum value is `42`.\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:nfs/share:Share": {
            "description": "Creates and manages Network File Storage (NFS) Share objects on IonosCloud.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\n// Basic example\nconst nfsDc = new ionoscloud.compute.Datacenter(\"nfsDc\", {\n    location: \"de/txl\",\n    description: \"Datacenter Description\",\n    secAuthProtection: false,\n});\nconst nfsLan = new ionoscloud.compute.Lan(\"nfsLan\", {\n    datacenterId: nfsDc.id,\n    \"public\": false,\n});\nconst exampleCluster = new ionoscloud.nfs.Cluster(\"exampleCluster\", {\n    location: \"de/txl\",\n    size: 2,\n    nfs: {\n        minVersion: \"4.2\",\n    },\n    connections: {\n        datacenterId: nfsDc.id,\n        ipAddress: \"192.168.100.10/24\",\n        lan: nfsLan.id,\n    },\n});\nconst exampleShare = new ionoscloud.nfs.Share(\"exampleShare\", {\n    location: \"de/txl\",\n    clusterId: exampleCluster.id,\n    quota: 512,\n    gid: 512,\n    uid: 512,\n    clientGroups: [{\n        description: \"Client Group 1\",\n        ipNetworks: [\"10.234.50.0/24\"],\n        hosts: [\"10.234.62.123\"],\n        nfs: {\n            squash: \"all-anonymous\",\n        },\n    }],\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\n# Basic example\nnfs_dc = ionoscloud.compute.Datacenter(\"nfsDc\",\n    location=\"de/txl\",\n    description=\"Datacenter Description\",\n    sec_auth_protection=False)\nnfs_lan = ionoscloud.compute.Lan(\"nfsLan\",\n    datacenter_id=nfs_dc.id,\n    public=False)\nexample_cluster = ionoscloud.nfs.Cluster(\"exampleCluster\",\n    location=\"de/txl\",\n    size=2,\n    nfs={\n        \"min_version\": \"4.2\",\n    },\n    connections={\n        \"datacenter_id\": nfs_dc.id,\n        \"ip_address\": \"192.168.100.10/24\",\n        \"lan\": nfs_lan.id,\n    })\nexample_share = ionoscloud.nfs.Share(\"exampleShare\",\n    location=\"de/txl\",\n    cluster_id=example_cluster.id,\n    quota=512,\n    gid=512,\n    uid=512,\n    client_groups=[{\n        \"description\": \"Client Group 1\",\n        \"ip_networks\": [\"10.234.50.0/24\"],\n        \"hosts\": [\"10.234.62.123\"],\n        \"nfs\": {\n            \"squash\": \"all-anonymous\",\n        },\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Basic example\n    var nfsDc = new Ionoscloud.Compute.Datacenter(\"nfsDc\", new()\n    {\n        Location = \"de/txl\",\n        Description = \"Datacenter Description\",\n        SecAuthProtection = false,\n    });\n\n    var nfsLan = new Ionoscloud.Compute.Lan(\"nfsLan\", new()\n    {\n        DatacenterId = nfsDc.Id,\n        Public = false,\n    });\n\n    var exampleCluster = new Ionoscloud.Nfs.Cluster(\"exampleCluster\", new()\n    {\n        Location = \"de/txl\",\n        Size = 2,\n        Nfs = new Ionoscloud.Nfs.Inputs.ClusterNfsArgs\n        {\n            MinVersion = \"4.2\",\n        },\n        Connections = new Ionoscloud.Nfs.Inputs.ClusterConnectionsArgs\n        {\n            DatacenterId = nfsDc.Id,\n            IpAddress = \"192.168.100.10/24\",\n            Lan = nfsLan.Id,\n        },\n    });\n\n    var exampleShare = new Ionoscloud.Nfs.Share(\"exampleShare\", new()\n    {\n        Location = \"de/txl\",\n        ClusterId = exampleCluster.Id,\n        Quota = 512,\n        Gid = 512,\n        Uid = 512,\n        ClientGroups = new[]\n        {\n            new Ionoscloud.Nfs.Inputs.ShareClientGroupArgs\n            {\n                Description = \"Client Group 1\",\n                IpNetworks = new[]\n                {\n                    \"10.234.50.0/24\",\n                },\n                Hosts = new[]\n                {\n                    \"10.234.62.123\",\n                },\n                Nfs = new Ionoscloud.Nfs.Inputs.ShareClientGroupNfsArgs\n                {\n                    Squash = \"all-anonymous\",\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/nfs\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Basic example\n\t\tnfsDc, err := compute.NewDatacenter(ctx, \"nfsDc\", \u0026compute.DatacenterArgs{\n\t\t\tLocation:          pulumi.String(\"de/txl\"),\n\t\t\tDescription:       pulumi.String(\"Datacenter Description\"),\n\t\t\tSecAuthProtection: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tnfsLan, err := compute.NewLan(ctx, \"nfsLan\", \u0026compute.LanArgs{\n\t\t\tDatacenterId: nfsDc.ID(),\n\t\t\tPublic:       pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleCluster, err := nfs.NewCluster(ctx, \"exampleCluster\", \u0026nfs.ClusterArgs{\n\t\t\tLocation: pulumi.String(\"de/txl\"),\n\t\t\tSize:     pulumi.Int(2),\n\t\t\tNfs: \u0026nfs.ClusterNfsArgs{\n\t\t\t\tMinVersion: pulumi.String(\"4.2\"),\n\t\t\t},\n\t\t\tConnections: \u0026nfs.ClusterConnectionsArgs{\n\t\t\t\tDatacenterId: nfsDc.ID(),\n\t\t\t\tIpAddress:    pulumi.String(\"192.168.100.10/24\"),\n\t\t\t\tLan:          nfsLan.ID(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = nfs.NewShare(ctx, \"exampleShare\", \u0026nfs.ShareArgs{\n\t\t\tLocation:  pulumi.String(\"de/txl\"),\n\t\t\tClusterId: exampleCluster.ID(),\n\t\t\tQuota:     pulumi.Int(512),\n\t\t\tGid:       pulumi.Int(512),\n\t\t\tUid:       pulumi.Int(512),\n\t\t\tClientGroups: nfs.ShareClientGroupArray{\n\t\t\t\t\u0026nfs.ShareClientGroupArgs{\n\t\t\t\t\tDescription: pulumi.String(\"Client Group 1\"),\n\t\t\t\t\tIpNetworks: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"10.234.50.0/24\"),\n\t\t\t\t\t},\n\t\t\t\t\tHosts: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"10.234.62.123\"),\n\t\t\t\t\t},\n\t\t\t\t\tNfs: \u0026nfs.ShareClientGroupNfsArgs{\n\t\t\t\t\t\tSquash: pulumi.String(\"all-anonymous\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.Datacenter;\nimport com.pulumi.ionoscloud.compute.DatacenterArgs;\nimport com.pulumi.ionoscloud.compute.Lan;\nimport com.pulumi.ionoscloud.compute.LanArgs;\nimport com.pulumi.ionoscloud.nfs.Cluster;\nimport com.pulumi.ionoscloud.nfs.ClusterArgs;\nimport com.pulumi.ionoscloud.nfs.inputs.ClusterNfsArgs;\nimport com.pulumi.ionoscloud.nfs.inputs.ClusterConnectionsArgs;\nimport com.pulumi.ionoscloud.nfs.Share;\nimport com.pulumi.ionoscloud.nfs.ShareArgs;\nimport com.pulumi.ionoscloud.nfs.inputs.ShareClientGroupArgs;\nimport com.pulumi.ionoscloud.nfs.inputs.ShareClientGroupNfsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Basic example\n        var nfsDc = new Datacenter(\"nfsDc\", DatacenterArgs.builder()\n            .location(\"de/txl\")\n            .description(\"Datacenter Description\")\n            .secAuthProtection(false)\n            .build());\n\n        var nfsLan = new Lan(\"nfsLan\", LanArgs.builder()\n            .datacenterId(nfsDc.id())\n            .public_(false)\n            .build());\n\n        var exampleCluster = new Cluster(\"exampleCluster\", ClusterArgs.builder()\n            .location(\"de/txl\")\n            .size(2)\n            .nfs(ClusterNfsArgs.builder()\n                .minVersion(\"4.2\")\n                .build())\n            .connections(ClusterConnectionsArgs.builder()\n                .datacenterId(nfsDc.id())\n                .ipAddress(\"192.168.100.10/24\")\n                .lan(nfsLan.id())\n                .build())\n            .build());\n\n        var exampleShare = new Share(\"exampleShare\", ShareArgs.builder()\n            .location(\"de/txl\")\n            .clusterId(exampleCluster.id())\n            .quota(512)\n            .gid(512)\n            .uid(512)\n            .clientGroups(ShareClientGroupArgs.builder()\n                .description(\"Client Group 1\")\n                .ipNetworks(\"10.234.50.0/24\")\n                .hosts(\"10.234.62.123\")\n                .nfs(ShareClientGroupNfsArgs.builder()\n                    .squash(\"all-anonymous\")\n                    .build())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Basic example\n  nfsDc:\n    type: ionoscloud:compute:Datacenter\n    properties:\n      location: de/txl\n      description: Datacenter Description\n      secAuthProtection: false\n  nfsLan:\n    type: ionoscloud:compute:Lan\n    properties:\n      datacenterId: ${nfsDc.id}\n      public: false\n  exampleCluster:\n    type: ionoscloud:nfs:Cluster\n    properties:\n      location: de/txl\n      size: 2\n      nfs:\n        minVersion: '4.2'\n      connections:\n        datacenterId: ${nfsDc.id}\n        ipAddress: 192.168.100.10/24\n        lan: ${nfsLan.id}\n  exampleShare:\n    type: ionoscloud:nfs:Share\n    properties:\n      location: de/txl\n      clusterId: ${exampleCluster.id}\n      quota: 512\n      gid: 512\n      uid: 512\n      clientGroups:\n        - description: Client Group 1\n          ipNetworks:\n            - 10.234.50.0/24\n          hosts:\n            - 10.234.62.123\n          nfs:\n            squash: all-anonymous\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nA Network File Storage Share resource can be imported using its `location`, `cluster_id` and `resource id`:\n\n```sh\n$ pulumi import ionoscloud:nfs/share:Share name location:cluster_id:resource_id\n```\n\n",
            "properties": {
                "clientGroups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:nfs/ShareClientGroup:ShareClientGroup"
                    },
                    "description": "The groups of clients are the systems connecting to the Network File Storage cluster. Each group includes:\n"
                },
                "clusterId": {
                    "type": "string",
                    "description": "The ID of the Network File Storage Cluster.\n"
                },
                "gid": {
                    "type": "integer",
                    "description": "The group ID that will own the exported directory. If not set, **anonymous** (`512`) will be used.\n"
                },
                "location": {
                    "type": "string",
                    "description": "The location of the Network File Storage Cluster.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The directory being exported.\n"
                },
                "nfsPath": {
                    "type": "string",
                    "description": "Path to the NFS export. The NFS path is the path to the directory being exported.\n"
                },
                "quota": {
                    "type": "integer",
                    "description": "The quota in MiB for the export. The quota can restrict the amount of data that can be stored within the export. The quota can be disabled using `0`. Default is `0`.\n"
                },
                "uid": {
                    "type": "integer",
                    "description": "The user ID that will own the exported directory. If not set, **anonymous** (`512`) will be used.\n"
                }
            },
            "required": [
                "clientGroups",
                "clusterId",
                "location",
                "name",
                "nfsPath"
            ],
            "inputProperties": {
                "clientGroups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:nfs/ShareClientGroup:ShareClientGroup"
                    },
                    "description": "The groups of clients are the systems connecting to the Network File Storage cluster. Each group includes:\n"
                },
                "clusterId": {
                    "type": "string",
                    "description": "The ID of the Network File Storage Cluster.\n",
                    "willReplaceOnChanges": true
                },
                "gid": {
                    "type": "integer",
                    "description": "The group ID that will own the exported directory. If not set, **anonymous** (`512`) will be used.\n"
                },
                "location": {
                    "type": "string",
                    "description": "The location of the Network File Storage Cluster.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The directory being exported.\n"
                },
                "quota": {
                    "type": "integer",
                    "description": "The quota in MiB for the export. The quota can restrict the amount of data that can be stored within the export. The quota can be disabled using `0`. Default is `0`.\n"
                },
                "uid": {
                    "type": "integer",
                    "description": "The user ID that will own the exported directory. If not set, **anonymous** (`512`) will be used.\n"
                }
            },
            "requiredInputs": [
                "clientGroups",
                "clusterId",
                "location"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Share resources.\n",
                "properties": {
                    "clientGroups": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:nfs/ShareClientGroup:ShareClientGroup"
                        },
                        "description": "The groups of clients are the systems connecting to the Network File Storage cluster. Each group includes:\n"
                    },
                    "clusterId": {
                        "type": "string",
                        "description": "The ID of the Network File Storage Cluster.\n",
                        "willReplaceOnChanges": true
                    },
                    "gid": {
                        "type": "integer",
                        "description": "The group ID that will own the exported directory. If not set, **anonymous** (`512`) will be used.\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "The location of the Network File Storage Cluster.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The directory being exported.\n"
                    },
                    "nfsPath": {
                        "type": "string",
                        "description": "Path to the NFS export. The NFS path is the path to the directory being exported.\n"
                    },
                    "quota": {
                        "type": "integer",
                        "description": "The quota in MiB for the export. The quota can restrict the amount of data that can be stored within the export. The quota can be disabled using `0`. Default is `0`.\n"
                    },
                    "uid": {
                        "type": "integer",
                        "description": "The user ID that will own the exported directory. If not set, **anonymous** (`512`) will be used.\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:nlb/balancer:Balancer": {
            "description": "Manages a **Network Load Balancer**  on IonosCloud.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst exampleDatacenter = new ionoscloud.compute.Datacenter(\"exampleDatacenter\", {\n    location: \"us/las\",\n    description: \"Datacenter Description\",\n    secAuthProtection: false,\n});\nconst example1 = new ionoscloud.compute.Lan(\"example1\", {\n    datacenterId: exampleDatacenter.id,\n    \"public\": false,\n});\nconst example2 = new ionoscloud.compute.Lan(\"example2\", {\n    datacenterId: exampleDatacenter.id,\n    \"public\": false,\n});\nconst exampleBalancer = new ionoscloud.nlb.Balancer(\"exampleBalancer\", {\n    datacenterId: exampleDatacenter.id,\n    listenerLan: example1.id,\n    targetLan: example2.id,\n    ips: [\"10.12.118.224\"],\n    lbPrivateIps: [\"10.13.72.225/24\"],\n    centralLogging: true,\n    loggingFormat: \"%{+Q}o %{-Q}ci - - [%trg] %r %ST %B \\\"\\\" \\\"\\\" %cp %ms %ft %b %s %TR %Tw %Tc %Tr %Ta %tsc %ac %fc %bc %sc %rc %sq %bq %CC %CS %hrl %hsl\",\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\nexample_datacenter = ionoscloud.compute.Datacenter(\"exampleDatacenter\",\n    location=\"us/las\",\n    description=\"Datacenter Description\",\n    sec_auth_protection=False)\nexample1 = ionoscloud.compute.Lan(\"example1\",\n    datacenter_id=example_datacenter.id,\n    public=False)\nexample2 = ionoscloud.compute.Lan(\"example2\",\n    datacenter_id=example_datacenter.id,\n    public=False)\nexample_balancer = ionoscloud.nlb.Balancer(\"exampleBalancer\",\n    datacenter_id=example_datacenter.id,\n    listener_lan=example1.id,\n    target_lan=example2.id,\n    ips=[\"10.12.118.224\"],\n    lb_private_ips=[\"10.13.72.225/24\"],\n    central_logging=True,\n    logging_format=\"%{+Q}o %{-Q}ci - - [%trg] %r %ST %B \\\"\\\" \\\"\\\" %cp %ms %ft %b %s %TR %Tw %Tc %Tr %Ta %tsc %ac %fc %bc %sc %rc %sq %bq %CC %CS %hrl %hsl\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleDatacenter = new Ionoscloud.Compute.Datacenter(\"exampleDatacenter\", new()\n    {\n        Location = \"us/las\",\n        Description = \"Datacenter Description\",\n        SecAuthProtection = false,\n    });\n\n    var example1 = new Ionoscloud.Compute.Lan(\"example1\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        Public = false,\n    });\n\n    var example2 = new Ionoscloud.Compute.Lan(\"example2\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        Public = false,\n    });\n\n    var exampleBalancer = new Ionoscloud.Nlb.Balancer(\"exampleBalancer\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        ListenerLan = example1.Id,\n        TargetLan = example2.Id,\n        Ips = new[]\n        {\n            \"10.12.118.224\",\n        },\n        LbPrivateIps = new[]\n        {\n            \"10.13.72.225/24\",\n        },\n        CentralLogging = true,\n        LoggingFormat = \"%{+Q}o %{-Q}ci - - [%trg] %r %ST %B \\\"\\\" \\\"\\\" %cp %ms %ft %b %s %TR %Tw %Tc %Tr %Ta %tsc %ac %fc %bc %sc %rc %sq %bq %CC %CS %hrl %hsl\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/nlb\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleDatacenter, err := compute.NewDatacenter(ctx, \"exampleDatacenter\", \u0026compute.DatacenterArgs{\n\t\t\tLocation:          pulumi.String(\"us/las\"),\n\t\t\tDescription:       pulumi.String(\"Datacenter Description\"),\n\t\t\tSecAuthProtection: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texample1, err := compute.NewLan(ctx, \"example1\", \u0026compute.LanArgs{\n\t\t\tDatacenterId: exampleDatacenter.ID(),\n\t\t\tPublic:       pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texample2, err := compute.NewLan(ctx, \"example2\", \u0026compute.LanArgs{\n\t\t\tDatacenterId: exampleDatacenter.ID(),\n\t\t\tPublic:       pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = nlb.NewBalancer(ctx, \"exampleBalancer\", \u0026nlb.BalancerArgs{\n\t\t\tDatacenterId: exampleDatacenter.ID(),\n\t\t\tListenerLan:  example1.ID(),\n\t\t\tTargetLan:    example2.ID(),\n\t\t\tIps: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"10.12.118.224\"),\n\t\t\t},\n\t\t\tLbPrivateIps: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"10.13.72.225/24\"),\n\t\t\t},\n\t\t\tCentralLogging: pulumi.Bool(true),\n\t\t\tLoggingFormat:  pulumi.String(\"%{+Q}o %{-Q}ci - - [%trg] %r %ST %B \\\"\\\" \\\"\\\" %cp %ms %ft %b %s %TR %Tw %Tc %Tr %Ta %tsc %ac %fc %bc %sc %rc %sq %bq %CC %CS %hrl %hsl\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.Datacenter;\nimport com.pulumi.ionoscloud.compute.DatacenterArgs;\nimport com.pulumi.ionoscloud.compute.Lan;\nimport com.pulumi.ionoscloud.compute.LanArgs;\nimport com.pulumi.ionoscloud.nlb.Balancer;\nimport com.pulumi.ionoscloud.nlb.BalancerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleDatacenter = new Datacenter(\"exampleDatacenter\", DatacenterArgs.builder()\n            .location(\"us/las\")\n            .description(\"Datacenter Description\")\n            .secAuthProtection(false)\n            .build());\n\n        var example1 = new Lan(\"example1\", LanArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .public_(false)\n            .build());\n\n        var example2 = new Lan(\"example2\", LanArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .public_(false)\n            .build());\n\n        var exampleBalancer = new Balancer(\"exampleBalancer\", BalancerArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .listenerLan(example1.id())\n            .targetLan(example2.id())\n            .ips(\"10.12.118.224\")\n            .lbPrivateIps(\"10.13.72.225/24\")\n            .centralLogging(true)\n            .loggingFormat(\"%{+Q}o %{-Q}ci - - [%trg] %r %ST %B \\\"\\\" \\\"\\\" %cp %ms %ft %b %s %TR %Tw %Tc %Tr %Ta %tsc %ac %fc %bc %sc %rc %sq %bq %CC %CS %hrl %hsl\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleDatacenter:\n    type: ionoscloud:compute:Datacenter\n    properties:\n      location: us/las\n      description: Datacenter Description\n      secAuthProtection: false\n  example1:\n    type: ionoscloud:compute:Lan\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      public: false\n  example2:\n    type: ionoscloud:compute:Lan\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      public: false\n  exampleBalancer:\n    type: ionoscloud:nlb:Balancer\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      listenerLan: ${example1.id}\n      targetLan: ${example2.id}\n      ips:\n        - 10.12.118.224\n      lbPrivateIps:\n        - 10.13.72.225/24\n      centralLogging: true\n      loggingFormat: '%{+Q}o %{-Q}ci - - [%trg] %r %ST %B \"\" \"\" %cp %ms %ft %b %s %TR %Tw %Tc %Tr %Ta %tsc %ac %fc %bc %sc %rc %sq %bq %CC %CS %hrl %hsl'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Example configuring Flowlog\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = new ionoscloud.nlb.Balancer(\"example\", {\n    datacenterId: ionoscloud_datacenter.example.id,\n    listenerLan: ionoscloud_lan.example1.id,\n    targetLan: ionoscloud_lan.example2.id,\n    ips: [\"10.12.118.224\"],\n    lbPrivateIps: [\"10.13.72.225/24\"],\n    flowlog: {\n        action: \"ALL\",\n        bucket: \"flowlog-bucket\",\n        direction: \"INGRESS\",\n        name: \"flowlog\",\n    },\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\nexample = ionoscloud.nlb.Balancer(\"example\",\n    datacenter_id=ionoscloud_datacenter[\"example\"][\"id\"],\n    listener_lan=ionoscloud_lan[\"example1\"][\"id\"],\n    target_lan=ionoscloud_lan[\"example2\"][\"id\"],\n    ips=[\"10.12.118.224\"],\n    lb_private_ips=[\"10.13.72.225/24\"],\n    flowlog={\n        \"action\": \"ALL\",\n        \"bucket\": \"flowlog-bucket\",\n        \"direction\": \"INGRESS\",\n        \"name\": \"flowlog\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Ionoscloud.Nlb.Balancer(\"example\", new()\n    {\n        DatacenterId = ionoscloud_datacenter.Example.Id,\n        ListenerLan = ionoscloud_lan.Example1.Id,\n        TargetLan = ionoscloud_lan.Example2.Id,\n        Ips = new[]\n        {\n            \"10.12.118.224\",\n        },\n        LbPrivateIps = new[]\n        {\n            \"10.13.72.225/24\",\n        },\n        Flowlog = new Ionoscloud.Nlb.Inputs.BalancerFlowlogArgs\n        {\n            Action = \"ALL\",\n            Bucket = \"flowlog-bucket\",\n            Direction = \"INGRESS\",\n            Name = \"flowlog\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/nlb\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := nlb.NewBalancer(ctx, \"example\", \u0026nlb.BalancerArgs{\n\t\t\tDatacenterId: pulumi.Any(ionoscloud_datacenter.Example.Id),\n\t\t\tListenerLan:  pulumi.Any(ionoscloud_lan.Example1.Id),\n\t\t\tTargetLan:    pulumi.Any(ionoscloud_lan.Example2.Id),\n\t\t\tIps: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"10.12.118.224\"),\n\t\t\t},\n\t\t\tLbPrivateIps: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"10.13.72.225/24\"),\n\t\t\t},\n\t\t\tFlowlog: \u0026nlb.BalancerFlowlogArgs{\n\t\t\t\tAction:    pulumi.String(\"ALL\"),\n\t\t\t\tBucket:    pulumi.String(\"flowlog-bucket\"),\n\t\t\t\tDirection: pulumi.String(\"INGRESS\"),\n\t\t\t\tName:      pulumi.String(\"flowlog\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.nlb.Balancer;\nimport com.pulumi.ionoscloud.nlb.BalancerArgs;\nimport com.pulumi.ionoscloud.nlb.inputs.BalancerFlowlogArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new Balancer(\"example\", BalancerArgs.builder()\n            .datacenterId(ionoscloud_datacenter.example().id())\n            .listenerLan(ionoscloud_lan.example1().id())\n            .targetLan(ionoscloud_lan.example2().id())\n            .ips(\"10.12.118.224\")\n            .lbPrivateIps(\"10.13.72.225/24\")\n            .flowlog(BalancerFlowlogArgs.builder()\n                .action(\"ALL\")\n                .bucket(\"flowlog-bucket\")\n                .direction(\"INGRESS\")\n                .name(\"flowlog\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: ionoscloud:nlb:Balancer\n    properties:\n      datacenterId: ${ionoscloud_datacenter.example.id}\n      listenerLan: ${ionoscloud_lan.example1.id}\n      targetLan: ${ionoscloud_lan.example2.id}\n      ips:\n        - 10.12.118.224\n      lbPrivateIps:\n        - 10.13.72.225/24\n      flowlog:\n        action: ALL\n        bucket: flowlog-bucket\n        direction: INGRESS\n        name: flowlog\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nThis will configure flowlog for ALL(rejected and accepted) ingress traffic and will log it into an existing ionos bucket named `flowlog-bucket`. Any s3 compatible client can be used to create it. Adding a flowlog does not force re-creation or the nic, but changing any other field than\n`name` will. Deleting a flowlog will also force nic re-creation.\n\n## Import\n\nA Network Load Balancer resource can be imported using its `resource id` and the `datacenter id` e.g.\n\n```sh\n$ pulumi import ionoscloud:nlb/balancer:Balancer my_networkloadbalancer {datacenter uuid}/{networkloadbalancer uuid}\n```\n\n",
            "properties": {
                "centralLogging": {
                    "type": "boolean",
                    "description": "[bool] Turn logging on and off for this product. Default value is 'false'.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "[string] A Datacenter's UUID.\n"
                },
                "flowlog": {
                    "$ref": "#/types/ionoscloud:nlb/BalancerFlowlog:BalancerFlowlog",
                    "description": "[list] Only 1 flow log can be configured. Only the name field can change as part of an update. Flow logs holistically capture network information such as source and destination IP addresses, source and destination ports, number of packets, amount of bytes, the start and end time of the recording, and the type of protocol – and log the extent to which your instances are being accessed.\n"
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] Collection of IP addresses of the Network Load Balancer. (inbound and outbound) IP of the listenerLan must be a customer reserved IP for the public load balancer and private IP for the private load balancer.\n"
                },
                "lbPrivateIps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] Collection of private IP addresses with subnet mask of the Network Load Balancer. IPs must contain valid subnet mask. If user will not provide any IP then the system will generate one IP with /24 subnet.\n"
                },
                "listenerLan": {
                    "type": "integer",
                    "description": "[int] Id of the listening LAN. (inbound)\n"
                },
                "loggingFormat": {
                    "type": "string",
                    "description": "Specifies the format of the logs.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] A name of that Network Load Balancer.\n"
                },
                "targetLan": {
                    "type": "integer",
                    "description": "[int] Id of the balanced private target LAN. (outbound)\n"
                }
            },
            "required": [
                "datacenterId",
                "lbPrivateIps",
                "listenerLan",
                "name",
                "targetLan"
            ],
            "inputProperties": {
                "centralLogging": {
                    "type": "boolean",
                    "description": "[bool] Turn logging on and off for this product. Default value is 'false'.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "[string] A Datacenter's UUID.\n",
                    "willReplaceOnChanges": true
                },
                "flowlog": {
                    "$ref": "#/types/ionoscloud:nlb/BalancerFlowlog:BalancerFlowlog",
                    "description": "[list] Only 1 flow log can be configured. Only the name field can change as part of an update. Flow logs holistically capture network information such as source and destination IP addresses, source and destination ports, number of packets, amount of bytes, the start and end time of the recording, and the type of protocol – and log the extent to which your instances are being accessed.\n"
                },
                "ips": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] Collection of IP addresses of the Network Load Balancer. (inbound and outbound) IP of the listenerLan must be a customer reserved IP for the public load balancer and private IP for the private load balancer.\n"
                },
                "lbPrivateIps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] Collection of private IP addresses with subnet mask of the Network Load Balancer. IPs must contain valid subnet mask. If user will not provide any IP then the system will generate one IP with /24 subnet.\n"
                },
                "listenerLan": {
                    "type": "integer",
                    "description": "[int] Id of the listening LAN. (inbound)\n"
                },
                "loggingFormat": {
                    "type": "string",
                    "description": "Specifies the format of the logs.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] A name of that Network Load Balancer.\n"
                },
                "targetLan": {
                    "type": "integer",
                    "description": "[int] Id of the balanced private target LAN. (outbound)\n"
                }
            },
            "requiredInputs": [
                "datacenterId",
                "listenerLan",
                "targetLan"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Balancer resources.\n",
                "properties": {
                    "centralLogging": {
                        "type": "boolean",
                        "description": "[bool] Turn logging on and off for this product. Default value is 'false'.\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "[string] A Datacenter's UUID.\n",
                        "willReplaceOnChanges": true
                    },
                    "flowlog": {
                        "$ref": "#/types/ionoscloud:nlb/BalancerFlowlog:BalancerFlowlog",
                        "description": "[list] Only 1 flow log can be configured. Only the name field can change as part of an update. Flow logs holistically capture network information such as source and destination IP addresses, source and destination ports, number of packets, amount of bytes, the start and end time of the recording, and the type of protocol – and log the extent to which your instances are being accessed.\n"
                    },
                    "ips": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "[list] Collection of IP addresses of the Network Load Balancer. (inbound and outbound) IP of the listenerLan must be a customer reserved IP for the public load balancer and private IP for the private load balancer.\n"
                    },
                    "lbPrivateIps": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "[list] Collection of private IP addresses with subnet mask of the Network Load Balancer. IPs must contain valid subnet mask. If user will not provide any IP then the system will generate one IP with /24 subnet.\n"
                    },
                    "listenerLan": {
                        "type": "integer",
                        "description": "[int] Id of the listening LAN. (inbound)\n"
                    },
                    "loggingFormat": {
                        "type": "string",
                        "description": "Specifies the format of the logs.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] A name of that Network Load Balancer.\n"
                    },
                    "targetLan": {
                        "type": "integer",
                        "description": "[int] Id of the balanced private target LAN. (outbound)\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:nlb/forwardingRule:ForwardingRule": {
            "description": "Manages a **Network Load Balancer Forwarding Rule** on IonosCloud.\n\n## Example Usage\n\n### \n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst exampleDatacenter = new ionoscloud.compute.Datacenter(\"exampleDatacenter\", {\n    location: \"us/las\",\n    description: \"Datacenter Description\",\n    secAuthProtection: false,\n});\nconst example1 = new ionoscloud.compute.Lan(\"example1\", {\n    datacenterId: exampleDatacenter.id,\n    \"public\": false,\n});\nconst example2 = new ionoscloud.compute.Lan(\"example2\", {\n    datacenterId: exampleDatacenter.id,\n    \"public\": false,\n});\nconst exampleBalancer = new ionoscloud.nlb.Balancer(\"exampleBalancer\", {\n    datacenterId: exampleDatacenter.id,\n    listenerLan: example1.id,\n    targetLan: example2.id,\n    ips: [\"10.12.118.224\"],\n    lbPrivateIps: [\"10.13.72.225/24\"],\n});\nconst exampleForwardingRule = new ionoscloud.nlb.ForwardingRule(\"exampleForwardingRule\", {\n    datacenterId: exampleDatacenter.id,\n    networkloadbalancerId: exampleBalancer.id,\n    algorithm: \"SOURCE_IP\",\n    protocol: \"TCP\",\n    listenerIp: \"10.12.118.224\",\n    listenerPort: 8081,\n    targets: [{\n        ip: \"22.231.2.2\",\n        port: 8080,\n        weight: 123,\n        proxyProtocol: \"v1\",\n        healthCheck: {\n            check: true,\n            checkInterval: 1000,\n        },\n    }],\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\nexample_datacenter = ionoscloud.compute.Datacenter(\"exampleDatacenter\",\n    location=\"us/las\",\n    description=\"Datacenter Description\",\n    sec_auth_protection=False)\nexample1 = ionoscloud.compute.Lan(\"example1\",\n    datacenter_id=example_datacenter.id,\n    public=False)\nexample2 = ionoscloud.compute.Lan(\"example2\",\n    datacenter_id=example_datacenter.id,\n    public=False)\nexample_balancer = ionoscloud.nlb.Balancer(\"exampleBalancer\",\n    datacenter_id=example_datacenter.id,\n    listener_lan=example1.id,\n    target_lan=example2.id,\n    ips=[\"10.12.118.224\"],\n    lb_private_ips=[\"10.13.72.225/24\"])\nexample_forwarding_rule = ionoscloud.nlb.ForwardingRule(\"exampleForwardingRule\",\n    datacenter_id=example_datacenter.id,\n    networkloadbalancer_id=example_balancer.id,\n    algorithm=\"SOURCE_IP\",\n    protocol=\"TCP\",\n    listener_ip=\"10.12.118.224\",\n    listener_port=8081,\n    targets=[{\n        \"ip\": \"22.231.2.2\",\n        \"port\": 8080,\n        \"weight\": 123,\n        \"proxy_protocol\": \"v1\",\n        \"health_check\": {\n            \"check\": True,\n            \"check_interval\": 1000,\n        },\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleDatacenter = new Ionoscloud.Compute.Datacenter(\"exampleDatacenter\", new()\n    {\n        Location = \"us/las\",\n        Description = \"Datacenter Description\",\n        SecAuthProtection = false,\n    });\n\n    var example1 = new Ionoscloud.Compute.Lan(\"example1\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        Public = false,\n    });\n\n    var example2 = new Ionoscloud.Compute.Lan(\"example2\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        Public = false,\n    });\n\n    var exampleBalancer = new Ionoscloud.Nlb.Balancer(\"exampleBalancer\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        ListenerLan = example1.Id,\n        TargetLan = example2.Id,\n        Ips = new[]\n        {\n            \"10.12.118.224\",\n        },\n        LbPrivateIps = new[]\n        {\n            \"10.13.72.225/24\",\n        },\n    });\n\n    var exampleForwardingRule = new Ionoscloud.Nlb.ForwardingRule(\"exampleForwardingRule\", new()\n    {\n        DatacenterId = exampleDatacenter.Id,\n        NetworkloadbalancerId = exampleBalancer.Id,\n        Algorithm = \"SOURCE_IP\",\n        Protocol = \"TCP\",\n        ListenerIp = \"10.12.118.224\",\n        ListenerPort = 8081,\n        Targets = new[]\n        {\n            new Ionoscloud.Nlb.Inputs.ForwardingRuleTargetArgs\n            {\n                Ip = \"22.231.2.2\",\n                Port = 8080,\n                Weight = 123,\n                ProxyProtocol = \"v1\",\n                HealthCheck = new Ionoscloud.Nlb.Inputs.ForwardingRuleTargetHealthCheckArgs\n                {\n                    Check = true,\n                    CheckInterval = 1000,\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/nlb\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleDatacenter, err := compute.NewDatacenter(ctx, \"exampleDatacenter\", \u0026compute.DatacenterArgs{\n\t\t\tLocation:          pulumi.String(\"us/las\"),\n\t\t\tDescription:       pulumi.String(\"Datacenter Description\"),\n\t\t\tSecAuthProtection: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texample1, err := compute.NewLan(ctx, \"example1\", \u0026compute.LanArgs{\n\t\t\tDatacenterId: exampleDatacenter.ID(),\n\t\t\tPublic:       pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texample2, err := compute.NewLan(ctx, \"example2\", \u0026compute.LanArgs{\n\t\t\tDatacenterId: exampleDatacenter.ID(),\n\t\t\tPublic:       pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleBalancer, err := nlb.NewBalancer(ctx, \"exampleBalancer\", \u0026nlb.BalancerArgs{\n\t\t\tDatacenterId: exampleDatacenter.ID(),\n\t\t\tListenerLan:  example1.ID(),\n\t\t\tTargetLan:    example2.ID(),\n\t\t\tIps: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"10.12.118.224\"),\n\t\t\t},\n\t\t\tLbPrivateIps: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"10.13.72.225/24\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = nlb.NewForwardingRule(ctx, \"exampleForwardingRule\", \u0026nlb.ForwardingRuleArgs{\n\t\t\tDatacenterId:          exampleDatacenter.ID(),\n\t\t\tNetworkloadbalancerId: exampleBalancer.ID(),\n\t\t\tAlgorithm:             pulumi.String(\"SOURCE_IP\"),\n\t\t\tProtocol:              pulumi.String(\"TCP\"),\n\t\t\tListenerIp:            pulumi.String(\"10.12.118.224\"),\n\t\t\tListenerPort:          pulumi.Int(8081),\n\t\t\tTargets: nlb.ForwardingRuleTargetArray{\n\t\t\t\t\u0026nlb.ForwardingRuleTargetArgs{\n\t\t\t\t\tIp:            pulumi.String(\"22.231.2.2\"),\n\t\t\t\t\tPort:          pulumi.Int(8080),\n\t\t\t\t\tWeight:        pulumi.Int(123),\n\t\t\t\t\tProxyProtocol: pulumi.String(\"v1\"),\n\t\t\t\t\tHealthCheck: \u0026nlb.ForwardingRuleTargetHealthCheckArgs{\n\t\t\t\t\t\tCheck:         pulumi.Bool(true),\n\t\t\t\t\t\tCheckInterval: pulumi.Int(1000),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.Datacenter;\nimport com.pulumi.ionoscloud.compute.DatacenterArgs;\nimport com.pulumi.ionoscloud.compute.Lan;\nimport com.pulumi.ionoscloud.compute.LanArgs;\nimport com.pulumi.ionoscloud.nlb.Balancer;\nimport com.pulumi.ionoscloud.nlb.BalancerArgs;\nimport com.pulumi.ionoscloud.nlb.ForwardingRule;\nimport com.pulumi.ionoscloud.nlb.ForwardingRuleArgs;\nimport com.pulumi.ionoscloud.nlb.inputs.ForwardingRuleTargetArgs;\nimport com.pulumi.ionoscloud.nlb.inputs.ForwardingRuleTargetHealthCheckArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleDatacenter = new Datacenter(\"exampleDatacenter\", DatacenterArgs.builder()\n            .location(\"us/las\")\n            .description(\"Datacenter Description\")\n            .secAuthProtection(false)\n            .build());\n\n        var example1 = new Lan(\"example1\", LanArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .public_(false)\n            .build());\n\n        var example2 = new Lan(\"example2\", LanArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .public_(false)\n            .build());\n\n        var exampleBalancer = new Balancer(\"exampleBalancer\", BalancerArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .listenerLan(example1.id())\n            .targetLan(example2.id())\n            .ips(\"10.12.118.224\")\n            .lbPrivateIps(\"10.13.72.225/24\")\n            .build());\n\n        var exampleForwardingRule = new ForwardingRule(\"exampleForwardingRule\", ForwardingRuleArgs.builder()\n            .datacenterId(exampleDatacenter.id())\n            .networkloadbalancerId(exampleBalancer.id())\n            .algorithm(\"SOURCE_IP\")\n            .protocol(\"TCP\")\n            .listenerIp(\"10.12.118.224\")\n            .listenerPort(\"8081\")\n            .targets(ForwardingRuleTargetArgs.builder()\n                .ip(\"22.231.2.2\")\n                .port(\"8080\")\n                .weight(\"123\")\n                .proxyProtocol(\"v1\")\n                .healthCheck(ForwardingRuleTargetHealthCheckArgs.builder()\n                    .check(true)\n                    .checkInterval(1000)\n                    .build())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleDatacenter:\n    type: ionoscloud:compute:Datacenter\n    properties:\n      location: us/las\n      description: Datacenter Description\n      secAuthProtection: false\n  example1:\n    type: ionoscloud:compute:Lan\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      public: false\n  example2:\n    type: ionoscloud:compute:Lan\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      public: false\n  exampleBalancer:\n    type: ionoscloud:nlb:Balancer\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      listenerLan: ${example1.id}\n      targetLan: ${example2.id}\n      ips:\n        - 10.12.118.224\n      lbPrivateIps:\n        - 10.13.72.225/24\n  exampleForwardingRule:\n    type: ionoscloud:nlb:ForwardingRule\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      networkloadbalancerId: ${exampleBalancer.id}\n      algorithm: SOURCE_IP\n      protocol: TCP\n      listenerIp: 10.12.118.224\n      listenerPort: '8081'\n      targets:\n        - ip: 22.231.2.2\n          port: '8080'\n          weight: '123'\n          proxyProtocol: v1\n          healthCheck:\n            check: true\n            checkInterval: 1000\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Usage with dynamic block for targets:\n\u003c!--Start PulumiCodeChooser --\u003e\n```yaml\nconfiguration:\n  iPs:\n    type: dynamic\n    default:\n      - 22.231.2.2\n      - 22.231.2.3\n      - 22.231.2.4\nresources:\n  exampleDatacenter:\n    type: ionoscloud:compute:Datacenter\n    properties:\n      location: us/las\n      description: Datacenter Description\n      secAuthProtection: false\n  example1:\n    type: ionoscloud:compute:Lan\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      public: false\n  example2:\n    type: ionoscloud:compute:Lan\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      public: false\n  exampleBalancer:\n    type: ionoscloud:nlb:Balancer\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      listenerLan: ${example1.id}\n      targetLan: ${example2.id}\n      ips:\n        - 10.12.118.224\n      lbPrivateIps:\n        - 10.13.72.225/24\n  exampleForwardingRule:\n    type: ionoscloud:nlb:ForwardingRule\n    properties:\n      datacenterId: ${exampleDatacenter.id}\n      networkloadbalancerId: ${exampleBalancer.id}\n      algorithm: SOURCE_IP\n      protocol: TCP\n      listenerIp: 10.12.118.224\n      listenerPort: '8081'\n      dynamic:\n        - forEach: ${iPs}\n          content:\n            - ip: ${targets.value}\n              port: '31234'\n              weight: '1'\n              healthCheck:\n                - check: true\n                  checkInterval: 1000\n                  maintenance: false\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nA Network Load Balancer Forwarding Rule resource can be imported using its `resource id`, the `datacenter id` and the `networkloadbalancer id` e.g.\n\n```sh\n$ pulumi import ionoscloud:nlb/forwardingRule:ForwardingRule my_networkloadbalancer_forwardingrule {datacenter uuid}/{networkloadbalancer uuid}/{networkloadbalancer_forwardingrule uuid}\n```\n\n",
            "properties": {
                "algorithm": {
                    "type": "string",
                    "description": "[string] Algorithm for the balancing.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "[string] A Datacenter's UUID.\n"
                },
                "healthCheck": {
                    "$ref": "#/types/ionoscloud:nlb/ForwardingRuleHealthCheck:ForwardingRuleHealthCheck",
                    "description": "Health check attributes for Network Load Balancer forwarding rule.\n"
                },
                "listenerIp": {
                    "type": "string",
                    "description": "[string] Listening IP. (inbound)\n"
                },
                "listenerPort": {
                    "type": "integer",
                    "description": "[int] Listening port number. (inbound) (range: 1 to 65535)\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] A name of that Network Load Balancer forwarding rule.\n"
                },
                "networkloadbalancerId": {
                    "type": "string"
                },
                "protocol": {
                    "type": "string",
                    "description": "[string] Protocol of the balancing.\n"
                },
                "targets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:nlb/ForwardingRuleTarget:ForwardingRuleTarget"
                    },
                    "description": "[Set] Array of items in that collection.\n"
                }
            },
            "required": [
                "algorithm",
                "datacenterId",
                "healthCheck",
                "listenerIp",
                "listenerPort",
                "name",
                "networkloadbalancerId",
                "protocol",
                "targets"
            ],
            "inputProperties": {
                "algorithm": {
                    "type": "string",
                    "description": "[string] Algorithm for the balancing.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "[string] A Datacenter's UUID.\n",
                    "willReplaceOnChanges": true
                },
                "healthCheck": {
                    "$ref": "#/types/ionoscloud:nlb/ForwardingRuleHealthCheck:ForwardingRuleHealthCheck",
                    "description": "Health check attributes for Network Load Balancer forwarding rule.\n"
                },
                "listenerIp": {
                    "type": "string",
                    "description": "[string] Listening IP. (inbound)\n"
                },
                "listenerPort": {
                    "type": "integer",
                    "description": "[int] Listening port number. (inbound) (range: 1 to 65535)\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] A name of that Network Load Balancer forwarding rule.\n"
                },
                "networkloadbalancerId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "protocol": {
                    "type": "string",
                    "description": "[string] Protocol of the balancing.\n"
                },
                "targets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:nlb/ForwardingRuleTarget:ForwardingRuleTarget"
                    },
                    "description": "[Set] Array of items in that collection.\n"
                }
            },
            "requiredInputs": [
                "algorithm",
                "datacenterId",
                "listenerIp",
                "listenerPort",
                "networkloadbalancerId",
                "protocol",
                "targets"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ForwardingRule resources.\n",
                "properties": {
                    "algorithm": {
                        "type": "string",
                        "description": "[string] Algorithm for the balancing.\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "[string] A Datacenter's UUID.\n",
                        "willReplaceOnChanges": true
                    },
                    "healthCheck": {
                        "$ref": "#/types/ionoscloud:nlb/ForwardingRuleHealthCheck:ForwardingRuleHealthCheck",
                        "description": "Health check attributes for Network Load Balancer forwarding rule.\n"
                    },
                    "listenerIp": {
                        "type": "string",
                        "description": "[string] Listening IP. (inbound)\n"
                    },
                    "listenerPort": {
                        "type": "integer",
                        "description": "[int] Listening port number. (inbound) (range: 1 to 65535)\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] A name of that Network Load Balancer forwarding rule.\n"
                    },
                    "networkloadbalancerId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "protocol": {
                        "type": "string",
                        "description": "[string] Protocol of the balancing.\n"
                    },
                    "targets": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:nlb/ForwardingRuleTarget:ForwardingRuleTarget"
                        },
                        "description": "[Set] Array of items in that collection.\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:vpn/ipsecGateway:IpsecGateway": {
            "description": "An IPSec Gateway resource manages the creation, management, and deletion of VPN IPSec Gateways within the IONOS Cloud\ninfrastructure. This resource facilitates the creation of VPN IPSec Gateways, enabling secure connections between your\nnetwork resources.\n\n## Usage example\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\n// Basic example\nconst testDatacenter = new ionoscloud.compute.Datacenter(\"testDatacenter\", {location: \"de/fra\"});\nconst testLan = new ionoscloud.compute.Lan(\"testLan\", {\n    \"public\": false,\n    datacenterId: testDatacenter.id,\n});\nconst testIpblock = new ionoscloud.compute.IPBlock(\"testIpblock\", {\n    location: \"de/fra\",\n    size: 1,\n});\nconst example = new ionoscloud.vpn.IpsecGateway(\"example\", {\n    location: \"de/fra\",\n    gatewayIp: testIpblock.ips[0],\n    version: \"IKEv2\",\n    description: \"This gateway connects site A to VDC X.\",\n    connections: [{\n        datacenterId: testDatacenter.id,\n        lanId: testLan.id,\n        ipv4Cidr: \"192.168.100.10/24\",\n    }],\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\n# Basic example\ntest_datacenter = ionoscloud.compute.Datacenter(\"testDatacenter\", location=\"de/fra\")\ntest_lan = ionoscloud.compute.Lan(\"testLan\",\n    public=False,\n    datacenter_id=test_datacenter.id)\ntest_ipblock = ionoscloud.compute.IPBlock(\"testIpblock\",\n    location=\"de/fra\",\n    size=1)\nexample = ionoscloud.vpn.IpsecGateway(\"example\",\n    location=\"de/fra\",\n    gateway_ip=test_ipblock.ips[0],\n    version=\"IKEv2\",\n    description=\"This gateway connects site A to VDC X.\",\n    connections=[{\n        \"datacenter_id\": test_datacenter.id,\n        \"lan_id\": test_lan.id,\n        \"ipv4_cidr\": \"192.168.100.10/24\",\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Basic example\n    var testDatacenter = new Ionoscloud.Compute.Datacenter(\"testDatacenter\", new()\n    {\n        Location = \"de/fra\",\n    });\n\n    var testLan = new Ionoscloud.Compute.Lan(\"testLan\", new()\n    {\n        Public = false,\n        DatacenterId = testDatacenter.Id,\n    });\n\n    var testIpblock = new Ionoscloud.Compute.IPBlock(\"testIpblock\", new()\n    {\n        Location = \"de/fra\",\n        Size = 1,\n    });\n\n    var example = new Ionoscloud.Vpn.IpsecGateway(\"example\", new()\n    {\n        Location = \"de/fra\",\n        GatewayIp = testIpblock.Ips.Apply(ips =\u003e ips[0]),\n        Version = \"IKEv2\",\n        Description = \"This gateway connects site A to VDC X.\",\n        Connections = new[]\n        {\n            new Ionoscloud.Vpn.Inputs.IpsecGatewayConnectionArgs\n            {\n                DatacenterId = testDatacenter.Id,\n                LanId = testLan.Id,\n                Ipv4Cidr = \"192.168.100.10/24\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/vpn\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Basic example\n\t\ttestDatacenter, err := compute.NewDatacenter(ctx, \"testDatacenter\", \u0026compute.DatacenterArgs{\n\t\t\tLocation: pulumi.String(\"de/fra\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestLan, err := compute.NewLan(ctx, \"testLan\", \u0026compute.LanArgs{\n\t\t\tPublic:       pulumi.Bool(false),\n\t\t\tDatacenterId: testDatacenter.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestIpblock, err := compute.NewIPBlock(ctx, \"testIpblock\", \u0026compute.IPBlockArgs{\n\t\t\tLocation: pulumi.String(\"de/fra\"),\n\t\t\tSize:     pulumi.Int(1),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vpn.NewIpsecGateway(ctx, \"example\", \u0026vpn.IpsecGatewayArgs{\n\t\t\tLocation: pulumi.String(\"de/fra\"),\n\t\t\tGatewayIp: testIpblock.Ips.ApplyT(func(ips []string) (string, error) {\n\t\t\t\treturn ips[0], nil\n\t\t\t}).(pulumi.StringOutput),\n\t\t\tVersion:     pulumi.String(\"IKEv2\"),\n\t\t\tDescription: pulumi.String(\"This gateway connects site A to VDC X.\"),\n\t\t\tConnections: vpn.IpsecGatewayConnectionArray{\n\t\t\t\t\u0026vpn.IpsecGatewayConnectionArgs{\n\t\t\t\t\tDatacenterId: testDatacenter.ID(),\n\t\t\t\t\tLanId:        testLan.ID(),\n\t\t\t\t\tIpv4Cidr:     pulumi.String(\"192.168.100.10/24\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.Datacenter;\nimport com.pulumi.ionoscloud.compute.DatacenterArgs;\nimport com.pulumi.ionoscloud.compute.Lan;\nimport com.pulumi.ionoscloud.compute.LanArgs;\nimport com.pulumi.ionoscloud.compute.IPBlock;\nimport com.pulumi.ionoscloud.compute.IPBlockArgs;\nimport com.pulumi.ionoscloud.vpn.IpsecGateway;\nimport com.pulumi.ionoscloud.vpn.IpsecGatewayArgs;\nimport com.pulumi.ionoscloud.vpn.inputs.IpsecGatewayConnectionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Basic example\n        var testDatacenter = new Datacenter(\"testDatacenter\", DatacenterArgs.builder()\n            .location(\"de/fra\")\n            .build());\n\n        var testLan = new Lan(\"testLan\", LanArgs.builder()\n            .public_(false)\n            .datacenterId(testDatacenter.id())\n            .build());\n\n        var testIpblock = new IPBlock(\"testIpblock\", IPBlockArgs.builder()\n            .location(\"de/fra\")\n            .size(1)\n            .build());\n\n        var example = new IpsecGateway(\"example\", IpsecGatewayArgs.builder()\n            .location(\"de/fra\")\n            .gatewayIp(testIpblock.ips().applyValue(ips -\u003e ips[0]))\n            .version(\"IKEv2\")\n            .description(\"This gateway connects site A to VDC X.\")\n            .connections(IpsecGatewayConnectionArgs.builder()\n                .datacenterId(testDatacenter.id())\n                .lanId(testLan.id())\n                .ipv4Cidr(\"192.168.100.10/24\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Basic example\n  testDatacenter:\n    type: ionoscloud:compute:Datacenter\n    properties:\n      location: de/fra\n  testLan:\n    type: ionoscloud:compute:Lan\n    properties:\n      public: false\n      datacenterId: ${testDatacenter.id}\n  testIpblock:\n    type: ionoscloud:compute:IPBlock\n    properties:\n      location: de/fra\n      size: 1\n  example:\n    type: ionoscloud:vpn:IpsecGateway\n    properties:\n      location: de/fra\n      gatewayIp: ${testIpblock.ips[0]}\n      version: IKEv2\n      description: This gateway connects site A to VDC X.\n      connections:\n        - datacenterId: ${testDatacenter.id}\n          lanId: ${testLan.id}\n          ipv4Cidr: 192.168.100.10/24\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nThe resource can be imported using the `location` and `gateway_id`, for example:\n\n```sh\n$ pulumi import ionoscloud:vpn/ipsecGateway:IpsecGateway example {location}:{gateway_id}\n```\n\n",
            "properties": {
                "connections": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:vpn/IpsecGatewayConnection:IpsecGatewayConnection"
                    },
                    "description": "[list] The network connection for your gateway. **Note**: all connections must belong to the\nsame datacenter. Minimum items: 1. Maximum items: 10.\n"
                },
                "description": {
                    "type": "string",
                    "description": "[string] The human-readable description of the IPSec Gateway.\n"
                },
                "gatewayIp": {
                    "type": "string",
                    "description": "[string] Public IP address to be assigned to the gateway. Note: This must be an IP address in\nthe same datacenter as the connections.\n"
                },
                "location": {
                    "type": "string",
                    "description": "[string] The location of the IPSec Gateway. Supported locations: de/fra, de/txl, es/vit,\ngb/lhr, us/ewr, us/las, us/mci, fr/par\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the IPSec Gateway.\n"
                },
                "version": {
                    "type": "string",
                    "description": "[string] The IKE version that is permitted for the VPN tunnels. Default: `IKEv2`. Possible\nvalues: `IKEv2`.\n"
                }
            },
            "required": [
                "connections",
                "gatewayIp",
                "location",
                "name"
            ],
            "inputProperties": {
                "connections": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:vpn/IpsecGatewayConnection:IpsecGatewayConnection"
                    },
                    "description": "[list] The network connection for your gateway. **Note**: all connections must belong to the\nsame datacenter. Minimum items: 1. Maximum items: 10.\n"
                },
                "description": {
                    "type": "string",
                    "description": "[string] The human-readable description of the IPSec Gateway.\n"
                },
                "gatewayIp": {
                    "type": "string",
                    "description": "[string] Public IP address to be assigned to the gateway. Note: This must be an IP address in\nthe same datacenter as the connections.\n"
                },
                "location": {
                    "type": "string",
                    "description": "[string] The location of the IPSec Gateway. Supported locations: de/fra, de/txl, es/vit,\ngb/lhr, us/ewr, us/las, us/mci, fr/par\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the IPSec Gateway.\n"
                },
                "version": {
                    "type": "string",
                    "description": "[string] The IKE version that is permitted for the VPN tunnels. Default: `IKEv2`. Possible\nvalues: `IKEv2`.\n"
                }
            },
            "requiredInputs": [
                "connections",
                "gatewayIp",
                "location"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IpsecGateway resources.\n",
                "properties": {
                    "connections": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:vpn/IpsecGatewayConnection:IpsecGatewayConnection"
                        },
                        "description": "[list] The network connection for your gateway. **Note**: all connections must belong to the\nsame datacenter. Minimum items: 1. Maximum items: 10.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "[string] The human-readable description of the IPSec Gateway.\n"
                    },
                    "gatewayIp": {
                        "type": "string",
                        "description": "[string] Public IP address to be assigned to the gateway. Note: This must be an IP address in\nthe same datacenter as the connections.\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "[string] The location of the IPSec Gateway. Supported locations: de/fra, de/txl, es/vit,\ngb/lhr, us/ewr, us/las, us/mci, fr/par\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] The name of the IPSec Gateway.\n"
                    },
                    "version": {
                        "type": "string",
                        "description": "[string] The IKE version that is permitted for the VPN tunnels. Default: `IKEv2`. Possible\nvalues: `IKEv2`.\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:vpn/ipsecTunnel:IpsecTunnel": {
            "description": "An IPSec Gateway Tunnel resource manages the creation, management, and deletion of VPN IPSec Gateway Tunnels within the\nIONOS Cloud infrastructure. This resource facilitates the creation of VPN IPSec Gateway Tunnels, enabling secure\nconnections between your network resources.\n\n## Usage example\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\n// Basic example\nconst testDatacenter = new ionoscloud.compute.Datacenter(\"testDatacenter\", {location: \"de/fra\"});\nconst testLan = new ionoscloud.compute.Lan(\"testLan\", {\n    \"public\": false,\n    datacenterId: testDatacenter.id,\n});\nconst testIpblock = new ionoscloud.compute.IPBlock(\"testIpblock\", {\n    location: \"de/fra\",\n    size: 1,\n});\nconst exampleIpsecGateway = new ionoscloud.vpn.IpsecGateway(\"exampleIpsecGateway\", {\n    location: \"de/fra\",\n    gatewayIp: testIpblock.ips[0],\n    version: \"IKEv2\",\n    description: \"This gateway connects site A to VDC X.\",\n    connections: [{\n        datacenterId: testDatacenter.id,\n        lanId: testLan.id,\n        ipv4Cidr: \"192.168.100.10/24\",\n    }],\n});\nconst exampleIpsecTunnel = new ionoscloud.vpn.IpsecTunnel(\"exampleIpsecTunnel\", {\n    location: \"de/fra\",\n    gatewayId: exampleIpsecGateway.id,\n    remoteHost: \"vpn.mycompany.com\",\n    description: \"Allows local subnet X to connect to virtual network Y.\",\n    auth: {\n        method: \"PSK\",\n        pskKey: \"X2wosbaw74M8hQGbK3jCCaEusR6CCFRa\",\n    },\n    ike: {\n        diffieHellmanGroup: \"16-MODP4096\",\n        encryptionAlgorithm: \"AES256\",\n        integrityAlgorithm: \"SHA256\",\n        lifetime: 86400,\n    },\n    esps: [{\n        diffieHellmanGroup: \"16-MODP4096\",\n        encryptionAlgorithm: \"AES256\",\n        integrityAlgorithm: \"SHA256\",\n        lifetime: 3600,\n    }],\n    cloudNetworkCidrs: [\"0.0.0.0/0\"],\n    peerNetworkCidrs: [\"1.2.3.4/32\"],\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\n# Basic example\ntest_datacenter = ionoscloud.compute.Datacenter(\"testDatacenter\", location=\"de/fra\")\ntest_lan = ionoscloud.compute.Lan(\"testLan\",\n    public=False,\n    datacenter_id=test_datacenter.id)\ntest_ipblock = ionoscloud.compute.IPBlock(\"testIpblock\",\n    location=\"de/fra\",\n    size=1)\nexample_ipsec_gateway = ionoscloud.vpn.IpsecGateway(\"exampleIpsecGateway\",\n    location=\"de/fra\",\n    gateway_ip=test_ipblock.ips[0],\n    version=\"IKEv2\",\n    description=\"This gateway connects site A to VDC X.\",\n    connections=[{\n        \"datacenter_id\": test_datacenter.id,\n        \"lan_id\": test_lan.id,\n        \"ipv4_cidr\": \"192.168.100.10/24\",\n    }])\nexample_ipsec_tunnel = ionoscloud.vpn.IpsecTunnel(\"exampleIpsecTunnel\",\n    location=\"de/fra\",\n    gateway_id=example_ipsec_gateway.id,\n    remote_host=\"vpn.mycompany.com\",\n    description=\"Allows local subnet X to connect to virtual network Y.\",\n    auth={\n        \"method\": \"PSK\",\n        \"psk_key\": \"X2wosbaw74M8hQGbK3jCCaEusR6CCFRa\",\n    },\n    ike={\n        \"diffie_hellman_group\": \"16-MODP4096\",\n        \"encryption_algorithm\": \"AES256\",\n        \"integrity_algorithm\": \"SHA256\",\n        \"lifetime\": 86400,\n    },\n    esps=[{\n        \"diffie_hellman_group\": \"16-MODP4096\",\n        \"encryption_algorithm\": \"AES256\",\n        \"integrity_algorithm\": \"SHA256\",\n        \"lifetime\": 3600,\n    }],\n    cloud_network_cidrs=[\"0.0.0.0/0\"],\n    peer_network_cidrs=[\"1.2.3.4/32\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Basic example\n    var testDatacenter = new Ionoscloud.Compute.Datacenter(\"testDatacenter\", new()\n    {\n        Location = \"de/fra\",\n    });\n\n    var testLan = new Ionoscloud.Compute.Lan(\"testLan\", new()\n    {\n        Public = false,\n        DatacenterId = testDatacenter.Id,\n    });\n\n    var testIpblock = new Ionoscloud.Compute.IPBlock(\"testIpblock\", new()\n    {\n        Location = \"de/fra\",\n        Size = 1,\n    });\n\n    var exampleIpsecGateway = new Ionoscloud.Vpn.IpsecGateway(\"exampleIpsecGateway\", new()\n    {\n        Location = \"de/fra\",\n        GatewayIp = testIpblock.Ips.Apply(ips =\u003e ips[0]),\n        Version = \"IKEv2\",\n        Description = \"This gateway connects site A to VDC X.\",\n        Connections = new[]\n        {\n            new Ionoscloud.Vpn.Inputs.IpsecGatewayConnectionArgs\n            {\n                DatacenterId = testDatacenter.Id,\n                LanId = testLan.Id,\n                Ipv4Cidr = \"192.168.100.10/24\",\n            },\n        },\n    });\n\n    var exampleIpsecTunnel = new Ionoscloud.Vpn.IpsecTunnel(\"exampleIpsecTunnel\", new()\n    {\n        Location = \"de/fra\",\n        GatewayId = exampleIpsecGateway.Id,\n        RemoteHost = \"vpn.mycompany.com\",\n        Description = \"Allows local subnet X to connect to virtual network Y.\",\n        Auth = new Ionoscloud.Vpn.Inputs.IpsecTunnelAuthArgs\n        {\n            Method = \"PSK\",\n            PskKey = \"X2wosbaw74M8hQGbK3jCCaEusR6CCFRa\",\n        },\n        Ike = new Ionoscloud.Vpn.Inputs.IpsecTunnelIkeArgs\n        {\n            DiffieHellmanGroup = \"16-MODP4096\",\n            EncryptionAlgorithm = \"AES256\",\n            IntegrityAlgorithm = \"SHA256\",\n            Lifetime = 86400,\n        },\n        Esps = new[]\n        {\n            new Ionoscloud.Vpn.Inputs.IpsecTunnelEspArgs\n            {\n                DiffieHellmanGroup = \"16-MODP4096\",\n                EncryptionAlgorithm = \"AES256\",\n                IntegrityAlgorithm = \"SHA256\",\n                Lifetime = 3600,\n            },\n        },\n        CloudNetworkCidrs = new[]\n        {\n            \"0.0.0.0/0\",\n        },\n        PeerNetworkCidrs = new[]\n        {\n            \"1.2.3.4/32\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/vpn\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Basic example\n\t\ttestDatacenter, err := compute.NewDatacenter(ctx, \"testDatacenter\", \u0026compute.DatacenterArgs{\n\t\t\tLocation: pulumi.String(\"de/fra\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestLan, err := compute.NewLan(ctx, \"testLan\", \u0026compute.LanArgs{\n\t\t\tPublic:       pulumi.Bool(false),\n\t\t\tDatacenterId: testDatacenter.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestIpblock, err := compute.NewIPBlock(ctx, \"testIpblock\", \u0026compute.IPBlockArgs{\n\t\t\tLocation: pulumi.String(\"de/fra\"),\n\t\t\tSize:     pulumi.Int(1),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleIpsecGateway, err := vpn.NewIpsecGateway(ctx, \"exampleIpsecGateway\", \u0026vpn.IpsecGatewayArgs{\n\t\t\tLocation: pulumi.String(\"de/fra\"),\n\t\t\tGatewayIp: testIpblock.Ips.ApplyT(func(ips []string) (string, error) {\n\t\t\t\treturn ips[0], nil\n\t\t\t}).(pulumi.StringOutput),\n\t\t\tVersion:     pulumi.String(\"IKEv2\"),\n\t\t\tDescription: pulumi.String(\"This gateway connects site A to VDC X.\"),\n\t\t\tConnections: vpn.IpsecGatewayConnectionArray{\n\t\t\t\t\u0026vpn.IpsecGatewayConnectionArgs{\n\t\t\t\t\tDatacenterId: testDatacenter.ID(),\n\t\t\t\t\tLanId:        testLan.ID(),\n\t\t\t\t\tIpv4Cidr:     pulumi.String(\"192.168.100.10/24\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vpn.NewIpsecTunnel(ctx, \"exampleIpsecTunnel\", \u0026vpn.IpsecTunnelArgs{\n\t\t\tLocation:    pulumi.String(\"de/fra\"),\n\t\t\tGatewayId:   exampleIpsecGateway.ID(),\n\t\t\tRemoteHost:  pulumi.String(\"vpn.mycompany.com\"),\n\t\t\tDescription: pulumi.String(\"Allows local subnet X to connect to virtual network Y.\"),\n\t\t\tAuth: \u0026vpn.IpsecTunnelAuthArgs{\n\t\t\t\tMethod: pulumi.String(\"PSK\"),\n\t\t\t\tPskKey: pulumi.String(\"X2wosbaw74M8hQGbK3jCCaEusR6CCFRa\"),\n\t\t\t},\n\t\t\tIke: \u0026vpn.IpsecTunnelIkeArgs{\n\t\t\t\tDiffieHellmanGroup:  pulumi.String(\"16-MODP4096\"),\n\t\t\t\tEncryptionAlgorithm: pulumi.String(\"AES256\"),\n\t\t\t\tIntegrityAlgorithm:  pulumi.String(\"SHA256\"),\n\t\t\t\tLifetime:            pulumi.Int(86400),\n\t\t\t},\n\t\t\tEsps: vpn.IpsecTunnelEspArray{\n\t\t\t\t\u0026vpn.IpsecTunnelEspArgs{\n\t\t\t\t\tDiffieHellmanGroup:  pulumi.String(\"16-MODP4096\"),\n\t\t\t\t\tEncryptionAlgorithm: pulumi.String(\"AES256\"),\n\t\t\t\t\tIntegrityAlgorithm:  pulumi.String(\"SHA256\"),\n\t\t\t\t\tLifetime:            pulumi.Int(3600),\n\t\t\t\t},\n\t\t\t},\n\t\t\tCloudNetworkCidrs: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"0.0.0.0/0\"),\n\t\t\t},\n\t\t\tPeerNetworkCidrs: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"1.2.3.4/32\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.Datacenter;\nimport com.pulumi.ionoscloud.compute.DatacenterArgs;\nimport com.pulumi.ionoscloud.compute.Lan;\nimport com.pulumi.ionoscloud.compute.LanArgs;\nimport com.pulumi.ionoscloud.compute.IPBlock;\nimport com.pulumi.ionoscloud.compute.IPBlockArgs;\nimport com.pulumi.ionoscloud.vpn.IpsecGateway;\nimport com.pulumi.ionoscloud.vpn.IpsecGatewayArgs;\nimport com.pulumi.ionoscloud.vpn.inputs.IpsecGatewayConnectionArgs;\nimport com.pulumi.ionoscloud.vpn.IpsecTunnel;\nimport com.pulumi.ionoscloud.vpn.IpsecTunnelArgs;\nimport com.pulumi.ionoscloud.vpn.inputs.IpsecTunnelAuthArgs;\nimport com.pulumi.ionoscloud.vpn.inputs.IpsecTunnelIkeArgs;\nimport com.pulumi.ionoscloud.vpn.inputs.IpsecTunnelEspArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Basic example\n        var testDatacenter = new Datacenter(\"testDatacenter\", DatacenterArgs.builder()\n            .location(\"de/fra\")\n            .build());\n\n        var testLan = new Lan(\"testLan\", LanArgs.builder()\n            .public_(false)\n            .datacenterId(testDatacenter.id())\n            .build());\n\n        var testIpblock = new IPBlock(\"testIpblock\", IPBlockArgs.builder()\n            .location(\"de/fra\")\n            .size(1)\n            .build());\n\n        var exampleIpsecGateway = new IpsecGateway(\"exampleIpsecGateway\", IpsecGatewayArgs.builder()\n            .location(\"de/fra\")\n            .gatewayIp(testIpblock.ips().applyValue(ips -\u003e ips[0]))\n            .version(\"IKEv2\")\n            .description(\"This gateway connects site A to VDC X.\")\n            .connections(IpsecGatewayConnectionArgs.builder()\n                .datacenterId(testDatacenter.id())\n                .lanId(testLan.id())\n                .ipv4Cidr(\"192.168.100.10/24\")\n                .build())\n            .build());\n\n        var exampleIpsecTunnel = new IpsecTunnel(\"exampleIpsecTunnel\", IpsecTunnelArgs.builder()\n            .location(\"de/fra\")\n            .gatewayId(exampleIpsecGateway.id())\n            .remoteHost(\"vpn.mycompany.com\")\n            .description(\"Allows local subnet X to connect to virtual network Y.\")\n            .auth(IpsecTunnelAuthArgs.builder()\n                .method(\"PSK\")\n                .pskKey(\"X2wosbaw74M8hQGbK3jCCaEusR6CCFRa\")\n                .build())\n            .ike(IpsecTunnelIkeArgs.builder()\n                .diffieHellmanGroup(\"16-MODP4096\")\n                .encryptionAlgorithm(\"AES256\")\n                .integrityAlgorithm(\"SHA256\")\n                .lifetime(86400)\n                .build())\n            .esps(IpsecTunnelEspArgs.builder()\n                .diffieHellmanGroup(\"16-MODP4096\")\n                .encryptionAlgorithm(\"AES256\")\n                .integrityAlgorithm(\"SHA256\")\n                .lifetime(3600)\n                .build())\n            .cloudNetworkCidrs(\"0.0.0.0/0\")\n            .peerNetworkCidrs(\"1.2.3.4/32\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Basic example\n  testDatacenter:\n    type: ionoscloud:compute:Datacenter\n    properties:\n      location: de/fra\n  testLan:\n    type: ionoscloud:compute:Lan\n    properties:\n      public: false\n      datacenterId: ${testDatacenter.id}\n  testIpblock:\n    type: ionoscloud:compute:IPBlock\n    properties:\n      location: de/fra\n      size: 1\n  exampleIpsecGateway:\n    type: ionoscloud:vpn:IpsecGateway\n    properties:\n      location: de/fra\n      gatewayIp: ${testIpblock.ips[0]}\n      version: IKEv2\n      description: This gateway connects site A to VDC X.\n      connections:\n        - datacenterId: ${testDatacenter.id}\n          lanId: ${testLan.id}\n          ipv4Cidr: 192.168.100.10/24\n  exampleIpsecTunnel:\n    type: ionoscloud:vpn:IpsecTunnel\n    properties:\n      location: de/fra\n      gatewayId: ${exampleIpsecGateway.id}\n      remoteHost: vpn.mycompany.com\n      description: Allows local subnet X to connect to virtual network Y.\n      auth:\n        method: PSK\n        pskKey: X2wosbaw74M8hQGbK3jCCaEusR6CCFRa\n      ike:\n        diffieHellmanGroup: 16-MODP4096\n        encryptionAlgorithm: AES256\n        integrityAlgorithm: SHA256\n        lifetime: 86400\n      esps:\n        - diffieHellmanGroup: 16-MODP4096\n          encryptionAlgorithm: AES256\n          integrityAlgorithm: SHA256\n          lifetime: 3600\n      cloudNetworkCidrs:\n        - 0.0.0.0/0\n      peerNetworkCidrs:\n        - 1.2.3.4/32\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nThe resource can be imported using the `location`, `gateway_id` and `tunnel_id`, for example:\n\n```sh\n$ pulumi import ionoscloud:vpn/ipsecTunnel:IpsecTunnel example {location}:{gateway_id}:{tunnel_id}\n```\n\n",
            "properties": {
                "auth": {
                    "$ref": "#/types/ionoscloud:vpn/IpsecTunnelAuth:IpsecTunnelAuth",
                    "description": "[string] Properties with all data needed to define IPSec Authentication. Minimum items: 1. Maximum\nitems: 1.\n"
                },
                "cloudNetworkCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] The network CIDRs on the \"Left\" side that are allowed to connect to the IPSec\ntunnel, i.e. the CIDRs within your IONOS Cloud LAN. Specify \"0.0.0.0/0\" or \"::/0\" for all addresses. Minimum items: 1.\nMaximum items: 20.\n"
                },
                "description": {
                    "type": "string",
                    "description": "[string] The human-readable description of your IPSec Gateway Tunnel.\n"
                },
                "esps": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:vpn/IpsecTunnelEsp:IpsecTunnelEsp"
                    },
                    "description": "[list] Settings for the IPSec SA (ESP) phase. Minimum items: 1. Maximum items: 1.\n"
                },
                "gatewayId": {
                    "type": "string",
                    "description": "[string] The ID of the IPSec Gateway that the tunnel belongs to.\n"
                },
                "ike": {
                    "$ref": "#/types/ionoscloud:vpn/IpsecTunnelIke:IpsecTunnelIke",
                    "description": "[list] Settings for the initial security exchange phase. Minimum items: 1. Maximum items: 1.\n"
                },
                "location": {
                    "type": "string",
                    "description": "[string] The location of the IPSec Gateway Tunnel. Supported locations: de/fra, de/txl, es/vit,\ngb/lhr, us/ewr, us/las, us/mci, fr/par\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the IPSec Gateway Tunnel.\n"
                },
                "peerNetworkCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] The network CIDRs on the \"Right\" side that are allowed to connect to the IPSec\ntunnel. Specify \"0.0.0.0/0\" or \"::/0\" for all addresses. Minimum items: 1. Maximum items: 20.\n"
                },
                "remoteHost": {
                    "type": "string",
                    "description": "[string] The remote peer host fully qualified domain name or public IPV4 IP to connect to.\n"
                }
            },
            "required": [
                "auth",
                "cloudNetworkCidrs",
                "esps",
                "gatewayId",
                "ike",
                "location",
                "name",
                "peerNetworkCidrs",
                "remoteHost"
            ],
            "inputProperties": {
                "auth": {
                    "$ref": "#/types/ionoscloud:vpn/IpsecTunnelAuth:IpsecTunnelAuth",
                    "description": "[string] Properties with all data needed to define IPSec Authentication. Minimum items: 1. Maximum\nitems: 1.\n"
                },
                "cloudNetworkCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] The network CIDRs on the \"Left\" side that are allowed to connect to the IPSec\ntunnel, i.e. the CIDRs within your IONOS Cloud LAN. Specify \"0.0.0.0/0\" or \"::/0\" for all addresses. Minimum items: 1.\nMaximum items: 20.\n"
                },
                "description": {
                    "type": "string",
                    "description": "[string] The human-readable description of your IPSec Gateway Tunnel.\n"
                },
                "esps": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:vpn/IpsecTunnelEsp:IpsecTunnelEsp"
                    },
                    "description": "[list] Settings for the IPSec SA (ESP) phase. Minimum items: 1. Maximum items: 1.\n"
                },
                "gatewayId": {
                    "type": "string",
                    "description": "[string] The ID of the IPSec Gateway that the tunnel belongs to.\n"
                },
                "ike": {
                    "$ref": "#/types/ionoscloud:vpn/IpsecTunnelIke:IpsecTunnelIke",
                    "description": "[list] Settings for the initial security exchange phase. Minimum items: 1. Maximum items: 1.\n"
                },
                "location": {
                    "type": "string",
                    "description": "[string] The location of the IPSec Gateway Tunnel. Supported locations: de/fra, de/txl, es/vit,\ngb/lhr, us/ewr, us/las, us/mci, fr/par\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "[string] The name of the IPSec Gateway Tunnel.\n"
                },
                "peerNetworkCidrs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list] The network CIDRs on the \"Right\" side that are allowed to connect to the IPSec\ntunnel. Specify \"0.0.0.0/0\" or \"::/0\" for all addresses. Minimum items: 1. Maximum items: 20.\n"
                },
                "remoteHost": {
                    "type": "string",
                    "description": "[string] The remote peer host fully qualified domain name or public IPV4 IP to connect to.\n"
                }
            },
            "requiredInputs": [
                "auth",
                "cloudNetworkCidrs",
                "esps",
                "gatewayId",
                "ike",
                "location",
                "peerNetworkCidrs",
                "remoteHost"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IpsecTunnel resources.\n",
                "properties": {
                    "auth": {
                        "$ref": "#/types/ionoscloud:vpn/IpsecTunnelAuth:IpsecTunnelAuth",
                        "description": "[string] Properties with all data needed to define IPSec Authentication. Minimum items: 1. Maximum\nitems: 1.\n"
                    },
                    "cloudNetworkCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "[list] The network CIDRs on the \"Left\" side that are allowed to connect to the IPSec\ntunnel, i.e. the CIDRs within your IONOS Cloud LAN. Specify \"0.0.0.0/0\" or \"::/0\" for all addresses. Minimum items: 1.\nMaximum items: 20.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "[string] The human-readable description of your IPSec Gateway Tunnel.\n"
                    },
                    "esps": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:vpn/IpsecTunnelEsp:IpsecTunnelEsp"
                        },
                        "description": "[list] Settings for the IPSec SA (ESP) phase. Minimum items: 1. Maximum items: 1.\n"
                    },
                    "gatewayId": {
                        "type": "string",
                        "description": "[string] The ID of the IPSec Gateway that the tunnel belongs to.\n"
                    },
                    "ike": {
                        "$ref": "#/types/ionoscloud:vpn/IpsecTunnelIke:IpsecTunnelIke",
                        "description": "[list] Settings for the initial security exchange phase. Minimum items: 1. Maximum items: 1.\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "[string] The location of the IPSec Gateway Tunnel. Supported locations: de/fra, de/txl, es/vit,\ngb/lhr, us/ewr, us/las, us/mci, fr/par\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] The name of the IPSec Gateway Tunnel.\n"
                    },
                    "peerNetworkCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "[list] The network CIDRs on the \"Right\" side that are allowed to connect to the IPSec\ntunnel. Specify \"0.0.0.0/0\" or \"::/0\" for all addresses. Minimum items: 1. Maximum items: 20.\n"
                    },
                    "remoteHost": {
                        "type": "string",
                        "description": "[string] The remote peer host fully qualified domain name or public IPV4 IP to connect to.\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:vpn/wireguardGateway:WireguardGateway": {
            "description": "## Overview\n\nThe `ionoscloud.vpn.WireguardGateway` resource manages a WireGuard Gateway within the IONOS Cloud infrastructure. \nThis resource facilitates the creation, management, and deletion of WireGuard VPN Gateways, enabling secure connections between your network resources.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst datacenterExample = new ionoscloud.compute.Datacenter(\"datacenterExample\", {location: \"de/fra\"});\nconst ipblockExample = new ionoscloud.compute.IPBlock(\"ipblockExample\", {\n    location: \"de/fra\",\n    size: 1,\n});\nconst lanExample = new ionoscloud.compute.Lan(\"lanExample\", {datacenterId: datacenterExample.id});\nconst gateway = new ionoscloud.vpn.WireguardGateway(\"gateway\", {\n    location: \"de/fra\",\n    description: \"description\",\n    privateKey: \"private\",\n    gatewayIp: ipblockExample.ips[0],\n    interfaceIpv4Cidr: \"192.168.1.100/24\",\n    connections: [{\n        datacenterId: datacenterExample.id,\n        lanId: lanExample.id,\n        ipv4Cidr: \"192.168.1.108/24\",\n    }],\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\ndatacenter_example = ionoscloud.compute.Datacenter(\"datacenterExample\", location=\"de/fra\")\nipblock_example = ionoscloud.compute.IPBlock(\"ipblockExample\",\n    location=\"de/fra\",\n    size=1)\nlan_example = ionoscloud.compute.Lan(\"lanExample\", datacenter_id=datacenter_example.id)\ngateway = ionoscloud.vpn.WireguardGateway(\"gateway\",\n    location=\"de/fra\",\n    description=\"description\",\n    private_key=\"private\",\n    gateway_ip=ipblock_example.ips[0],\n    interface_ipv4_cidr=\"192.168.1.100/24\",\n    connections=[{\n        \"datacenter_id\": datacenter_example.id,\n        \"lan_id\": lan_example.id,\n        \"ipv4_cidr\": \"192.168.1.108/24\",\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenterExample = new Ionoscloud.Compute.Datacenter(\"datacenterExample\", new()\n    {\n        Location = \"de/fra\",\n    });\n\n    var ipblockExample = new Ionoscloud.Compute.IPBlock(\"ipblockExample\", new()\n    {\n        Location = \"de/fra\",\n        Size = 1,\n    });\n\n    var lanExample = new Ionoscloud.Compute.Lan(\"lanExample\", new()\n    {\n        DatacenterId = datacenterExample.Id,\n    });\n\n    var gateway = new Ionoscloud.Vpn.WireguardGateway(\"gateway\", new()\n    {\n        Location = \"de/fra\",\n        Description = \"description\",\n        PrivateKey = \"private\",\n        GatewayIp = ipblockExample.Ips.Apply(ips =\u003e ips[0]),\n        InterfaceIpv4Cidr = \"192.168.1.100/24\",\n        Connections = new[]\n        {\n            new Ionoscloud.Vpn.Inputs.WireguardGatewayConnectionArgs\n            {\n                DatacenterId = datacenterExample.Id,\n                LanId = lanExample.Id,\n                Ipv4Cidr = \"192.168.1.108/24\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/vpn\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenterExample, err := compute.NewDatacenter(ctx, \"datacenterExample\", \u0026compute.DatacenterArgs{\n\t\t\tLocation: pulumi.String(\"de/fra\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tipblockExample, err := compute.NewIPBlock(ctx, \"ipblockExample\", \u0026compute.IPBlockArgs{\n\t\t\tLocation: pulumi.String(\"de/fra\"),\n\t\t\tSize:     pulumi.Int(1),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tlanExample, err := compute.NewLan(ctx, \"lanExample\", \u0026compute.LanArgs{\n\t\t\tDatacenterId: datacenterExample.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vpn.NewWireguardGateway(ctx, \"gateway\", \u0026vpn.WireguardGatewayArgs{\n\t\t\tLocation:    pulumi.String(\"de/fra\"),\n\t\t\tDescription: pulumi.String(\"description\"),\n\t\t\tPrivateKey:  pulumi.String(\"private\"),\n\t\t\tGatewayIp: ipblockExample.Ips.ApplyT(func(ips []string) (string, error) {\n\t\t\t\treturn ips[0], nil\n\t\t\t}).(pulumi.StringOutput),\n\t\t\tInterfaceIpv4Cidr: pulumi.String(\"192.168.1.100/24\"),\n\t\t\tConnections: vpn.WireguardGatewayConnectionArray{\n\t\t\t\t\u0026vpn.WireguardGatewayConnectionArgs{\n\t\t\t\t\tDatacenterId: datacenterExample.ID(),\n\t\t\t\t\tLanId:        lanExample.ID(),\n\t\t\t\t\tIpv4Cidr:     pulumi.String(\"192.168.1.108/24\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.Datacenter;\nimport com.pulumi.ionoscloud.compute.DatacenterArgs;\nimport com.pulumi.ionoscloud.compute.IPBlock;\nimport com.pulumi.ionoscloud.compute.IPBlockArgs;\nimport com.pulumi.ionoscloud.compute.Lan;\nimport com.pulumi.ionoscloud.compute.LanArgs;\nimport com.pulumi.ionoscloud.vpn.WireguardGateway;\nimport com.pulumi.ionoscloud.vpn.WireguardGatewayArgs;\nimport com.pulumi.ionoscloud.vpn.inputs.WireguardGatewayConnectionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var datacenterExample = new Datacenter(\"datacenterExample\", DatacenterArgs.builder()\n            .location(\"de/fra\")\n            .build());\n\n        var ipblockExample = new IPBlock(\"ipblockExample\", IPBlockArgs.builder()\n            .location(\"de/fra\")\n            .size(1)\n            .build());\n\n        var lanExample = new Lan(\"lanExample\", LanArgs.builder()\n            .datacenterId(datacenterExample.id())\n            .build());\n\n        var gateway = new WireguardGateway(\"gateway\", WireguardGatewayArgs.builder()\n            .location(\"de/fra\")\n            .description(\"description\")\n            .privateKey(\"private\")\n            .gatewayIp(ipblockExample.ips().applyValue(ips -\u003e ips[0]))\n            .interfaceIpv4Cidr(\"192.168.1.100/24\")\n            .connections(WireguardGatewayConnectionArgs.builder()\n                .datacenterId(datacenterExample.id())\n                .lanId(lanExample.id())\n                .ipv4Cidr(\"192.168.1.108/24\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  datacenterExample:\n    type: ionoscloud:compute:Datacenter\n    properties:\n      location: de/fra\n  ipblockExample:\n    type: ionoscloud:compute:IPBlock\n    properties:\n      location: de/fra\n      size: 1\n  lanExample:\n    type: ionoscloud:compute:Lan\n    properties:\n      datacenterId: ${datacenterExample.id}\n  gateway:\n    type: ionoscloud:vpn:WireguardGateway\n    properties:\n      location: de/fra\n      description: description\n      privateKey: private\n      gatewayIp: ${ipblockExample.ips[0]}\n      interfaceIpv4Cidr: 192.168.1.100/24\n      connections:\n        - datacenterId: ${datacenterExample.id}\n          lanId: ${lanExample.id}\n          ipv4Cidr: 192.168.1.108/24\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nWireGuard Gateways can be imported using their ID:\n\n```sh\n$ pulumi import ionoscloud:vpn/wireguardGateway:WireguardGateway example_gateway location:id\n```\n\n",
            "properties": {
                "connections": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:vpn/WireguardGatewayConnection:WireguardGatewayConnection"
                    },
                    "description": "[Block] The connection configuration for the WireGuard Gateway. This block supports fields documented below.\n"
                },
                "description": {
                    "type": "string",
                    "description": "[String] A description of the WireGuard Gateway.\n"
                },
                "gatewayIp": {
                    "type": "string",
                    "description": "[String] The IP address of the WireGuard Gateway.\n"
                },
                "interfaceIpv4Cidr": {
                    "type": "string",
                    "description": "[String] The IPv4 CIDR for the WireGuard Gateway interface.\n"
                },
                "interfaceIpv6Cidr": {
                    "type": "string",
                    "description": "[String] The IPv6 CIDR for the WireGuard Gateway interface.\n"
                },
                "listenPort": {
                    "type": "integer"
                },
                "location": {
                    "type": "string",
                    "description": "[String] The location of the WireGuard Gateway.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[String] The name of the WireGuard Gateway.\n"
                },
                "privateKey": {
                    "type": "string",
                    "description": "[String] The private key for the WireGuard Gateway. To be created with the wg utility.\n",
                    "secret": true
                },
                "publicKey": {
                    "type": "string",
                    "description": "(Computed)[String] The public key for the WireGuard Gateway.\n"
                },
                "status": {
                    "type": "string",
                    "description": "(Computed)[String] The current status of the WireGuard Gateway.\n"
                }
            },
            "required": [
                "connections",
                "gatewayIp",
                "location",
                "name",
                "privateKey",
                "publicKey",
                "status"
            ],
            "inputProperties": {
                "connections": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/ionoscloud:vpn/WireguardGatewayConnection:WireguardGatewayConnection"
                    },
                    "description": "[Block] The connection configuration for the WireGuard Gateway. This block supports fields documented below.\n"
                },
                "description": {
                    "type": "string",
                    "description": "[String] A description of the WireGuard Gateway.\n"
                },
                "gatewayIp": {
                    "type": "string",
                    "description": "[String] The IP address of the WireGuard Gateway.\n"
                },
                "interfaceIpv4Cidr": {
                    "type": "string",
                    "description": "[String] The IPv4 CIDR for the WireGuard Gateway interface.\n"
                },
                "interfaceIpv6Cidr": {
                    "type": "string",
                    "description": "[String] The IPv6 CIDR for the WireGuard Gateway interface.\n"
                },
                "listenPort": {
                    "type": "integer"
                },
                "location": {
                    "type": "string",
                    "description": "[String] The location of the WireGuard Gateway.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "[String] The name of the WireGuard Gateway.\n"
                },
                "privateKey": {
                    "type": "string",
                    "description": "[String] The private key for the WireGuard Gateway. To be created with the wg utility.\n",
                    "secret": true
                }
            },
            "requiredInputs": [
                "connections",
                "gatewayIp",
                "location",
                "privateKey"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WireguardGateway resources.\n",
                "properties": {
                    "connections": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:vpn/WireguardGatewayConnection:WireguardGatewayConnection"
                        },
                        "description": "[Block] The connection configuration for the WireGuard Gateway. This block supports fields documented below.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "[String] A description of the WireGuard Gateway.\n"
                    },
                    "gatewayIp": {
                        "type": "string",
                        "description": "[String] The IP address of the WireGuard Gateway.\n"
                    },
                    "interfaceIpv4Cidr": {
                        "type": "string",
                        "description": "[String] The IPv4 CIDR for the WireGuard Gateway interface.\n"
                    },
                    "interfaceIpv6Cidr": {
                        "type": "string",
                        "description": "[String] The IPv6 CIDR for the WireGuard Gateway interface.\n"
                    },
                    "listenPort": {
                        "type": "integer"
                    },
                    "location": {
                        "type": "string",
                        "description": "[String] The location of the WireGuard Gateway.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "[String] The name of the WireGuard Gateway.\n"
                    },
                    "privateKey": {
                        "type": "string",
                        "description": "[String] The private key for the WireGuard Gateway. To be created with the wg utility.\n",
                        "secret": true
                    },
                    "publicKey": {
                        "type": "string",
                        "description": "(Computed)[String] The public key for the WireGuard Gateway.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "(Computed)[String] The current status of the WireGuard Gateway.\n"
                    }
                },
                "type": "object"
            }
        },
        "ionoscloud:vpn/wireguardPeer:WireguardPeer": {
            "description": "This page provides an overview of the `ionoscloud.vpn.WireguardPeer` resource, which allows you to manage a WireGuard Peer in your cloud infrastructure. \nThis resource enables the creation, management, and deletion of a WireGuard VPN Peer, facilitating secure connections between your network resources.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = new ionoscloud.vpn.WireguardPeer(\"example\", {\n    allowedIps: [\n        \"10.0.0.0/8\",\n        \"192.168.1.0/24\",\n    ],\n    description: \"An example WireGuard peer\",\n    endpoint: {\n        host: \"1.2.3.4\",\n        port: 51820,\n    },\n    gatewayId: \"your gateway id here\",\n    location: \"de/fra\",\n    publicKey: \"examplePublicKey==\",\n});\n```\n```python\nimport pulumi\nimport ionoscloud as ionoscloud\n\nexample = ionoscloud.vpn.WireguardPeer(\"example\",\n    allowed_ips=[\n        \"10.0.0.0/8\",\n        \"192.168.1.0/24\",\n    ],\n    description=\"An example WireGuard peer\",\n    endpoint={\n        \"host\": \"1.2.3.4\",\n        \"port\": 51820,\n    },\n    gateway_id=\"your gateway id here\",\n    location=\"de/fra\",\n    public_key=\"examplePublicKey==\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Ionoscloud.Vpn.WireguardPeer(\"example\", new()\n    {\n        AllowedIps = new[]\n        {\n            \"10.0.0.0/8\",\n            \"192.168.1.0/24\",\n        },\n        Description = \"An example WireGuard peer\",\n        Endpoint = new Ionoscloud.Vpn.Inputs.WireguardPeerEndpointArgs\n        {\n            Host = \"1.2.3.4\",\n            Port = 51820,\n        },\n        GatewayId = \"your gateway id here\",\n        Location = \"de/fra\",\n        PublicKey = \"examplePublicKey==\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/vpn\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vpn.NewWireguardPeer(ctx, \"example\", \u0026vpn.WireguardPeerArgs{\n\t\t\tAllowedIps: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"10.0.0.0/8\"),\n\t\t\t\tpulumi.String(\"192.168.1.0/24\"),\n\t\t\t},\n\t\t\tDescription: pulumi.String(\"An example WireGuard peer\"),\n\t\t\tEndpoint: \u0026vpn.WireguardPeerEndpointArgs{\n\t\t\t\tHost: pulumi.String(\"1.2.3.4\"),\n\t\t\t\tPort: pulumi.Int(51820),\n\t\t\t},\n\t\t\tGatewayId: pulumi.String(\"your gateway id here\"),\n\t\t\tLocation:  pulumi.String(\"de/fra\"),\n\t\t\tPublicKey: pulumi.String(\"examplePublicKey==\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.vpn.WireguardPeer;\nimport com.pulumi.ionoscloud.vpn.WireguardPeerArgs;\nimport com.pulumi.ionoscloud.vpn.inputs.WireguardPeerEndpointArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new WireguardPeer(\"example\", WireguardPeerArgs.builder()\n            .allowedIps(            \n                \"10.0.0.0/8\",\n                \"192.168.1.0/24\")\n            .description(\"An example WireGuard peer\")\n            .endpoint(WireguardPeerEndpointArgs.builder()\n                .host(\"1.2.3.4\")\n                .port(51820)\n                .build())\n            .gatewayId(\"your gateway id here\")\n            .location(\"de/fra\")\n            .publicKey(\"examplePublicKey==\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: ionoscloud:vpn:WireguardPeer\n    properties:\n      allowedIps:\n        - 10.0.0.0/8\n        - 192.168.1.0/24\n      description: An example WireGuard peer\n      endpoint:\n        host: 1.2.3.4\n        port: 51820\n      gatewayId: your gateway id here\n      location: de/fra\n      publicKey: examplePublicKey==\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nWireGuard Peers can be imported using the `gateway_id` and `id`, e.g.,\n\n```sh\n$ pulumi import ionoscloud:vpn/wireguardPeer:WireguardPeer example \u003cgateway_id\u003e:\u003cpeer_id\u003e\n```\n\n",
            "properties": {
                "allowedIps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list, string] A list of subnet CIDRs that are allowed to connect to the WireGuard Gateway.\n"
                },
                "description": {
                    "type": "string",
                    "description": "[string] A description of the WireGuard Gateway.\n"
                },
                "endpoint": {
                    "$ref": "#/types/ionoscloud:vpn/WireguardPeerEndpoint:WireguardPeerEndpoint",
                    "description": "[block] An endpoint configuration block for the WireGuard Gateway. The structure of this block is as follows:\n"
                },
                "gatewayId": {
                    "type": "string",
                    "description": "[string] The ID of the WireGuard Gateway that the Peer will connect to.\n"
                },
                "location": {
                    "type": "string",
                    "description": "[string] The location of the WireGuard Gateway.\n"
                },
                "name": {
                    "type": "string",
                    "description": "[string] The human-readable name of the WireGuard Gateway.\n"
                },
                "publicKey": {
                    "type": "string",
                    "description": "[string] The public key for the WireGuard Gateway.\n"
                },
                "status": {
                    "type": "string",
                    "description": "The current status of the WireGuard Gateway Peer.\n"
                }
            },
            "required": [
                "allowedIps",
                "gatewayId",
                "location",
                "name",
                "publicKey",
                "status"
            ],
            "inputProperties": {
                "allowedIps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "[list, string] A list of subnet CIDRs that are allowed to connect to the WireGuard Gateway.\n"
                },
                "description": {
                    "type": "string",
                    "description": "[string] A description of the WireGuard Gateway.\n"
                },
                "endpoint": {
                    "$ref": "#/types/ionoscloud:vpn/WireguardPeerEndpoint:WireguardPeerEndpoint",
                    "description": "[block] An endpoint configuration block for the WireGuard Gateway. The structure of this block is as follows:\n"
                },
                "gatewayId": {
                    "type": "string",
                    "description": "[string] The ID of the WireGuard Gateway that the Peer will connect to.\n"
                },
                "location": {
                    "type": "string",
                    "description": "[string] The location of the WireGuard Gateway.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "[string] The human-readable name of the WireGuard Gateway.\n"
                },
                "publicKey": {
                    "type": "string",
                    "description": "[string] The public key for the WireGuard Gateway.\n"
                }
            },
            "requiredInputs": [
                "allowedIps",
                "gatewayId",
                "location",
                "publicKey"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WireguardPeer resources.\n",
                "properties": {
                    "allowedIps": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "[list, string] A list of subnet CIDRs that are allowed to connect to the WireGuard Gateway.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "[string] A description of the WireGuard Gateway.\n"
                    },
                    "endpoint": {
                        "$ref": "#/types/ionoscloud:vpn/WireguardPeerEndpoint:WireguardPeerEndpoint",
                        "description": "[block] An endpoint configuration block for the WireGuard Gateway. The structure of this block is as follows:\n"
                    },
                    "gatewayId": {
                        "type": "string",
                        "description": "[string] The ID of the WireGuard Gateway that the Peer will connect to.\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "[string] The location of the WireGuard Gateway.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] The human-readable name of the WireGuard Gateway.\n"
                    },
                    "publicKey": {
                        "type": "string",
                        "description": "[string] The public key for the WireGuard Gateway.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "The current status of the WireGuard Gateway Peer.\n"
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "ionoscloud:alb/getBalancer:getBalancer": {
            "description": "The **Application Load Balancer data source** can be used to search for and return an existing Application Load Balancer.\nYou can provide a string for the name parameter which will be compared with provisioned Application Load Balancers.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search and make sure that your resources have unique names.\n\n## Example Usage\n\n### By Name\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.alb.getBalancer({\n    datacenterId: ionoscloud_datacenter.example.id,\n    name: \"ALB name\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.alb.get_balancer(datacenter_id=ionoscloud_datacenter[\"example\"][\"id\"],\n    name=\"ALB name\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Alb.GetBalancer.Invoke(new()\n    {\n        DatacenterId = ionoscloud_datacenter.Example.Id,\n        Name = \"ALB name\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/alb\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := alb.LookupBalancer(ctx, \u0026alb.LookupBalancerArgs{\n\t\t\tDatacenterId: ionoscloud_datacenter.Example.Id,\n\t\t\tName:         pulumi.StringRef(\"ALB name\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.alb.AlbFunctions;\nimport com.pulumi.ionoscloud.alb.inputs.GetBalancerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = AlbFunctions.getBalancer(GetBalancerArgs.builder()\n            .datacenterId(ionoscloud_datacenter.example().id())\n            .name(\"ALB name\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:alb:getBalancer\n      arguments:\n        datacenterId: ${ionoscloud_datacenter.example.id}\n        name: ALB name\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### By Name with Partial Match\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.alb.getBalancer({\n    datacenterId: ionoscloud_datacenter.example.id,\n    name: \"name\",\n    partialMatch: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.alb.get_balancer(datacenter_id=ionoscloud_datacenter[\"example\"][\"id\"],\n    name=\"name\",\n    partial_match=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Alb.GetBalancer.Invoke(new()\n    {\n        DatacenterId = ionoscloud_datacenter.Example.Id,\n        Name = \"name\",\n        PartialMatch = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/alb\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := alb.LookupBalancer(ctx, \u0026alb.LookupBalancerArgs{\n\t\t\tDatacenterId: ionoscloud_datacenter.Example.Id,\n\t\t\tName:         pulumi.StringRef(\"name\"),\n\t\t\tPartialMatch: pulumi.BoolRef(true),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.alb.AlbFunctions;\nimport com.pulumi.ionoscloud.alb.inputs.GetBalancerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = AlbFunctions.getBalancer(GetBalancerArgs.builder()\n            .datacenterId(ionoscloud_datacenter.example().id())\n            .name(\"name\")\n            .partialMatch(true)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:alb:getBalancer\n      arguments:\n        datacenterId: ${ionoscloud_datacenter.example.id}\n        name: name\n        partialMatch: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getBalancer.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "Datacenter's UUID.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "ID of the application load balancer you want to search for.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of an existing application load balancer that you want to search for. Search by name is case-insensitive. The whole resource name is required if `partial_match` parameter is not set to true.\n"
                    },
                    "partialMatch": {
                        "type": "boolean",
                        "description": "Whether partial matching is allowed or not when using name argument. Default value is false.\n\n`datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.\n"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getBalancer.\n",
                "properties": {
                    "centralLogging": {
                        "type": "boolean",
                        "description": "Turn logging on and off for this product. Default value is 'false'.\n"
                    },
                    "datacenterId": {
                        "type": "string"
                    },
                    "flowlogs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:alb/getBalancerFlowlog:getBalancerFlowlog"
                        },
                        "description": "Only 1 flow log can be configured. Only the name field can change as part of an update. Flow logs holistically capture network information such as source and destination IP addresses, source and destination ports, number of packets, amount of bytes, the start and end time of the recording, and the type of protocol – and log the extent to which your instances are being accessed.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Id of the application load balancer.\n"
                    },
                    "ips": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Collection of the Application Load Balancer IP addresses. (Inbound and outbound) IPs of the listenerLan are customer-reserved public IPs for the public Load Balancers, and private IPs for the private Load Balancers.\n"
                    },
                    "lbPrivateIps": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Collection of private IP addresses with the subnet mask of the Application Load Balancer. IPs must contain valid a subnet mask. If no IP is provided, the system will generate an IP with /24 subnet.\n"
                    },
                    "listenerLan": {
                        "type": "integer",
                        "description": "ID of the listening (inbound) LAN.\n"
                    },
                    "loggingFormat": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the name of the flow log.\n"
                    },
                    "partialMatch": {
                        "type": "boolean"
                    },
                    "targetLan": {
                        "type": "integer",
                        "description": "ID of the balanced private target LAN (outbound).\n"
                    }
                },
                "type": "object",
                "required": [
                    "centralLogging",
                    "datacenterId",
                    "flowlogs",
                    "ips",
                    "lbPrivateIps",
                    "listenerLan",
                    "loggingFormat",
                    "targetLan"
                ]
            }
        },
        "ionoscloud:alb/getForwardingRule:getForwardingRule": {
            "description": "The Application Load Balancer Forwarding Rule data source can be used to search for and return an existing Application Load Balancer Forwarding Rules.\nYou can provide a string for the name parameter which will be compared with provisioned Application Load Balancers Forwarding Rules.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search and make sure that your resources have unique names.\n\n## Example Usage\n\n### By Name\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.alb.getForwardingRule({\n    datacenterId: ionoscloud_datacenter.example.id,\n    applicationLoadbalancerId: ionoscloud_application_loadbalancer.example.id,\n    name: \"ALB FR Example\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.alb.get_forwarding_rule(datacenter_id=ionoscloud_datacenter[\"example\"][\"id\"],\n    application_loadbalancer_id=ionoscloud_application_loadbalancer[\"example\"][\"id\"],\n    name=\"ALB FR Example\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Alb.GetForwardingRule.Invoke(new()\n    {\n        DatacenterId = ionoscloud_datacenter.Example.Id,\n        ApplicationLoadbalancerId = ionoscloud_application_loadbalancer.Example.Id,\n        Name = \"ALB FR Example\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/alb\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := alb.LookupForwardingRule(ctx, \u0026alb.LookupForwardingRuleArgs{\n\t\t\tDatacenterId:              ionoscloud_datacenter.Example.Id,\n\t\t\tApplicationLoadbalancerId: ionoscloud_application_loadbalancer.Example.Id,\n\t\t\tName:                      pulumi.StringRef(\"ALB FR Example\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.alb.AlbFunctions;\nimport com.pulumi.ionoscloud.alb.inputs.GetForwardingRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = AlbFunctions.getForwardingRule(GetForwardingRuleArgs.builder()\n            .datacenterId(ionoscloud_datacenter.example().id())\n            .applicationLoadbalancerId(ionoscloud_application_loadbalancer.example().id())\n            .name(\"ALB FR Example\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:alb:getForwardingRule\n      arguments:\n        datacenterId: ${ionoscloud_datacenter.example.id}\n        applicationLoadbalancerId: ${ionoscloud_application_loadbalancer.example.id}\n        name: ALB FR Example\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### By Name with Partial Match\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.alb.getForwardingRule({\n    datacenterId: ionoscloud_datacenter.example.id,\n    applicationLoadbalancerId: ionoscloud_application_loadbalancer.example.id,\n    name: \"Example\",\n    partialMatch: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.alb.get_forwarding_rule(datacenter_id=ionoscloud_datacenter[\"example\"][\"id\"],\n    application_loadbalancer_id=ionoscloud_application_loadbalancer[\"example\"][\"id\"],\n    name=\"Example\",\n    partial_match=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Alb.GetForwardingRule.Invoke(new()\n    {\n        DatacenterId = ionoscloud_datacenter.Example.Id,\n        ApplicationLoadbalancerId = ionoscloud_application_loadbalancer.Example.Id,\n        Name = \"Example\",\n        PartialMatch = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/alb\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := alb.LookupForwardingRule(ctx, \u0026alb.LookupForwardingRuleArgs{\n\t\t\tDatacenterId:              ionoscloud_datacenter.Example.Id,\n\t\t\tApplicationLoadbalancerId: ionoscloud_application_loadbalancer.Example.Id,\n\t\t\tName:                      pulumi.StringRef(\"Example\"),\n\t\t\tPartialMatch:              pulumi.BoolRef(true),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.alb.AlbFunctions;\nimport com.pulumi.ionoscloud.alb.inputs.GetForwardingRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = AlbFunctions.getForwardingRule(GetForwardingRuleArgs.builder()\n            .datacenterId(ionoscloud_datacenter.example().id())\n            .applicationLoadbalancerId(ionoscloud_application_loadbalancer.example().id())\n            .name(\"Example\")\n            .partialMatch(true)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:alb:getForwardingRule\n      arguments:\n        datacenterId: ${ionoscloud_datacenter.example.id}\n        applicationLoadbalancerId: ${ionoscloud_application_loadbalancer.example.id}\n        name: Example\n        partialMatch: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getForwardingRule.\n",
                "properties": {
                    "applicationLoadbalancerId": {
                        "type": "string",
                        "description": "Application Load Balancer's UUID.\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "Datacenter's UUID.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "ID of the application load balancer you want to search for.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of an existing application load balancer that you want to search for. Search by name is case-insensitive. The whole resource name is required if `partial_match` parameter is not set to true.\n"
                    },
                    "partialMatch": {
                        "type": "boolean",
                        "description": "Whether partial matching is allowed or not when using name argument. Default value is false.\n\nBoth `datacenter_id` and `application_loadbalancer_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.\n"
                    }
                },
                "type": "object",
                "required": [
                    "applicationLoadbalancerId",
                    "datacenterId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getForwardingRule.\n",
                "properties": {
                    "applicationLoadbalancerId": {
                        "type": "string"
                    },
                    "clientTimeout": {
                        "type": "integer",
                        "description": "The maximum time in milliseconds to wait for the client to acknowledge or send data; default is 50,000 (50 seconds).\n- `server certificates` - Array of items in that collection.\n"
                    },
                    "datacenterId": {
                        "type": "string"
                    },
                    "httpRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:alb/getForwardingRuleHttpRule:getForwardingRuleHttpRule"
                        },
                        "description": "Array of items in that collection\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Id of Application Load Balancer Forwarding Rule\n"
                    },
                    "listenerIp": {
                        "type": "string",
                        "description": "Listening (inbound) IP.\n"
                    },
                    "listenerPort": {
                        "type": "integer",
                        "description": "Listening (inbound) port number; valid range is 1 to 65535.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The unique name of the Application Load Balancer HTTP rule.\n"
                    },
                    "partialMatch": {
                        "type": "boolean"
                    },
                    "protocol": {
                        "type": "string",
                        "description": "Balancing protocol.\n"
                    },
                    "serverCertificates": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "applicationLoadbalancerId",
                    "clientTimeout",
                    "datacenterId",
                    "httpRules",
                    "listenerIp",
                    "listenerPort",
                    "protocol",
                    "serverCertificates"
                ]
            }
        },
        "ionoscloud:apigateway/getApigateway:getApigateway": {
            "description": "The **API Gateway data source** can be used to search for and return an existing API Gateway.\nYou can provide a string for the name parameter which will be compared with provisioned API Gateways.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search string so that it is specific enough to return only one result.\n\n## Example Usage\n\n### By Name\n\nNeeds to have the resource be previously created, or a depends_on clause to ensure that the resource is created before\nthis data source is called.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.apigateway.getApigateway({\n    name: \"example-apigateway\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.apigateway.get_apigateway(name=\"example-apigateway\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Apigateway.GetApigateway.Invoke(new()\n    {\n        Name = \"example-apigateway\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/apigateway\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := apigateway.LookupApigateway(ctx, \u0026apigateway.LookupApigatewayArgs{\n\t\t\tName: pulumi.StringRef(\"example-apigateway\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.apigateway.ApigatewayFunctions;\nimport com.pulumi.ionoscloud.apigateway.inputs.GetApigatewayArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = ApigatewayFunctions.getApigateway(GetApigatewayArgs.builder()\n            .name(\"example-apigateway\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:apigateway:getApigateway\n      arguments:\n        name: example-apigateway\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getApigateway.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "ID of an existing API Gateway that you want to search for.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of an existing API Gateway that you want to search for.\n"
                    },
                    "partialMatch": {
                        "type": "boolean",
                        "description": "Whether partial matching is allowed or not when using the name filter. Defaults to `false`.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getApigateway.\n",
                "properties": {
                    "customDomains": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:apigateway/getApigatewayCustomDomain:getApigatewayCustomDomain"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "ID of the API Gateway.\n"
                    },
                    "logs": {
                        "type": "boolean",
                        "description": "Shows whether the collection and reporting of logs for observability of this instance is enabled or disabled.\n"
                    },
                    "metrics": {
                        "type": "boolean",
                        "description": "Shows whether the collection and reporting of metrics for observability of this instance is enabled or disabled.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The domain name of the distribution.\n"
                    },
                    "partialMatch": {
                        "type": "boolean"
                    },
                    "publicEndpoint": {
                        "type": "string",
                        "description": "The public endpoint of the API Gateway.\n"
                    }
                },
                "type": "object",
                "required": [
                    "customDomains",
                    "id",
                    "logs",
                    "metrics",
                    "name",
                    "publicEndpoint"
                ]
            }
        },
        "ionoscloud:apigateway/getRoute:getRoute": {
            "description": "The **API Gateway Route data source** can be used to search for and return an existing API Gateway route.\nYou can provide a string for the name parameter which will be compared with provisioned API Gateway routes.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search string so that it is specific enough to return only one result.\n\n## Example Usage\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getRoute.\n",
                "properties": {
                    "gatewayId": {
                        "type": "string",
                        "description": "The ID of the API Gateway that the route belongs to.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "ID of an existing API Gateway Route that you want to search for.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of an existing API Gateway Route that you want to search for.\n"
                    },
                    "partialMatch": {
                        "type": "boolean"
                    }
                },
                "type": "object",
                "required": [
                    "gatewayId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRoute.\n",
                "properties": {
                    "gatewayId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "ID of the API Gateway Route.\n"
                    },
                    "methods": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The HTTP methods that the route should match.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the API Gateway Route.\n"
                    },
                    "partialMatch": {
                        "type": "boolean"
                    },
                    "paths": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The paths that the route should match.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "This field specifies the protocol used by the ingress to route traffic to the backend service.\n"
                    },
                    "upstreams": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:apigateway/getRouteUpstream:getRouteUpstream"
                        }
                    },
                    "websocket": {
                        "type": "boolean",
                        "description": "Shows whether websocket support is enabled or disabled.\n"
                    }
                },
                "type": "object",
                "required": [
                    "gatewayId",
                    "id",
                    "methods",
                    "name",
                    "paths",
                    "type",
                    "upstreams",
                    "websocket"
                ]
            }
        },
        "ionoscloud:autoscaling/getGroup:getGroup": {
            "description": "The autoscaling group data source can be used to search for and return an existing Autoscaling Group. You can provide a string for the name or id parameters which will be compared with provisioned Autoscaling Groups. If a single match is found, it will be returned.\n\n## Example Usage\n\n### By Name\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst autoscalingGroup = ionoscloud.autoscaling.getGroup({\n    name: \"test_ds\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nautoscaling_group = ionoscloud.autoscaling.get_group(name=\"test_ds\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var autoscalingGroup = Ionoscloud.Autoscaling.GetGroup.Invoke(new()\n    {\n        Name = \"test_ds\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/autoscaling\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := autoscaling.LookupGroup(ctx, \u0026autoscaling.LookupGroupArgs{\n\t\t\tName: pulumi.StringRef(\"test_ds\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.autoscaling.AutoscalingFunctions;\nimport com.pulumi.ionoscloud.autoscaling.inputs.GetGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var autoscalingGroup = AutoscalingFunctions.getGroup(GetGroupArgs.builder()\n            .name(\"test_ds\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  autoscalingGroup:\n    fn::invoke:\n      function: ionoscloud:autoscaling:getGroup\n      arguments:\n        name: test_ds\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getGroup.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "Id of an existing Autoscaling Group that you want to search for.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of an existing Autoscaling Group that you want to search for.\n\nEither `name` or `id` must be provided. If none or both are provided, the datasource will return an error.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getGroup.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "Unique identifier for the resource\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "Location of the datacenter. This location is the same as the one from the selected template.\n"
                    },
                    "maxReplicaCount": {
                        "type": "integer",
                        "description": "Maximum replica count value for `targetReplicaCount`. Will be enforced for both automatic and manual changes.\n"
                    },
                    "minReplicaCount": {
                        "type": "integer",
                        "description": "Minimum replica count value for `targetReplicaCount`. Will be enforced for both automatic and manual changes.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the Autoscaling Group.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:autoscaling/getGroupPolicy:getGroupPolicy"
                        },
                        "description": "Specifies the behavior of this Autoscaling Group. A policy consists of Triggers and Actions, whereby an Action is some kind of automated behavior, and a Trigger is defined by the circumstances under which the Action is triggered. Currently, two separate Actions, namely Scaling In and Out are supported, triggered through Thresholds defined on a given Metric.\n"
                    },
                    "replicaConfigurations": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:autoscaling/getGroupReplicaConfiguration:getGroupReplicaConfiguration"
                        }
                    },
                    "targetReplicaCount": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId",
                    "location",
                    "maxReplicaCount",
                    "minReplicaCount",
                    "policies",
                    "replicaConfigurations",
                    "targetReplicaCount"
                ]
            }
        },
        "ionoscloud:autoscaling/getServers:getServers": {
            "description": "The autoscaling group servers data source can be used to search for and return existing servers that are part of a specific autoscaling group.\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getServers.\n",
                "properties": {
                    "groupId": {
                        "type": "string",
                        "description": "The unique ID of the autoscaling group.\n\n`group_id` must be provided. If it is not provided, the datasource will return an error.\n"
                    }
                },
                "type": "object",
                "required": [
                    "groupId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getServers.\n",
                "properties": {
                    "groupId": {
                        "type": "string",
                        "description": "Id of the autoscaling group.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "servers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:autoscaling/getServersServer:getServersServer"
                        },
                        "description": "List of servers.\n"
                    }
                },
                "type": "object",
                "required": [
                    "groupId",
                    "servers",
                    "id"
                ]
            }
        },
        "ionoscloud:cdn/getDistribution:getDistribution": {
            "description": "The Distribution data source can be used to search for and return an existing Distributions.\nYou can provide a string for the domain parameter which will be compared with provisioned Distributions.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search and make sure that your resources have unique domains.\n\n## Example Usage\n\n### By Domain\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.cdn.getDistribution({\n    domain: \"example.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.cdn.get_distribution(domain=\"example.com\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Cdn.GetDistribution.Invoke(new()\n    {\n        Domain = \"example.com\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/cdn\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cdn.LookupDistribution(ctx, \u0026cdn.LookupDistributionArgs{\n\t\t\tDomain: pulumi.StringRef(\"example.com\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.cdn.CdnFunctions;\nimport com.pulumi.ionoscloud.cdn.inputs.GetDistributionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = CdnFunctions.getDistribution(GetDistributionArgs.builder()\n            .domain(\"example.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:cdn:getDistribution\n      arguments:\n        domain: example.com\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### By Domain with Partial Match\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.cdn.getDistribution({\n    domain: \"example\",\n    partialMatch: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.cdn.get_distribution(domain=\"example\",\n    partial_match=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Cdn.GetDistribution.Invoke(new()\n    {\n        Domain = \"example\",\n        PartialMatch = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/cdn\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cdn.LookupDistribution(ctx, \u0026cdn.LookupDistributionArgs{\n\t\t\tDomain:       pulumi.StringRef(\"example\"),\n\t\t\tPartialMatch: pulumi.BoolRef(true),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.cdn.CdnFunctions;\nimport com.pulumi.ionoscloud.cdn.inputs.GetDistributionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = CdnFunctions.getDistribution(GetDistributionArgs.builder()\n            .domain(\"example\")\n            .partialMatch(true)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:cdn:getDistribution\n      arguments:\n        domain: example\n        partialMatch: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDistribution.\n",
                "properties": {
                    "domain": {
                        "type": "string",
                        "description": "Domain of an existing distribution that you want to search for. Search by domain is case-insensitive. The whole resource domain is required if `partial_match` parameter is not set to true.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "ID of the distribution you want to search for.\n"
                    },
                    "partialMatch": {
                        "type": "boolean",
                        "description": "Whether partial matching is allowed or not when using domain argument. Default value is false.\n\nEither `domain` or `id` must be provided. If none, or both of `domain` and `id` are provided, the datasource will return an error.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getDistribution.\n",
                "properties": {
                    "certificateId": {
                        "type": "string",
                        "description": "The ID of the certificate to use for the distribution. You can create certificates with the certificate resource.\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "The domain of the distribution.\n"
                    },
                    "id": {
                        "type": "string"
                    },
                    "partialMatch": {
                        "type": "boolean"
                    },
                    "publicEndpointV4": {
                        "type": "string",
                        "description": "IP of the distribution, it has to be included on the domain DNS Zone as A record.\n"
                    },
                    "publicEndpointV6": {
                        "type": "string",
                        "description": "IP of the distribution, it has to be included on the domain DNS Zone as AAAA record.\n"
                    },
                    "resourceUrn": {
                        "type": "string",
                        "description": "Unique resource identifier.\n"
                    },
                    "routingRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:cdn/getDistributionRoutingRule:getDistributionRoutingRule"
                        },
                        "description": "The routing rules for the distribution.\n"
                    }
                },
                "type": "object",
                "required": [
                    "certificateId",
                    "publicEndpointV4",
                    "publicEndpointV6",
                    "resourceUrn",
                    "routingRules"
                ]
            }
        },
        "ionoscloud:cert/getAutoCertificate:getAutoCertificate": {
            "description": "The **CM AutoCertificate data source** can be used to search for and return an existing auto-certificate.\nYou can provide a string for either id or name parameters which will be compared with provisioned auto-certificates.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search string so that it is specific enough to return only one result.\n\n## Example Usage\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAutoCertificate.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "[string] ID of the auto-certificate you want to search for.\n\nEither `name` or `id` must be provided. If none, or both are provided, the datasource will return an error.\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "[string] The location of the auto-certificate.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] Name of an existing auto-certificate that you want to search for.\n"
                    }
                },
                "type": "object",
                "required": [
                    "location"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAutoCertificate.\n",
                "properties": {
                    "commonName": {
                        "type": "string",
                        "description": "[string] The common name (DNS) of the certificate to issue. The common name needs to be part of a zone in IONOS Cloud DNS.\n"
                    },
                    "id": {
                        "type": "string"
                    },
                    "keyAlgorithm": {
                        "type": "string",
                        "description": "[string] The key algorithm used to generate the certificate.\n"
                    },
                    "lastIssuedCertificateId": {
                        "type": "string",
                        "description": "[string] The ID of the last certificate that was issued.\n"
                    },
                    "location": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "providerId": {
                        "type": "string"
                    },
                    "subjectAlternativeNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "[list][string] Optional additional names to be added to the issued certificate. The additional names needs to be part of a zone in IONOS Cloud DNS.\n"
                    }
                },
                "type": "object",
                "required": [
                    "commonName",
                    "keyAlgorithm",
                    "lastIssuedCertificateId",
                    "location",
                    "providerId",
                    "subjectAlternativeNames"
                ]
            }
        },
        "ionoscloud:cert/getAutoCertificateProvider:getAutoCertificateProvider": {
            "description": "The **CM Provider data source** can be used to search for and return an existing certificate manager provider.\nYou can provide a string for either id or name parameters which will be compared with provisioned providers.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search string so that it is specific enough to return only one result.\n\n## Example Usage\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAutoCertificateProvider.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "[string] ID of the provider you want to search for.\n\nEither `name` or `id` must be provided. If none, or both are provided, the datasource will return an error.\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "[string] The location of the provider.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] Name of an existing provider that you want to search for.\n"
                    }
                },
                "type": "object",
                "required": [
                    "location"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAutoCertificateProvider.\n",
                "properties": {
                    "email": {
                        "type": "string",
                        "description": "[string] The email address of the certificate requester.\n"
                    },
                    "externalAccountBindings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:cert/getAutoCertificateProviderExternalAccountBinding:getAutoCertificateProviderExternalAccountBinding"
                        },
                        "description": "[list]\n"
                    },
                    "id": {
                        "type": "string"
                    },
                    "location": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "server": {
                        "type": "string",
                        "description": "[string] The URL of the certificate provider.\n"
                    }
                },
                "type": "object",
                "required": [
                    "email",
                    "externalAccountBindings",
                    "location",
                    "server"
                ]
            }
        },
        "ionoscloud:cert/getCertificate:getCertificate": {
            "description": "The **Certificate data source** can be used to search for and return an existing certificate.\nYou can provide a string for either id or name parameters which will be compared with provisioned certificates.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search string so that it is specific enough to return only one result.\n\n## Example Usage\n\n### By Name\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.cert.getCertificate({\n    name: \"Certificate Name Example\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.cert.get_certificate(name=\"Certificate Name Example\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Cert.GetCertificate.Invoke(new()\n    {\n        Name = \"Certificate Name Example\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/cert\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := cert.LookupCertificate(ctx, \u0026cert.LookupCertificateArgs{\n\t\t\tName: pulumi.StringRef(\"Certificate Name Example\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.cert.CertFunctions;\nimport com.pulumi.ionoscloud.cert.inputs.GetCertificateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = CertFunctions.getCertificate(GetCertificateArgs.builder()\n            .name(\"Certificate Name Example\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:cert:getCertificate\n      arguments:\n        name: Certificate Name Example\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCertificate.\n",
                "properties": {
                    "certificate": {
                        "type": "string",
                        "description": "Certificate body.\n"
                    },
                    "certificateChain": {
                        "type": "string",
                        "description": "Certificate chain.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "ID of the certificate you want to search for.\n\nEither `name` or `id` must be provided, or both. If none are provided, the datasource will return an error.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of an existing certificate that you want to search for.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getCertificate.\n",
                "properties": {
                    "certificate": {
                        "type": "string",
                        "description": "Certificate body.\n"
                    },
                    "certificateChain": {
                        "type": "string",
                        "description": "Certificate chain.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The id of the certificate.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the certificate.\n"
                    }
                },
                "type": "object",
                "required": [
                    "certificate",
                    "certificateChain"
                ]
            }
        },
        "ionoscloud:compute/getBackupUnit:getBackupUnit": {
            "description": "The **Backup Unit data source** can be used to search for and return an existing Backup Unit.\nYou can provide a string for either id or name parameters which will be compared with provisioned Backup Units. \nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned. \nWhen this happens, please refine your search string so that it is specific enough to return only one result.\n\n## Example Usage\n\n### By Name\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.compute.getBackupUnit({\n    name: \"Backup Unit Example\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.compute.get_backup_unit(name=\"Backup Unit Example\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Compute.GetBackupUnit.Invoke(new()\n    {\n        Name = \"Backup Unit Example\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := compute.LookupBackupUnit(ctx, \u0026compute.LookupBackupUnitArgs{\n\t\t\tName: pulumi.StringRef(\"Backup Unit Example\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.ComputeFunctions;\nimport com.pulumi.ionoscloud.compute.inputs.GetBackupUnitArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = ComputeFunctions.getBackupUnit(GetBackupUnitArgs.builder()\n            .name(\"Backup Unit Example\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:compute:getBackupUnit\n      arguments:\n        name: Backup Unit Example\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getBackupUnit.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "ID of the backup unit you want to search for.\n\nEither `name` or `id` must be provided. If none, or both are provided, the datasource will return an error.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of an existing backup unit that you want to search for.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getBackupUnit.\n",
                "properties": {
                    "email": {
                        "type": "string",
                        "description": "The e-mail address you want assigned to the backup unit.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The id of the Backup Unit.\n"
                    },
                    "login": {
                        "type": "string",
                        "description": "The login associated with the backup unit. Derived from the contract number.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the Backup Unit.\n"
                    }
                },
                "type": "object",
                "required": [
                    "email",
                    "login"
                ]
            }
        },
        "ionoscloud:compute/getCrossconnect:getCrossconnect": {
            "description": "The **Cross Connect data source** can be used to search for and return existing cross connects.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search string so that it is specific enough to return only one result.\n\n## Example Usage\n\n### By Name\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.compute.getCrossconnect({\n    name: \"Cross Connect Example\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.compute.get_crossconnect(name=\"Cross Connect Example\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Compute.GetCrossconnect.Invoke(new()\n    {\n        Name = \"Cross Connect Example\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := compute.LookupCrossconnect(ctx, \u0026compute.LookupCrossconnectArgs{\n\t\t\tName: pulumi.StringRef(\"Cross Connect Example\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.ComputeFunctions;\nimport com.pulumi.ionoscloud.compute.inputs.GetCrossconnectArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = ComputeFunctions.getCrossconnect(GetCrossconnectArgs.builder()\n            .name(\"Cross Connect Example\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:compute:getCrossconnect\n      arguments:\n        name: Cross Connect Example\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCrossconnect.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of cross connect\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "ID of the cross connect you want to search for.\n\nEither `name` or `id` must be provided. If none, or both are provided, the datasource will return an error.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of an existing cross connect that you want to search for.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getCrossconnect.\n",
                "properties": {
                    "connectableDatacenters": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:compute/getCrossconnectConnectableDatacenter:getCrossconnectConnectableDatacenter"
                        },
                        "description": "Lists datacenters that can be joined to this cross connect\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of cross connect\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The UUID of the connectable datacenter\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the connectable datacenter\n"
                    },
                    "peers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:compute/getCrossconnectPeer:getCrossconnectPeer"
                        },
                        "description": "Lists LAN's joined to this cross connect\n"
                    }
                },
                "type": "object",
                "required": [
                    "connectableDatacenters",
                    "peers"
                ]
            }
        },
        "ionoscloud:compute/getCubeServer:getCubeServer": {
            "description": "The **Cube Server data source** can be used to search for and return existing servers. \nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search string so that it is specific enough to return only one result.\n\n## Example Usage\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCubeServer.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "Datacenter's UUID.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "ID of the server you want to search for.\n\n`datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of an existing server that you want to search for.\n"
                    },
                    "templateUuid": {
                        "type": "string",
                        "description": "The UUID of the template for creating a CUBE server; the available templates for CUBE servers can be found on the templates resource\n"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCubeServer.\n",
                "properties": {
                    "availabilityZone": {
                        "type": "string",
                        "description": "The availability zone in which the volume should exist\n"
                    },
                    "bootCdrom": {
                        "type": "string"
                    },
                    "bootImage": {
                        "type": "string"
                    },
                    "bootVolume": {
                        "type": "string"
                    },
                    "cdroms": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:compute/getCubeServerCdrom:getCubeServerCdrom"
                        },
                        "description": "list of\n"
                    },
                    "cores": {
                        "type": "integer"
                    },
                    "cpuFamily": {
                        "type": "string"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "The id of the datacenter\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Id of the firewall rule\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the firewall rule\n"
                    },
                    "nics": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:compute/getCubeServerNic:getCubeServerNic"
                        },
                        "description": "list of\n"
                    },
                    "ram": {
                        "type": "integer"
                    },
                    "templateUuid": {
                        "type": "string",
                        "description": "The UUID of the template for creating a CUBE server; the available templates for CUBE servers can be found on the templates resource\n"
                    },
                    "token": {
                        "type": "string"
                    },
                    "vmState": {
                        "type": "string",
                        "description": "Status of the virtual Machine\n"
                    },
                    "volumes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:compute/getCubeServerVolume:getCubeServerVolume"
                        },
                        "description": "list of\n"
                    }
                },
                "type": "object",
                "required": [
                    "availabilityZone",
                    "bootCdrom",
                    "bootImage",
                    "bootVolume",
                    "cdroms",
                    "cores",
                    "cpuFamily",
                    "datacenterId",
                    "nics",
                    "ram",
                    "token",
                    "vmState",
                    "volumes"
                ]
            }
        },
        "ionoscloud:compute/getDatacenter:getDatacenter": {
            "description": "The **Datacenter data source** can be used to search for and return an existing Virtual Data Center.\nYou can provide a string for the name and location parameters which will be compared with provisioned Virtual Data Centers.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search string so that it is specific enough to return only one result.\n\n## Example Usage\n\n### By Name \u0026 Location\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.compute.getDatacenter({\n    location: \"us/las\",\n    name: \"Datacenter Example\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.compute.get_datacenter(location=\"us/las\",\n    name=\"Datacenter Example\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Compute.GetDatacenter.Invoke(new()\n    {\n        Location = \"us/las\",\n        Name = \"Datacenter Example\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := compute.LookupDatacenter(ctx, \u0026compute.LookupDatacenterArgs{\n\t\t\tLocation: pulumi.StringRef(\"us/las\"),\n\t\t\tName:     pulumi.StringRef(\"Datacenter Example\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.ComputeFunctions;\nimport com.pulumi.ionoscloud.compute.inputs.GetDatacenterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = ComputeFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .location(\"us/las\")\n            .name(\"Datacenter Example\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:compute:getDatacenter\n      arguments:\n        location: us/las\n        name: Datacenter Example\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDatacenter.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "Id of an existing Virtual Data Center that you want to search for.\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "Id of the existing Virtual Data Center's location.\n\nEither `name`, `location` or `id` must be provided. If none, the datasource will return an error.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of an existing Virtual Data Center that you want to search for.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getDatacenter.\n",
                "properties": {
                    "cpuArchitectures": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:compute/getDatacenterCpuArchitecture:getDatacenterCpuArchitecture"
                        },
                        "description": "Array of features and CPU families available in a location\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description for the Virtual Data Center\n"
                    },
                    "features": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of features supported by the location this data center is part of\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "UUID of the Virtual Data Center\n"
                    },
                    "ipv6CidrBlock": {
                        "type": "string"
                    },
                    "location": {
                        "type": "string",
                        "description": "The regional location where the Virtual Data Center will be created\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the Virtual Data Center\n"
                    },
                    "secAuthProtection": {
                        "type": "boolean",
                        "description": "Boolean value representing if the data center requires extra protection e.g. two factor protection\n"
                    },
                    "version": {
                        "type": "integer",
                        "description": "The version of that Data Center. Gets incremented with every change\n"
                    }
                },
                "type": "object",
                "required": [
                    "cpuArchitectures",
                    "description",
                    "features",
                    "ipv6CidrBlock",
                    "secAuthProtection",
                    "version"
                ]
            }
        },
        "ionoscloud:compute/getFirewall:getFirewall": {
            "description": "The **Firewall data source** can be used to search for and return an existing FirewallRules. \nYou can provide a string for either id or name parameters which will be compared with provisioned Firewall Rules.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned. \nWhen this happens, please refine your search string so that it is specific enough to return only one result.\n\n## Example Usage\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getFirewall.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The Virtual Data Center ID.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "ID of the firewall rule you want to search for.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of an existing firewall rule that you want to search for.\n"
                    },
                    "nicId": {
                        "type": "string",
                        "description": "The NIC ID.\n\nEither `name` or   `id` must be provided. If none, or both are provided, the datasource will return an error.\n"
                    },
                    "serverId": {
                        "type": "string",
                        "description": "The Server ID.\n"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId",
                    "nicId",
                    "serverId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getFirewall.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "icmpCode": {
                        "type": "string",
                        "description": "Defines the allowed code (from 0 to 254) if protocol ICMP is chosen.\n"
                    },
                    "icmpType": {
                        "type": "string",
                        "description": "Defines the allowed type (from 0 to 254) if the protocol ICMP is chosen.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The id of the firewall rule.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the firewall rule.\n"
                    },
                    "nicId": {
                        "type": "string"
                    },
                    "portRangeEnd": {
                        "type": "integer",
                        "description": "Defines the end range of the allowed port (from 1 to 65534) if the protocol TCP or UDP is chosen.\n"
                    },
                    "portRangeStart": {
                        "type": "integer",
                        "description": "Defines the start range of the allowed port (from 1 to 65534) if protocol TCP or UDP is chosen.\n"
                    },
                    "protocol": {
                        "type": "string",
                        "description": "The protocol for the rule: TCP, UDP, ICMP, ANY. This property is immutable.\n"
                    },
                    "serverId": {
                        "type": "string"
                    },
                    "sourceIp": {
                        "type": "string",
                        "description": "Only traffic originating from the respective IPv4 address is allowed.\n"
                    },
                    "sourceMac": {
                        "type": "string",
                        "description": "Only traffic originating from the respective MAC address is allowed.\n"
                    },
                    "targetIp": {
                        "type": "string",
                        "description": "Only traffic directed to the respective IP address of the NIC is allowed.\n"
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId",
                    "icmpCode",
                    "icmpType",
                    "nicId",
                    "portRangeEnd",
                    "portRangeStart",
                    "protocol",
                    "serverId",
                    "sourceIp",
                    "sourceMac",
                    "targetIp",
                    "type"
                ]
            }
        },
        "ionoscloud:compute/getGroup:getGroup": {
            "description": "The **Group data source** can be used to search for and return existing groups.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned. \nWhen this happens, please refine your search string so that it is specific enough to return only one result.\n\n## Example Usage\n\n### By Name\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.compute.getGroup({\n    name: \"Group Example\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.compute.get_group(name=\"Group Example\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Compute.GetGroup.Invoke(new()\n    {\n        Name = \"Group Example\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := compute.LookupGroup(ctx, \u0026compute.LookupGroupArgs{\n\t\t\tName: pulumi.StringRef(\"Group Example\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.ComputeFunctions;\nimport com.pulumi.ionoscloud.compute.inputs.GetGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = ComputeFunctions.getGroup(GetGroupArgs.builder()\n            .name(\"Group Example\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:compute:getGroup\n      arguments:\n        name: Group Example\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getGroup.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "ID of the group you want to search for.\n\nEither `name` or `id` must be provided. If none, or both are provided, the datasource will return an error.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of an existing group that you want to search for.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getGroup.\n",
                "properties": {
                    "accessActivityLog": {
                        "type": "boolean",
                        "description": "The group will be allowed to access the activity log.\n"
                    },
                    "accessAndManageCertificates": {
                        "type": "boolean",
                        "description": "The group will be allowed to access and manage certificates.\n"
                    },
                    "accessAndManageMonitoring": {
                        "type": "boolean",
                        "description": "The group will be allowed to access and manage monitoring.\n"
                    },
                    "createBackupUnit": {
                        "type": "boolean",
                        "description": "The group will be allowed to create backup unit privilege.\n"
                    },
                    "createDatacenter": {
                        "type": "boolean",
                        "description": "The group will be allowed to create virtual data centers.\n"
                    },
                    "createFlowLog": {
                        "type": "boolean",
                        "description": "The group will be allowed to create flow log.\n"
                    },
                    "createInternetAccess": {
                        "type": "boolean",
                        "description": "The group will be allowed to create internet access privilege.\n"
                    },
                    "createK8sCluster": {
                        "type": "boolean",
                        "description": "The group will be allowed to create kubernetes cluster privilege.\n"
                    },
                    "createPcc": {
                        "type": "boolean",
                        "description": "The group will be allowed to create Cross Connects privilege.\n"
                    },
                    "createSnapshot": {
                        "type": "boolean",
                        "description": "The group will be allowed to create snapshots.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The id of the group.\n"
                    },
                    "manageDbaas": {
                        "type": "boolean",
                        "description": "Privilege for a group to manage DBaaS related functionality.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A name for the group.\n"
                    },
                    "reserveIp": {
                        "type": "boolean",
                        "description": "The group will be allowed to reserve IP addresses.\n"
                    },
                    "s3Privilege": {
                        "type": "boolean",
                        "description": "The group will have S3 privilege.\n"
                    },
                    "users": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:compute/getGroupUser:getGroupUser"
                        },
                        "description": "List of users in group.\n"
                    }
                },
                "type": "object",
                "required": [
                    "accessActivityLog",
                    "accessAndManageCertificates",
                    "accessAndManageMonitoring",
                    "createBackupUnit",
                    "createDatacenter",
                    "createFlowLog",
                    "createInternetAccess",
                    "createK8sCluster",
                    "createPcc",
                    "createSnapshot",
                    "manageDbaas",
                    "reserveIp",
                    "s3Privilege",
                    "users"
                ]
            }
        },
        "ionoscloud:compute/getIPBlock:getIPBlock": {
            "description": "The **IP Block data source** can be used to search for and return an existing Ip Block.\nYou can provide a string for the id, the name or the location parameters which will be compared with the provisioned Ip Blocks.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search string so that it is specific enough to return only one result.\n\n## Example Usage\n\n### By Name\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.compute.getIPBlock({\n    name: \"IP Block Name\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.compute.get_ip_block(name=\"IP Block Name\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Compute.GetIPBlock.Invoke(new()\n    {\n        Name = \"IP Block Name\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := compute.LookupIPBlock(ctx, \u0026compute.LookupIPBlockArgs{\n\t\t\tName: pulumi.StringRef(\"IP Block Name\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.ComputeFunctions;\nimport com.pulumi.ionoscloud.compute.inputs.GetIPBlockArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = ComputeFunctions.getIPBlock(GetIPBlockArgs.builder()\n            .name(\"IP Block Name\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:compute:getIPBlock\n      arguments:\n        name: IP Block Name\n```\n\u003c!--End PulumiCodeChooser --\u003e \n\n### By Location\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.compute.getIPBlock({\n    location: \"us/las\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.compute.get_ip_block(location=\"us/las\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Compute.GetIPBlock.Invoke(new()\n    {\n        Location = \"us/las\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := compute.LookupIPBlock(ctx, \u0026compute.LookupIPBlockArgs{\n\t\t\tLocation: pulumi.StringRef(\"us/las\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.ComputeFunctions;\nimport com.pulumi.ionoscloud.compute.inputs.GetIPBlockArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = ComputeFunctions.getIPBlock(GetIPBlockArgs.builder()\n            .location(\"us/las\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:compute:getIPBlock\n      arguments:\n        location: us/las\n```\n\u003c!--End PulumiCodeChooser --\u003e \n\n### By Name \u0026 Location\n``` \ndata \"ionoscloud_ipblock\" \"example\" {\n  name      = \"IP Block Name\"\n  location  = \"us/las\"\n}\n```\n",
            "inputs": {
                "description": "A collection of arguments for invoking getIPBlock.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "ID of an existing Ip Block that you want to search for.\n"
                    },
                    "ipConsumers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:compute/getIPBlockIpConsumer:getIPBlockIpConsumer"
                        },
                        "description": "Read-Only attribute. Lists consumption detail of an individual ip\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "The regional location for this IP Block: us/las, us/ewr, de/fra, de/fkb.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of an existing Ip Block that you want to search for.\n"
                    },
                    "size": {
                        "type": "integer",
                        "description": "The number of IP addresses to reserve for this block.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getIPBlock.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The id of Ip Block\n"
                    },
                    "ipConsumers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:compute/getIPBlockIpConsumer:getIPBlockIpConsumer"
                        },
                        "description": "Read-Only attribute. Lists consumption detail of an individual ip\n"
                    },
                    "ips": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of IP addresses associated with this block.\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "The regional location for this IP Block: us/las, us/ewr, de/fra, de/fkb.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of Ip Block\n"
                    },
                    "size": {
                        "type": "integer",
                        "description": "The number of IP addresses to reserve for this block.\n"
                    }
                },
                "type": "object",
                "required": [
                    "ipConsumers",
                    "ips"
                ]
            }
        },
        "ionoscloud:compute/getIPFailover:getIPFailover": {
            "description": "The **IP Failover data source** can be used to search for and return an existing IP Failover object.\nYou need to provide the datacenter_id and the id of the lan to get the ip failover object for the provided datacenter.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getIPFailover.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The ID of the datacenter containing the ip failover datasource\n"
                    },
                    "ip": {
                        "type": "string",
                        "description": "The reserved IP address to be used in the IP failover group.\n"
                    },
                    "lanId": {
                        "type": "string",
                        "description": "The ID of a LAN.\n"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId",
                    "ip",
                    "lanId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIPFailover.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The ID of a Data Center.\n"
                    },
                    "id": {
                        "type": "string"
                    },
                    "ip": {
                        "type": "string",
                        "description": "The reserved IP address to be used in the IP failover group.\n"
                    },
                    "lanId": {
                        "type": "string",
                        "description": "The ID of a LAN.\n"
                    },
                    "nicuuid": {
                        "type": "string",
                        "description": "The ID of a NIC.\n"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId",
                    "id",
                    "ip",
                    "lanId",
                    "nicuuid"
                ]
            }
        },
        "ionoscloud:compute/getImage:getImage": {
            "description": "The **Image data source** can be used to search for and return an existing image which can then be used to provision a server.  \nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned. \nWhen this happens, please refine your search string so that it is specific enough to return only one result. In case multiple matches are found, enable debug(`TF_LOG=debug`) to show the name and location of the images.\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst cdrom = ionoscloud.compute.getImage({\n    cloudInit: \"NONE\",\n    imageAlias: \"ubuntu:latest_iso\",\n    location: \"de/txl\",\n    type: \"CDROM\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\ncdrom = ionoscloud.compute.get_image(cloud_init=\"NONE\",\n    image_alias=\"ubuntu:latest_iso\",\n    location=\"de/txl\",\n    type=\"CDROM\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var cdrom = Ionoscloud.Compute.GetImage.Invoke(new()\n    {\n        CloudInit = \"NONE\",\n        ImageAlias = \"ubuntu:latest_iso\",\n        Location = \"de/txl\",\n        Type = \"CDROM\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := compute.GetImage(ctx, \u0026compute.GetImageArgs{\n\t\t\tCloudInit:  pulumi.StringRef(\"NONE\"),\n\t\t\tImageAlias: pulumi.StringRef(\"ubuntu:latest_iso\"),\n\t\t\tLocation:   pulumi.StringRef(\"de/txl\"),\n\t\t\tType:       pulumi.StringRef(\"CDROM\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.ComputeFunctions;\nimport com.pulumi.ionoscloud.compute.inputs.GetImageArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var cdrom = ComputeFunctions.getImage(GetImageArgs.builder()\n            .cloudInit(\"NONE\")\n            .imageAlias(\"ubuntu:latest_iso\")\n            .location(\"de/txl\")\n            .type(\"CDROM\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  cdrom:\n    fn::invoke:\n      function: ionoscloud:compute:getImage\n      arguments:\n        cloudInit: NONE\n        imageAlias: ubuntu:latest_iso\n        location: de/txl\n        type: CDROM\n```\n\u003c!--End PulumiCodeChooser --\u003e\nFinds an image with alias `ubuntu:latest_iso`, in location `de/txl`, that does not support `cloud_init` and is of type `CDROM`.\n\n### Additional Examples\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.compute.getImage({\n    imageAlias: \"ubuntu:latest\",\n    location: \"de/txl\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.compute.get_image(image_alias=\"ubuntu:latest\",\n    location=\"de/txl\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Compute.GetImage.Invoke(new()\n    {\n        ImageAlias = \"ubuntu:latest\",\n        Location = \"de/txl\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := compute.GetImage(ctx, \u0026compute.GetImageArgs{\n\t\t\tImageAlias: pulumi.StringRef(\"ubuntu:latest\"),\n\t\t\tLocation:   pulumi.StringRef(\"de/txl\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.ComputeFunctions;\nimport com.pulumi.ionoscloud.compute.inputs.GetImageArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = ComputeFunctions.getImage(GetImageArgs.builder()\n            .imageAlias(\"ubuntu:latest\")\n            .location(\"de/txl\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:compute:getImage\n      arguments:\n        imageAlias: ubuntu:latest\n        location: de/txl\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nFinds an image with alias `ubuntu:latest` in location `de/txl`. Uses exact matching on both fields.\n\n### Additional Examples\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.compute.getImage({\n    cloudInit: \"V1\",\n    imageAlias: \"ubuntu:latest\",\n    location: \"us/ewr\",\n    type: \"HDD\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.compute.get_image(cloud_init=\"V1\",\n    image_alias=\"ubuntu:latest\",\n    location=\"us/ewr\",\n    type=\"HDD\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Compute.GetImage.Invoke(new()\n    {\n        CloudInit = \"V1\",\n        ImageAlias = \"ubuntu:latest\",\n        Location = \"us/ewr\",\n        Type = \"HDD\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := compute.GetImage(ctx, \u0026compute.GetImageArgs{\n\t\t\tCloudInit:  pulumi.StringRef(\"V1\"),\n\t\t\tImageAlias: pulumi.StringRef(\"ubuntu:latest\"),\n\t\t\tLocation:   pulumi.StringRef(\"us/ewr\"),\n\t\t\tType:       pulumi.StringRef(\"HDD\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.ComputeFunctions;\nimport com.pulumi.ionoscloud.compute.inputs.GetImageArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = ComputeFunctions.getImage(GetImageArgs.builder()\n            .cloudInit(\"V1\")\n            .imageAlias(\"ubuntu:latest\")\n            .location(\"us/ewr\")\n            .type(\"HDD\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:compute:getImage\n      arguments:\n        cloudInit: V1\n        imageAlias: ubuntu:latest\n        location: us/ewr\n        type: HDD\n```\n\u003c!--End PulumiCodeChooser --\u003e\nFinds an image named `ubuntu-20.04.6` in location `de/txl`. Uses exact matching.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getImage.\n",
                "properties": {
                    "cloudInit": {
                        "type": "string",
                        "description": "Cloud init compatibility (\"NONE\" or \"V1\"). Exact match.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "description of the image\n"
                    },
                    "imageAlias": {
                        "type": "string",
                        "description": "Image alias of the image you are searching for. Exact match. E.g. =`centos:latest`, `ubuntu:latest`\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "Id of the existing image's location. Exact match. Possible values: `de/fra`, `de/txl`, `gb/lhr`, `es/vit`, `us/ewr`, `us/las`\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of an existing image that you want to search for. It will return an exact match if one exists, otherwise it will retrieve partial matches.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The image type, HDD or CD-ROM. Exact match.\n"
                    },
                    "version": {
                        "type": "string",
                        "description": "The version of the image that you want to search for.\n\nIf both \"name\" and \"version\" are provided the plugin will concatenate the two strings in this format [name]-[version].\nThe resulting string will be used to search for an exact match. An error will be thrown if one is not found.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getImage.\n",
                "properties": {
                    "cloudInit": {
                        "type": "string",
                        "description": "Cloud init compatibility\n"
                    },
                    "cpuHotPlug": {
                        "type": "boolean",
                        "description": "Is capable of CPU hot plug (no reboot required)\n"
                    },
                    "cpuHotUnplug": {
                        "type": "boolean",
                        "description": "Is capable of CPU hot unplug (no reboot required)\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "description of the image\n"
                    },
                    "discScsiHotPlug": {
                        "type": "boolean",
                        "description": "Is capable of SCSI drive hot plug (no reboot required)\n"
                    },
                    "discScsiHotUnplug": {
                        "type": "boolean",
                        "description": "Is capable of SCSI drive hot unplug (no reboot required)\n"
                    },
                    "discVirtioHotPlug": {
                        "type": "boolean",
                        "description": "Is capable of Virt-IO drive hot plug (no reboot required)\n"
                    },
                    "discVirtioHotUnplug": {
                        "type": "boolean",
                        "description": "Is capable of Virt-IO drive hot unplug (no reboot required)\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "imageAlias": {
                        "type": "string"
                    },
                    "imageAliases": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of image aliases mapped for this Image\n"
                    },
                    "licenceType": {
                        "type": "string",
                        "description": "OS type of this Image\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "Location of that image/snapshot.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "name of the image\n"
                    },
                    "nicHotPlug": {
                        "type": "boolean",
                        "description": "Is capable of nic hot plug (no reboot required)\n"
                    },
                    "nicHotUnplug": {
                        "type": "boolean",
                        "description": "Is capable of nic hot unplug (no reboot required)\n"
                    },
                    "public": {
                        "type": "boolean",
                        "description": "Indicates if the image is part of the public repository or not\n"
                    },
                    "ramHotPlug": {
                        "type": "boolean",
                        "description": "Is capable of memory hot plug (no reboot required)\n"
                    },
                    "ramHotUnplug": {
                        "type": "boolean",
                        "description": "Is capable of memory hot unplug (no reboot required)\n"
                    },
                    "size": {
                        "type": "number",
                        "description": "The size of the image in GB\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "This indicates the type of image\n"
                    },
                    "version": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "cloudInit",
                    "cpuHotPlug",
                    "cpuHotUnplug",
                    "discScsiHotPlug",
                    "discScsiHotUnplug",
                    "discVirtioHotPlug",
                    "discVirtioHotUnplug",
                    "imageAliases",
                    "licenceType",
                    "nicHotPlug",
                    "nicHotUnplug",
                    "public",
                    "ramHotPlug",
                    "ramHotUnplug",
                    "size",
                    "id"
                ]
            }
        },
        "ionoscloud:compute/getLan:getLan": {
            "description": "The **LAN data source** can be used to search for and return existing lans.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search string so that it is specific enough to return only one result.\n\n## Example Usage\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getLan.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "Datacenter's UUID.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "ID of the lan you want to search for.\n\n`datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of an existing lan that you want to search for.\n"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getLan.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The ID of lan's Virtual Data Center.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The id of the LAN.\n"
                    },
                    "ipFailovers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:compute/getLanIpFailover:getLanIpFailover"
                        },
                        "description": "list of\n"
                    },
                    "ipv6CidrBlock": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the LAN.\n"
                    },
                    "pcc": {
                        "type": "string",
                        "description": "The unique id of a `ionoscloud.compute.Crossconnect` resource, in order.\n"
                    },
                    "public": {
                        "type": "boolean",
                        "description": "Indicates if the LAN faces the public Internet (true) or not (false).\n"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId",
                    "ipFailovers",
                    "ipv6CidrBlock",
                    "pcc",
                    "public"
                ]
            }
        },
        "ionoscloud:compute/getLocation:getLocation": {
            "description": "The **Location data source** can be used to search for and return an existing location which can then be used elsewhere in the configuration.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search string so that it is specific enough to return only one result.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.compute.getLocation({\n    feature: \"SSD\",\n    name: \"karlsruhe\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.compute.get_location(feature=\"SSD\",\n    name=\"karlsruhe\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Compute.GetLocation.Invoke(new()\n    {\n        Feature = \"SSD\",\n        Name = \"karlsruhe\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := compute.GetLocation(ctx, \u0026compute.GetLocationArgs{\n\t\t\tFeature: pulumi.StringRef(\"SSD\"),\n\t\t\tName:    pulumi.StringRef(\"karlsruhe\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.ComputeFunctions;\nimport com.pulumi.ionoscloud.compute.inputs.GetLocationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = ComputeFunctions.getLocation(GetLocationArgs.builder()\n            .feature(\"SSD\")\n            .name(\"karlsruhe\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:compute:getLocation\n      arguments:\n        feature: SSD\n        name: karlsruhe\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getLocation.\n",
                "properties": {
                    "feature": {
                        "type": "string",
                        "description": "A desired feature that the location must be able to provide.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the location to search for.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getLocation.\n",
                "properties": {
                    "cpuArchitectures": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:compute/getLocationCpuArchitecture:getLocationCpuArchitecture"
                        },
                        "description": "Array of features and CPU families available in a location\n"
                    },
                    "feature": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "imageAliases": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of image aliases available for the location\n"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "cpuArchitectures",
                    "imageAliases",
                    "id"
                ]
            }
        },
        "ionoscloud:compute/getNatGateway:getNatGateway": {
            "description": "The **NAT gateway data source** can be used to search for and return existing NAT Gateways.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search string so that it is specific enough to return only one result.\n\n## Example Usage\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNatGateway.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "Datacenter's UUID.\n",
                        "willReplaceOnChanges": true
                    },
                    "id": {
                        "type": "string",
                        "description": "ID of the network load balancer forwarding rule you want to search for.\n\n`datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of an existing network load balancer forwarding rule that you want to search for.\n"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNatGateway.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "Id for the LAN connected to the NAT gateway\n"
                    },
                    "lans": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:compute/getNatGatewayLan:getNatGatewayLan"
                        },
                        "description": "Collection of LANs connected to the NAT gateway. IPs must contain valid subnet mask. If user will not provide any IP then system will generate an IP with /24 subnet.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of that natgateway\n"
                    },
                    "publicIps": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Collection of public IP addresses of the NAT gateway. Should be customer reserved IP addresses in that location\n"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId",
                    "lans",
                    "publicIps"
                ]
            }
        },
        "ionoscloud:compute/getNatGatewayRule:getNatGatewayRule": {
            "description": "The **NAT Gateway Rule data source** can be used to search for and return existing NAT Gateway Rules.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search string so that it is specific enough to return only one result.\n\n## Example Usage\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNatGatewayRule.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "Datacenter's UUID.\n",
                        "willReplaceOnChanges": true
                    },
                    "id": {
                        "type": "string",
                        "description": "ID of the NAT gateway rule you want to search for.\n\nBoth `datacenter_id` and `natgateway_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of an existing NAT gateway rule that you want to search for.\n"
                    },
                    "natgatewayId": {
                        "type": "string",
                        "description": "Nat Gateway's UUID.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId",
                    "natgatewayId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNatGatewayRule.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "Id of the NAT gateway rule\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the NAT gateway rule\n"
                    },
                    "natgatewayId": {
                        "type": "string"
                    },
                    "protocol": {
                        "type": "string",
                        "description": "Protocol of the NAT gateway rule. Defaults to ALL. If protocol is 'ICMP' then targetPortRange start and end cannot be set.\n"
                    },
                    "publicIp": {
                        "type": "string",
                        "description": "Public IP address of the NAT gateway rule. Specifies the address used for masking outgoing packets source address field. Should be one of the customer reserved IP address already configured on the NAT gateway resource\n"
                    },
                    "sourceSubnet": {
                        "type": "string",
                        "description": "Source subnet of the NAT gateway rule. For SNAT rules it specifies which packets this translation rule applies to based on the packets source IP address.\n"
                    },
                    "targetPortRanges": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:compute/getNatGatewayRuleTargetPortRange:getNatGatewayRuleTargetPortRange"
                        },
                        "description": "Target port range of the NAT gateway rule. For SNAT rules it specifies which packets this translation rule applies to based on destination port. If none is provided, rule will match any port\n"
                    },
                    "targetSubnet": {
                        "type": "string",
                        "description": "Target or destination subnet of the NAT gateway rule. For SNAT rules it specifies which packets this translation rule applies to based on the packets destination IP address. If none is provided, rule will match any address.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "ype of the NAT gateway rule.\n"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId",
                    "natgatewayId",
                    "protocol",
                    "publicIp",
                    "sourceSubnet",
                    "targetPortRanges",
                    "targetSubnet",
                    "type"
                ]
            }
        },
        "ionoscloud:compute/getNic:getNic": {
            "description": "The **Nic data source** can be used to search for and return existing nics.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search string so that it is specific enough to return only one result.\n\n## Example Usage\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNic.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "[string] The ID of a Virtual Data Center.\n"
                    },
                    "dhcp": {
                        "type": "boolean",
                        "description": "Indicates if the NIC should get an IP address using DHCP (true) or not (false).\n"
                    },
                    "dhcpv6": {
                        "type": "boolean"
                    },
                    "firewallActive": {
                        "type": "boolean",
                        "description": "If this resource is set to true and is nested under a server resource firewall, with open SSH port, resource must be nested under the NIC.\n"
                    },
                    "firewallType": {
                        "type": "string",
                        "description": "The type of firewall rules that will be allowed on the NIC. If it is not specified it will take the default value INGRESS\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "ID of the nic you want to search for.\n\n`datacenter_id` and either `name` or `id` must be provided.\nIf none, are provided, the datasource will return an error.\n"
                    },
                    "ips": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Collection of IP addresses assigned to a nic. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.\n"
                    },
                    "ipv6CidrBlock": {
                        "type": "string"
                    },
                    "ipv6Ips": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "lan": {
                        "type": "integer",
                        "description": "The LAN ID the NIC will sit on.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] The name of the LAN.\n"
                    },
                    "serverId": {
                        "type": "string",
                        "description": "[string] The ID of a server.\n"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId",
                    "serverId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNic.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The ID of a Virtual Data Center.\n"
                    },
                    "deviceNumber": {
                        "type": "integer",
                        "description": "The Logical Unit Number (LUN) of the storage volume. Null if this NIC was created from CloudAPI and no DCD changes were done on the Datacenter.\n"
                    },
                    "dhcp": {
                        "type": "boolean",
                        "description": "Indicates if the NIC should get an IP address using DHCP (true) or not (false).\n"
                    },
                    "dhcpv6": {
                        "type": "boolean"
                    },
                    "firewallActive": {
                        "type": "boolean",
                        "description": "If this resource is set to true and is nested under a server resource firewall, with open SSH port, resource must be nested under the NIC.\n"
                    },
                    "firewallType": {
                        "type": "string",
                        "description": "The type of firewall rules that will be allowed on the NIC. If it is not specified it will take the default value INGRESS\n"
                    },
                    "flowlogs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:compute/getNicFlowlog:getNicFlowlog"
                        },
                        "description": "Only 1 flow log can be configured. Only the name field can change as part of an update. Flow logs holistically capture network information such as source and destination IP addresses, source and destination ports, number of packets, amount of bytes, the start and end time of the recording, and the type of protocol – and log the extent to which your instances are being accessed.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The id of the NIC.\n"
                    },
                    "ips": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Collection of IP addresses assigned to a nic. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.\n"
                    },
                    "ipv6CidrBlock": {
                        "type": "string"
                    },
                    "ipv6Ips": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "lan": {
                        "type": "integer",
                        "description": "The LAN ID the NIC will sit on.\n"
                    },
                    "mac": {
                        "type": "string",
                        "description": "The MAC address of the NIC.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the name of the flow log.\n"
                    },
                    "pciSlot": {
                        "type": "integer",
                        "description": "The PCI slot number of the Nic.\n"
                    },
                    "serverId": {
                        "type": "string",
                        "description": "The ID of a server.\n"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId",
                    "deviceNumber",
                    "firewallType",
                    "flowlogs",
                    "ips",
                    "ipv6CidrBlock",
                    "ipv6Ips",
                    "mac",
                    "pciSlot",
                    "serverId"
                ]
            }
        },
        "ionoscloud:compute/getResource:getResource": {
            "description": "The **Resource data source** can be used to search for and return any existing IonosCloud resource and optionally their group associations.\nYou can provide a string for the resource type (datacenter,image,snapshot,ipblock) and/or resource id parameters which will be queries against available resources.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search string so that it is specific enough to return only one result.\n\n## Example Usage\n\n### By Type\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.compute.getResource({\n    resourceType: \"datacenter\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.compute.get_resource(resource_type=\"datacenter\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Compute.GetResource.Invoke(new()\n    {\n        ResourceType = \"datacenter\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := compute.GetResource(ctx, \u0026compute.GetResourceArgs{\n\t\t\tResourceType: pulumi.StringRef(\"datacenter\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.ComputeFunctions;\nimport com.pulumi.ionoscloud.compute.inputs.GetResourceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = ComputeFunctions.getResource(GetResourceArgs.builder()\n            .resourceType(\"datacenter\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:compute:getResource\n      arguments:\n        resourceType: datacenter\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getResource.\n",
                "properties": {
                    "resourceId": {
                        "type": "string",
                        "description": "The ID of the specific resource to retrieve information about.\n"
                    },
                    "resourceType": {
                        "type": "string",
                        "description": "The specific type of resources to retrieve information about.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getResource.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "resourceId": {
                        "type": "string"
                    },
                    "resourceType": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "id"
                ]
            }
        },
        "ionoscloud:compute/getS3Key:getS3Key": {
            "description": "The **IONOS Object Storage key data source** can be used to search for and return an existing IONOS Object Storage key.\nYou can provide a string id which will be compared with provisioned IONOS Object Storage keys.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search string so that it is specific enough to return only one result.\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getS3Key.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "The state of the IONOS Object Storage key\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "ID of the IONOS Object Storage key you want to search for.\n"
                    },
                    "userId": {
                        "type": "string",
                        "description": "[string] The UUID of the user owning the IONOS Object Storage Key.\n"
                    }
                },
                "type": "object",
                "required": [
                    "userId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getS3Key.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "The state of the IONOS Object Storage key\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The id of the IONOS Object Storage key\n"
                    },
                    "secretKey": {
                        "type": "string",
                        "description": "(Computed)The IONOS Object Storage Secret key.\n"
                    },
                    "userId": {
                        "type": "string",
                        "description": "The ID of the user that owns the key\n"
                    }
                },
                "type": "object",
                "required": [
                    "secretKey",
                    "userId"
                ]
            }
        },
        "ionoscloud:compute/getServer:getServer": {
            "description": "The **Server data source** can be used to search for and return existing servers. \nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search string so that it is specific enough to return only one result.\n\n## Example Usage\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getServer.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "Datacenter's UUID.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "ID of the server you want to search for.\n\n`datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of an existing server that you want to search for.\n"
                    },
                    "templateUuid": {
                        "type": "string",
                        "description": "The UUID of the template for creating a CUBE server; the available templates for CUBE servers can be found on the templates resource\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of firewall rule\n"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getServer.\n",
                "properties": {
                    "availabilityZone": {
                        "type": "string",
                        "description": "The availability zone in which the volume should exist\n"
                    },
                    "bootCdrom": {
                        "type": "string"
                    },
                    "bootImage": {
                        "type": "string"
                    },
                    "bootVolume": {
                        "type": "string"
                    },
                    "cdroms": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:compute/getServerCdrom:getServerCdrom"
                        },
                        "description": "list of\n"
                    },
                    "cores": {
                        "type": "integer",
                        "description": "The total number of cores for the server\n"
                    },
                    "cpuFamily": {
                        "type": "string",
                        "description": "CPU architecture on which server gets provisioned; not all CPU architectures are available in all datacenter regions; available CPU architectures can be retrieved from the datacenter resource.\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "The id of the datacenter\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The Id of the label\n"
                    },
                    "labels": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:compute/getServerLabel:getServerLabel"
                        },
                        "description": "list of\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the firewall rule\n"
                    },
                    "nics": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:compute/getServerNic:getServerNic"
                        },
                        "description": "list of\n"
                    },
                    "ram": {
                        "type": "integer",
                        "description": "The amount of memory for the server in MB\n"
                    },
                    "templateUuid": {
                        "type": "string",
                        "description": "The UUID of the template for creating a CUBE server; the available templates for CUBE servers can be found on the templates resource\n"
                    },
                    "token": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of firewall rule\n"
                    },
                    "vmState": {
                        "type": "string",
                        "description": "Status of the virtual Machine\n"
                    },
                    "volumes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:compute/getServerVolume:getServerVolume"
                        },
                        "description": "list of\n"
                    }
                },
                "type": "object",
                "required": [
                    "availabilityZone",
                    "bootCdrom",
                    "bootImage",
                    "bootVolume",
                    "cdroms",
                    "cores",
                    "cpuFamily",
                    "datacenterId",
                    "labels",
                    "nics",
                    "ram",
                    "token",
                    "type",
                    "vmState",
                    "volumes"
                ]
            }
        },
        "ionoscloud:compute/getServers:getServers": {
            "description": "The **Servers data source** can be used to search for and return existing servers based on filters used.\n\n## Example Usage\n\n### By Name\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.compute.getServers({\n    datacenterId: ionoscloud_datacenter.example.id,\n    filters: [{\n        name: \"name\",\n        value: \"server_name_to_look_here\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.compute.get_servers(datacenter_id=ionoscloud_datacenter[\"example\"][\"id\"],\n    filters=[{\n        \"name\": \"name\",\n        \"value\": \"server_name_to_look_here\",\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Compute.GetServers.Invoke(new()\n    {\n        DatacenterId = ionoscloud_datacenter.Example.Id,\n        Filters = new[]\n        {\n            new Ionoscloud.Compute.Inputs.GetServersFilterInputArgs\n            {\n                Name = \"name\",\n                Value = \"server_name_to_look_here\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := compute.GetServers(ctx, \u0026compute.GetServersArgs{\n\t\t\tDatacenterId: ionoscloud_datacenter.Example.Id,\n\t\t\tFilters: []compute.GetServersFilter{\n\t\t\t\t{\n\t\t\t\t\tName:  \"name\",\n\t\t\t\t\tValue: \"server_name_to_look_here\",\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.ComputeFunctions;\nimport com.pulumi.ionoscloud.compute.inputs.GetServersArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = ComputeFunctions.getServers(GetServersArgs.builder()\n            .datacenterId(ionoscloud_datacenter.example().id())\n            .filters(GetServersFilterArgs.builder()\n                .name(\"name\")\n                .value(\"server_name_to_look_here\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:compute:getServers\n      arguments:\n        datacenterId: ${ionoscloud_datacenter.example.id}\n        filters:\n          - name: name\n            value: server_name_to_look_here\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### By CPU Family\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.compute.getServers({\n    datacenterId: ionoscloud_datacenter.example.id,\n    filters: [{\n        name: \"cpu_family\",\n        value: \"INTEL_XEON\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.compute.get_servers(datacenter_id=ionoscloud_datacenter[\"example\"][\"id\"],\n    filters=[{\n        \"name\": \"cpu_family\",\n        \"value\": \"INTEL_XEON\",\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Compute.GetServers.Invoke(new()\n    {\n        DatacenterId = ionoscloud_datacenter.Example.Id,\n        Filters = new[]\n        {\n            new Ionoscloud.Compute.Inputs.GetServersFilterInputArgs\n            {\n                Name = \"cpu_family\",\n                Value = \"INTEL_XEON\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := compute.GetServers(ctx, \u0026compute.GetServersArgs{\n\t\t\tDatacenterId: ionoscloud_datacenter.Example.Id,\n\t\t\tFilters: []compute.GetServersFilter{\n\t\t\t\t{\n\t\t\t\t\tName:  \"cpu_family\",\n\t\t\t\t\tValue: \"INTEL_XEON\",\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.ComputeFunctions;\nimport com.pulumi.ionoscloud.compute.inputs.GetServersArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = ComputeFunctions.getServers(GetServersArgs.builder()\n            .datacenterId(ionoscloud_datacenter.example().id())\n            .filters(GetServersFilterArgs.builder()\n                .name(\"cpu_family\")\n                .value(\"INTEL_XEON\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:compute:getServers\n      arguments:\n        datacenterId: ${ionoscloud_datacenter.example.id}\n        filters:\n          - name: cpu_family\n            value: INTEL_XEON\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### By Name and Cores\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.compute.getServers({\n    datacenterId: ionoscloud_datacenter.example.id,\n    filters: [\n        {\n            name: \"name\",\n            value: \"test\",\n        },\n        {\n            name: \"cores\",\n            value: \"1\",\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.compute.get_servers(datacenter_id=ionoscloud_datacenter[\"example\"][\"id\"],\n    filters=[\n        {\n            \"name\": \"name\",\n            \"value\": \"test\",\n        },\n        {\n            \"name\": \"cores\",\n            \"value\": \"1\",\n        },\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Compute.GetServers.Invoke(new()\n    {\n        DatacenterId = ionoscloud_datacenter.Example.Id,\n        Filters = new[]\n        {\n            new Ionoscloud.Compute.Inputs.GetServersFilterInputArgs\n            {\n                Name = \"name\",\n                Value = \"test\",\n            },\n            new Ionoscloud.Compute.Inputs.GetServersFilterInputArgs\n            {\n                Name = \"cores\",\n                Value = \"1\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := compute.GetServers(ctx, \u0026compute.GetServersArgs{\n\t\t\tDatacenterId: ionoscloud_datacenter.Example.Id,\n\t\t\tFilters: []compute.GetServersFilter{\n\t\t\t\t{\n\t\t\t\t\tName:  \"name\",\n\t\t\t\t\tValue: \"test\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tName:  \"cores\",\n\t\t\t\t\tValue: \"1\",\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.ComputeFunctions;\nimport com.pulumi.ionoscloud.compute.inputs.GetServersArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = ComputeFunctions.getServers(GetServersArgs.builder()\n            .datacenterId(ionoscloud_datacenter.example().id())\n            .filters(            \n                GetServersFilterArgs.builder()\n                    .name(\"name\")\n                    .value(\"test\")\n                    .build(),\n                GetServersFilterArgs.builder()\n                    .name(\"cores\")\n                    .value(\"1\")\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:compute:getServers\n      arguments:\n        datacenterId: ${ionoscloud_datacenter.example.id}\n        filters:\n          - name: name\n            value: test\n          - name: cores\n            value: '1'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getServers.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "Name of an existing datacenter that the servers are a part of\n"
                    },
                    "filters": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:compute/getServersFilter:getServersFilter"
                        },
                        "description": "One or more name/value pairs to filter off of. You can use most base fields in the server resource. These do **NOT** include nested fields in nics or volume nested fields.\n\n\n`datacenter_id` must be provided. If `datacenter_id` is missing , the datasource will return an error.\n\n**NOTE:** Lookup by filter is partial. Searching for a server using filter name and value `test`, will find all servers that have `test` in the name.\nFor example, it will find servers named `test`, `test1`, `testsomething`.\n\n**NOTE:** You cannot search by `image_name` by providing an alias like `ubuntu`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getServers.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "filters": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:compute/getServersFilter:getServersFilter"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "servers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:compute/getServersServer:getServersServer"
                        },
                        "description": "list of servers that matches the filters provided.\nFor a full reference of all attributes returned, check out documentation\n"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId",
                    "servers",
                    "id"
                ]
            }
        },
        "ionoscloud:compute/getShare:getShare": {
            "description": "The **Share data source** can be used to search for and return an existing share object.\nYou need to provide the group_id and resource_id to get the group resources for the shared resource.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search string so that it is specific enough to return only one result.\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getShare.\n",
                "properties": {
                    "editPrivilege": {
                        "type": "boolean",
                        "description": "The flag that specifies if the group has permission to edit privileges on this resource.\n"
                    },
                    "groupId": {
                        "type": "string",
                        "description": "The ID of the specific group containing the resource to update.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The uuid of the share object\n\n\n`id`, `resource_id` and `group_id` must be provided. If any of them are missing, the datasource will return an error.\n"
                    },
                    "resourceId": {
                        "type": "string",
                        "description": "The ID of the specific resource to update.\n"
                    },
                    "sharePrivilege": {
                        "type": "boolean",
                        "description": "The group has permission to share this resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "groupId",
                    "id",
                    "resourceId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getShare.\n",
                "properties": {
                    "editPrivilege": {
                        "type": "boolean",
                        "description": "The flag that specifies if the group has permission to edit privileges on this resource.\n"
                    },
                    "groupId": {
                        "type": "string",
                        "description": "The ID of the specific group containing the resource to update.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The id of the share resource.\n"
                    },
                    "resourceId": {
                        "type": "string",
                        "description": "The ID of the specific resource to update.\n"
                    },
                    "sharePrivilege": {
                        "type": "boolean",
                        "description": "The group has permission to share this resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "groupId",
                    "id",
                    "resourceId"
                ]
            }
        },
        "ionoscloud:compute/getSnapshot:getSnapshot": {
            "description": "The **Snapshot data source** can be used to search for and return an existing snapshot which can then be used to provision a server. If a single match is found, it will be returned. If your search results in multiple matches, an error will be returned. When this happens, please refine your search string so that it is specific enough to return only one result.\n\n## Example Usage\n\n### By Name \u0026 Size \u0026 Location\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.compute.getSnapshot({\n    location: \"us/las\",\n    name: \"Snapshot Example\",\n    size: 2,\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.compute.get_snapshot(location=\"us/las\",\n    name=\"Snapshot Example\",\n    size=2)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Compute.GetSnapshot.Invoke(new()\n    {\n        Location = \"us/las\",\n        Name = \"Snapshot Example\",\n        Size = 2,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := compute.LookupSnapshot(ctx, \u0026compute.LookupSnapshotArgs{\n\t\t\tLocation: pulumi.StringRef(\"us/las\"),\n\t\t\tName:     pulumi.StringRef(\"Snapshot Example\"),\n\t\t\tSize:     pulumi.IntRef(2),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.ComputeFunctions;\nimport com.pulumi.ionoscloud.compute.inputs.GetSnapshotArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = ComputeFunctions.getSnapshot(GetSnapshotArgs.builder()\n            .location(\"us/las\")\n            .name(\"Snapshot Example\")\n            .size(\"2\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:compute:getSnapshot\n      arguments:\n        location: us/las\n        name: Snapshot Example\n        size: '2'\n```\n\u003c!--End PulumiCodeChooser --\u003e\nNote: The size argument is in GB\n",
            "inputs": {
                "description": "A collection of arguments for invoking getSnapshot.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "UUID of an existing snapshot that you want to search for.\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "Existing snapshot's location.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of an existing snapshot that you want to search for.\n"
                    },
                    "size": {
                        "type": "integer",
                        "description": "The size of the snapshot to look for.\n\nEither `name` or `id` must be provided. If none, or both are provided, the datasource will return an error.\nAdditionally, you can add `location` and `size` along with the `name` argument for a more refined search.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search string so that it is specific enough to return only one result.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getSnapshot.\n",
                "properties": {
                    "cpuHotPlug": {
                        "type": "boolean",
                        "description": "Is capable of CPU hot plug (no reboot required)\n"
                    },
                    "cpuHotUnplug": {
                        "type": "boolean",
                        "description": "Is capable of CPU hot unplug (no reboot required)\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Human readable description\n"
                    },
                    "discScsiHotPlug": {
                        "type": "boolean",
                        "description": "Is capable of SCSI drive hot plug (no reboot required)\n"
                    },
                    "discScsiHotUnplug": {
                        "type": "boolean",
                        "description": "Is capable of SCSI drive hot unplug (no reboot required). This works only for non-Windows virtual Machines.\n"
                    },
                    "discVirtioHotPlug": {
                        "type": "boolean",
                        "description": "Is capable of Virt-IO drive hot plug (no reboot required)\n"
                    },
                    "discVirtioHotUnplug": {
                        "type": "boolean",
                        "description": "Is capable of Virt-IO drive hot unplug (no reboot required). This works only for non-Windows virtual Machines.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "UUID of the snapshot\n"
                    },
                    "licenceType": {
                        "type": "string",
                        "description": "OS type of this Snapshot\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "Location of that image/snapshot\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the snapshot.\n"
                    },
                    "nicHotPlug": {
                        "type": "boolean",
                        "description": "Is capable of nic hot plug (no reboot required)\n"
                    },
                    "nicHotUnplug": {
                        "type": "boolean",
                        "description": "Is capable of nic hot unplug (no reboot required)\n"
                    },
                    "ramHotPlug": {
                        "type": "boolean",
                        "description": "Is capable of memory hot plug (no reboot required)\n"
                    },
                    "ramHotUnplug": {
                        "type": "boolean",
                        "description": "Is capable of memory hot unplug (no reboot required)\n"
                    },
                    "secAuthProtection": {
                        "type": "boolean",
                        "description": "Boolean value representing if the snapshot requires extra protection e.g. two factor protection\n"
                    },
                    "size": {
                        "type": "integer",
                        "description": "The size of the image in GB\n"
                    }
                },
                "type": "object",
                "required": [
                    "cpuHotPlug",
                    "cpuHotUnplug",
                    "description",
                    "discScsiHotPlug",
                    "discScsiHotUnplug",
                    "discVirtioHotPlug",
                    "discVirtioHotUnplug",
                    "licenceType",
                    "location",
                    "name",
                    "nicHotPlug",
                    "nicHotUnplug",
                    "ramHotPlug",
                    "ramHotUnplug",
                    "secAuthProtection",
                    "size"
                ]
            }
        },
        "ionoscloud:compute/getTargetGroup:getTargetGroup": {
            "description": "The **Target Group** data source can be used to search for and return an existing Application Load Balancer Target Group.\nYou can provide a string for the name parameter which will be compared with provisioned Application Load Balancer Target Groups.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search and make sure that your resources have unique names.\n\n## Example Usage\n\n### By Name\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.compute.getTargetGroup({\n    name: \"Target Group Example\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.compute.get_target_group(name=\"Target Group Example\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Compute.GetTargetGroup.Invoke(new()\n    {\n        Name = \"Target Group Example\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := compute.LookupTargetGroup(ctx, \u0026compute.LookupTargetGroupArgs{\n\t\t\tName: pulumi.StringRef(\"Target Group Example\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.ComputeFunctions;\nimport com.pulumi.ionoscloud.compute.inputs.GetTargetGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = ComputeFunctions.getTargetGroup(GetTargetGroupArgs.builder()\n            .name(\"Target Group Example\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:compute:getTargetGroup\n      arguments:\n        name: Target Group Example\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### By Name with Partial Match\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.compute.getTargetGroup({\n    name: \"Example\",\n    partialMatch: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.compute.get_target_group(name=\"Example\",\n    partial_match=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Compute.GetTargetGroup.Invoke(new()\n    {\n        Name = \"Example\",\n        PartialMatch = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := compute.LookupTargetGroup(ctx, \u0026compute.LookupTargetGroupArgs{\n\t\t\tName:         pulumi.StringRef(\"Example\"),\n\t\t\tPartialMatch: pulumi.BoolRef(true),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.ComputeFunctions;\nimport com.pulumi.ionoscloud.compute.inputs.GetTargetGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = ComputeFunctions.getTargetGroup(GetTargetGroupArgs.builder()\n            .name(\"Example\")\n            .partialMatch(true)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:compute:getTargetGroup\n      arguments:\n        name: Example\n        partialMatch: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getTargetGroup.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "ID of the target group you want to search for.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of an existing target group that you want to search for. Search by name is case-insensitive. The whole resource name is required if `partial_match` parameter is not set to true.\n"
                    },
                    "partialMatch": {
                        "type": "boolean",
                        "description": "Whether partial matching is allowed or not when using name argument. Default value is false.\n\nEither `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getTargetGroup.\n",
                "properties": {
                    "algorithm": {
                        "type": "string",
                        "description": "Balancing algorithm.\n"
                    },
                    "healthChecks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:compute/getTargetGroupHealthCheck:getTargetGroupHealthCheck"
                        },
                        "description": "Health check attributes for Target Group.\n"
                    },
                    "httpHealthChecks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:compute/getTargetGroupHttpHealthCheck:getTargetGroupHttpHealthCheck"
                        },
                        "description": "Http health check attributes for Target Group\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The Id of that Target group\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of that Target Group.\n"
                    },
                    "partialMatch": {
                        "type": "boolean"
                    },
                    "protocol": {
                        "type": "string",
                        "description": "Balancing protocol.\n"
                    },
                    "protocolVersion": {
                        "type": "string",
                        "description": "The forwarding protocol version. Value is ignored when protocol is not 'HTTP'.\n"
                    },
                    "targets": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:compute/getTargetGroupTarget:getTargetGroupTarget"
                        },
                        "description": "Array of items in the collection\n"
                    }
                },
                "type": "object",
                "required": [
                    "algorithm",
                    "healthChecks",
                    "httpHealthChecks",
                    "protocol",
                    "protocolVersion",
                    "targets"
                ]
            }
        },
        "ionoscloud:compute/getTemplate:getTemplate": {
            "description": "The **Template data source** can be used to search for and return existing templates by providing any of template properties (name, cores, ram, storage_size).\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search string so that it is specific enough to return only one result.\n\n## Example Usage\n\n### By Name\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.compute.getTemplate({\n    name: \"CUBES S\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.compute.get_template(name=\"CUBES S\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Compute.GetTemplate.Invoke(new()\n    {\n        Name = \"CUBES S\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := compute.GetTemplate(ctx, \u0026compute.GetTemplateArgs{\n\t\t\tName: pulumi.StringRef(\"CUBES S\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.ComputeFunctions;\nimport com.pulumi.ionoscloud.compute.inputs.GetTemplateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = ComputeFunctions.getTemplate(GetTemplateArgs.builder()\n            .name(\"CUBES S\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:compute:getTemplate\n      arguments:\n        name: CUBES S\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### By Cores\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.compute.getTemplate({\n    cores: 6,\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.compute.get_template(cores=6)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Compute.GetTemplate.Invoke(new()\n    {\n        Cores = 6,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := compute.GetTemplate(ctx, \u0026compute.GetTemplateArgs{\n\t\t\tCores: pulumi.Float64Ref(6),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.ComputeFunctions;\nimport com.pulumi.ionoscloud.compute.inputs.GetTemplateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = ComputeFunctions.getTemplate(GetTemplateArgs.builder()\n            .cores(6)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:compute:getTemplate\n      arguments:\n        cores: 6\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### By Ram\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.compute.getTemplate({\n    ram: 49152,\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.compute.get_template(ram=49152)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Compute.GetTemplate.Invoke(new()\n    {\n        Ram = 49152,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := compute.GetTemplate(ctx, \u0026compute.GetTemplateArgs{\n\t\t\tRam: pulumi.Float64Ref(49152),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.ComputeFunctions;\nimport com.pulumi.ionoscloud.compute.inputs.GetTemplateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = ComputeFunctions.getTemplate(GetTemplateArgs.builder()\n            .ram(49152)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:compute:getTemplate\n      arguments:\n        ram: 49152\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### By Storage Size\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.compute.getTemplate({\n    storageSize: 80,\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.compute.get_template(storage_size=80)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Compute.GetTemplate.Invoke(new()\n    {\n        StorageSize = 80,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := compute.GetTemplate(ctx, \u0026compute.GetTemplateArgs{\n\t\t\tStorageSize: pulumi.Float64Ref(80),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.ComputeFunctions;\nimport com.pulumi.ionoscloud.compute.inputs.GetTemplateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = ComputeFunctions.getTemplate(GetTemplateArgs.builder()\n            .storageSize(80)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:compute:getTemplate\n      arguments:\n        storageSize: 80\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getTemplate.\n",
                "properties": {
                    "cores": {
                        "type": "number",
                        "description": "The CPU cores count.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A name of that resource.\n"
                    },
                    "ram": {
                        "type": "number",
                        "description": "The RAM size in MB.\n"
                    },
                    "storageSize": {
                        "type": "number",
                        "description": "The storage size in GB.\n\nAny of the arguments ca be provided. If none, the datasource will return an error.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getTemplate.\n",
                "properties": {
                    "cores": {
                        "type": "number",
                        "description": "The CPU cores count\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Id of template\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of template\n"
                    },
                    "ram": {
                        "type": "number",
                        "description": "The RAM size in MB\n"
                    },
                    "storageSize": {
                        "type": "number",
                        "description": "The storage size in GB\n"
                    }
                },
                "type": "object",
                "required": [
                    "cores",
                    "id",
                    "name",
                    "ram",
                    "storageSize"
                ]
            }
        },
        "ionoscloud:compute/getUser:getUser": {
            "description": "The **User data source** can be used to search for and return existing users.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search string so that it is specific enough to return only one result.\n\n## Example Usage\n\n### By Email\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.compute.getUser({\n    email: \"example@email.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.compute.get_user(email=\"example@email.com\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Compute.GetUser.Invoke(new()\n    {\n        Email = \"example@email.com\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := compute.LookupUser(ctx, \u0026compute.LookupUserArgs{\n\t\t\tEmail: pulumi.StringRef(\"example@email.com\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.compute.ComputeFunctions;\nimport com.pulumi.ionoscloud.compute.inputs.GetUserArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = ComputeFunctions.getUser(GetUserArgs.builder()\n            .email(\"example@email.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:compute:getUser\n      arguments:\n        email: example@email.com\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### By Email from Env Variables - Current User\ndata \"ionoscloud.compute.User\" \"example\" {\n}\n",
            "inputs": {
                "description": "A collection of arguments for invoking getUser.\n",
                "properties": {
                    "email": {
                        "type": "string",
                        "description": "Email of an existing user that you want to search for.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "ID of the user you want to search for.\n\nEither `email` or `id` can be provided. If no argument is set, the provider will search for the **email that was provided for the configuration**. If none is found, the provider will return an error.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getUser.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "Indicates if the user is active\n"
                    },
                    "administrator": {
                        "type": "boolean",
                        "description": "Indicates if the user has administrative rights. Administrators do not need to be managed in groups, as they automatically have access to all resources associated with the contract.\n"
                    },
                    "email": {
                        "type": "string",
                        "description": "The e-mail address for the user.\n"
                    },
                    "firstName": {
                        "type": "string",
                        "description": "The first name for the user.\n"
                    },
                    "forceSecAuth": {
                        "type": "boolean",
                        "description": "Indicates if secure (two-factor) authentication should be forced for the user (true) or not (false).\n"
                    },
                    "groups": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:compute/getUserGroup:getUserGroup"
                        },
                        "description": "Shows the id and name of the groups that the user is a member of\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The id of the user.\n"
                    },
                    "lastName": {
                        "type": "string",
                        "description": "The last name for the user.\n"
                    },
                    "s3CanonicalUserId": {
                        "type": "string",
                        "description": "Canonical (S3) id of the user for a given identity\n"
                    },
                    "secAuthActive": {
                        "type": "boolean",
                        "description": "Indicates if secure authentication is active for the user or not\n"
                    }
                },
                "type": "object",
                "required": [
                    "active",
                    "administrator",
                    "firstName",
                    "forceSecAuth",
                    "groups",
                    "lastName",
                    "s3CanonicalUserId",
                    "secAuthActive"
                ]
            }
        },
        "ionoscloud:compute/getVCPUServer:getVCPUServer": {
            "description": "The **VCPU Server data source** can be used to search for and return existing VCPU servers. \nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search string so that it is specific enough to return only one result.\n\n## Example Usage\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getVCPUServer.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "Datacenter's UUID.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "ID of the server you want to search for.\n\n`datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of an existing server that you want to search for.\n"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getVCPUServer.\n",
                "properties": {
                    "availabilityZone": {
                        "type": "string",
                        "description": "The availability zone in which the volume should exist\n"
                    },
                    "bootCdrom": {
                        "type": "string"
                    },
                    "bootImage": {
                        "type": "string"
                    },
                    "bootVolume": {
                        "type": "string"
                    },
                    "cdroms": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:compute/getVCPUServerCdrom:getVCPUServerCdrom"
                        },
                        "description": "list of\n"
                    },
                    "cores": {
                        "type": "integer",
                        "description": "The total number of cores for the server\n"
                    },
                    "cpuFamily": {
                        "type": "string",
                        "description": "CPU architecture on which server gets provisioned; not all CPU architectures are available in all datacenter regions; available CPU architectures can be retrieved from the datacenter resource.\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "The id of the datacenter\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The Id of the label\n"
                    },
                    "labels": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:compute/getVCPUServerLabel:getVCPUServerLabel"
                        },
                        "description": "list of\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the firewall rule\n"
                    },
                    "nics": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:compute/getVCPUServerNic:getVCPUServerNic"
                        },
                        "description": "list of\n"
                    },
                    "ram": {
                        "type": "integer",
                        "description": "The amount of memory for the server in MB\n"
                    },
                    "token": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of firewall rule\n"
                    },
                    "vmState": {
                        "type": "string",
                        "description": "Status of the virtual Machine\n"
                    },
                    "volumes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:compute/getVCPUServerVolume:getVCPUServerVolume"
                        },
                        "description": "list of\n"
                    }
                },
                "type": "object",
                "required": [
                    "availabilityZone",
                    "bootCdrom",
                    "bootImage",
                    "bootVolume",
                    "cdroms",
                    "cores",
                    "cpuFamily",
                    "datacenterId",
                    "labels",
                    "nics",
                    "ram",
                    "token",
                    "type",
                    "vmState",
                    "volumes"
                ]
            }
        },
        "ionoscloud:compute/getVolume:getVolume": {
            "description": "The volume data source can be used to search for and return existing volumes.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search string so that it is specific enough to return only one result.\n\n## Example Usage\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getVolume.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "ID of the volume you want to search for.\n\nEither `volume` or `id` must be provided. If none, or both are provided, the datasource will return an error.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of an existing volume that you want to search for.\n"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getVolume.\n",
                "properties": {
                    "availabilityZone": {
                        "type": "string",
                        "description": "The storage availability zone assigned to the volume: AUTO, ZONE_1, ZONE_2, or ZONE_3. This property is immutable.\n"
                    },
                    "backupUnitId": {
                        "type": "string",
                        "description": "The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.\n"
                    },
                    "bootServer": {
                        "type": "string",
                        "description": "The UUID of the attached server.\n"
                    },
                    "bus": {
                        "type": "string",
                        "description": "The bus type of the volume: VIRTIO or IDE.\n"
                    },
                    "cpuHotPlug": {
                        "type": "boolean",
                        "description": "Is capable of CPU hot plug (no reboot required)\n"
                    },
                    "datacenterId": {
                        "type": "string"
                    },
                    "deviceNumber": {
                        "type": "integer",
                        "description": "The LUN ID of the storage volume. Null for volumes not mounted to any VM\n"
                    },
                    "discVirtioHotPlug": {
                        "type": "boolean",
                        "description": "Is capable of Virt-IO drive hot plug (no reboot required)\n"
                    },
                    "discVirtioHotUnplug": {
                        "type": "boolean",
                        "description": "Is capable of Virt-IO drive hot unplug (no reboot required). This works only for non-Windows virtual Machines.\n"
                    },
                    "diskType": {
                        "type": "string",
                        "description": "The volume type: HDD or SSD.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The id of the volume.\n"
                    },
                    "image": {
                        "type": "string",
                        "description": "The image or snapshot UUID.\n"
                    },
                    "imagePassword": {
                        "type": "string",
                        "description": "Required if `sshkey_path` is not provided.\n"
                    },
                    "licenceType": {
                        "type": "string",
                        "description": "The type of the licence.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the volume.\n"
                    },
                    "nicHotPlug": {
                        "type": "boolean",
                        "description": "Is capable of nic hot plug (no reboot required)\n"
                    },
                    "nicHotUnplug": {
                        "type": "boolean",
                        "description": "Is capable of nic hot unplug (no reboot required)\n"
                    },
                    "ramHotPlug": {
                        "type": "boolean",
                        "description": "Is capable of memory hot plug (no reboot required)\n"
                    },
                    "size": {
                        "type": "integer",
                        "description": "The size of the volume in GB.\n"
                    },
                    "sshkey": {
                        "type": "string",
                        "description": "The associated public SSH key.\n"
                    },
                    "userData": {
                        "type": "string",
                        "description": "The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. This option will work only with cloud-init compatible images.\n"
                    }
                },
                "type": "object",
                "required": [
                    "availabilityZone",
                    "backupUnitId",
                    "bootServer",
                    "bus",
                    "cpuHotPlug",
                    "datacenterId",
                    "deviceNumber",
                    "discVirtioHotPlug",
                    "discVirtioHotUnplug",
                    "diskType",
                    "image",
                    "imagePassword",
                    "licenceType",
                    "nicHotPlug",
                    "nicHotUnplug",
                    "ramHotPlug",
                    "size",
                    "sshkey",
                    "userData"
                ]
            }
        },
        "ionoscloud:creg/getRegistry:getRegistry": {
            "description": "The **Container Registry data source** can be used to search for and return an existing Container Registry.\nYou can provide a string for the name parameter which will be compared with provisioned Container Registry.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search and make sure that your resources have unique names.\n\n## Example Usage\n\n### By Name\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.creg.getRegistry({\n    name: \"container-registry-example\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.creg.get_registry(name=\"container-registry-example\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Creg.GetRegistry.Invoke(new()\n    {\n        Name = \"container-registry-example\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/creg\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := creg.LookupRegistry(ctx, \u0026creg.LookupRegistryArgs{\n\t\t\tName: pulumi.StringRef(\"container-registry-example\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.creg.CregFunctions;\nimport com.pulumi.ionoscloud.creg.inputs.GetRegistryArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = CregFunctions.getRegistry(GetRegistryArgs.builder()\n            .name(\"container-registry-example\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:creg:getRegistry\n      arguments:\n        name: container-registry-example\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### By Name with Partial Match\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.creg.getRegistry({\n    name: \"-example\",\n    partialMatch: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.creg.get_registry(name=\"-example\",\n    partial_match=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Creg.GetRegistry.Invoke(new()\n    {\n        Name = \"-example\",\n        PartialMatch = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/creg\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := creg.LookupRegistry(ctx, \u0026creg.LookupRegistryArgs{\n\t\t\tName:         pulumi.StringRef(\"-example\"),\n\t\t\tPartialMatch: pulumi.BoolRef(true),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.creg.CregFunctions;\nimport com.pulumi.ionoscloud.creg.inputs.GetRegistryArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = CregFunctions.getRegistry(GetRegistryArgs.builder()\n            .name(\"-example\")\n            .partialMatch(true)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:creg:getRegistry\n      arguments:\n        name: -example\n        partialMatch: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getRegistry.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "ID of the container registry you want to search for.\n"
                    },
                    "location": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of an existing container registry that you want to search for. Search by name is case-insensitive. The whole resource name is required if `partial_match` parameter is not set to true.\n"
                    },
                    "partialMatch": {
                        "type": "boolean",
                        "description": "Whether partial matching is allowed or not when using name argument. Default value is false.\n\nEither `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getRegistry.\n",
                "properties": {
                    "apiSubnetAllowLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The subnet CIDRs that are allowed to connect to the registry.  Specify \"a.b.c.d/32\" for an individual IP address. __Note__: If this list is empty or not set, there are no restrictions.\n"
                    },
                    "features": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:creg/getRegistryFeature:getRegistryFeature"
                        }
                    },
                    "garbageCollectionSchedules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:creg/getRegistryGarbageCollectionSchedule:getRegistryGarbageCollectionSchedule"
                        }
                    },
                    "hostname": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "Id of the container registry.\n"
                    },
                    "location": {
                        "type": "string"
                    },
                    "maintenanceWindows": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:creg/getRegistryMaintenanceWindow:getRegistryMaintenanceWindow"
                        }
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the container registry.\n"
                    },
                    "partialMatch": {
                        "type": "boolean"
                    },
                    "storageUsages": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:creg/getRegistryStorageUsage:getRegistryStorageUsage"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "apiSubnetAllowLists",
                    "features",
                    "garbageCollectionSchedules",
                    "hostname",
                    "maintenanceWindows",
                    "storageUsages"
                ]
            }
        },
        "ionoscloud:creg/getRegistryLocations:getRegistryLocations": {
            "description": "The **Container Registry Locations data source** can be used to get a list of Container Registry Locations\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.creg.getRegistryLocations({});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.creg.get_registry_locations()\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Creg.GetRegistryLocations.Invoke();\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/creg\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := creg.GetRegistryLocations(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.creg.CregFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = CregFunctions.getRegistryLocations();\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:creg:getRegistryLocations\n      arguments: {}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "outputs": {
                "description": "A collection of values returned by getRegistryLocations.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "locations": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "list of container registry locations\n"
                    }
                },
                "type": "object",
                "required": [
                    "locations",
                    "id"
                ]
            }
        },
        "ionoscloud:creg/getRegistryToken:getRegistryToken": {
            "description": "The **Container Registry Token data source** can be used to search for and return an existing Container Registry Token.\nYou can provide a string for the name parameter which will be compared with provisioned Container Registry Token.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search and make sure that your resources have unique names.\n\n## Example Usage\n\n### By Name\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.creg.getRegistryToken({\n    registryId: ionoscloud_container_registry.example.id,\n    name: \"container-registry-token-example\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.creg.get_registry_token(registry_id=ionoscloud_container_registry[\"example\"][\"id\"],\n    name=\"container-registry-token-example\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Creg.GetRegistryToken.Invoke(new()\n    {\n        RegistryId = ionoscloud_container_registry.Example.Id,\n        Name = \"container-registry-token-example\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/creg\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := creg.LookupRegistryToken(ctx, \u0026creg.LookupRegistryTokenArgs{\n\t\t\tRegistryId: ionoscloud_container_registry.Example.Id,\n\t\t\tName:       pulumi.StringRef(\"container-registry-token-example\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.creg.CregFunctions;\nimport com.pulumi.ionoscloud.creg.inputs.GetRegistryTokenArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = CregFunctions.getRegistryToken(GetRegistryTokenArgs.builder()\n            .registryId(ionoscloud_container_registry.example().id())\n            .name(\"container-registry-token-example\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:creg:getRegistryToken\n      arguments:\n        registryId: ${ionoscloud_container_registry.example.id}\n        name: container-registry-token-example\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### By Name with Partial Match\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.creg.getRegistryToken({\n    registryId: ionoscloud_container_registry.example.id,\n    name: \"-example\",\n    partialMatch: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.creg.get_registry_token(registry_id=ionoscloud_container_registry[\"example\"][\"id\"],\n    name=\"-example\",\n    partial_match=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Creg.GetRegistryToken.Invoke(new()\n    {\n        RegistryId = ionoscloud_container_registry.Example.Id,\n        Name = \"-example\",\n        PartialMatch = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/creg\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := creg.LookupRegistryToken(ctx, \u0026creg.LookupRegistryTokenArgs{\n\t\t\tRegistryId:   ionoscloud_container_registry.Example.Id,\n\t\t\tName:         pulumi.StringRef(\"-example\"),\n\t\t\tPartialMatch: pulumi.BoolRef(true),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.creg.CregFunctions;\nimport com.pulumi.ionoscloud.creg.inputs.GetRegistryTokenArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = CregFunctions.getRegistryToken(GetRegistryTokenArgs.builder()\n            .registryId(ionoscloud_container_registry.example().id())\n            .name(\"-example\")\n            .partialMatch(true)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:creg:getRegistryToken\n      arguments:\n        registryId: ${ionoscloud_container_registry.example.id}\n        name: -example\n        partialMatch: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getRegistryToken.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "ID of the container registry token you want to search for.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of an existing container registry token that you want to search for. Search by name is case-insensitive. The whole resource name is required if `partial_match` parameter is not set to true.\n"
                    },
                    "partialMatch": {
                        "type": "boolean",
                        "description": "Whether partial matching is allowed or not when using name argument. Default value is false.\n\n`registry_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.\n"
                    },
                    "registryId": {
                        "type": "string",
                        "description": "Registry's UUID.\n"
                    }
                },
                "type": "object",
                "required": [
                    "registryId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRegistryToken.\n",
                "properties": {
                    "credentials": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:creg/getRegistryTokenCredential:getRegistryTokenCredential"
                        }
                    },
                    "expiryDate": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "Id of the container registry token.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "partialMatch": {
                        "type": "boolean"
                    },
                    "registryId": {
                        "type": "string"
                    },
                    "scopes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:creg/getRegistryTokenScope:getRegistryTokenScope"
                        }
                    },
                    "status": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "credentials",
                    "expiryDate",
                    "registryId",
                    "scopes",
                    "status"
                ]
            }
        },
        "ionoscloud:dbaas/getInMemoryDBReplicaSet:getInMemoryDBReplicaSet": {
            "description": "The `ionoscloud.dbaas.InMemoryDBReplicaSet` data source can be used to retrieve information about an existing InMemoryDB Replica Set.\n\n## Example Usage\n\n### By id\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.dbaas.getInMemoryDBReplicaSet({\n    id: \"example-id\",\n    location: \"es/vit\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.dbaas.get_in_memory_db_replica_set(id=\"example-id\",\n    location=\"es/vit\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Dbaas.GetInMemoryDBReplicaSet.Invoke(new()\n    {\n        Id = \"example-id\",\n        Location = \"es/vit\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/dbaas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dbaas.LookupInMemoryDBReplicaSet(ctx, \u0026dbaas.LookupInMemoryDBReplicaSetArgs{\n\t\t\tId:       pulumi.StringRef(\"example-id\"),\n\t\t\tLocation: \"es/vit\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.dbaas.DbaasFunctions;\nimport com.pulumi.ionoscloud.dbaas.inputs.GetInMemoryDBReplicaSetArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = DbaasFunctions.getInMemoryDBReplicaSet(GetInMemoryDBReplicaSetArgs.builder()\n            .id(\"example-id\")\n            .location(\"es/vit\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:dbaas:getInMemoryDBReplicaSet\n      arguments:\n        id: example-id\n        location: es/vit\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### By display_name\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.dbaas.getInMemoryDBReplicaSet({\n    displayName: \"example-id\",\n    location: \"us/las\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.dbaas.get_in_memory_db_replica_set(display_name=\"example-id\",\n    location=\"us/las\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Dbaas.GetInMemoryDBReplicaSet.Invoke(new()\n    {\n        DisplayName = \"example-id\",\n        Location = \"us/las\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/dbaas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dbaas.LookupInMemoryDBReplicaSet(ctx, \u0026dbaas.LookupInMemoryDBReplicaSetArgs{\n\t\t\tDisplayName: pulumi.StringRef(\"example-id\"),\n\t\t\tLocation:    \"us/las\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.dbaas.DbaasFunctions;\nimport com.pulumi.ionoscloud.dbaas.inputs.GetInMemoryDBReplicaSetArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = DbaasFunctions.getInMemoryDBReplicaSet(GetInMemoryDBReplicaSetArgs.builder()\n            .displayName(\"example-id\")\n            .location(\"us/las\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:dbaas:getInMemoryDBReplicaSet\n      arguments:\n        displayName: example-id\n        location: us/las\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getInMemoryDBReplicaSet.\n",
                "properties": {
                    "displayName": {
                        "type": "string",
                        "description": "The display name of the InMemoryDB Replica Set.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The ID of the InMemoryDB Replica Set.\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "The location of the InMemoryDB Replica Set.\n\n\u003e **Note:** Either `id` or `display_name` must be provided. If none, or both are provided, the datasource will return an error.\n"
                    }
                },
                "type": "object",
                "required": [
                    "location"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getInMemoryDBReplicaSet.\n",
                "properties": {
                    "connections": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:dbaas/getInMemoryDBReplicaSetConnection:getInMemoryDBReplicaSetConnection"
                        },
                        "description": "[object] The network connection for your replica set. Only one connection is allowed. It includes:\n"
                    },
                    "credentials": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:dbaas/getInMemoryDBReplicaSetCredential:getInMemoryDBReplicaSetCredential"
                        },
                        "description": "[object] Credentials for the InMemoryDB replicaset, only one type of password can be used since they are mutually exclusive. It includes:\n"
                    },
                    "displayName": {
                        "type": "string"
                    },
                    "dnsName": {
                        "type": "string",
                        "description": "[string] The DNS name pointing to your replica set. Will be used to connect to the active/standalone instance.\n"
                    },
                    "evictionPolicy": {
                        "type": "string",
                        "description": "[string] The eviction policy for the replica set, possible values are:\n"
                    },
                    "id": {
                        "type": "string"
                    },
                    "location": {
                        "type": "string"
                    },
                    "maintenanceWindows": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:dbaas/getInMemoryDBReplicaSetMaintenanceWindow:getInMemoryDBReplicaSetMaintenanceWindow"
                        },
                        "description": "A weekly 4 hour-long window, during which maintenance might occur. It includes:\n"
                    },
                    "persistenceMode": {
                        "type": "string",
                        "description": "[string] Specifies How and If data is persisted, possible values are:\n* `None` - Data is inMemory only and will not be persisted. Useful for cache only applications.\n* `AOF` - (Append Only File) AOF persistence logs every write operation received by the server. These operations can then be replayed again at server startup, reconstructing the original dataset. Commands are logged using the same format as the InMemoryDB protocol itself.\n* `RDB` - RDB persistence performs snapshots of the current in memory state.\n* `RDB_AOF` - Both, RDB and AOF persistence are enabled.\n"
                    },
                    "replicas": {
                        "type": "integer",
                        "description": "[int] The total number of replicas in the replica set (one active and n-1 passive). In case of a standalone instance, the value is 1. In all other cases, the value is \u003e 1. The replicas will not be available as read replicas, they are only standby for a failure of the active instance.\n"
                    },
                    "resources": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:dbaas/getInMemoryDBReplicaSetResource:getInMemoryDBReplicaSetResource"
                        },
                        "description": "[object] The resources of the individual replicas. It includes:\n"
                    },
                    "version": {
                        "type": "string",
                        "description": "[string] The InMemoryDB version of your replica set.\n"
                    }
                },
                "type": "object",
                "required": [
                    "connections",
                    "credentials",
                    "dnsName",
                    "evictionPolicy",
                    "location",
                    "maintenanceWindows",
                    "persistenceMode",
                    "replicas",
                    "resources",
                    "version"
                ]
            }
        },
        "ionoscloud:dbaas/getInmemorydbSnapshot:getInmemorydbSnapshot": {
            "description": "The `ionoscloud.dbaas.getInmemorydbSnapshot` data source can be used to retrieve information about an existing InMemoryDB Snapshot.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.dbaas.getInmemorydbSnapshot({\n    id: \"snapshot-id\",\n    location: \"de/txl\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.dbaas.get_inmemorydb_snapshot(id=\"snapshot-id\",\n    location=\"de/txl\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Dbaas.GetInmemorydbSnapshot.Invoke(new()\n    {\n        Id = \"snapshot-id\",\n        Location = \"de/txl\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/dbaas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dbaas.GetInmemorydbSnapshot(ctx, \u0026dbaas.GetInmemorydbSnapshotArgs{\n\t\t\tId:       \"snapshot-id\",\n\t\t\tLocation: \"de/txl\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.dbaas.DbaasFunctions;\nimport com.pulumi.ionoscloud.dbaas.inputs.GetInmemorydbSnapshotArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = DbaasFunctions.getInmemorydbSnapshot(GetInmemorydbSnapshotArgs.builder()\n            .id(\"snapshot-id\")\n            .location(\"de/txl\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:dbaas:getInmemorydbSnapshot\n      arguments:\n        id: snapshot-id\n        location: de/txl\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getInmemorydbSnapshot.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The ID of the InMemoryDB Snapshot.\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "The location of the InMemoryDB Snapshot.\n"
                    }
                },
                "type": "object",
                "required": [
                    "id",
                    "location"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getInmemorydbSnapshot.\n",
                "properties": {
                    "id": {
                        "type": "string"
                    },
                    "location": {
                        "type": "string"
                    },
                    "metadatas": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:dbaas/getInmemorydbSnapshotMetadata:getInmemorydbSnapshotMetadata"
                        },
                        "description": "Metadata of the snapshot.\n"
                    }
                },
                "type": "object",
                "required": [
                    "id",
                    "location",
                    "metadatas"
                ]
            }
        },
        "ionoscloud:dbaas/getMariaDBBackups:getMariaDBBackups": {
            "description": "The **DBaaS MariaDB Backups data source** can be used to search for and return existing DBaaS MariaDB Backups for a specific cluster.\n\n## Example Usage\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getMariaDBBackups.\n",
                "properties": {
                    "backupId": {
                        "type": "string",
                        "description": "[string] The unique ID of the backup.\n"
                    },
                    "clusterId": {
                        "type": "string",
                        "description": "[string] The unique ID of the cluster.\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "[string] The location of the cluster. Different service endpoints are used based on location, possible options are: \"de/fra\", \"de/txl\", \"es/vit\", \"fr/par\", \"gb/lhr\", \"us/ewr\", \"us/las\", \"us/mci\". If not set, the endpoint will be the one corresponding to \"de/txl\".\n\n⚠️ **Note:** Either `cluster_id` or `backup_id` must be used, but not both at the same time.\n\n\u003e **⚠ WARNING:** `Location` attribute will become required in the future.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getMariaDBBackups.\n",
                "properties": {
                    "backupId": {
                        "type": "string"
                    },
                    "backups": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:dbaas/getMariaDBBackupsBackup:getMariaDBBackupsBackup"
                        }
                    },
                    "clusterId": {
                        "type": "string",
                        "description": "The unique ID of the cluster that was backed up.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "location": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "backups",
                    "id"
                ]
            }
        },
        "ionoscloud:dbaas/getMariaDBCluster:getMariaDBCluster": {
            "description": "The **DBaaS MariaDB Cluster data source** can be used to search for and return an existing DBaaS MariaDB Cluster.\n\n## Example Usage\n\n### By Name\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.dbaas.getMariaDBCluster({\n    displayName: \"MariaDB_cluster\",\n    location: \"de/txl\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.dbaas.get_maria_db_cluster(display_name=\"MariaDB_cluster\",\n    location=\"de/txl\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Dbaas.GetMariaDBCluster.Invoke(new()\n    {\n        DisplayName = \"MariaDB_cluster\",\n        Location = \"de/txl\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/dbaas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dbaas.LookupMariaDBCluster(ctx, \u0026dbaas.LookupMariaDBClusterArgs{\n\t\t\tDisplayName: pulumi.StringRef(\"MariaDB_cluster\"),\n\t\t\tLocation:    pulumi.StringRef(\"de/txl\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.dbaas.DbaasFunctions;\nimport com.pulumi.ionoscloud.dbaas.inputs.GetMariaDBClusterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = DbaasFunctions.getMariaDBCluster(GetMariaDBClusterArgs.builder()\n            .displayName(\"MariaDB_cluster\")\n            .location(\"de/txl\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:dbaas:getMariaDBCluster\n      arguments:\n        displayName: MariaDB_cluster\n        location: de/txl\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getMariaDBCluster.\n",
                "properties": {
                    "displayName": {
                        "type": "string",
                        "description": "[string] Display Name of an existing cluster that you want to search for.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "[string] ID of the cluster you want to search for.\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "[string] The location of the cluster. Different service endpoints are used based on location, possible options are: \"de/fra\", \"de/txl\", \"es/vit\", \"fr/par\", \"gb/lhr\", \"us/ewr\", \"us/las\", \"us/mci\". If not set, the endpoint will be the one corresponding to \"de/txl\".\n\n\u003e **⚠ WARNING:** `Location` attribute will become required in the future.\n\nEither `display_name` or `id` must be provided. If none or both are provided, the datasource will return an error.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getMariaDBCluster.\n",
                "properties": {
                    "connections": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:dbaas/getMariaDBClusterConnection:getMariaDBClusterConnection"
                        },
                        "description": "The network connection for your cluster. Only one connection is allowed.\n"
                    },
                    "cores": {
                        "type": "integer",
                        "description": "[int] The number of CPU cores per instance.\n"
                    },
                    "displayName": {
                        "type": "string",
                        "description": "[string] The friendly name of your cluster.\n"
                    },
                    "dnsName": {
                        "type": "string",
                        "description": "[string] The DNS name pointing to your cluster.\n"
                    },
                    "id": {
                        "type": "string"
                    },
                    "instances": {
                        "type": "integer",
                        "description": "[int] The total number of instances in the cluster (one primary and n-1 secondary).\n"
                    },
                    "location": {
                        "type": "string"
                    },
                    "maintenanceWindows": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:dbaas/getMariaDBClusterMaintenanceWindow:getMariaDBClusterMaintenanceWindow"
                        },
                        "description": "A weekly 4 hour-long window, during which maintenance might occur.\n"
                    },
                    "mariadbVersion": {
                        "type": "string",
                        "description": "[string] The MariaDB version of your cluster.\n"
                    },
                    "ram": {
                        "type": "integer",
                        "description": "[int] The amount of memory per instance in gigabytes (GB).\n"
                    },
                    "storageSize": {
                        "type": "integer",
                        "description": "[int] The amount of storage per instance in gigabytes (GB).\n"
                    }
                },
                "type": "object",
                "required": [
                    "connections",
                    "cores",
                    "dnsName",
                    "instances",
                    "maintenanceWindows",
                    "mariadbVersion",
                    "ram",
                    "storageSize"
                ]
            }
        },
        "ionoscloud:dbaas/getMongoCluster:getMongoCluster": {
            "description": "The **DbaaS Mongo Cluster data source** can be used to search for and return an existing DbaaS MongoDB Cluster.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search string so that it is specific enough to return only one result.\n\n## Example Usage\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getMongoCluster.\n",
                "properties": {
                    "displayName": {
                        "type": "string",
                        "description": "The name of your cluster. Updates to the value of the field force the cluster to be re-created.\n"
                    },
                    "id": {
                        "type": "string"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getMongoCluster.\n",
                "properties": {
                    "backups": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:dbaas/getMongoClusterBackup:getMongoClusterBackup"
                        }
                    },
                    "biConnectors": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:dbaas/getMongoClusterBiConnector:getMongoClusterBiConnector"
                        }
                    },
                    "connectionString": {
                        "type": "string",
                        "description": "The physical location where the cluster will be created. This will be where all of your instances live. Updates to the value of the field force the cluster to be re-created. Available locations: de/txl, gb/lhr, es/vit\"\n"
                    },
                    "connections": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:dbaas/getMongoClusterConnection:getMongoClusterConnection"
                        },
                        "description": "Details about the network connection for your cluster. Updates to the value of the field force the cluster to be re-created.\n"
                    },
                    "cores": {
                        "type": "integer",
                        "description": "The number of CPU cores per replica. Required for enterprise edition.\n"
                    },
                    "displayName": {
                        "type": "string",
                        "description": "The name of your cluster. Updates to the value of the field force the cluster to be re-created.\n"
                    },
                    "edition": {
                        "type": "string",
                        "description": "Cluster edition. Playground, business or enterprise.\n"
                    },
                    "id": {
                        "type": "string"
                    },
                    "instances": {
                        "type": "integer",
                        "description": "The total number of instances in the cluster (one master and n-1 standbys). Example: 3, 5, 7. Updates to the value of the field force the cluster to be re-created.\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "The location where the cluster backups will be stored. If not set, the backup is stored in the nearest location of the cluster. Possible values are de, eu-south-2, or eu-central-2.\n"
                    },
                    "maintenanceWindows": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:dbaas/getMongoClusterMaintenanceWindow:getMongoClusterMaintenanceWindow"
                        },
                        "description": "A weekly 4 hour-long window, during which maintenance might occur.  Updates to the value of the field force the cluster to be re-created.\n"
                    },
                    "mongodbVersion": {
                        "type": "string",
                        "description": "The MongoDB version of your cluster. Updates to the value of the field force the cluster to be re-created.\n"
                    },
                    "ram": {
                        "type": "integer",
                        "description": "The amount of memory per instance in megabytes. Required for enterprise edition.\n"
                    },
                    "shards": {
                        "type": "integer"
                    },
                    "storageSize": {
                        "type": "integer",
                        "description": "The amount of storage per instance in MB. Required for enterprise edition.\n"
                    },
                    "storageType": {
                        "type": "string",
                        "description": "The storage type used in your cluster. Required for enterprise edition.\n"
                    },
                    "templateId": {
                        "type": "string",
                        "description": "The unique ID of the template, which specifies the number of cores, storage size, and memory. Updates to the value of the field force the cluster to be re-created.\n"
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "backups",
                    "biConnectors",
                    "connectionString",
                    "connections",
                    "cores",
                    "edition",
                    "instances",
                    "location",
                    "maintenanceWindows",
                    "mongodbVersion",
                    "ram",
                    "shards",
                    "storageSize",
                    "storageType",
                    "templateId",
                    "type"
                ]
            }
        },
        "ionoscloud:dbaas/getMongoTemplate:getMongoTemplate": {
            "description": "The **DbaaS Mongo Template data source** can be used to search for and return an existing DbaaS MongoDB Template.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search string so that it is specific enough to return only one result.\n\n## Example Usage\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getMongoTemplate.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The ID of the template.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the template.\n"
                    },
                    "partialMatch": {
                        "type": "boolean"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getMongoTemplate.\n",
                "properties": {
                    "cores": {
                        "type": "integer",
                        "description": "The number of CPU cores.\n"
                    },
                    "edition": {
                        "type": "string",
                        "description": "The edition of the template (e.g. enterprise).\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The ID of the template.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the template.\n"
                    },
                    "partialMatch": {
                        "type": "boolean"
                    },
                    "ram": {
                        "type": "integer",
                        "description": "The amount of memory in GB.\n"
                    },
                    "storageSize": {
                        "type": "integer",
                        "description": "The amount of storage size in GB.\n"
                    }
                },
                "type": "object",
                "required": [
                    "cores",
                    "edition",
                    "id",
                    "name",
                    "ram",
                    "storageSize"
                ]
            }
        },
        "ionoscloud:dbaas/getMongoUser:getMongoUser": {
            "description": "The **DbaaS Mongo User data source** can be used to search for and return an existing DbaaS MongoDB User.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search string so that it is specific enough to return only one result.\n\n## Example Usage\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getMongoUser.\n",
                "properties": {
                    "clusterId": {
                        "type": "string",
                        "description": "[string] The unique ID of the cluster. Updates to the value of the field force the cluster to be re-created.\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "[string] The user database to use for authentication. Updates to the value of the field force the cluster to be re-created.\n"
                    },
                    "id": {
                        "type": "string"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:dbaas/getMongoUserRole:getMongoUserRole"
                        },
                        "description": "[string] a list of mongodb user roles. Updates to the value of the field force the cluster to be re-created.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "[string] Used for authentication. Updates to the value of the field force the cluster to be re-created.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusterId",
                    "username"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getMongoUser.\n",
                "properties": {
                    "clusterId": {
                        "type": "string"
                    },
                    "database": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:dbaas/getMongoUserRole:getMongoUserRole"
                        }
                    },
                    "username": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "clusterId",
                    "database",
                    "roles",
                    "username"
                ]
            }
        },
        "ionoscloud:dbaas/getPSQLBackups:getPSQLBackups": {
            "description": "The **DbaaS Postgres Backups data source** can be used to search for and return existing DbaaS Postgres Backups for a specific Cluster.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search string so that it is specific enough to return only one result.\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPSQLBackups.\n",
                "properties": {
                    "clusterId": {
                        "type": "string",
                        "description": "The unique ID of the cluster.\n\n`cluster_id` must be provided. If it is not provided, the datasource will return an error.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusterId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPSQLBackups.\n",
                "properties": {
                    "clusterBackups": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:dbaas/getPSQLBackupsClusterBackup:getPSQLBackupsClusterBackup"
                        },
                        "description": "List of backups.\n"
                    },
                    "clusterId": {
                        "type": "string",
                        "description": "The unique ID of the cluster\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusterBackups",
                    "clusterId",
                    "id"
                ]
            }
        },
        "ionoscloud:dbaas/getPSQLCluster:getPSQLCluster": {
            "description": "The **DbaaS Postgres Cluster data source** can be used to search for and return an existing DbaaS Postgres Cluster.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search string so that it is specific enough to return only one result.\n\n## Example Usage\n\n### By Name\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.dbaas.getPSQLCluster({\n    displayName: \"PostgreSQL_cluster\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.dbaas.get_psql_cluster(display_name=\"PostgreSQL_cluster\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Dbaas.GetPSQLCluster.Invoke(new()\n    {\n        DisplayName = \"PostgreSQL_cluster\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/dbaas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dbaas.LookupPSQLCluster(ctx, \u0026dbaas.LookupPSQLClusterArgs{\n\t\t\tDisplayName: pulumi.StringRef(\"PostgreSQL_cluster\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.dbaas.DbaasFunctions;\nimport com.pulumi.ionoscloud.dbaas.inputs.GetPSQLClusterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = DbaasFunctions.getPSQLCluster(GetPSQLClusterArgs.builder()\n            .displayName(\"PostgreSQL_cluster\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:dbaas:getPSQLCluster\n      arguments:\n        displayName: PostgreSQL_cluster\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPSQLCluster.\n",
                "properties": {
                    "displayName": {
                        "type": "string",
                        "description": "Display Name of an existing cluster that you want to search for.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "ID of the cluster you want to search for.\n\nEither `display_name` or `id` must be provided. If none, or both are provided, the datasource will return an error.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getPSQLCluster.\n",
                "properties": {
                    "backupLocation": {
                        "type": "string",
                        "description": "The IONOS Object Storage location where the backups will be stored.\n"
                    },
                    "connectionPoolers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:dbaas/getPSQLClusterConnectionPooler:getPSQLClusterConnectionPooler"
                        },
                        "description": "Details about the connection pooler.\n"
                    },
                    "connections": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:dbaas/getPSQLClusterConnection:getPSQLClusterConnection"
                        },
                        "description": "Details about the network connection for your cluster.\n"
                    },
                    "cores": {
                        "type": "integer",
                        "description": "The number of CPU cores per replica.\n"
                    },
                    "displayName": {
                        "type": "string",
                        "description": "The friendly name of your cluster.\n"
                    },
                    "dnsName": {
                        "type": "string",
                        "description": "The DNS name pointing to your cluster.\n"
                    },
                    "fromBackups": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:dbaas/getPSQLClusterFromBackup:getPSQLClusterFromBackup"
                        },
                        "description": "The unique ID of the backup you want to restore.\n"
                    },
                    "id": {
                        "type": "string"
                    },
                    "instances": {
                        "type": "integer",
                        "description": "The total number of instances in the cluster (one master and n-1 standbys)\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "The physical location where the cluster will be created. This will be where all of your instances live.\n"
                    },
                    "maintenanceWindows": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:dbaas/getPSQLClusterMaintenanceWindow:getPSQLClusterMaintenanceWindow"
                        },
                        "description": "A weekly 4 hour-long window, during which maintenance might occur\n"
                    },
                    "postgresVersion": {
                        "type": "string",
                        "description": "The PostgreSQL version of your cluster.\n"
                    },
                    "ram": {
                        "type": "integer",
                        "description": "The amount of memory per instance in megabytes.\n"
                    },
                    "storageSize": {
                        "type": "integer",
                        "description": "The amount of storage per instance in MB.\n"
                    },
                    "storageType": {
                        "type": "string",
                        "description": "The storage type used in your cluster.\n"
                    },
                    "synchronizationMode": {
                        "type": "string",
                        "description": "Represents different modes of replication.\n"
                    }
                },
                "type": "object",
                "required": [
                    "backupLocation",
                    "connectionPoolers",
                    "connections",
                    "cores",
                    "dnsName",
                    "fromBackups",
                    "instances",
                    "location",
                    "maintenanceWindows",
                    "postgresVersion",
                    "ram",
                    "storageSize",
                    "storageType",
                    "synchronizationMode"
                ]
            }
        },
        "ionoscloud:dbaas/getPSQLDatabase:getPSQLDatabase": {
            "description": "The **PgSql Database data source** can be used to search for and return an existing PgSql database.\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPSQLDatabase.\n",
                "properties": {
                    "clusterId": {
                        "type": "string",
                        "description": "[string] The ID of the cluster.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] Name of an existing database that you want to search for.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusterId",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPSQLDatabase.\n",
                "properties": {
                    "clusterId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "[string] The id of the database.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "owner": {
                        "type": "string",
                        "description": "[string] The owner of the database.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusterId",
                    "id",
                    "name",
                    "owner"
                ]
            }
        },
        "ionoscloud:dbaas/getPSQLDatabases:getPSQLDatabases": {
            "description": "The **PgSql Databases data source** can be used to search for and return multiple existing PgSql databases.\n\n## Example Usage\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPSQLDatabases.\n",
                "properties": {
                    "clusterId": {
                        "type": "string",
                        "description": "[string] The ID of the cluster.\n"
                    },
                    "owner": {
                        "type": "string",
                        "description": "[string] Filter using a specific owner.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusterId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPSQLDatabases.\n",
                "properties": {
                    "clusterId": {
                        "type": "string"
                    },
                    "databases": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:dbaas/getPSQLDatabasesDatabase:getPSQLDatabasesDatabase"
                        },
                        "description": "[list] A list that contains either all databases, either some of them (filter by owner). A database from list has the following format:\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "owner": {
                        "type": "string",
                        "description": "[string] The owner of the database.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusterId",
                    "databases",
                    "id"
                ]
            }
        },
        "ionoscloud:dbaas/getPSQLUser:getPSQLUser": {
            "description": "The **PgSql User data source** can be used to search for and return an existing PgSql user.\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPSQLUser.\n",
                "properties": {
                    "clusterId": {
                        "type": "string",
                        "description": "[string] The ID of the cluster.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "[string] Name of an existing user that you want to search for.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusterId",
                    "username"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPSQLUser.\n",
                "properties": {
                    "clusterId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "[string] The id of the user.\n"
                    },
                    "isSystemUser": {
                        "type": "boolean",
                        "description": "[bool] Describes whether this user is a system user or not. A system user cannot be updated or deleted.\n"
                    },
                    "username": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "clusterId",
                    "id",
                    "isSystemUser",
                    "username"
                ]
            }
        },
        "ionoscloud:dbaas/getPSQLVersions:getPSQLVersions": {
            "description": "The **DbaaS Postgres Versions data source** can be used to search for and retrieve list of available postgres versions for a specific cluster or for all clusters.\n\n## Example Usage\n\n### Retrieve list of postgres versions for all clusters\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.dbaas.getPSQLVersions({});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.dbaas.get_psql_versions()\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Dbaas.GetPSQLVersions.Invoke();\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/dbaas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dbaas.GetPSQLVersions(ctx, \u0026dbaas.GetPSQLVersionsArgs{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.dbaas.DbaasFunctions;\nimport com.pulumi.ionoscloud.dbaas.inputs.GetPSQLVersionsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = DbaasFunctions.getPSQLVersions();\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:dbaas:getPSQLVersions\n      arguments: {}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPSQLVersions.\n",
                "properties": {
                    "clusterId": {
                        "type": "string",
                        "description": "The unique ID of the cluster.\n\nIf `cluster_id` is not provided the data source will return the list of postgres version for all cluster.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getPSQLVersions.\n",
                "properties": {
                    "clusterId": {
                        "type": "string",
                        "description": "Id of the cluster\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "postgresVersions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "list of PostgreSQL versions.\n"
                    }
                },
                "type": "object",
                "required": [
                    "postgresVersions",
                    "id"
                ]
            }
        },
        "ionoscloud:dns/getRecord:getRecord": {
            "description": "The **DNS Record** can be used to search for and return an existing DNS Record.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search and make sure that your resources have unique names.\n\n\u003e ⚠️  Only tokens are accepted for authorization in the **ionoscloud_dns_record** data source. Please ensure you are using tokens as other methods will not be valid.\n\n## Example Usage\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getRecord.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "[string] The ID of the DNS Record you want to search for.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] The name of the DNS Record you want to search for.\n"
                    },
                    "partialMatch": {
                        "type": "boolean",
                        "description": "[bool] Whether partial matching is allowed or not when using name argument. Default value is false.\n\nEither `id` or `name` must be provided. If none, or both are provided, the datasource will return an error.\n"
                    },
                    "zoneId": {
                        "type": "string",
                        "description": "[string] The ID of the DNS Zone in which the DNS Record can be found.\n"
                    }
                },
                "type": "object",
                "required": [
                    "zoneId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRecord.\n",
                "properties": {
                    "content": {
                        "type": "string",
                        "description": "The content of the DNS Record.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Indicates if the DNS Record is active or not.\n"
                    },
                    "fqdn": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The UUID of the DNS Record.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the DNS Record.\n"
                    },
                    "partialMatch": {
                        "type": "boolean"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "The priority for the DNS Record.\n"
                    },
                    "ttl": {
                        "type": "integer",
                        "description": "The time to live of the DNS Record.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of the DNS Record.\n"
                    },
                    "zoneId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "content",
                    "enabled",
                    "fqdn",
                    "priority",
                    "ttl",
                    "type",
                    "zoneId"
                ]
            }
        },
        "ionoscloud:dns/getZone:getZone": {
            "description": "The **DNS Zone** can be used to search for and return an existing DNS Zone.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search and make sure that your resources have unique names.\n\n\u003e ⚠️  Only tokens are accepted for authorization in the **ionoscloud_dns_zone** data source. Please ensure you are using tokens as other methods will not be valid.\n\n## Example Usage\n\n### By name\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.dns.getZone({\n    name: \"example.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.dns.get_zone(name=\"example.com\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Dns.GetZone.Invoke(new()\n    {\n        Name = \"example.com\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/dns\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dns.LookupZone(ctx, \u0026dns.LookupZoneArgs{\n\t\t\tName: pulumi.StringRef(\"example.com\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.dns.DnsFunctions;\nimport com.pulumi.ionoscloud.dns.inputs.GetZoneArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = DnsFunctions.getZone(GetZoneArgs.builder()\n            .name(\"example.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:dns:getZone\n      arguments:\n        name: example.com\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### By name with partial match\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.dns.getZone({\n    name: \"example\",\n    partialMatch: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.dns.get_zone(name=\"example\",\n    partial_match=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Dns.GetZone.Invoke(new()\n    {\n        Name = \"example\",\n        PartialMatch = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/dns\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dns.LookupZone(ctx, \u0026dns.LookupZoneArgs{\n\t\t\tName:         pulumi.StringRef(\"example\"),\n\t\t\tPartialMatch: pulumi.BoolRef(true),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.dns.DnsFunctions;\nimport com.pulumi.ionoscloud.dns.inputs.GetZoneArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = DnsFunctions.getZone(GetZoneArgs.builder()\n            .name(\"example\")\n            .partialMatch(true)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:dns:getZone\n      arguments:\n        name: example\n        partialMatch: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getZone.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "[string] The ID of the DNS Zone you want to search for.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] The name of the DNS Zone you want to search for.\n"
                    },
                    "partialMatch": {
                        "type": "boolean",
                        "description": "[bool] Whether partial matching is allowed or not when using name argument. Default value is false.\n\nEither `id` or `name` must be provided. If none, or both are provided, the datasource will return an error.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getZone.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "The description of the DNS Zone.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Indicates if the DNS Zone is activated or not.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The UUID of the DNS Zone.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the DNS Zone.\n"
                    },
                    "nameservers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of available name servers.\n"
                    },
                    "partialMatch": {
                        "type": "boolean"
                    }
                },
                "type": "object",
                "required": [
                    "description",
                    "enabled",
                    "nameservers"
                ]
            }
        },
        "ionoscloud:dsaas/getCluster:getCluster": {
            "description": "The **Dataplatform Cluster Data Source** can be used to search for and return an existing Dataplatform Cluster.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search and make sure that your resources have unique names.\n\n## Example Usage\n\n### By Name\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.dsaas.getCluster({\n    name: \"Dataplatform_Cluster_Example\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.dsaas.get_cluster(name=\"Dataplatform_Cluster_Example\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Dsaas.GetCluster.Invoke(new()\n    {\n        Name = \"Dataplatform_Cluster_Example\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/dsaas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dsaas.LookupCluster(ctx, \u0026dsaas.LookupClusterArgs{\n\t\t\tName: pulumi.StringRef(\"Dataplatform_Cluster_Example\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.dsaas.DsaasFunctions;\nimport com.pulumi.ionoscloud.dsaas.inputs.GetClusterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = DsaasFunctions.getCluster(GetClusterArgs.builder()\n            .name(\"Dataplatform_Cluster_Example\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:dsaas:getCluster\n      arguments:\n        name: Dataplatform_Cluster_Example\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### By Name with Partial Match\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.dsaas.getCluster({\n    name: \"_Example\",\n    partialMatch: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.dsaas.get_cluster(name=\"_Example\",\n    partial_match=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Dsaas.GetCluster.Invoke(new()\n    {\n        Name = \"_Example\",\n        PartialMatch = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/dsaas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dsaas.LookupCluster(ctx, \u0026dsaas.LookupClusterArgs{\n\t\t\tName:         pulumi.StringRef(\"_Example\"),\n\t\t\tPartialMatch: pulumi.BoolRef(true),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.dsaas.DsaasFunctions;\nimport com.pulumi.ionoscloud.dsaas.inputs.GetClusterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = DsaasFunctions.getCluster(GetClusterArgs.builder()\n            .name(\"_Example\")\n            .partialMatch(true)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:dsaas:getCluster\n      arguments:\n        name: _Example\n        partialMatch: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCluster.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "ID of the cluster you want to search for.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of an existing cluster that you want to search for. Search by name is case-insensitive. The whole resource name is required if `partial_match` parameter is not set to true.\n"
                    },
                    "partialMatch": {
                        "type": "boolean",
                        "description": "Whether partial matching is allowed or not when using name argument. Default value is false.\n\nEither `id` or `name` must be provided. If none, or both are provided, the datasource will return an error.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getCluster.\n",
                "properties": {
                    "caCrt": {
                        "type": "string",
                        "description": "base64 decoded cluster certificate authority data (provided as an attribute for direct use)\n",
                        "secret": true
                    },
                    "configs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:dsaas/getClusterConfig:getClusterConfig"
                        },
                        "description": "structured kubernetes config consisting of a list with 1 item with the following fields:\n* api_version - Kubernetes API Version\n* kind - \"Config\"\n* current-context - string\n* clusters - list of\n* name - name of cluster\n* cluster - map of\n* certificate-authority-data - **base64 decoded** cluster CA data\n* server -  server address in the form `https://host:port`\n* contexts - list of\n* name - context name\n* context - map of\n* cluster - cluster name\n* user - cluster user\n* users - list of\n* name - user name\n* user - map of\n* token - user token used for authentication\n",
                        "secret": true
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "The UUID of the virtual data center (VDC) in which the cluster is provisioned.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The UUID of the cluster.\n"
                    },
                    "kubeConfig": {
                        "type": "string",
                        "description": "Kubernetes configuration\n"
                    },
                    "lans": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:dsaas/getClusterLan:getClusterLan"
                        },
                        "description": "A list of LANs you want this node pool to be part of\n"
                    },
                    "maintenanceWindows": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:dsaas/getClusterMaintenanceWindow:getClusterMaintenanceWindow"
                        },
                        "description": "Starting time of a weekly 4 hour-long window, during which maintenance might occur in hh:mm:ss format\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of your cluster.\n"
                    },
                    "partialMatch": {
                        "type": "boolean"
                    },
                    "server": {
                        "type": "string",
                        "description": "cluster server (same as `config[0].clusters[0].cluster.server` but provided as an attribute for ease of use)\n",
                        "secret": true
                    },
                    "userTokens": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "a convenience map to be search the token of a specific user\n* key - is the user name\n* value - is the token\n",
                        "secret": true
                    },
                    "version": {
                        "type": "string",
                        "description": "The version of the Data Platform.\n"
                    }
                },
                "type": "object",
                "required": [
                    "caCrt",
                    "configs",
                    "datacenterId",
                    "kubeConfig",
                    "lans",
                    "maintenanceWindows",
                    "server",
                    "userTokens",
                    "version"
                ]
            }
        },
        "ionoscloud:dsaas/getNodePool:getNodePool": {
            "description": "The **Dataplatform Node Pool Data Source** can be used to search for and return an existing Dataplatform Node Pool under a Dataplatform Cluster.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search and make sure that your resources have unique names.\n\n## Example Usage\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNodePool.\n",
                "properties": {
                    "clusterId": {
                        "type": "string",
                        "description": "ID of the cluster the searched node pool is part of.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "ID of the node pool you want to search for.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of an existing cluster that you want to search for. Search by name is case-insensitive. The whole resource name is required if `partial_match` parameter is not set to true.\n"
                    },
                    "partialMatch": {
                        "type": "boolean",
                        "description": "Whether partial matching is allowed or not when using name argument. Default value is false.\n\nEither `id` or `name` must be provided. If none, or both are provided, the datasource will return an error.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusterId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNodePool.\n",
                "properties": {
                    "annotations": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Key-value pairs attached to node pool resource as [Kubernetes annotations](https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/).\n"
                    },
                    "availabilityZone": {
                        "type": "string",
                        "description": "The availability zone of the virtual datacenter region where the node pool resources should be provisioned.\n"
                    },
                    "clusterId": {
                        "type": "string",
                        "description": "ID of the cluster the searched node pool is part of.\n"
                    },
                    "coresCount": {
                        "type": "integer",
                        "description": "The number of CPU cores per node.\n"
                    },
                    "cpuFamily": {
                        "type": "string",
                        "description": "A CPU family.\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "The UUID of the virtual data center (VDC) the cluster is provisioned.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "ID of your node pool.\n"
                    },
                    "labels": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Key-value pairs attached to the node pool resource as [Kubernetes labels](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/).\n"
                    },
                    "maintenanceWindows": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:dsaas/getNodePoolMaintenanceWindow:getNodePoolMaintenanceWindow"
                        },
                        "description": "Starting time of a weekly 4 hour-long window, during which maintenance might occur in hh:mm:ss format\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of your node pool\n"
                    },
                    "nodeCount": {
                        "type": "integer",
                        "description": "The number of nodes that make up the node pool.\n"
                    },
                    "partialMatch": {
                        "type": "boolean"
                    },
                    "ramSize": {
                        "type": "integer",
                        "description": "The RAM size for one node in MB.\n"
                    },
                    "storageSize": {
                        "type": "integer",
                        "description": "The size of the volume in GB.\n"
                    },
                    "storageType": {
                        "type": "string",
                        "description": "The type of hardware for the volume.\n"
                    },
                    "version": {
                        "type": "string",
                        "description": "The version of the Data Platform.\n"
                    }
                },
                "type": "object",
                "required": [
                    "annotations",
                    "availabilityZone",
                    "clusterId",
                    "coresCount",
                    "cpuFamily",
                    "datacenterId",
                    "labels",
                    "maintenanceWindows",
                    "nodeCount",
                    "ramSize",
                    "storageSize",
                    "storageType",
                    "version"
                ]
            }
        },
        "ionoscloud:dsaas/getNodePools:getNodePools": {
            "description": "The **Dataplatform Node Pools Data Source** can be used to search for and return a list of existing Dataplatform Node Pools under a Dataplatform Cluster.\n\n## Example Usage\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNodePools.\n",
                "properties": {
                    "clusterId": {
                        "type": "string",
                        "description": "ID of the cluster the searched node pool is part of.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of an existing cluster that you want to search for. Search by name is case-insensitive. The whole resource name is required if `partial_match` parameter is not set to true.\n"
                    },
                    "partialMatch": {
                        "type": "boolean",
                        "description": "Whether partial matching is allowed or not when using name argument. Default value is false.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusterId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNodePools.\n",
                "properties": {
                    "clusterId": {
                        "type": "string",
                        "description": "ID of the cluster the searched node pool is part of.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "nodePools": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:dsaas/getNodePoolsNodePool:getNodePoolsNodePool"
                        },
                        "description": "List of Node Pools - See the Node Pool section.\n"
                    },
                    "partialMatch": {
                        "type": "boolean"
                    }
                },
                "type": "object",
                "required": [
                    "clusterId",
                    "nodePools",
                    "id"
                ]
            }
        },
        "ionoscloud:dsaas/getVersions:getVersions": {
            "description": "The **Dataplatform Versions Data Source** can be used to search for and retrieve list of available Managed Dataplatform API versions.\n\n\n## Example Usage\n\n### Retrieve list of Managed Dataplatform API versions\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.dsaas.getVersions({});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.dsaas.get_versions()\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Dsaas.GetVersions.Invoke();\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/dsaas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := dsaas.GetVersions(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.dsaas.DsaasFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = DsaasFunctions.getVersions();\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:dsaas:getVersions\n      arguments: {}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "outputs": {
                "description": "A collection of values returned by getVersions.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "versions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "list of Managed Dataplatform API versions.\n"
                    }
                },
                "type": "object",
                "required": [
                    "versions",
                    "id"
                ]
            }
        },
        "ionoscloud:k8s/getCluster:getCluster": {
            "description": "The **k8s Cluster data source** can be used to search for and return existing k8s clusters.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search string so that it is specific enough to return only one result.\n\n## Example Usage\n\n### By Name\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.k8s.getCluster({\n    name: \"K8s Cluster Example\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.k8s.get_cluster(name=\"K8s Cluster Example\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.K8s.GetCluster.Invoke(new()\n    {\n        Name = \"K8s Cluster Example\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/k8s\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := k8s.LookupCluster(ctx, \u0026k8s.LookupClusterArgs{\n\t\t\tName: pulumi.StringRef(\"K8s Cluster Example\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.k8s.K8sFunctions;\nimport com.pulumi.ionoscloud.k8s.inputs.GetClusterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = K8sFunctions.getCluster(GetClusterArgs.builder()\n            .name(\"K8s Cluster Example\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:k8s:getCluster\n      arguments:\n        name: K8s Cluster Example\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCluster.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "ID of the cluster you want to search for.\n\nEither `name` or `id` must be provided. If none, or both are provided, the datasource will return an error.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of an existing cluster that you want to search for.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getCluster.\n",
                "properties": {
                    "apiSubnetAllowLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "access to the K8s API server is restricted to these CIDRs\n"
                    },
                    "availableUpgradeVersions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of available versions for upgrading the cluster\n"
                    },
                    "caCrt": {
                        "type": "string",
                        "description": "base64 decoded cluster certificate authority data (provided as an attribute for direct use)\n",
                        "secret": true
                    },
                    "configs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:k8s/getClusterConfig:getClusterConfig"
                        },
                        "description": "structured kubernetes config consisting of a list with 1 item with the following fields:\n* api_version - Kubernetes API Version\n* kind - \"Config\"\n* current-context - string\n* clusters - list of\n* name - name of cluster\n* cluster - map of\n* certificate-authority-data - **base64 decoded** cluster CA data\n* server -  server address in the form `https://host:port`\n* contexts - list of\n* name - context name\n* context - map of\n* cluster - cluster name\n* user - cluster user\n* users - list of\n* name - user name\n* user - map of\n* token - user token used for authentication\n",
                        "secret": true
                    },
                    "id": {
                        "type": "string",
                        "description": "id of the cluster\n"
                    },
                    "k8sVersion": {
                        "type": "string",
                        "description": "Kubernetes version\n"
                    },
                    "kubeConfig": {
                        "type": "string",
                        "description": "Kubernetes configuration\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "this attribute is mandatory if the cluster is private.\n"
                    },
                    "maintenanceWindows": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:k8s/getClusterMaintenanceWindow:getClusterMaintenanceWindow"
                        },
                        "description": "A maintenance window comprise of a day of the week and a time for maintenance to be allowed\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "name of the cluster\n"
                    },
                    "natGatewayIp": {
                        "type": "string",
                        "description": "the NAT gateway IP of the cluster if the cluster is private.\n"
                    },
                    "nodePools": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "list of the IDs of the node pools in this cluster\n"
                    },
                    "nodeSubnet": {
                        "type": "string",
                        "description": "the node subnet of the cluster, if the cluster is private.\n"
                    },
                    "public": {
                        "type": "boolean",
                        "description": "indicates if the cluster is public or private.\n"
                    },
                    "s3Buckets": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:k8s/getClusterS3Bucket:getClusterS3Bucket"
                        },
                        "description": "list of IONOS Object Storage bucket configured for K8s usage\n"
                    },
                    "server": {
                        "type": "string",
                        "description": "cluster server (same as `config[0].clusters[0].cluster.server` but provided as an attribute for ease of use)\n",
                        "secret": true
                    },
                    "state": {
                        "type": "string",
                        "description": "one of \"AVAILABLE\",\n\"INACTIVE\",\n\"BUSY\",\n\"DEPLOYING\",\n\"ACTIVE\",\n\"FAILED\",\n\"SUSPENDED\",\n\"FAILED_SUSPENDED\",\n\"UPDATING\",\n\"FAILED_UPDATING\",\n\"DESTROYING\",\n\"FAILED_DESTROYING\",\n\"TERMINATED\"\n"
                    },
                    "userTokens": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "a convenience map to be search the token of a specific user\n- key - is the user name\n- value - is the token\n",
                        "secret": true
                    },
                    "viableNodePoolVersions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of versions that may be used for node pools under this cluster\n"
                    }
                },
                "type": "object",
                "required": [
                    "apiSubnetAllowLists",
                    "availableUpgradeVersions",
                    "caCrt",
                    "configs",
                    "k8sVersion",
                    "kubeConfig",
                    "location",
                    "maintenanceWindows",
                    "natGatewayIp",
                    "nodePools",
                    "nodeSubnet",
                    "public",
                    "s3Buckets",
                    "server",
                    "state",
                    "userTokens",
                    "viableNodePoolVersions"
                ]
            }
        },
        "ionoscloud:k8s/getClusters:getClusters": {
            "inputs": {
                "description": "A collection of arguments for invoking getClusters.\n",
                "properties": {
                    "filters": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:k8s/getClustersFilter:getClustersFilter"
                        }
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getClusters.\n",
                "properties": {
                    "clusters": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:k8s/getClustersCluster:getClustersCluster"
                        }
                    },
                    "entries": {
                        "type": "integer"
                    },
                    "filters": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:k8s/getClustersFilter:getClustersFilter"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusters",
                    "entries",
                    "id"
                ]
            }
        },
        "ionoscloud:k8s/getNodePool:getNodePool": {
            "description": "The **k8s Node Pool** data source can be used to search for and return existing k8s Node Pools.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search string so that it is specific enough to return only one result.\n\n## Example Usage\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNodePool.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "ID of the node pool you want to search for.\n\n`k8s_cluster_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.\n"
                    },
                    "k8sClusterId": {
                        "type": "string",
                        "description": "K8s Cluster' UUID\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of an existing node pool that you want to search for.\n"
                    }
                },
                "type": "object",
                "required": [
                    "k8sClusterId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNodePool.\n",
                "properties": {
                    "annotations": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map of annotations in the form of key \u003e value\n"
                    },
                    "autoScalings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:k8s/getNodePoolAutoScaling:getNodePoolAutoScaling"
                        },
                        "description": "The range defining the minimum and maximum number of worker nodes that the managed node group can scale in\n"
                    },
                    "availabilityZone": {
                        "type": "string",
                        "description": "The compute availability zone in which the nodes should exist\n"
                    },
                    "availableUpgradeVersions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of kubernetes versions available for upgrade\n"
                    },
                    "coresCount": {
                        "type": "integer",
                        "description": "CPU cores count\n"
                    },
                    "cpuFamily": {
                        "type": "string",
                        "description": "CPU Family\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "The UUID of the VDC\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The LAN ID of an existing LAN at the related datacenter\n"
                    },
                    "k8sClusterId": {
                        "type": "string",
                        "description": "ID of the cluster this node pool is part of\n"
                    },
                    "k8sVersion": {
                        "type": "string",
                        "description": "The kubernetes version\n"
                    },
                    "labels": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map of labels in the form of key \u003e value\n"
                    },
                    "lans": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:k8s/getNodePoolLan:getNodePoolLan"
                        },
                        "description": "A list of Local Area Networks the node pool is a part of\n"
                    },
                    "maintenanceWindows": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:k8s/getNodePoolMaintenanceWindow:getNodePoolMaintenanceWindow"
                        },
                        "description": "A maintenance window comprise of a day of the week and a time for maintenance to be allowed\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "name of the node pool\n"
                    },
                    "nodeCount": {
                        "type": "integer",
                        "description": "The number of nodes in this node pool\n"
                    },
                    "publicIps": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of fixed IPs associated with this node pool\n"
                    },
                    "ramSize": {
                        "type": "integer",
                        "description": "The amount of RAM in MB\n"
                    },
                    "state": {
                        "type": "string",
                        "description": "one of \"AVAILABLE\",\n\"INACTIVE\",\n\"BUSY\",\n\"DEPLOYING\",\n\"ACTIVE\",\n\"FAILED\",\n\"SUSPENDED\",\n\"FAILED_SUSPENDED\",\n\"UPDATING\",\n\"FAILED_UPDATING\",\n\"DESTROYING\",\n\"FAILED_DESTROYING\",\n\"TERMINATED\"\n"
                    },
                    "storageSize": {
                        "type": "integer",
                        "description": "The size of the volume in GB. The size should be greater than 10GB.\n"
                    },
                    "storageType": {
                        "type": "string",
                        "description": "HDD or SDD\n"
                    }
                },
                "type": "object",
                "required": [
                    "annotations",
                    "autoScalings",
                    "availabilityZone",
                    "availableUpgradeVersions",
                    "coresCount",
                    "cpuFamily",
                    "datacenterId",
                    "k8sClusterId",
                    "k8sVersion",
                    "labels",
                    "lans",
                    "maintenanceWindows",
                    "nodeCount",
                    "publicIps",
                    "ramSize",
                    "state",
                    "storageSize",
                    "storageType"
                ]
            }
        },
        "ionoscloud:k8s/getNodePoolNodes:getNodePoolNodes": {
            "description": "The **k8s Node Pool Nodes** data source can be used to search for and return a list of existing k8s Node Pool nodes.\n## Example Usage\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNodePoolNodes.\n",
                "properties": {
                    "k8sClusterId": {
                        "type": "string",
                        "description": "K8s Cluster' UUID\n"
                    },
                    "nodePoolId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "k8sClusterId",
                    "nodePoolId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNodePoolNodes.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "k8sClusterId": {
                        "type": "string"
                    },
                    "nodePoolId": {
                        "type": "string"
                    },
                    "nodes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:k8s/getNodePoolNodesNode:getNodePoolNodesNode"
                        },
                        "description": "a list of the nodes that are in the nodepool\n"
                    }
                },
                "type": "object",
                "required": [
                    "k8sClusterId",
                    "nodePoolId",
                    "nodes",
                    "id"
                ]
            }
        },
        "ionoscloud:kafka/getCluster:getCluster": {
            "description": "The **Kafka Cluster data source** can be used to search for and return an existing Kafka Cluster.\nYou can provide a string for the name parameter which will be compared with provisioned Kafka Clusters.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search string so that it is specific enough to return only one result.\n\n## Example Usage\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCluster.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "ID of an existing Kafka Cluster that you want to search for.\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "The location of the Kafka Cluster. Possible values: `de/fra`, `de/txl`\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of an existing Kafka Cluster that you want to search for.\n"
                    },
                    "partialMatch": {
                        "type": "boolean"
                    }
                },
                "type": "object",
                "required": [
                    "location"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCluster.\n",
                "properties": {
                    "brokerAddresses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "IP address and port of cluster brokers.\n"
                    },
                    "connections": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:kafka/getClusterConnection:getClusterConnection"
                        },
                        "description": "Connection information of the Kafka Cluster. Minimum items: 1, maximum items: 1.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "UUID of the Kafka Cluster.\n"
                    },
                    "location": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the Kafka Cluster.\n"
                    },
                    "partialMatch": {
                        "type": "boolean"
                    },
                    "size": {
                        "type": "string",
                        "description": "The size of the Kafka Cluster.\n"
                    },
                    "version": {
                        "type": "string",
                        "description": "The version of the Kafka Cluster.\n"
                    }
                },
                "type": "object",
                "required": [
                    "brokerAddresses",
                    "connections",
                    "id",
                    "location",
                    "name",
                    "size",
                    "version"
                ]
            }
        },
        "ionoscloud:kafka/getTopic:getTopic": {
            "description": "The **Kafka topic data source** can be used to search for and return an existing Kafka Cluster Topic.\nYou can provide a string for the name parameter which will be compared with provisioned Kafka Cluster Topics.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search string so that it is specific enough to return only one result.\n\n## Example Usage\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getTopic.\n",
                "properties": {
                    "clusterId": {
                        "type": "string",
                        "description": "ID of the Kafka Cluster that the topic belongs to.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "ID of an existing Kafka Cluster Topic that you want to search for.\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "The location of the Kafka Cluster Topic. Must be the same as the location of the Kafka\nCluster. Possible values: `de/fra`, `de/txl`\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of an existing Kafka Cluster Topic that you want to search for.\n"
                    },
                    "partialMatch": {
                        "type": "boolean"
                    }
                },
                "type": "object",
                "required": [
                    "clusterId",
                    "location"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getTopic.\n",
                "properties": {
                    "clusterId": {
                        "type": "string",
                        "description": "The id of the Kafka Cluster that the topic belongs to.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "UUID of the Kafka Cluster Topic.\n"
                    },
                    "location": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the Kafka Cluster Topic.\n"
                    },
                    "numberOfPartitions": {
                        "type": "integer",
                        "description": "The number of partitions of the topic. Partitions allow for parallel processing of messages.\n"
                    },
                    "partialMatch": {
                        "type": "boolean"
                    },
                    "replicationFactor": {
                        "type": "integer",
                        "description": "The number of replicas of the topic. The replication factor determines how many copies of the\ntopic are stored on different brokers.\n"
                    },
                    "retentionTime": {
                        "type": "integer",
                        "description": "This configuration controls the maximum time we will retain a log before we will discard old log\nsegments to free up space. This represents an SLA on how soon consumers must read their data. If set to -1, no time\nlimit is applied.\n"
                    },
                    "segmentBytes": {
                        "type": "integer",
                        "description": "This configuration controls the segment file size for the log. Retention and cleaning is always done a file at a time so a larger segment size means fewer files but less granular control over retention.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusterId",
                    "id",
                    "location",
                    "name",
                    "numberOfPartitions",
                    "replicationFactor",
                    "retentionTime",
                    "segmentBytes"
                ]
            }
        },
        "ionoscloud:logging/getPipeline:getPipeline": {
            "description": "The **Logging pipeline** datasource can be used to search for and return an existing Logging pipeline.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\n\n\u003e ⚠️  Only tokens are accepted for authorization in the **logging_pipeline** data source. Please ensure you are using tokens as other methods will not be valid.\n\n## Example Usage\n\n### By name\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.logging.getPipeline({\n    location: \"de/txl\",\n    name: \"pipeline_name\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.logging.get_pipeline(location=\"de/txl\",\n    name=\"pipeline_name\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Logging.GetPipeline.Invoke(new()\n    {\n        Location = \"de/txl\",\n        Name = \"pipeline_name\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/logging\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := logging.LookupPipeline(ctx, \u0026logging.LookupPipelineArgs{\n\t\t\tLocation: pulumi.StringRef(\"de/txl\"),\n\t\t\tName:     pulumi.StringRef(\"pipeline_name\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.logging.LoggingFunctions;\nimport com.pulumi.ionoscloud.logging.inputs.GetPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = LoggingFunctions.getPipeline(GetPipelineArgs.builder()\n            .location(\"de/txl\")\n            .name(\"pipeline_name\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:logging:getPipeline\n      arguments:\n        location: de/txl\n        name: pipeline_name\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPipeline.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "[string] The ID of the Logging pipeline you want to search for.\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "[string] The location of the Logging pipeline. Default: `de/txl`. One of `de/fra`, `de/txl`, `gb/lhr`, `es/vit`, `fr/par`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "[string] The name of the Logging pipeline you want to search for.\n\nEither `id` or `name` must be provided. If none, or both are provided, the datasource will return an error.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getPipeline.\n",
                "properties": {
                    "grafanaAddress": {
                        "type": "string",
                        "description": "The address of the client's grafana instance.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The UUID of the Logging pipeline.\n"
                    },
                    "location": {
                        "type": "string"
                    },
                    "logs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:logging/getPipelineLog:getPipelineLog"
                        },
                        "description": "[list] Pipeline logs, a list that contains elements with the following structure:\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the Logging pipeline.\n"
                    }
                },
                "type": "object",
                "required": [
                    "grafanaAddress",
                    "logs",
                    "name"
                ]
            }
        },
        "ionoscloud:nfs/getCluster:getCluster": {
            "description": "Returns information about clusters of Network File Storage (NFS) on IonosCloud.\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCluster.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "ID of the Network File Storage cluster.\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "The location where the Network File Storage cluster is located.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the Network File Storage cluster.\n"
                    },
                    "partialMatch": {
                        "type": "boolean",
                        "description": "Whether partial matching is allowed or not when using the name filter. Defaults to `false`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "location"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCluster.\n",
                "properties": {
                    "connections": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:nfs/getClusterConnection:getClusterConnection"
                        },
                        "description": "A list of connections for the Network File Storage cluster. You can specify only one connection. Each connection supports the following:\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The ID of the Network File Storage cluster.\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "The location where the Network File Storage cluster is located.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the Network File Storage cluster.\n"
                    },
                    "nfs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:nfs/getClusterNf:getClusterNf"
                        },
                        "description": "The NFS configuration for the Network File Storage cluster. Each NFS configuration supports the following:\n"
                    },
                    "partialMatch": {
                        "type": "boolean"
                    },
                    "size": {
                        "type": "integer",
                        "description": "The size of the Network File Storage cluster in TiB. Note that the cluster size cannot be reduced after provisioning. This value determines the billing fees. Default is `2`. The minimum value is `2` and the maximum value is `42`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "connections",
                    "id",
                    "location",
                    "name",
                    "nfs",
                    "size"
                ]
            }
        },
        "ionoscloud:nfs/getShare:getShare": {
            "description": "Returns information about shares of Network File Storage (NFS) on IonosCloud.\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getShare.\n",
                "properties": {
                    "clientGroups": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:nfs/getShareClientGroup:getShareClientGroup"
                        },
                        "description": "The groups of clients are the systems connecting to the Network File Storage cluster. Each client group supports the following:\n"
                    },
                    "clusterId": {
                        "type": "string",
                        "description": "The ID of the Network File Storage cluster.\n"
                    },
                    "gid": {
                        "type": "integer",
                        "description": "The group ID that will own the exported directory. If not set, **anonymous** (`512`) will be used.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "ID of the Network File Storage share.\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "The location where the Network File Storage share is located.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the Network File Storage share.\n"
                    },
                    "partialMatch": {
                        "type": "boolean",
                        "description": "Whether partial matching is allowed or not when using the name filter. Defaults to `false`.\n"
                    },
                    "quota": {
                        "type": "integer",
                        "description": "The quota in MiB for the export. The quota can restrict the amount of data that can be stored within the export. The quota can be disabled using `0`.\n"
                    },
                    "uid": {
                        "type": "integer",
                        "description": "The user ID that will own the exported directory. If not set, **anonymous** (`512`) will be used.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusterId",
                    "location"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getShare.\n",
                "properties": {
                    "clientGroups": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:nfs/getShareClientGroup:getShareClientGroup"
                        },
                        "description": "The groups of clients are the systems connecting to the Network File Storage cluster. Each client group supports the following:\n"
                    },
                    "clusterId": {
                        "type": "string",
                        "description": "The ID of the Network File Storage cluster.\n"
                    },
                    "gid": {
                        "type": "integer",
                        "description": "The group ID that will own the exported directory. If not set, **anonymous** (`512`) will be used.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The ID of the Network File Storage share.\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "The location where the Network File Storage share is located.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the Network File Storage share.\n"
                    },
                    "nfsPath": {
                        "type": "string",
                        "description": "Path to the NFS export. The NFS path is the path to the directory being exported.\n"
                    },
                    "partialMatch": {
                        "type": "boolean"
                    },
                    "quota": {
                        "type": "integer",
                        "description": "The quota in MiB for the export. The quota can restrict the amount of data that can be stored within the export. The quota can be disabled using `0`.\n"
                    },
                    "uid": {
                        "type": "integer",
                        "description": "The user ID that will own the exported directory. If not set, **anonymous** (`512`) will be used.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clientGroups",
                    "clusterId",
                    "gid",
                    "id",
                    "location",
                    "name",
                    "nfsPath",
                    "quota",
                    "uid"
                ]
            }
        },
        "ionoscloud:nlb/getBalancer:getBalancer": {
            "description": "The **Network Load Balancer data source** can be used to search for and return existing network load balancers.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search string so that it is specific enough to return only one result.\n\n## Example Usage\n\n### By Name\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.nlb.getBalancer({\n    datacenterId: ionoscloud_datacenter.example.id,\n    name: \"Network Load Balancer Name\",\n});\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.nlb.get_balancer(datacenter_id=ionoscloud_datacenter[\"example\"][\"id\"],\n    name=\"Network Load Balancer Name\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Nlb.GetBalancer.Invoke(new()\n    {\n        DatacenterId = ionoscloud_datacenter.Example.Id,\n        Name = \"Network Load Balancer Name\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/nlb\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := nlb.LookupBalancer(ctx, \u0026nlb.LookupBalancerArgs{\n\t\t\tDatacenterId: ionoscloud_datacenter.Example.Id,\n\t\t\tName:         pulumi.StringRef(\"Network Load Balancer Name\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.nlb.NlbFunctions;\nimport com.pulumi.ionoscloud.nlb.inputs.GetBalancerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = NlbFunctions.getBalancer(GetBalancerArgs.builder()\n            .datacenterId(ionoscloud_datacenter.example().id())\n            .name(\"Network Load Balancer Name\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:nlb:getBalancer\n      arguments:\n        datacenterId: ${ionoscloud_datacenter.example.id}\n        name: Network Load Balancer Name\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getBalancer.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "Datacenter's UUID.\n",
                        "willReplaceOnChanges": true
                    },
                    "id": {
                        "type": "string",
                        "description": "ID of the network load balancer you want to search for.\n\n`datacenter_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of an existing network load balancer that you want to search for.\n"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getBalancer.\n",
                "properties": {
                    "centralLogging": {
                        "type": "boolean",
                        "description": "Turn logging on and off for this product. Default value is 'false'.\n"
                    },
                    "datacenterId": {
                        "type": "string"
                    },
                    "flowlogs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:nlb/getBalancerFlowlog:getBalancerFlowlog"
                        },
                        "description": "Only 1 flow log can be configured. Only the name field can change as part of an update. Flow logs holistically capture network information such as source and destination IP addresses, source and destination ports, number of packets, amount of bytes, the start and end time of the recording, and the type of protocol – and log the extent to which your instances are being accessed.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Id of that Network Load Balancer\n"
                    },
                    "ips": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Collection of IP addresses of the Network Load Balancer. (inbound and outbound) IP of the listenerLan must be a customer reserved IP for the public load balancer and private IP for the private load balancer.\n"
                    },
                    "lbPrivateIps": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Collection of private IP addresses with subnet mask of the Network Load Balancer. IPs must contain valid subnet mask. If user will not provide any IP then the system will generate one IP with /24 subnet.\n"
                    },
                    "listenerLan": {
                        "type": "integer",
                        "description": "Id of the listening LAN. (inbound)\n"
                    },
                    "loggingFormat": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the name of the flow log.\n"
                    },
                    "targetLan": {
                        "type": "integer",
                        "description": "Id of the balanced private target LAN. (outbound)\n"
                    }
                },
                "type": "object",
                "required": [
                    "centralLogging",
                    "datacenterId",
                    "flowlogs",
                    "ips",
                    "lbPrivateIps",
                    "listenerLan",
                    "loggingFormat",
                    "targetLan"
                ]
            }
        },
        "ionoscloud:nlb/getForwardingRule:getForwardingRule": {
            "description": "The **Network Load Balancer Forwarding Rule data source** can be used to search for and return existing network forwarding rules.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search string so that it is specific enough to return only one result.\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getForwardingRule.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "Datacenter's UUID.\n",
                        "willReplaceOnChanges": true
                    },
                    "id": {
                        "type": "string",
                        "description": "ID of the network load balancer forwarding rule you want to search for.\n\nBoth `datacenter_id` and `networkloadbalancer_id` and either `name` or `id` must be provided. If none, or both of `name` and `id` are provided, the datasource will return an error.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of an existing network load balancer forwarding rule that you want to search for.\n"
                    },
                    "networkloadbalancerId": {
                        "type": "string",
                        "description": "Network Load Balancer's UUID.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId",
                    "networkloadbalancerId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getForwardingRule.\n",
                "properties": {
                    "algorithm": {
                        "type": "string",
                        "description": "Algorithm for the balancing.\n"
                    },
                    "datacenterId": {
                        "type": "string"
                    },
                    "healthChecks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:nlb/getForwardingRuleHealthCheck:getForwardingRuleHealthCheck"
                        },
                        "description": "Health check attributes for Network Load Balancer forwarding rule target.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The id of that Network Load Balancer forwarding rule.\n"
                    },
                    "listenerIp": {
                        "type": "string",
                        "description": "Listening IP. (inbound)\n"
                    },
                    "listenerPort": {
                        "type": "integer",
                        "description": "Listening port number. (inbound) (range: 1 to 65535)\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of that Network Load Balancer forwarding rule.\n"
                    },
                    "networkloadbalancerId": {
                        "type": "string"
                    },
                    "protocol": {
                        "type": "string",
                        "description": "Protocol of the balancing.\n"
                    },
                    "targets": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:nlb/getForwardingRuleTarget:getForwardingRuleTarget"
                        },
                        "description": "Array of items in that collection.\n"
                    }
                },
                "type": "object",
                "required": [
                    "algorithm",
                    "datacenterId",
                    "healthChecks",
                    "listenerIp",
                    "listenerPort",
                    "networkloadbalancerId",
                    "protocol",
                    "targets"
                ]
            }
        },
        "ionoscloud:vpn/getIpsecGateway:getIpsecGateway": {
            "description": "The **VPN IPSec Gateway data source** can be used to search for and return an existing IPSec Gateway.\nYou can provide a string for the name parameter which will be compared with provisioned IPSec Gateways.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search string so that it is specific enough to return only one result.\n\n## Example Usage\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getIpsecGateway.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "ID of an existing IPSec Gateway that you want to search for.\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "The location of the IPSec Gateway.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of an existing IPSec Gateway that you want to search for.\n"
                    },
                    "version": {
                        "type": "string",
                        "description": "The IKE version that is permitted for the VPN tunnels.\n"
                    }
                },
                "type": "object",
                "required": [
                    "location"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIpsecGateway.\n",
                "properties": {
                    "connections": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:vpn/getIpsecGatewayConnection:getIpsecGatewayConnection"
                        },
                        "description": "The network connection for your gateway.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "(Optional)[string] The human-readable description of the IPSec Gateway.\n"
                    },
                    "gatewayIp": {
                        "type": "string",
                        "description": "Public IP address to be assigned to the gateway.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The unique ID of the IPSec Gateway.\n"
                    },
                    "location": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the IPSec Gateway.\n"
                    },
                    "version": {
                        "type": "string",
                        "description": "The IKE version that is permitted for the VPN tunnels.\n"
                    }
                },
                "type": "object",
                "required": [
                    "connections",
                    "description",
                    "gatewayIp",
                    "id",
                    "location",
                    "name",
                    "version"
                ]
            }
        },
        "ionoscloud:vpn/getIpsecTunnel:getIpsecTunnel": {
            "description": "The **VPN IPSec Gateway Tunnel data source** can be used to search for and return an existing IPSec Gateway Tunnel.\nYou can provide a string for the name parameter which will be compared with provisioned IPSec Gateway Tunnels.\nIf a single match is found, it will be returned. If your search results in multiple matches, an error will be returned.\nWhen this happens, please refine your search string so that it is specific enough to return only one result.\n\n## Example Usage\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getIpsecTunnel.\n",
                "properties": {
                    "gatewayId": {
                        "type": "string",
                        "description": "The ID of the IPSec Gateway that the tunnel belongs to.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "ID of an existing IPSec Gateway Tunnel that you want to search for.\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "The location of the IPSec Gateway Tunnel.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of an existing IPSec Gateway Tunnel that you want to search for.\n"
                    }
                },
                "type": "object",
                "required": [
                    "gatewayId",
                    "location"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getIpsecTunnel.\n",
                "properties": {
                    "auths": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:vpn/getIpsecTunnelAuth:getIpsecTunnelAuth"
                        }
                    },
                    "cloudNetworkCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "description": {
                        "type": "string"
                    },
                    "esps": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:vpn/getIpsecTunnelEsp:getIpsecTunnelEsp"
                        }
                    },
                    "gatewayId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string"
                    },
                    "ikes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:vpn/getIpsecTunnelIke:getIpsecTunnelIke"
                        }
                    },
                    "location": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "peerNetworkCidrs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "remoteHost": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "auths",
                    "cloudNetworkCidrs",
                    "description",
                    "esps",
                    "gatewayId",
                    "id",
                    "ikes",
                    "location",
                    "name",
                    "peerNetworkCidrs",
                    "remoteHost"
                ]
            }
        },
        "ionoscloud:vpn/getWireguardGateway:getWireguardGateway": {
            "description": "The `ionoscloud.vpn.WireguardGateway` data source provides information about a specific IonosCloud VPN WireGuard Gateway. You can use this data source to retrieve details of a WireGuard Gateway for use in other resources and configurations.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.vpn.getWireguardGateway({\n    location: \"de/fra\",\n    name: \"example-gateway\",\n});\nexport const vpnWireguardGatewayPublicKey = data.vpn_wireguard_gateway.example.public_key;\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.vpn.get_wireguard_gateway(location=\"de/fra\",\n    name=\"example-gateway\")\npulumi.export(\"vpnWireguardGatewayPublicKey\", data[\"vpn_wireguard_gateway\"][\"example\"][\"public_key\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Vpn.GetWireguardGateway.Invoke(new()\n    {\n        Location = \"de/fra\",\n        Name = \"example-gateway\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"vpnWireguardGatewayPublicKey\"] = data.Vpn_wireguard_gateway.Example.Public_key,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/vpn\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vpn.LookupWireguardGateway(ctx, \u0026vpn.LookupWireguardGatewayArgs{\n\t\t\tLocation: \"de/fra\",\n\t\t\tName:     pulumi.StringRef(\"example-gateway\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"vpnWireguardGatewayPublicKey\", data.Vpn_wireguard_gateway.Example.Public_key)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.vpn.VpnFunctions;\nimport com.pulumi.ionoscloud.vpn.inputs.GetWireguardGatewayArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = VpnFunctions.getWireguardGateway(GetWireguardGatewayArgs.builder()\n            .location(\"de/fra\")\n            .name(\"example-gateway\")\n            .build());\n\n        ctx.export(\"vpnWireguardGatewayPublicKey\", data.vpn_wireguard_gateway().example().public_key());\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:vpn:getWireguardGateway\n      arguments:\n        location: de/fra\n        name: example-gateway\noutputs:\n  vpnWireguardGatewayPublicKey: ${data.vpn_wireguard_gateway.example.public_key}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getWireguardGateway.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "The description of the WireGuard Gateway.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "[String] The ID of the WireGuard Gateway.\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "[String] The location of the WireGuard Gateway.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "[String] The name of the WireGuard Gateway.\n"
                    }
                },
                "type": "object",
                "required": [
                    "location"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getWireguardGateway.\n",
                "properties": {
                    "connections": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:vpn/getWireguardGatewayConnection:getWireguardGatewayConnection"
                        },
                        "description": "A list of connection configurations for the WireGuard Gateway. Each `connections` block contains:\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the WireGuard Gateway.\n"
                    },
                    "gatewayIp": {
                        "type": "string",
                        "description": "The IP address of the WireGuard Gateway.\n"
                    },
                    "id": {
                        "type": "string"
                    },
                    "interfaceIpv4Cidr": {
                        "type": "string",
                        "description": "The IPv4 CIDR for the WireGuard Gateway interface.\n"
                    },
                    "interfaceIpv6Cidr": {
                        "type": "string",
                        "description": "The IPv6 CIDR for the WireGuard Gateway interface.\n"
                    },
                    "listenPort": {
                        "type": "integer"
                    },
                    "location": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "publicKey": {
                        "type": "string",
                        "description": "The public key for the WireGuard Gateway.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "The current status of the WireGuard Gateway.\n"
                    }
                },
                "type": "object",
                "required": [
                    "connections",
                    "gatewayIp",
                    "id",
                    "interfaceIpv4Cidr",
                    "interfaceIpv6Cidr",
                    "listenPort",
                    "location",
                    "name",
                    "publicKey",
                    "status"
                ]
            }
        },
        "ionoscloud:vpn/getWireguardPeer:getWireguardPeer": {
            "description": "The `ionoscloud.vpn.WireguardGateway` data source provides information about a specific IonosCloud VPN WireGuard Gateway. You can use this data source to retrieve details of a WireGuard Gateway for use in other resources and configurations.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as ionoscloud from \"@pulumi/ionoscloud\";\n\nconst example = ionoscloud.vpn.getWireguardPeer({\n    location: \"de/fra\",\n    gatewayId: \"example-gateway\",\n    name: \"example-peer\",\n});\nexport const vpnWireguardPeerPublicKey = data.vpn_wireguard_peer.example.public_key;\n```\n```python\nimport pulumi\nimport pulumi_ionoscloud as ionoscloud\n\nexample = ionoscloud.vpn.get_wireguard_peer(location=\"de/fra\",\n    gateway_id=\"example-gateway\",\n    name=\"example-peer\")\npulumi.export(\"vpnWireguardPeerPublicKey\", data[\"vpn_wireguard_peer\"][\"example\"][\"public_key\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Ionoscloud = Pulumi.Ionoscloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Ionoscloud.Vpn.GetWireguardPeer.Invoke(new()\n    {\n        Location = \"de/fra\",\n        GatewayId = \"example-gateway\",\n        Name = \"example-peer\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"vpnWireguardPeerPublicKey\"] = data.Vpn_wireguard_peer.Example.Public_key,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/ionos-cloud/pulumi-ionoscloud/sdk/go/ionoscloud/vpn\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vpn.LookupWireguardPeer(ctx, \u0026vpn.LookupWireguardPeerArgs{\n\t\t\tLocation:  \"de/fra\",\n\t\t\tGatewayId: \"example-gateway\",\n\t\t\tName:      pulumi.StringRef(\"example-peer\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"vpnWireguardPeerPublicKey\", data.Vpn_wireguard_peer.Example.Public_key)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.ionoscloud.vpn.VpnFunctions;\nimport com.pulumi.ionoscloud.vpn.inputs.GetWireguardPeerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = VpnFunctions.getWireguardPeer(GetWireguardPeerArgs.builder()\n            .location(\"de/fra\")\n            .gatewayId(\"example-gateway\")\n            .name(\"example-peer\")\n            .build());\n\n        ctx.export(\"vpnWireguardPeerPublicKey\", data.vpn_wireguard_peer().example().public_key());\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      function: ionoscloud:vpn:getWireguardPeer\n      arguments:\n        location: de/fra\n        gatewayId: example-gateway\n        name: example-peer\noutputs:\n  vpnWireguardPeerPublicKey: ${data.vpn_wireguard_peer.example.public_key}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getWireguardPeer.\n",
                "properties": {
                    "gatewayId": {
                        "type": "string",
                        "description": "[String] The ID of the WireGuard Gateway.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "[String] The ID of the WireGuard Peer.\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "[String] The location of the WireGuard Gateway.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "[String] The name of the WireGuard Peer.\n"
                    }
                },
                "type": "object",
                "required": [
                    "gatewayId",
                    "location"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getWireguardPeer.\n",
                "properties": {
                    "allowedIps": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The subnet CIDRs that are allowed to connect to the WireGuard Gateway.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the WireGuard Peer.\n"
                    },
                    "endpoints": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/ionoscloud:vpn/getWireguardPeerEndpoint:getWireguardPeerEndpoint"
                        },
                        "description": "The endpoint of the WireGuard Peer.\n"
                    },
                    "gatewayId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The unique ID of the WireGuard Peer.\n"
                    },
                    "location": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the WireGuard Peer.\n"
                    },
                    "publicKey": {
                        "type": "string",
                        "description": "WireGuard public key of the connecting peer.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "The current status of the WireGuard Peer.\n"
                    }
                },
                "type": "object",
                "required": [
                    "allowedIps",
                    "description",
                    "endpoints",
                    "gatewayId",
                    "location",
                    "name",
                    "publicKey",
                    "status"
                ]
            }
        }
    }
}